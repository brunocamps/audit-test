(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
  var __esm = (fn2, res) => function __init() {
    return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name2 in all)
      __defProp(target, name2, { get: all[name2], enumerable: true });
  };
  var __reExport = (target, module4, copyDefault, desc) => {
    if (module4 && typeof module4 === "object" || typeof module4 === "function") {
      for (let key of __getOwnPropNames(module4))
        if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
          __defProp(target, key, { get: () => module4[key], enumerable: !(desc = __getOwnPropDesc(module4, key)) || desc.enumerable });
    }
    return target;
  };
  var __toESM = (module4, isNodeMode) => {
    return __reExport(__markAsModule(__defProp(module4 != null ? __create(__getProtoOf(module4)) : {}, "default", !isNodeMode && module4 && module4.__esModule ? { get: () => module4.default, enumerable: true } : { value: module4, enumerable: true })), module4);
  };
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // ../../node_modules/@rails/ujs/lib/assets/compiled/rails-ujs.js
  var require_rails_ujs = __commonJS({
    "../../node_modules/@rails/ujs/lib/assets/compiled/rails-ujs.js"(exports2, module4) {
      (function() {
        var context = this;
        (function() {
          (function() {
            this.Rails = {
              linkClickSelector: "a[data-confirm], a[data-method], a[data-remote]:not([disabled]), a[data-disable-with], a[data-disable]",
              buttonClickSelector: {
                selector: "button[data-remote]:not([form]), button[data-confirm]:not([form])",
                exclude: "form button"
              },
              inputChangeSelector: "select[data-remote], input[data-remote], textarea[data-remote]",
              formSubmitSelector: "form:not([data-turbo=true])",
              formInputClickSelector: "form:not([data-turbo=true]) input[type=submit], form:not([data-turbo=true]) input[type=image], form:not([data-turbo=true]) button[type=submit], form:not([data-turbo=true]) button:not([type]), input[type=submit][form], input[type=image][form], button[type=submit][form], button[form]:not([type])",
              formDisableSelector: "input[data-disable-with]:enabled, button[data-disable-with]:enabled, textarea[data-disable-with]:enabled, input[data-disable]:enabled, button[data-disable]:enabled, textarea[data-disable]:enabled",
              formEnableSelector: "input[data-disable-with]:disabled, button[data-disable-with]:disabled, textarea[data-disable-with]:disabled, input[data-disable]:disabled, button[data-disable]:disabled, textarea[data-disable]:disabled",
              fileInputSelector: "input[name][type=file]:not([disabled])",
              linkDisableSelector: "a[data-disable-with], a[data-disable]",
              buttonDisableSelector: "button[data-remote][data-disable-with], button[data-remote][data-disable]"
            };
          }).call(this);
        }).call(context);
        var Rails3 = context.Rails;
        (function() {
          (function() {
            var nonce;
            nonce = null;
            Rails3.loadCSPNonce = function() {
              var ref;
              return nonce = (ref = document.querySelector("meta[name=csp-nonce]")) != null ? ref.content : void 0;
            };
            Rails3.cspNonce = function() {
              return nonce != null ? nonce : Rails3.loadCSPNonce();
            };
          }).call(this);
          (function() {
            var expando, m3;
            m3 = Element.prototype.matches || Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector;
            Rails3.matches = function(element, selector) {
              if (selector.exclude != null) {
                return m3.call(element, selector.selector) && !m3.call(element, selector.exclude);
              } else {
                return m3.call(element, selector);
              }
            };
            expando = "_ujsData";
            Rails3.getData = function(element, key) {
              var ref;
              return (ref = element[expando]) != null ? ref[key] : void 0;
            };
            Rails3.setData = function(element, key, value) {
              if (element[expando] == null) {
                element[expando] = {};
              }
              return element[expando][key] = value;
            };
            Rails3.$ = function(selector) {
              return Array.prototype.slice.call(document.querySelectorAll(selector));
            };
          }).call(this);
          (function() {
            var $, csrfParam, csrfToken;
            $ = Rails3.$;
            csrfToken = Rails3.csrfToken = function() {
              var meta;
              meta = document.querySelector("meta[name=csrf-token]");
              return meta && meta.content;
            };
            csrfParam = Rails3.csrfParam = function() {
              var meta;
              meta = document.querySelector("meta[name=csrf-param]");
              return meta && meta.content;
            };
            Rails3.CSRFProtection = function(xhr) {
              var token;
              token = csrfToken();
              if (token != null) {
                return xhr.setRequestHeader("X-CSRF-Token", token);
              }
            };
            Rails3.refreshCSRFTokens = function() {
              var param, token;
              token = csrfToken();
              param = csrfParam();
              if (token != null && param != null) {
                return $('form input[name="' + param + '"]').forEach(function(input) {
                  return input.value = token;
                });
              }
            };
          }).call(this);
          (function() {
            var CustomEvent2, fire, matches, preventDefault;
            matches = Rails3.matches;
            CustomEvent2 = window.CustomEvent;
            if (typeof CustomEvent2 !== "function") {
              CustomEvent2 = function(event, params) {
                var evt;
                evt = document.createEvent("CustomEvent");
                evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
                return evt;
              };
              CustomEvent2.prototype = window.Event.prototype;
              preventDefault = CustomEvent2.prototype.preventDefault;
              CustomEvent2.prototype.preventDefault = function() {
                var result;
                result = preventDefault.call(this);
                if (this.cancelable && !this.defaultPrevented) {
                  Object.defineProperty(this, "defaultPrevented", {
                    get: function() {
                      return true;
                    }
                  });
                }
                return result;
              };
            }
            fire = Rails3.fire = function(obj, name2, data) {
              var event;
              event = new CustomEvent2(name2, {
                bubbles: true,
                cancelable: true,
                detail: data
              });
              obj.dispatchEvent(event);
              return !event.defaultPrevented;
            };
            Rails3.stopEverything = function(e3) {
              fire(e3.target, "ujs:everythingStopped");
              e3.preventDefault();
              e3.stopPropagation();
              return e3.stopImmediatePropagation();
            };
            Rails3.delegate = function(element, selector, eventType, handler) {
              return element.addEventListener(eventType, function(e3) {
                var target;
                target = e3.target;
                while (!(!(target instanceof Element) || matches(target, selector))) {
                  target = target.parentNode;
                }
                if (target instanceof Element && handler.call(target, e3) === false) {
                  e3.preventDefault();
                  return e3.stopPropagation();
                }
              });
            };
          }).call(this);
          (function() {
            var AcceptHeaders, CSRFProtection, createXHR, cspNonce, fire, prepareOptions, processResponse;
            cspNonce = Rails3.cspNonce, CSRFProtection = Rails3.CSRFProtection, fire = Rails3.fire;
            AcceptHeaders = {
              "*": "*/*",
              text: "text/plain",
              html: "text/html",
              xml: "application/xml, text/xml",
              json: "application/json, text/javascript",
              script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
            };
            Rails3.ajax = function(options2) {
              var xhr;
              options2 = prepareOptions(options2);
              xhr = createXHR(options2, function() {
                var ref, response;
                response = processResponse((ref = xhr.response) != null ? ref : xhr.responseText, xhr.getResponseHeader("Content-Type"));
                if (Math.floor(xhr.status / 100) === 2) {
                  if (typeof options2.success === "function") {
                    options2.success(response, xhr.statusText, xhr);
                  }
                } else {
                  if (typeof options2.error === "function") {
                    options2.error(response, xhr.statusText, xhr);
                  }
                }
                return typeof options2.complete === "function" ? options2.complete(xhr, xhr.statusText) : void 0;
              });
              if (options2.beforeSend != null && !options2.beforeSend(xhr, options2)) {
                return false;
              }
              if (xhr.readyState === XMLHttpRequest.OPENED) {
                return xhr.send(options2.data);
              }
            };
            prepareOptions = function(options2) {
              options2.url = options2.url || location.href;
              options2.type = options2.type.toUpperCase();
              if (options2.type === "GET" && options2.data) {
                if (options2.url.indexOf("?") < 0) {
                  options2.url += "?" + options2.data;
                } else {
                  options2.url += "&" + options2.data;
                }
              }
              if (AcceptHeaders[options2.dataType] == null) {
                options2.dataType = "*";
              }
              options2.accept = AcceptHeaders[options2.dataType];
              if (options2.dataType !== "*") {
                options2.accept += ", */*; q=0.01";
              }
              return options2;
            };
            createXHR = function(options2, done) {
              var xhr;
              xhr = new XMLHttpRequest();
              xhr.open(options2.type, options2.url, true);
              xhr.setRequestHeader("Accept", options2.accept);
              if (typeof options2.data === "string") {
                xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8");
              }
              if (!options2.crossDomain) {
                xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
                CSRFProtection(xhr);
              }
              xhr.withCredentials = !!options2.withCredentials;
              xhr.onreadystatechange = function() {
                if (xhr.readyState === XMLHttpRequest.DONE) {
                  return done(xhr);
                }
              };
              return xhr;
            };
            processResponse = function(response, type) {
              var parser, script;
              if (typeof response === "string" && typeof type === "string") {
                if (type.match(/\bjson\b/)) {
                  try {
                    response = JSON.parse(response);
                  } catch (error2) {
                  }
                } else if (type.match(/\b(?:java|ecma)script\b/)) {
                  script = document.createElement("script");
                  script.setAttribute("nonce", cspNonce());
                  script.text = response;
                  document.head.appendChild(script).parentNode.removeChild(script);
                } else if (type.match(/\b(xml|html|svg)\b/)) {
                  parser = new DOMParser();
                  type = type.replace(/;.+/, "");
                  try {
                    response = parser.parseFromString(response, type);
                  } catch (error2) {
                  }
                }
              }
              return response;
            };
            Rails3.href = function(element) {
              return element.href;
            };
            Rails3.isCrossDomain = function(url) {
              var e3, originAnchor, urlAnchor;
              originAnchor = document.createElement("a");
              originAnchor.href = location.href;
              urlAnchor = document.createElement("a");
              try {
                urlAnchor.href = url;
                return !((!urlAnchor.protocol || urlAnchor.protocol === ":") && !urlAnchor.host || originAnchor.protocol + "//" + originAnchor.host === urlAnchor.protocol + "//" + urlAnchor.host);
              } catch (error2) {
                e3 = error2;
                return true;
              }
            };
          }).call(this);
          (function() {
            var matches, toArray;
            matches = Rails3.matches;
            toArray = function(e3) {
              return Array.prototype.slice.call(e3);
            };
            Rails3.serializeElement = function(element, additionalParam) {
              var inputs, params;
              inputs = [element];
              if (matches(element, "form")) {
                inputs = toArray(element.elements);
              }
              params = [];
              inputs.forEach(function(input) {
                if (!input.name || input.disabled) {
                  return;
                }
                if (matches(input, "fieldset[disabled] *")) {
                  return;
                }
                if (matches(input, "select")) {
                  return toArray(input.options).forEach(function(option) {
                    if (option.selected) {
                      return params.push({
                        name: input.name,
                        value: option.value
                      });
                    }
                  });
                } else if (input.checked || ["radio", "checkbox", "submit"].indexOf(input.type) === -1) {
                  return params.push({
                    name: input.name,
                    value: input.value
                  });
                }
              });
              if (additionalParam) {
                params.push(additionalParam);
              }
              return params.map(function(param) {
                if (param.name != null) {
                  return encodeURIComponent(param.name) + "=" + encodeURIComponent(param.value);
                } else {
                  return param;
                }
              }).join("&");
            };
            Rails3.formElements = function(form, selector) {
              if (matches(form, "form")) {
                return toArray(form.elements).filter(function(el) {
                  return matches(el, selector);
                });
              } else {
                return toArray(form.querySelectorAll(selector));
              }
            };
          }).call(this);
          (function() {
            var allowAction, fire, stopEverything;
            fire = Rails3.fire, stopEverything = Rails3.stopEverything;
            Rails3.handleConfirm = function(e3) {
              if (!allowAction(this)) {
                return stopEverything(e3);
              }
            };
            Rails3.confirm = function(message, element) {
              return confirm(message);
            };
            allowAction = function(element) {
              var answer, callback2, message;
              message = element.getAttribute("data-confirm");
              if (!message) {
                return true;
              }
              answer = false;
              if (fire(element, "confirm")) {
                try {
                  answer = Rails3.confirm(message, element);
                } catch (error2) {
                }
                callback2 = fire(element, "confirm:complete", [answer]);
              }
              return answer && callback2;
            };
          }).call(this);
          (function() {
            var disableFormElement, disableFormElements, disableLinkElement, enableFormElement, enableFormElements, enableLinkElement, formElements, getData2, isXhrRedirect, matches, setData, stopEverything;
            matches = Rails3.matches, getData2 = Rails3.getData, setData = Rails3.setData, stopEverything = Rails3.stopEverything, formElements = Rails3.formElements;
            Rails3.handleDisabledElement = function(e3) {
              var element;
              element = this;
              if (element.disabled) {
                return stopEverything(e3);
              }
            };
            Rails3.enableElement = function(e3) {
              var element;
              if (e3 instanceof Event) {
                if (isXhrRedirect(e3)) {
                  return;
                }
                element = e3.target;
              } else {
                element = e3;
              }
              if (matches(element, Rails3.linkDisableSelector)) {
                return enableLinkElement(element);
              } else if (matches(element, Rails3.buttonDisableSelector) || matches(element, Rails3.formEnableSelector)) {
                return enableFormElement(element);
              } else if (matches(element, Rails3.formSubmitSelector)) {
                return enableFormElements(element);
              }
            };
            Rails3.disableElement = function(e3) {
              var element;
              element = e3 instanceof Event ? e3.target : e3;
              if (matches(element, Rails3.linkDisableSelector)) {
                return disableLinkElement(element);
              } else if (matches(element, Rails3.buttonDisableSelector) || matches(element, Rails3.formDisableSelector)) {
                return disableFormElement(element);
              } else if (matches(element, Rails3.formSubmitSelector)) {
                return disableFormElements(element);
              }
            };
            disableLinkElement = function(element) {
              var replacement;
              if (getData2(element, "ujs:disabled")) {
                return;
              }
              replacement = element.getAttribute("data-disable-with");
              if (replacement != null) {
                setData(element, "ujs:enable-with", element.innerHTML);
                element.innerHTML = replacement;
              }
              element.addEventListener("click", stopEverything);
              return setData(element, "ujs:disabled", true);
            };
            enableLinkElement = function(element) {
              var originalText;
              originalText = getData2(element, "ujs:enable-with");
              if (originalText != null) {
                element.innerHTML = originalText;
                setData(element, "ujs:enable-with", null);
              }
              element.removeEventListener("click", stopEverything);
              return setData(element, "ujs:disabled", null);
            };
            disableFormElements = function(form) {
              return formElements(form, Rails3.formDisableSelector).forEach(disableFormElement);
            };
            disableFormElement = function(element) {
              var replacement;
              if (getData2(element, "ujs:disabled")) {
                return;
              }
              replacement = element.getAttribute("data-disable-with");
              if (replacement != null) {
                if (matches(element, "button")) {
                  setData(element, "ujs:enable-with", element.innerHTML);
                  element.innerHTML = replacement;
                } else {
                  setData(element, "ujs:enable-with", element.value);
                  element.value = replacement;
                }
              }
              element.disabled = true;
              return setData(element, "ujs:disabled", true);
            };
            enableFormElements = function(form) {
              return formElements(form, Rails3.formEnableSelector).forEach(enableFormElement);
            };
            enableFormElement = function(element) {
              var originalText;
              originalText = getData2(element, "ujs:enable-with");
              if (originalText != null) {
                if (matches(element, "button")) {
                  element.innerHTML = originalText;
                } else {
                  element.value = originalText;
                }
                setData(element, "ujs:enable-with", null);
              }
              element.disabled = false;
              return setData(element, "ujs:disabled", null);
            };
            isXhrRedirect = function(event) {
              var ref, xhr;
              xhr = (ref = event.detail) != null ? ref[0] : void 0;
              return (xhr != null ? xhr.getResponseHeader("X-Xhr-Redirect") : void 0) != null;
            };
          }).call(this);
          (function() {
            var stopEverything;
            stopEverything = Rails3.stopEverything;
            Rails3.handleMethod = function(e3) {
              var csrfParam, csrfToken, form, formContent, href, link, method;
              link = this;
              method = link.getAttribute("data-method");
              if (!method) {
                return;
              }
              href = Rails3.href(link);
              csrfToken = Rails3.csrfToken();
              csrfParam = Rails3.csrfParam();
              form = document.createElement("form");
              formContent = "<input name='_method' value='" + method + "' type='hidden' />";
              if (csrfParam != null && csrfToken != null && !Rails3.isCrossDomain(href)) {
                formContent += "<input name='" + csrfParam + "' value='" + csrfToken + "' type='hidden' />";
              }
              formContent += '<input type="submit" />';
              form.method = "post";
              form.action = href;
              form.target = link.target;
              form.innerHTML = formContent;
              form.style.display = "none";
              document.body.appendChild(form);
              form.querySelector('[type="submit"]').click();
              return stopEverything(e3);
            };
          }).call(this);
          (function() {
            var ajax, fire, getData2, isCrossDomain, isRemote, matches, serializeElement, setData, stopEverything, slice = [].slice;
            matches = Rails3.matches, getData2 = Rails3.getData, setData = Rails3.setData, fire = Rails3.fire, stopEverything = Rails3.stopEverything, ajax = Rails3.ajax, isCrossDomain = Rails3.isCrossDomain, serializeElement = Rails3.serializeElement;
            isRemote = function(element) {
              var value;
              value = element.getAttribute("data-remote");
              return value != null && value !== "false";
            };
            Rails3.handleRemote = function(e3) {
              var button, data, dataType, element, method, url, withCredentials;
              element = this;
              if (!isRemote(element)) {
                return true;
              }
              if (!fire(element, "ajax:before")) {
                fire(element, "ajax:stopped");
                return false;
              }
              withCredentials = element.getAttribute("data-with-credentials");
              dataType = element.getAttribute("data-type") || "script";
              if (matches(element, Rails3.formSubmitSelector)) {
                button = getData2(element, "ujs:submit-button");
                method = getData2(element, "ujs:submit-button-formmethod") || element.method;
                url = getData2(element, "ujs:submit-button-formaction") || element.getAttribute("action") || location.href;
                if (method.toUpperCase() === "GET") {
                  url = url.replace(/\?.*$/, "");
                }
                if (element.enctype === "multipart/form-data") {
                  data = new FormData(element);
                  if (button != null) {
                    data.append(button.name, button.value);
                  }
                } else {
                  data = serializeElement(element, button);
                }
                setData(element, "ujs:submit-button", null);
                setData(element, "ujs:submit-button-formmethod", null);
                setData(element, "ujs:submit-button-formaction", null);
              } else if (matches(element, Rails3.buttonClickSelector) || matches(element, Rails3.inputChangeSelector)) {
                method = element.getAttribute("data-method");
                url = element.getAttribute("data-url");
                data = serializeElement(element, element.getAttribute("data-params"));
              } else {
                method = element.getAttribute("data-method");
                url = Rails3.href(element);
                data = element.getAttribute("data-params");
              }
              ajax({
                type: method || "GET",
                url,
                data,
                dataType,
                beforeSend: function(xhr, options2) {
                  if (fire(element, "ajax:beforeSend", [xhr, options2])) {
                    return fire(element, "ajax:send", [xhr]);
                  } else {
                    fire(element, "ajax:stopped");
                    return false;
                  }
                },
                success: function() {
                  var args;
                  args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
                  return fire(element, "ajax:success", args);
                },
                error: function() {
                  var args;
                  args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
                  return fire(element, "ajax:error", args);
                },
                complete: function() {
                  var args;
                  args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
                  return fire(element, "ajax:complete", args);
                },
                crossDomain: isCrossDomain(url),
                withCredentials: withCredentials != null && withCredentials !== "false"
              });
              return stopEverything(e3);
            };
            Rails3.formSubmitButtonClick = function(e3) {
              var button, form;
              button = this;
              form = button.form;
              if (!form) {
                return;
              }
              if (button.name) {
                setData(form, "ujs:submit-button", {
                  name: button.name,
                  value: button.value
                });
              }
              setData(form, "ujs:formnovalidate-button", button.formNoValidate);
              setData(form, "ujs:submit-button-formaction", button.getAttribute("formaction"));
              return setData(form, "ujs:submit-button-formmethod", button.getAttribute("formmethod"));
            };
            Rails3.preventInsignificantClick = function(e3) {
              var data, insignificantMetaClick, link, metaClick, method, nonPrimaryMouseClick;
              link = this;
              method = (link.getAttribute("data-method") || "GET").toUpperCase();
              data = link.getAttribute("data-params");
              metaClick = e3.metaKey || e3.ctrlKey;
              insignificantMetaClick = metaClick && method === "GET" && !data;
              nonPrimaryMouseClick = e3.button != null && e3.button !== 0;
              if (nonPrimaryMouseClick || insignificantMetaClick) {
                return e3.stopImmediatePropagation();
              }
            };
          }).call(this);
          (function() {
            var $, CSRFProtection, delegate, disableElement, enableElement, fire, formSubmitButtonClick, getData2, handleConfirm, handleDisabledElement, handleMethod, handleRemote, loadCSPNonce, preventInsignificantClick, refreshCSRFTokens;
            fire = Rails3.fire, delegate = Rails3.delegate, getData2 = Rails3.getData, $ = Rails3.$, refreshCSRFTokens = Rails3.refreshCSRFTokens, CSRFProtection = Rails3.CSRFProtection, loadCSPNonce = Rails3.loadCSPNonce, enableElement = Rails3.enableElement, disableElement = Rails3.disableElement, handleDisabledElement = Rails3.handleDisabledElement, handleConfirm = Rails3.handleConfirm, preventInsignificantClick = Rails3.preventInsignificantClick, handleRemote = Rails3.handleRemote, formSubmitButtonClick = Rails3.formSubmitButtonClick, handleMethod = Rails3.handleMethod;
            if (typeof jQuery !== "undefined" && jQuery !== null && jQuery.ajax != null) {
              if (jQuery.rails) {
                throw new Error("If you load both jquery_ujs and rails-ujs, use rails-ujs only.");
              }
              jQuery.rails = Rails3;
              jQuery.ajaxPrefilter(function(options2, originalOptions, xhr) {
                if (!options2.crossDomain) {
                  return CSRFProtection(xhr);
                }
              });
            }
            Rails3.start = function() {
              if (window._rails_loaded) {
                throw new Error("rails-ujs has already been loaded!");
              }
              window.addEventListener("pageshow", function() {
                $(Rails3.formEnableSelector).forEach(function(el) {
                  if (getData2(el, "ujs:disabled")) {
                    return enableElement(el);
                  }
                });
                return $(Rails3.linkDisableSelector).forEach(function(el) {
                  if (getData2(el, "ujs:disabled")) {
                    return enableElement(el);
                  }
                });
              });
              delegate(document, Rails3.linkDisableSelector, "ajax:complete", enableElement);
              delegate(document, Rails3.linkDisableSelector, "ajax:stopped", enableElement);
              delegate(document, Rails3.buttonDisableSelector, "ajax:complete", enableElement);
              delegate(document, Rails3.buttonDisableSelector, "ajax:stopped", enableElement);
              delegate(document, Rails3.linkClickSelector, "click", preventInsignificantClick);
              delegate(document, Rails3.linkClickSelector, "click", handleDisabledElement);
              delegate(document, Rails3.linkClickSelector, "click", handleConfirm);
              delegate(document, Rails3.linkClickSelector, "click", disableElement);
              delegate(document, Rails3.linkClickSelector, "click", handleRemote);
              delegate(document, Rails3.linkClickSelector, "click", handleMethod);
              delegate(document, Rails3.buttonClickSelector, "click", preventInsignificantClick);
              delegate(document, Rails3.buttonClickSelector, "click", handleDisabledElement);
              delegate(document, Rails3.buttonClickSelector, "click", handleConfirm);
              delegate(document, Rails3.buttonClickSelector, "click", disableElement);
              delegate(document, Rails3.buttonClickSelector, "click", handleRemote);
              delegate(document, Rails3.inputChangeSelector, "change", handleDisabledElement);
              delegate(document, Rails3.inputChangeSelector, "change", handleConfirm);
              delegate(document, Rails3.inputChangeSelector, "change", handleRemote);
              delegate(document, Rails3.formSubmitSelector, "submit", handleDisabledElement);
              delegate(document, Rails3.formSubmitSelector, "submit", handleConfirm);
              delegate(document, Rails3.formSubmitSelector, "submit", handleRemote);
              delegate(document, Rails3.formSubmitSelector, "submit", function(e3) {
                return setTimeout(function() {
                  return disableElement(e3);
                }, 13);
              });
              delegate(document, Rails3.formSubmitSelector, "ajax:send", disableElement);
              delegate(document, Rails3.formSubmitSelector, "ajax:complete", enableElement);
              delegate(document, Rails3.formInputClickSelector, "click", preventInsignificantClick);
              delegate(document, Rails3.formInputClickSelector, "click", handleDisabledElement);
              delegate(document, Rails3.formInputClickSelector, "click", handleConfirm);
              delegate(document, Rails3.formInputClickSelector, "click", formSubmitButtonClick);
              document.addEventListener("DOMContentLoaded", refreshCSRFTokens);
              document.addEventListener("DOMContentLoaded", loadCSPNonce);
              return window._rails_loaded = true;
            };
            if (window.Rails === Rails3 && fire(document, "rails:attachBindings")) {
              Rails3.start();
            }
          }).call(this);
        }).call(this);
        if (typeof module4 === "object" && module4.exports) {
          module4.exports = Rails3;
        } else if (typeof define === "function" && define.amd) {
          define(Rails3);
        }
      }).call(exports2);
    }
  });

  // ../../node_modules/@hotwired/turbo-rails/node_modules/@rails/actioncable/src/adapters.js
  var adapters_default;
  var init_adapters = __esm({
    "../../node_modules/@hotwired/turbo-rails/node_modules/@rails/actioncable/src/adapters.js"() {
      adapters_default = {
        logger: self.console,
        WebSocket: self.WebSocket
      };
    }
  });

  // ../../node_modules/@hotwired/turbo-rails/node_modules/@rails/actioncable/src/logger.js
  var logger_default;
  var init_logger = __esm({
    "../../node_modules/@hotwired/turbo-rails/node_modules/@rails/actioncable/src/logger.js"() {
      init_adapters();
      logger_default = {
        log(...messages) {
          if (this.enabled) {
            messages.push(Date.now());
            adapters_default.logger.log("[ActionCable]", ...messages);
          }
        }
      };
    }
  });

  // ../../node_modules/@hotwired/turbo-rails/node_modules/@rails/actioncable/src/connection_monitor.js
  var now, secondsSince, clamp, ConnectionMonitor, connection_monitor_default;
  var init_connection_monitor = __esm({
    "../../node_modules/@hotwired/turbo-rails/node_modules/@rails/actioncable/src/connection_monitor.js"() {
      init_logger();
      now = () => new Date().getTime();
      secondsSince = (time) => (now() - time) / 1e3;
      clamp = (number, min2, max2) => Math.max(min2, Math.min(max2, number));
      ConnectionMonitor = class {
        constructor(connection) {
          this.visibilityDidChange = this.visibilityDidChange.bind(this);
          this.connection = connection;
          this.reconnectAttempts = 0;
        }
        start() {
          if (!this.isRunning()) {
            this.startedAt = now();
            delete this.stoppedAt;
            this.startPolling();
            addEventListener("visibilitychange", this.visibilityDidChange);
            logger_default.log(`ConnectionMonitor started. pollInterval = ${this.getPollInterval()} ms`);
          }
        }
        stop() {
          if (this.isRunning()) {
            this.stoppedAt = now();
            this.stopPolling();
            removeEventListener("visibilitychange", this.visibilityDidChange);
            logger_default.log("ConnectionMonitor stopped");
          }
        }
        isRunning() {
          return this.startedAt && !this.stoppedAt;
        }
        recordPing() {
          this.pingedAt = now();
        }
        recordConnect() {
          this.reconnectAttempts = 0;
          this.recordPing();
          delete this.disconnectedAt;
          logger_default.log("ConnectionMonitor recorded connect");
        }
        recordDisconnect() {
          this.disconnectedAt = now();
          logger_default.log("ConnectionMonitor recorded disconnect");
        }
        startPolling() {
          this.stopPolling();
          this.poll();
        }
        stopPolling() {
          clearTimeout(this.pollTimeout);
        }
        poll() {
          this.pollTimeout = setTimeout(() => {
            this.reconnectIfStale();
            this.poll();
          }, this.getPollInterval());
        }
        getPollInterval() {
          const { min: min2, max: max2, multiplier } = this.constructor.pollInterval;
          const interval = multiplier * Math.log(this.reconnectAttempts + 1);
          return Math.round(clamp(interval, min2, max2) * 1e3);
        }
        reconnectIfStale() {
          if (this.connectionIsStale()) {
            logger_default.log(`ConnectionMonitor detected stale connection. reconnectAttempts = ${this.reconnectAttempts}, pollInterval = ${this.getPollInterval()} ms, time disconnected = ${secondsSince(this.disconnectedAt)} s, stale threshold = ${this.constructor.staleThreshold} s`);
            this.reconnectAttempts++;
            if (this.disconnectedRecently()) {
              logger_default.log("ConnectionMonitor skipping reopening recent disconnect");
            } else {
              logger_default.log("ConnectionMonitor reopening");
              this.connection.reopen();
            }
          }
        }
        connectionIsStale() {
          return secondsSince(this.pingedAt ? this.pingedAt : this.startedAt) > this.constructor.staleThreshold;
        }
        disconnectedRecently() {
          return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold;
        }
        visibilityDidChange() {
          if (document.visibilityState === "visible") {
            setTimeout(() => {
              if (this.connectionIsStale() || !this.connection.isOpen()) {
                logger_default.log(`ConnectionMonitor reopening stale connection on visibilitychange. visibilityState = ${document.visibilityState}`);
                this.connection.reopen();
              }
            }, 200);
          }
        }
      };
      ConnectionMonitor.pollInterval = {
        min: 3,
        max: 30,
        multiplier: 5
      };
      ConnectionMonitor.staleThreshold = 6;
      connection_monitor_default = ConnectionMonitor;
    }
  });

  // ../../node_modules/@hotwired/turbo-rails/node_modules/@rails/actioncable/src/internal.js
  var internal_default;
  var init_internal = __esm({
    "../../node_modules/@hotwired/turbo-rails/node_modules/@rails/actioncable/src/internal.js"() {
      internal_default = {
        "message_types": {
          "welcome": "welcome",
          "disconnect": "disconnect",
          "ping": "ping",
          "confirmation": "confirm_subscription",
          "rejection": "reject_subscription"
        },
        "disconnect_reasons": {
          "unauthorized": "unauthorized",
          "invalid_request": "invalid_request",
          "server_restart": "server_restart"
        },
        "default_mount_path": "/cable",
        "protocols": [
          "actioncable-v1-json",
          "actioncable-unsupported"
        ]
      };
    }
  });

  // ../../node_modules/@hotwired/turbo-rails/node_modules/@rails/actioncable/src/connection.js
  var message_types, protocols, supportedProtocols, indexOf, Connection, connection_default;
  var init_connection = __esm({
    "../../node_modules/@hotwired/turbo-rails/node_modules/@rails/actioncable/src/connection.js"() {
      init_adapters();
      init_connection_monitor();
      init_internal();
      init_logger();
      ({ message_types, protocols } = internal_default);
      supportedProtocols = protocols.slice(0, protocols.length - 1);
      indexOf = [].indexOf;
      Connection = class {
        constructor(consumer2) {
          this.open = this.open.bind(this);
          this.consumer = consumer2;
          this.subscriptions = this.consumer.subscriptions;
          this.monitor = new connection_monitor_default(this);
          this.disconnected = true;
        }
        send(data) {
          if (this.isOpen()) {
            this.webSocket.send(JSON.stringify(data));
            return true;
          } else {
            return false;
          }
        }
        open() {
          if (this.isActive()) {
            logger_default.log(`Attempted to open WebSocket, but existing socket is ${this.getState()}`);
            return false;
          } else {
            logger_default.log(`Opening WebSocket, current state is ${this.getState()}, subprotocols: ${protocols}`);
            if (this.webSocket) {
              this.uninstallEventHandlers();
            }
            this.webSocket = new adapters_default.WebSocket(this.consumer.url, protocols);
            this.installEventHandlers();
            this.monitor.start();
            return true;
          }
        }
        close({ allowReconnect } = { allowReconnect: true }) {
          if (!allowReconnect) {
            this.monitor.stop();
          }
          if (this.isActive()) {
            return this.webSocket.close();
          }
        }
        reopen() {
          logger_default.log(`Reopening WebSocket, current state is ${this.getState()}`);
          if (this.isActive()) {
            try {
              return this.close();
            } catch (error2) {
              logger_default.log("Failed to reopen WebSocket", error2);
            } finally {
              logger_default.log(`Reopening WebSocket in ${this.constructor.reopenDelay}ms`);
              setTimeout(this.open, this.constructor.reopenDelay);
            }
          } else {
            return this.open();
          }
        }
        getProtocol() {
          if (this.webSocket) {
            return this.webSocket.protocol;
          }
        }
        isOpen() {
          return this.isState("open");
        }
        isActive() {
          return this.isState("open", "connecting");
        }
        isProtocolSupported() {
          return indexOf.call(supportedProtocols, this.getProtocol()) >= 0;
        }
        isState(...states) {
          return indexOf.call(states, this.getState()) >= 0;
        }
        getState() {
          if (this.webSocket) {
            for (let state in adapters_default.WebSocket) {
              if (adapters_default.WebSocket[state] === this.webSocket.readyState) {
                return state.toLowerCase();
              }
            }
          }
          return null;
        }
        installEventHandlers() {
          for (let eventName in this.events) {
            const handler = this.events[eventName].bind(this);
            this.webSocket[`on${eventName}`] = handler;
          }
        }
        uninstallEventHandlers() {
          for (let eventName in this.events) {
            this.webSocket[`on${eventName}`] = function() {
            };
          }
        }
      };
      Connection.reopenDelay = 500;
      Connection.prototype.events = {
        message(event) {
          if (!this.isProtocolSupported()) {
            return;
          }
          const { identifier, message, reason, reconnect, type } = JSON.parse(event.data);
          switch (type) {
            case message_types.welcome:
              this.monitor.recordConnect();
              return this.subscriptions.reload();
            case message_types.disconnect:
              logger_default.log(`Disconnecting. Reason: ${reason}`);
              return this.close({ allowReconnect: reconnect });
            case message_types.ping:
              return this.monitor.recordPing();
            case message_types.confirmation:
              return this.subscriptions.notify(identifier, "connected");
            case message_types.rejection:
              return this.subscriptions.reject(identifier);
            default:
              return this.subscriptions.notify(identifier, "received", message);
          }
        },
        open() {
          logger_default.log(`WebSocket onopen event, using '${this.getProtocol()}' subprotocol`);
          this.disconnected = false;
          if (!this.isProtocolSupported()) {
            logger_default.log("Protocol is unsupported. Stopping monitor and disconnecting.");
            return this.close({ allowReconnect: false });
          }
        },
        close(event) {
          logger_default.log("WebSocket onclose event");
          if (this.disconnected) {
            return;
          }
          this.disconnected = true;
          this.monitor.recordDisconnect();
          return this.subscriptions.notifyAll("disconnected", { willAttemptReconnect: this.monitor.isRunning() });
        },
        error() {
          logger_default.log("WebSocket onerror event");
        }
      };
      connection_default = Connection;
    }
  });

  // ../../node_modules/@hotwired/turbo-rails/node_modules/@rails/actioncable/src/subscription.js
  var extend, Subscription;
  var init_subscription = __esm({
    "../../node_modules/@hotwired/turbo-rails/node_modules/@rails/actioncable/src/subscription.js"() {
      extend = function(object, properties) {
        if (properties != null) {
          for (let key in properties) {
            const value = properties[key];
            object[key] = value;
          }
        }
        return object;
      };
      Subscription = class {
        constructor(consumer2, params = {}, mixin) {
          this.consumer = consumer2;
          this.identifier = JSON.stringify(params);
          extend(this, mixin);
        }
        perform(action, data = {}) {
          data.action = action;
          return this.send(data);
        }
        send(data) {
          return this.consumer.send({ command: "message", identifier: this.identifier, data: JSON.stringify(data) });
        }
        unsubscribe() {
          return this.consumer.subscriptions.remove(this);
        }
      };
    }
  });

  // ../../node_modules/@hotwired/turbo-rails/node_modules/@rails/actioncable/src/subscriptions.js
  var Subscriptions;
  var init_subscriptions = __esm({
    "../../node_modules/@hotwired/turbo-rails/node_modules/@rails/actioncable/src/subscriptions.js"() {
      init_subscription();
      Subscriptions = class {
        constructor(consumer2) {
          this.consumer = consumer2;
          this.subscriptions = [];
        }
        create(channelName, mixin) {
          const channel = channelName;
          const params = typeof channel === "object" ? channel : { channel };
          const subscription = new Subscription(this.consumer, params, mixin);
          return this.add(subscription);
        }
        add(subscription) {
          this.subscriptions.push(subscription);
          this.consumer.ensureActiveConnection();
          this.notify(subscription, "initialized");
          this.sendCommand(subscription, "subscribe");
          return subscription;
        }
        remove(subscription) {
          this.forget(subscription);
          if (!this.findAll(subscription.identifier).length) {
            this.sendCommand(subscription, "unsubscribe");
          }
          return subscription;
        }
        reject(identifier) {
          return this.findAll(identifier).map((subscription) => {
            this.forget(subscription);
            this.notify(subscription, "rejected");
            return subscription;
          });
        }
        forget(subscription) {
          this.subscriptions = this.subscriptions.filter((s4) => s4 !== subscription);
          return subscription;
        }
        findAll(identifier) {
          return this.subscriptions.filter((s4) => s4.identifier === identifier);
        }
        reload() {
          return this.subscriptions.map((subscription) => this.sendCommand(subscription, "subscribe"));
        }
        notifyAll(callbackName, ...args) {
          return this.subscriptions.map((subscription) => this.notify(subscription, callbackName, ...args));
        }
        notify(subscription, callbackName, ...args) {
          let subscriptions;
          if (typeof subscription === "string") {
            subscriptions = this.findAll(subscription);
          } else {
            subscriptions = [subscription];
          }
          return subscriptions.map((subscription2) => typeof subscription2[callbackName] === "function" ? subscription2[callbackName](...args) : void 0);
        }
        sendCommand(subscription, command) {
          const { identifier } = subscription;
          return this.consumer.send({ command, identifier });
        }
      };
    }
  });

  // ../../node_modules/@hotwired/turbo-rails/node_modules/@rails/actioncable/src/consumer.js
  function createWebSocketURL(url) {
    if (typeof url === "function") {
      url = url();
    }
    if (url && !/^wss?:/i.test(url)) {
      const a4 = document.createElement("a");
      a4.href = url;
      a4.href = a4.href;
      a4.protocol = a4.protocol.replace("http", "ws");
      return a4.href;
    } else {
      return url;
    }
  }
  var Consumer;
  var init_consumer = __esm({
    "../../node_modules/@hotwired/turbo-rails/node_modules/@rails/actioncable/src/consumer.js"() {
      init_connection();
      init_subscriptions();
      Consumer = class {
        constructor(url) {
          this._url = url;
          this.subscriptions = new Subscriptions(this);
          this.connection = new connection_default(this);
        }
        get url() {
          return createWebSocketURL(this._url);
        }
        send(data) {
          return this.connection.send(data);
        }
        connect() {
          return this.connection.open();
        }
        disconnect() {
          return this.connection.close({ allowReconnect: false });
        }
        ensureActiveConnection() {
          if (!this.connection.isActive()) {
            return this.connection.open();
          }
        }
      };
    }
  });

  // ../../node_modules/@hotwired/turbo-rails/node_modules/@rails/actioncable/src/index.js
  var src_exports = {};
  __export(src_exports, {
    Connection: () => connection_default,
    ConnectionMonitor: () => connection_monitor_default,
    Consumer: () => Consumer,
    INTERNAL: () => internal_default,
    Subscription: () => Subscription,
    Subscriptions: () => Subscriptions,
    adapters: () => adapters_default,
    createConsumer: () => createConsumer,
    createWebSocketURL: () => createWebSocketURL,
    getConfig: () => getConfig,
    logger: () => logger_default
  });
  function createConsumer(url = getConfig("url") || internal_default.default_mount_path) {
    return new Consumer(url);
  }
  function getConfig(name2) {
    const element = document.head.querySelector(`meta[name='action-cable-${name2}']`);
    if (element) {
      return element.getAttribute("content");
    }
  }
  var init_src = __esm({
    "../../node_modules/@hotwired/turbo-rails/node_modules/@rails/actioncable/src/index.js"() {
      init_connection();
      init_connection_monitor();
      init_consumer();
      init_internal();
      init_subscription();
      init_subscriptions();
      init_adapters();
      init_logger();
    }
  });

  // ../../node_modules/@rails/activestorage/app/assets/javascripts/activestorage.js
  var require_activestorage = __commonJS({
    "../../node_modules/@rails/activestorage/app/assets/javascripts/activestorage.js"(exports2, module4) {
      (function(global, factory) {
        typeof exports2 === "object" && typeof module4 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.ActiveStorage = {}));
      })(exports2, function(exports3) {
        "use strict";
        var sparkMd5 = {
          exports: {}
        };
        (function(module5, exports4) {
          (function(factory) {
            {
              module5.exports = factory();
            }
          })(function(undefined$1) {
            var hex_chr = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
            function md5cycle(x2, k2) {
              var a4 = x2[0], b2 = x2[1], c2 = x2[2], d3 = x2[3];
              a4 += (b2 & c2 | ~b2 & d3) + k2[0] - 680876936 | 0;
              a4 = (a4 << 7 | a4 >>> 25) + b2 | 0;
              d3 += (a4 & b2 | ~a4 & c2) + k2[1] - 389564586 | 0;
              d3 = (d3 << 12 | d3 >>> 20) + a4 | 0;
              c2 += (d3 & a4 | ~d3 & b2) + k2[2] + 606105819 | 0;
              c2 = (c2 << 17 | c2 >>> 15) + d3 | 0;
              b2 += (c2 & d3 | ~c2 & a4) + k2[3] - 1044525330 | 0;
              b2 = (b2 << 22 | b2 >>> 10) + c2 | 0;
              a4 += (b2 & c2 | ~b2 & d3) + k2[4] - 176418897 | 0;
              a4 = (a4 << 7 | a4 >>> 25) + b2 | 0;
              d3 += (a4 & b2 | ~a4 & c2) + k2[5] + 1200080426 | 0;
              d3 = (d3 << 12 | d3 >>> 20) + a4 | 0;
              c2 += (d3 & a4 | ~d3 & b2) + k2[6] - 1473231341 | 0;
              c2 = (c2 << 17 | c2 >>> 15) + d3 | 0;
              b2 += (c2 & d3 | ~c2 & a4) + k2[7] - 45705983 | 0;
              b2 = (b2 << 22 | b2 >>> 10) + c2 | 0;
              a4 += (b2 & c2 | ~b2 & d3) + k2[8] + 1770035416 | 0;
              a4 = (a4 << 7 | a4 >>> 25) + b2 | 0;
              d3 += (a4 & b2 | ~a4 & c2) + k2[9] - 1958414417 | 0;
              d3 = (d3 << 12 | d3 >>> 20) + a4 | 0;
              c2 += (d3 & a4 | ~d3 & b2) + k2[10] - 42063 | 0;
              c2 = (c2 << 17 | c2 >>> 15) + d3 | 0;
              b2 += (c2 & d3 | ~c2 & a4) + k2[11] - 1990404162 | 0;
              b2 = (b2 << 22 | b2 >>> 10) + c2 | 0;
              a4 += (b2 & c2 | ~b2 & d3) + k2[12] + 1804603682 | 0;
              a4 = (a4 << 7 | a4 >>> 25) + b2 | 0;
              d3 += (a4 & b2 | ~a4 & c2) + k2[13] - 40341101 | 0;
              d3 = (d3 << 12 | d3 >>> 20) + a4 | 0;
              c2 += (d3 & a4 | ~d3 & b2) + k2[14] - 1502002290 | 0;
              c2 = (c2 << 17 | c2 >>> 15) + d3 | 0;
              b2 += (c2 & d3 | ~c2 & a4) + k2[15] + 1236535329 | 0;
              b2 = (b2 << 22 | b2 >>> 10) + c2 | 0;
              a4 += (b2 & d3 | c2 & ~d3) + k2[1] - 165796510 | 0;
              a4 = (a4 << 5 | a4 >>> 27) + b2 | 0;
              d3 += (a4 & c2 | b2 & ~c2) + k2[6] - 1069501632 | 0;
              d3 = (d3 << 9 | d3 >>> 23) + a4 | 0;
              c2 += (d3 & b2 | a4 & ~b2) + k2[11] + 643717713 | 0;
              c2 = (c2 << 14 | c2 >>> 18) + d3 | 0;
              b2 += (c2 & a4 | d3 & ~a4) + k2[0] - 373897302 | 0;
              b2 = (b2 << 20 | b2 >>> 12) + c2 | 0;
              a4 += (b2 & d3 | c2 & ~d3) + k2[5] - 701558691 | 0;
              a4 = (a4 << 5 | a4 >>> 27) + b2 | 0;
              d3 += (a4 & c2 | b2 & ~c2) + k2[10] + 38016083 | 0;
              d3 = (d3 << 9 | d3 >>> 23) + a4 | 0;
              c2 += (d3 & b2 | a4 & ~b2) + k2[15] - 660478335 | 0;
              c2 = (c2 << 14 | c2 >>> 18) + d3 | 0;
              b2 += (c2 & a4 | d3 & ~a4) + k2[4] - 405537848 | 0;
              b2 = (b2 << 20 | b2 >>> 12) + c2 | 0;
              a4 += (b2 & d3 | c2 & ~d3) + k2[9] + 568446438 | 0;
              a4 = (a4 << 5 | a4 >>> 27) + b2 | 0;
              d3 += (a4 & c2 | b2 & ~c2) + k2[14] - 1019803690 | 0;
              d3 = (d3 << 9 | d3 >>> 23) + a4 | 0;
              c2 += (d3 & b2 | a4 & ~b2) + k2[3] - 187363961 | 0;
              c2 = (c2 << 14 | c2 >>> 18) + d3 | 0;
              b2 += (c2 & a4 | d3 & ~a4) + k2[8] + 1163531501 | 0;
              b2 = (b2 << 20 | b2 >>> 12) + c2 | 0;
              a4 += (b2 & d3 | c2 & ~d3) + k2[13] - 1444681467 | 0;
              a4 = (a4 << 5 | a4 >>> 27) + b2 | 0;
              d3 += (a4 & c2 | b2 & ~c2) + k2[2] - 51403784 | 0;
              d3 = (d3 << 9 | d3 >>> 23) + a4 | 0;
              c2 += (d3 & b2 | a4 & ~b2) + k2[7] + 1735328473 | 0;
              c2 = (c2 << 14 | c2 >>> 18) + d3 | 0;
              b2 += (c2 & a4 | d3 & ~a4) + k2[12] - 1926607734 | 0;
              b2 = (b2 << 20 | b2 >>> 12) + c2 | 0;
              a4 += (b2 ^ c2 ^ d3) + k2[5] - 378558 | 0;
              a4 = (a4 << 4 | a4 >>> 28) + b2 | 0;
              d3 += (a4 ^ b2 ^ c2) + k2[8] - 2022574463 | 0;
              d3 = (d3 << 11 | d3 >>> 21) + a4 | 0;
              c2 += (d3 ^ a4 ^ b2) + k2[11] + 1839030562 | 0;
              c2 = (c2 << 16 | c2 >>> 16) + d3 | 0;
              b2 += (c2 ^ d3 ^ a4) + k2[14] - 35309556 | 0;
              b2 = (b2 << 23 | b2 >>> 9) + c2 | 0;
              a4 += (b2 ^ c2 ^ d3) + k2[1] - 1530992060 | 0;
              a4 = (a4 << 4 | a4 >>> 28) + b2 | 0;
              d3 += (a4 ^ b2 ^ c2) + k2[4] + 1272893353 | 0;
              d3 = (d3 << 11 | d3 >>> 21) + a4 | 0;
              c2 += (d3 ^ a4 ^ b2) + k2[7] - 155497632 | 0;
              c2 = (c2 << 16 | c2 >>> 16) + d3 | 0;
              b2 += (c2 ^ d3 ^ a4) + k2[10] - 1094730640 | 0;
              b2 = (b2 << 23 | b2 >>> 9) + c2 | 0;
              a4 += (b2 ^ c2 ^ d3) + k2[13] + 681279174 | 0;
              a4 = (a4 << 4 | a4 >>> 28) + b2 | 0;
              d3 += (a4 ^ b2 ^ c2) + k2[0] - 358537222 | 0;
              d3 = (d3 << 11 | d3 >>> 21) + a4 | 0;
              c2 += (d3 ^ a4 ^ b2) + k2[3] - 722521979 | 0;
              c2 = (c2 << 16 | c2 >>> 16) + d3 | 0;
              b2 += (c2 ^ d3 ^ a4) + k2[6] + 76029189 | 0;
              b2 = (b2 << 23 | b2 >>> 9) + c2 | 0;
              a4 += (b2 ^ c2 ^ d3) + k2[9] - 640364487 | 0;
              a4 = (a4 << 4 | a4 >>> 28) + b2 | 0;
              d3 += (a4 ^ b2 ^ c2) + k2[12] - 421815835 | 0;
              d3 = (d3 << 11 | d3 >>> 21) + a4 | 0;
              c2 += (d3 ^ a4 ^ b2) + k2[15] + 530742520 | 0;
              c2 = (c2 << 16 | c2 >>> 16) + d3 | 0;
              b2 += (c2 ^ d3 ^ a4) + k2[2] - 995338651 | 0;
              b2 = (b2 << 23 | b2 >>> 9) + c2 | 0;
              a4 += (c2 ^ (b2 | ~d3)) + k2[0] - 198630844 | 0;
              a4 = (a4 << 6 | a4 >>> 26) + b2 | 0;
              d3 += (b2 ^ (a4 | ~c2)) + k2[7] + 1126891415 | 0;
              d3 = (d3 << 10 | d3 >>> 22) + a4 | 0;
              c2 += (a4 ^ (d3 | ~b2)) + k2[14] - 1416354905 | 0;
              c2 = (c2 << 15 | c2 >>> 17) + d3 | 0;
              b2 += (d3 ^ (c2 | ~a4)) + k2[5] - 57434055 | 0;
              b2 = (b2 << 21 | b2 >>> 11) + c2 | 0;
              a4 += (c2 ^ (b2 | ~d3)) + k2[12] + 1700485571 | 0;
              a4 = (a4 << 6 | a4 >>> 26) + b2 | 0;
              d3 += (b2 ^ (a4 | ~c2)) + k2[3] - 1894986606 | 0;
              d3 = (d3 << 10 | d3 >>> 22) + a4 | 0;
              c2 += (a4 ^ (d3 | ~b2)) + k2[10] - 1051523 | 0;
              c2 = (c2 << 15 | c2 >>> 17) + d3 | 0;
              b2 += (d3 ^ (c2 | ~a4)) + k2[1] - 2054922799 | 0;
              b2 = (b2 << 21 | b2 >>> 11) + c2 | 0;
              a4 += (c2 ^ (b2 | ~d3)) + k2[8] + 1873313359 | 0;
              a4 = (a4 << 6 | a4 >>> 26) + b2 | 0;
              d3 += (b2 ^ (a4 | ~c2)) + k2[15] - 30611744 | 0;
              d3 = (d3 << 10 | d3 >>> 22) + a4 | 0;
              c2 += (a4 ^ (d3 | ~b2)) + k2[6] - 1560198380 | 0;
              c2 = (c2 << 15 | c2 >>> 17) + d3 | 0;
              b2 += (d3 ^ (c2 | ~a4)) + k2[13] + 1309151649 | 0;
              b2 = (b2 << 21 | b2 >>> 11) + c2 | 0;
              a4 += (c2 ^ (b2 | ~d3)) + k2[4] - 145523070 | 0;
              a4 = (a4 << 6 | a4 >>> 26) + b2 | 0;
              d3 += (b2 ^ (a4 | ~c2)) + k2[11] - 1120210379 | 0;
              d3 = (d3 << 10 | d3 >>> 22) + a4 | 0;
              c2 += (a4 ^ (d3 | ~b2)) + k2[2] + 718787259 | 0;
              c2 = (c2 << 15 | c2 >>> 17) + d3 | 0;
              b2 += (d3 ^ (c2 | ~a4)) + k2[9] - 343485551 | 0;
              b2 = (b2 << 21 | b2 >>> 11) + c2 | 0;
              x2[0] = a4 + x2[0] | 0;
              x2[1] = b2 + x2[1] | 0;
              x2[2] = c2 + x2[2] | 0;
              x2[3] = d3 + x2[3] | 0;
            }
            function md5blk(s4) {
              var md5blks = [], i3;
              for (i3 = 0; i3 < 64; i3 += 4) {
                md5blks[i3 >> 2] = s4.charCodeAt(i3) + (s4.charCodeAt(i3 + 1) << 8) + (s4.charCodeAt(i3 + 2) << 16) + (s4.charCodeAt(i3 + 3) << 24);
              }
              return md5blks;
            }
            function md5blk_array(a4) {
              var md5blks = [], i3;
              for (i3 = 0; i3 < 64; i3 += 4) {
                md5blks[i3 >> 2] = a4[i3] + (a4[i3 + 1] << 8) + (a4[i3 + 2] << 16) + (a4[i3 + 3] << 24);
              }
              return md5blks;
            }
            function md51(s4) {
              var n2 = s4.length, state = [1732584193, -271733879, -1732584194, 271733878], i3, length, tail, tmp, lo, hi;
              for (i3 = 64; i3 <= n2; i3 += 64) {
                md5cycle(state, md5blk(s4.substring(i3 - 64, i3)));
              }
              s4 = s4.substring(i3 - 64);
              length = s4.length;
              tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
              for (i3 = 0; i3 < length; i3 += 1) {
                tail[i3 >> 2] |= s4.charCodeAt(i3) << (i3 % 4 << 3);
              }
              tail[i3 >> 2] |= 128 << (i3 % 4 << 3);
              if (i3 > 55) {
                md5cycle(state, tail);
                for (i3 = 0; i3 < 16; i3 += 1) {
                  tail[i3] = 0;
                }
              }
              tmp = n2 * 8;
              tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
              lo = parseInt(tmp[2], 16);
              hi = parseInt(tmp[1], 16) || 0;
              tail[14] = lo;
              tail[15] = hi;
              md5cycle(state, tail);
              return state;
            }
            function md51_array(a4) {
              var n2 = a4.length, state = [1732584193, -271733879, -1732584194, 271733878], i3, length, tail, tmp, lo, hi;
              for (i3 = 64; i3 <= n2; i3 += 64) {
                md5cycle(state, md5blk_array(a4.subarray(i3 - 64, i3)));
              }
              a4 = i3 - 64 < n2 ? a4.subarray(i3 - 64) : new Uint8Array(0);
              length = a4.length;
              tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
              for (i3 = 0; i3 < length; i3 += 1) {
                tail[i3 >> 2] |= a4[i3] << (i3 % 4 << 3);
              }
              tail[i3 >> 2] |= 128 << (i3 % 4 << 3);
              if (i3 > 55) {
                md5cycle(state, tail);
                for (i3 = 0; i3 < 16; i3 += 1) {
                  tail[i3] = 0;
                }
              }
              tmp = n2 * 8;
              tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
              lo = parseInt(tmp[2], 16);
              hi = parseInt(tmp[1], 16) || 0;
              tail[14] = lo;
              tail[15] = hi;
              md5cycle(state, tail);
              return state;
            }
            function rhex(n2) {
              var s4 = "", j;
              for (j = 0; j < 4; j += 1) {
                s4 += hex_chr[n2 >> j * 8 + 4 & 15] + hex_chr[n2 >> j * 8 & 15];
              }
              return s4;
            }
            function hex2(x2) {
              var i3;
              for (i3 = 0; i3 < x2.length; i3 += 1) {
                x2[i3] = rhex(x2[i3]);
              }
              return x2.join("");
            }
            if (hex2(md51("hello")) !== "5d41402abc4b2a76b9719d911017c592")
              ;
            if (typeof ArrayBuffer !== "undefined" && !ArrayBuffer.prototype.slice) {
              (function() {
                function clamp2(val, length) {
                  val = val | 0 || 0;
                  if (val < 0) {
                    return Math.max(val + length, 0);
                  }
                  return Math.min(val, length);
                }
                ArrayBuffer.prototype.slice = function(from2, to2) {
                  var length = this.byteLength, begin = clamp2(from2, length), end2 = length, num, target, targetArray, sourceArray;
                  if (to2 !== undefined$1) {
                    end2 = clamp2(to2, length);
                  }
                  if (begin > end2) {
                    return new ArrayBuffer(0);
                  }
                  num = end2 - begin;
                  target = new ArrayBuffer(num);
                  targetArray = new Uint8Array(target);
                  sourceArray = new Uint8Array(this, begin, num);
                  targetArray.set(sourceArray);
                  return target;
                };
              })();
            }
            function toUtf8(str) {
              if (/[\u0080-\uFFFF]/.test(str)) {
                str = unescape(encodeURIComponent(str));
              }
              return str;
            }
            function utf8Str2ArrayBuffer(str, returnUInt8Array) {
              var length = str.length, buff = new ArrayBuffer(length), arr = new Uint8Array(buff), i3;
              for (i3 = 0; i3 < length; i3 += 1) {
                arr[i3] = str.charCodeAt(i3);
              }
              return returnUInt8Array ? arr : buff;
            }
            function arrayBuffer2Utf8Str(buff) {
              return String.fromCharCode.apply(null, new Uint8Array(buff));
            }
            function concatenateArrayBuffers(first, second, returnUInt8Array) {
              var result = new Uint8Array(first.byteLength + second.byteLength);
              result.set(new Uint8Array(first));
              result.set(new Uint8Array(second), first.byteLength);
              return returnUInt8Array ? result : result.buffer;
            }
            function hexToBinaryString(hex3) {
              var bytes = [], length = hex3.length, x2;
              for (x2 = 0; x2 < length - 1; x2 += 2) {
                bytes.push(parseInt(hex3.substr(x2, 2), 16));
              }
              return String.fromCharCode.apply(String, bytes);
            }
            function SparkMD52() {
              this.reset();
            }
            SparkMD52.prototype.append = function(str) {
              this.appendBinary(toUtf8(str));
              return this;
            };
            SparkMD52.prototype.appendBinary = function(contents) {
              this._buff += contents;
              this._length += contents.length;
              var length = this._buff.length, i3;
              for (i3 = 64; i3 <= length; i3 += 64) {
                md5cycle(this._hash, md5blk(this._buff.substring(i3 - 64, i3)));
              }
              this._buff = this._buff.substring(i3 - 64);
              return this;
            };
            SparkMD52.prototype.end = function(raw) {
              var buff = this._buff, length = buff.length, i3, tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], ret;
              for (i3 = 0; i3 < length; i3 += 1) {
                tail[i3 >> 2] |= buff.charCodeAt(i3) << (i3 % 4 << 3);
              }
              this._finish(tail, length);
              ret = hex2(this._hash);
              if (raw) {
                ret = hexToBinaryString(ret);
              }
              this.reset();
              return ret;
            };
            SparkMD52.prototype.reset = function() {
              this._buff = "";
              this._length = 0;
              this._hash = [1732584193, -271733879, -1732584194, 271733878];
              return this;
            };
            SparkMD52.prototype.getState = function() {
              return {
                buff: this._buff,
                length: this._length,
                hash: this._hash.slice()
              };
            };
            SparkMD52.prototype.setState = function(state) {
              this._buff = state.buff;
              this._length = state.length;
              this._hash = state.hash;
              return this;
            };
            SparkMD52.prototype.destroy = function() {
              delete this._hash;
              delete this._buff;
              delete this._length;
            };
            SparkMD52.prototype._finish = function(tail, length) {
              var i3 = length, tmp, lo, hi;
              tail[i3 >> 2] |= 128 << (i3 % 4 << 3);
              if (i3 > 55) {
                md5cycle(this._hash, tail);
                for (i3 = 0; i3 < 16; i3 += 1) {
                  tail[i3] = 0;
                }
              }
              tmp = this._length * 8;
              tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
              lo = parseInt(tmp[2], 16);
              hi = parseInt(tmp[1], 16) || 0;
              tail[14] = lo;
              tail[15] = hi;
              md5cycle(this._hash, tail);
            };
            SparkMD52.hash = function(str, raw) {
              return SparkMD52.hashBinary(toUtf8(str), raw);
            };
            SparkMD52.hashBinary = function(content, raw) {
              var hash3 = md51(content), ret = hex2(hash3);
              return raw ? hexToBinaryString(ret) : ret;
            };
            SparkMD52.ArrayBuffer = function() {
              this.reset();
            };
            SparkMD52.ArrayBuffer.prototype.append = function(arr) {
              var buff = concatenateArrayBuffers(this._buff.buffer, arr, true), length = buff.length, i3;
              this._length += arr.byteLength;
              for (i3 = 64; i3 <= length; i3 += 64) {
                md5cycle(this._hash, md5blk_array(buff.subarray(i3 - 64, i3)));
              }
              this._buff = i3 - 64 < length ? new Uint8Array(buff.buffer.slice(i3 - 64)) : new Uint8Array(0);
              return this;
            };
            SparkMD52.ArrayBuffer.prototype.end = function(raw) {
              var buff = this._buff, length = buff.length, tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], i3, ret;
              for (i3 = 0; i3 < length; i3 += 1) {
                tail[i3 >> 2] |= buff[i3] << (i3 % 4 << 3);
              }
              this._finish(tail, length);
              ret = hex2(this._hash);
              if (raw) {
                ret = hexToBinaryString(ret);
              }
              this.reset();
              return ret;
            };
            SparkMD52.ArrayBuffer.prototype.reset = function() {
              this._buff = new Uint8Array(0);
              this._length = 0;
              this._hash = [1732584193, -271733879, -1732584194, 271733878];
              return this;
            };
            SparkMD52.ArrayBuffer.prototype.getState = function() {
              var state = SparkMD52.prototype.getState.call(this);
              state.buff = arrayBuffer2Utf8Str(state.buff);
              return state;
            };
            SparkMD52.ArrayBuffer.prototype.setState = function(state) {
              state.buff = utf8Str2ArrayBuffer(state.buff, true);
              return SparkMD52.prototype.setState.call(this, state);
            };
            SparkMD52.ArrayBuffer.prototype.destroy = SparkMD52.prototype.destroy;
            SparkMD52.ArrayBuffer.prototype._finish = SparkMD52.prototype._finish;
            SparkMD52.ArrayBuffer.hash = function(arr, raw) {
              var hash3 = md51_array(new Uint8Array(arr)), ret = hex2(hash3);
              return raw ? hexToBinaryString(ret) : ret;
            };
            return SparkMD52;
          });
        })(sparkMd5);
        var SparkMD5 = sparkMd5.exports;
        const fileSlice = File.prototype.slice || File.prototype.mozSlice || File.prototype.webkitSlice;
        class FileChecksum {
          static create(file, callback2) {
            const instance = new FileChecksum(file);
            instance.create(callback2);
          }
          constructor(file) {
            this.file = file;
            this.chunkSize = 2097152;
            this.chunkCount = Math.ceil(this.file.size / this.chunkSize);
            this.chunkIndex = 0;
          }
          create(callback2) {
            this.callback = callback2;
            this.md5Buffer = new SparkMD5.ArrayBuffer();
            this.fileReader = new FileReader();
            this.fileReader.addEventListener("load", (event) => this.fileReaderDidLoad(event));
            this.fileReader.addEventListener("error", (event) => this.fileReaderDidError(event));
            this.readNextChunk();
          }
          fileReaderDidLoad(event) {
            this.md5Buffer.append(event.target.result);
            if (!this.readNextChunk()) {
              const binaryDigest = this.md5Buffer.end(true);
              const base64digest = btoa(binaryDigest);
              this.callback(null, base64digest);
            }
          }
          fileReaderDidError(event) {
            this.callback(`Error reading ${this.file.name}`);
          }
          readNextChunk() {
            if (this.chunkIndex < this.chunkCount || this.chunkIndex == 0 && this.chunkCount == 0) {
              const start4 = this.chunkIndex * this.chunkSize;
              const end2 = Math.min(start4 + this.chunkSize, this.file.size);
              const bytes = fileSlice.call(this.file, start4, end2);
              this.fileReader.readAsArrayBuffer(bytes);
              this.chunkIndex++;
              return true;
            } else {
              return false;
            }
          }
        }
        function getMetaValue(name2) {
          const element = findElement(document.head, `meta[name="${name2}"]`);
          if (element) {
            return element.getAttribute("content");
          }
        }
        function findElements(root, selector) {
          if (typeof root == "string") {
            selector = root;
            root = document;
          }
          const elements3 = root.querySelectorAll(selector);
          return toArray(elements3);
        }
        function findElement(root, selector) {
          if (typeof root == "string") {
            selector = root;
            root = document;
          }
          return root.querySelector(selector);
        }
        function dispatchEvent2(element, type, eventInit = {}) {
          const { disabled } = element;
          const { bubbles, cancelable, detail } = eventInit;
          const event = document.createEvent("Event");
          event.initEvent(type, bubbles || true, cancelable || true);
          event.detail = detail || {};
          try {
            element.disabled = false;
            element.dispatchEvent(event);
          } finally {
            element.disabled = disabled;
          }
          return event;
        }
        function toArray(value) {
          if (Array.isArray(value)) {
            return value;
          } else if (Array.from) {
            return Array.from(value);
          } else {
            return [].slice.call(value);
          }
        }
        class BlobRecord {
          constructor(file, checksum, url, directUploadToken, attachmentName) {
            this.file = file;
            this.attributes = {
              filename: file.name,
              content_type: file.type || "application/octet-stream",
              byte_size: file.size,
              checksum
            };
            this.directUploadToken = directUploadToken;
            this.attachmentName = attachmentName;
            this.xhr = new XMLHttpRequest();
            this.xhr.open("POST", url, true);
            this.xhr.responseType = "json";
            this.xhr.setRequestHeader("Content-Type", "application/json");
            this.xhr.setRequestHeader("Accept", "application/json");
            this.xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
            const csrfToken = getMetaValue("csrf-token");
            if (csrfToken != void 0) {
              this.xhr.setRequestHeader("X-CSRF-Token", csrfToken);
            }
            this.xhr.addEventListener("load", (event) => this.requestDidLoad(event));
            this.xhr.addEventListener("error", (event) => this.requestDidError(event));
          }
          get status() {
            return this.xhr.status;
          }
          get response() {
            const { responseType, response } = this.xhr;
            if (responseType == "json") {
              return response;
            } else {
              return JSON.parse(response);
            }
          }
          create(callback2) {
            this.callback = callback2;
            this.xhr.send(JSON.stringify({
              blob: this.attributes,
              direct_upload_token: this.directUploadToken,
              attachment_name: this.attachmentName
            }));
          }
          requestDidLoad(event) {
            if (this.status >= 200 && this.status < 300) {
              const { response } = this;
              const { direct_upload } = response;
              delete response.direct_upload;
              this.attributes = response;
              this.directUploadData = direct_upload;
              this.callback(null, this.toJSON());
            } else {
              this.requestDidError(event);
            }
          }
          requestDidError(event) {
            this.callback(`Error creating Blob for "${this.file.name}". Status: ${this.status}`);
          }
          toJSON() {
            const result = {};
            for (const key in this.attributes) {
              result[key] = this.attributes[key];
            }
            return result;
          }
        }
        class BlobUpload {
          constructor(blob) {
            this.blob = blob;
            this.file = blob.file;
            const { url, headers } = blob.directUploadData;
            this.xhr = new XMLHttpRequest();
            this.xhr.open("PUT", url, true);
            this.xhr.responseType = "text";
            for (const key in headers) {
              this.xhr.setRequestHeader(key, headers[key]);
            }
            this.xhr.addEventListener("load", (event) => this.requestDidLoad(event));
            this.xhr.addEventListener("error", (event) => this.requestDidError(event));
          }
          create(callback2) {
            this.callback = callback2;
            this.xhr.send(this.file.slice());
          }
          requestDidLoad(event) {
            const { status, response } = this.xhr;
            if (status >= 200 && status < 300) {
              this.callback(null, response);
            } else {
              this.requestDidError(event);
            }
          }
          requestDidError(event) {
            this.callback(`Error storing "${this.file.name}". Status: ${this.xhr.status}`);
          }
        }
        let id = 0;
        class DirectUpload2 {
          constructor(file, url, serviceName, attachmentName, delegate) {
            this.id = ++id;
            this.file = file;
            this.url = url;
            this.serviceName = serviceName;
            this.attachmentName = attachmentName;
            this.delegate = delegate;
          }
          create(callback2) {
            FileChecksum.create(this.file, (error2, checksum) => {
              if (error2) {
                callback2(error2);
                return;
              }
              const blob = new BlobRecord(this.file, checksum, this.url, this.serviceName, this.attachmentName);
              notify(this.delegate, "directUploadWillCreateBlobWithXHR", blob.xhr);
              blob.create((error3) => {
                if (error3) {
                  callback2(error3);
                } else {
                  const upload = new BlobUpload(blob);
                  notify(this.delegate, "directUploadWillStoreFileWithXHR", upload.xhr);
                  upload.create((error4) => {
                    if (error4) {
                      callback2(error4);
                    } else {
                      callback2(null, blob.toJSON());
                    }
                  });
                }
              });
            });
          }
        }
        function notify(object, methodName, ...messages) {
          if (object && typeof object[methodName] == "function") {
            return object[methodName](...messages);
          }
        }
        class DirectUploadController {
          constructor(input, file) {
            this.input = input;
            this.file = file;
            this.directUpload = new DirectUpload2(this.file, this.url, this.directUploadToken, this.attachmentName, this);
            this.dispatch("initialize");
          }
          start(callback2) {
            const hiddenInput = document.createElement("input");
            hiddenInput.type = "hidden";
            hiddenInput.name = this.input.name;
            this.input.insertAdjacentElement("beforebegin", hiddenInput);
            this.dispatch("start");
            this.directUpload.create((error2, attributes) => {
              if (error2) {
                hiddenInput.parentNode.removeChild(hiddenInput);
                this.dispatchError(error2);
              } else {
                hiddenInput.value = attributes.signed_id;
              }
              this.dispatch("end");
              callback2(error2);
            });
          }
          uploadRequestDidProgress(event) {
            const progress = event.loaded / event.total * 100;
            if (progress) {
              this.dispatch("progress", {
                progress
              });
            }
          }
          get url() {
            return this.input.getAttribute("data-direct-upload-url");
          }
          get directUploadToken() {
            return this.input.getAttribute("data-direct-upload-token");
          }
          get attachmentName() {
            return this.input.getAttribute("data-direct-upload-attachment-name");
          }
          dispatch(name2, detail = {}) {
            detail.file = this.file;
            detail.id = this.directUpload.id;
            return dispatchEvent2(this.input, `direct-upload:${name2}`, {
              detail
            });
          }
          dispatchError(error2) {
            const event = this.dispatch("error", {
              error: error2
            });
            if (!event.defaultPrevented) {
              alert(error2);
            }
          }
          directUploadWillCreateBlobWithXHR(xhr) {
            this.dispatch("before-blob-request", {
              xhr
            });
          }
          directUploadWillStoreFileWithXHR(xhr) {
            this.dispatch("before-storage-request", {
              xhr
            });
            xhr.upload.addEventListener("progress", (event) => this.uploadRequestDidProgress(event));
          }
        }
        const inputSelector = "input[type=file][data-direct-upload-url]:not([disabled])";
        class DirectUploadsController {
          constructor(form) {
            this.form = form;
            this.inputs = findElements(form, inputSelector).filter((input) => input.files.length);
          }
          start(callback2) {
            const controllers2 = this.createDirectUploadControllers();
            const startNextController = () => {
              const controller = controllers2.shift();
              if (controller) {
                controller.start((error2) => {
                  if (error2) {
                    callback2(error2);
                    this.dispatch("end");
                  } else {
                    startNextController();
                  }
                });
              } else {
                callback2();
                this.dispatch("end");
              }
            };
            this.dispatch("start");
            startNextController();
          }
          createDirectUploadControllers() {
            const controllers2 = [];
            this.inputs.forEach((input) => {
              toArray(input.files).forEach((file) => {
                const controller = new DirectUploadController(input, file);
                controllers2.push(controller);
              });
            });
            return controllers2;
          }
          dispatch(name2, detail = {}) {
            return dispatchEvent2(this.form, `direct-uploads:${name2}`, {
              detail
            });
          }
        }
        const processingAttribute = "data-direct-uploads-processing";
        const submitButtonsByForm = /* @__PURE__ */ new WeakMap();
        let started = false;
        function start3() {
          if (!started) {
            started = true;
            document.addEventListener("click", didClick, true);
            document.addEventListener("submit", didSubmitForm, true);
            document.addEventListener("ajax:before", didSubmitRemoteElement);
          }
        }
        function didClick(event) {
          const { target } = event;
          if ((target.tagName == "INPUT" || target.tagName == "BUTTON") && target.type == "submit" && target.form) {
            submitButtonsByForm.set(target.form, target);
          }
        }
        function didSubmitForm(event) {
          handleFormSubmissionEvent(event);
        }
        function didSubmitRemoteElement(event) {
          if (event.target.tagName == "FORM") {
            handleFormSubmissionEvent(event);
          }
        }
        function handleFormSubmissionEvent(event) {
          const form = event.target;
          if (form.hasAttribute(processingAttribute)) {
            event.preventDefault();
            return;
          }
          const controller = new DirectUploadsController(form);
          const { inputs } = controller;
          if (inputs.length) {
            event.preventDefault();
            form.setAttribute(processingAttribute, "");
            inputs.forEach(disable);
            controller.start((error2) => {
              form.removeAttribute(processingAttribute);
              if (error2) {
                inputs.forEach(enable);
              } else {
                submitForm(form);
              }
            });
          }
        }
        function submitForm(form) {
          let button = submitButtonsByForm.get(form) || findElement(form, "input[type=submit], button[type=submit]");
          if (button) {
            const { disabled } = button;
            button.disabled = false;
            button.focus();
            button.click();
            button.disabled = disabled;
          } else {
            button = document.createElement("input");
            button.type = "submit";
            button.style.display = "none";
            form.appendChild(button);
            button.click();
            form.removeChild(button);
          }
          submitButtonsByForm.delete(form);
        }
        function disable(input) {
          input.disabled = true;
        }
        function enable(input) {
          input.disabled = false;
        }
        function autostart() {
          if (window.ActiveStorage) {
            start3();
          }
        }
        setTimeout(autostart, 1);
        exports3.DirectUpload = DirectUpload2;
        exports3.start = start3;
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
      });
    }
  });

  // ../../node_modules/clipboard/dist/clipboard.js
  var require_clipboard = __commonJS({
    "../../node_modules/clipboard/dist/clipboard.js"(exports2, module4) {
      (function webpackUniversalModuleDefinition(root, factory) {
        if (typeof exports2 === "object" && typeof module4 === "object")
          module4.exports = factory();
        else if (typeof define === "function" && define.amd)
          define([], factory);
        else if (typeof exports2 === "object")
          exports2["ClipboardJS"] = factory();
        else
          root["ClipboardJS"] = factory();
      })(exports2, function() {
        return function() {
          var __webpack_modules__ = {
            134: function(__unused_webpack_module, __webpack_exports__, __webpack_require__2) {
              "use strict";
              __webpack_require__2.d(__webpack_exports__, {
                "default": function() {
                  return clipboard;
                }
              });
              var tiny_emitter = __webpack_require__2(279);
              var tiny_emitter_default = /* @__PURE__ */ __webpack_require__2.n(tiny_emitter);
              var listen = __webpack_require__2(370);
              var listen_default = /* @__PURE__ */ __webpack_require__2.n(listen);
              var src_select = __webpack_require__2(817);
              var select_default = /* @__PURE__ */ __webpack_require__2.n(src_select);
              ;
              function _typeof36(obj) {
                "@babel/helpers - typeof";
                if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                  _typeof36 = function _typeof37(obj2) {
                    return typeof obj2;
                  };
                } else {
                  _typeof36 = function _typeof37(obj2) {
                    return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                  };
                }
                return _typeof36(obj);
              }
              function _classCallCheck35(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _defineProperties35(target, props) {
                for (var i3 = 0; i3 < props.length; i3++) {
                  var descriptor = props[i3];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              function _createClass35(Constructor, protoProps, staticProps) {
                if (protoProps)
                  _defineProperties35(Constructor.prototype, protoProps);
                if (staticProps)
                  _defineProperties35(Constructor, staticProps);
                return Constructor;
              }
              var ClipboardAction = /* @__PURE__ */ function() {
                function ClipboardAction2(options2) {
                  _classCallCheck35(this, ClipboardAction2);
                  this.resolveOptions(options2);
                  this.initSelection();
                }
                _createClass35(ClipboardAction2, [{
                  key: "resolveOptions",
                  value: function resolveOptions() {
                    var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                    this.action = options2.action;
                    this.container = options2.container;
                    this.emitter = options2.emitter;
                    this.target = options2.target;
                    this.text = options2.text;
                    this.trigger = options2.trigger;
                    this.selectedText = "";
                  }
                }, {
                  key: "initSelection",
                  value: function initSelection() {
                    if (this.text) {
                      this.selectFake();
                    } else if (this.target) {
                      this.selectTarget();
                    }
                  }
                }, {
                  key: "createFakeElement",
                  value: function createFakeElement() {
                    var isRTL = document.documentElement.getAttribute("dir") === "rtl";
                    this.fakeElem = document.createElement("textarea");
                    this.fakeElem.style.fontSize = "12pt";
                    this.fakeElem.style.border = "0";
                    this.fakeElem.style.padding = "0";
                    this.fakeElem.style.margin = "0";
                    this.fakeElem.style.position = "absolute";
                    this.fakeElem.style[isRTL ? "right" : "left"] = "-9999px";
                    var yPosition = window.pageYOffset || document.documentElement.scrollTop;
                    this.fakeElem.style.top = "".concat(yPosition, "px");
                    this.fakeElem.setAttribute("readonly", "");
                    this.fakeElem.value = this.text;
                    return this.fakeElem;
                  }
                }, {
                  key: "selectFake",
                  value: function selectFake() {
                    var _this = this;
                    var fakeElem = this.createFakeElement();
                    this.fakeHandlerCallback = function() {
                      return _this.removeFake();
                    };
                    this.fakeHandler = this.container.addEventListener("click", this.fakeHandlerCallback) || true;
                    this.container.appendChild(fakeElem);
                    this.selectedText = select_default()(fakeElem);
                    this.copyText();
                    this.removeFake();
                  }
                }, {
                  key: "removeFake",
                  value: function removeFake() {
                    if (this.fakeHandler) {
                      this.container.removeEventListener("click", this.fakeHandlerCallback);
                      this.fakeHandler = null;
                      this.fakeHandlerCallback = null;
                    }
                    if (this.fakeElem) {
                      this.container.removeChild(this.fakeElem);
                      this.fakeElem = null;
                    }
                  }
                }, {
                  key: "selectTarget",
                  value: function selectTarget() {
                    this.selectedText = select_default()(this.target);
                    this.copyText();
                  }
                }, {
                  key: "copyText",
                  value: function copyText() {
                    var succeeded;
                    try {
                      succeeded = document.execCommand(this.action);
                    } catch (err) {
                      succeeded = false;
                    }
                    this.handleResult(succeeded);
                  }
                }, {
                  key: "handleResult",
                  value: function handleResult(succeeded) {
                    this.emitter.emit(succeeded ? "success" : "error", {
                      action: this.action,
                      text: this.selectedText,
                      trigger: this.trigger,
                      clearSelection: this.clearSelection.bind(this)
                    });
                  }
                }, {
                  key: "clearSelection",
                  value: function clearSelection() {
                    if (this.trigger) {
                      this.trigger.focus();
                    }
                    document.activeElement.blur();
                    window.getSelection().removeAllRanges();
                  }
                }, {
                  key: "destroy",
                  value: function destroy6() {
                    this.removeFake();
                  }
                }, {
                  key: "action",
                  set: function set2() {
                    var action = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "copy";
                    this._action = action;
                    if (this._action !== "copy" && this._action !== "cut") {
                      throw new Error('Invalid "action" value, use either "copy" or "cut"');
                    }
                  },
                  get: function get2() {
                    return this._action;
                  }
                }, {
                  key: "target",
                  set: function set2(target) {
                    if (target !== void 0) {
                      if (target && _typeof36(target) === "object" && target.nodeType === 1) {
                        if (this.action === "copy" && target.hasAttribute("disabled")) {
                          throw new Error('Invalid "target" attribute. Please use "readonly" instead of "disabled" attribute');
                        }
                        if (this.action === "cut" && (target.hasAttribute("readonly") || target.hasAttribute("disabled"))) {
                          throw new Error(`Invalid "target" attribute. You can't cut text from elements with "readonly" or "disabled" attributes`);
                        }
                        this._target = target;
                      } else {
                        throw new Error('Invalid "target" value, use a valid Element');
                      }
                    }
                  },
                  get: function get2() {
                    return this._target;
                  }
                }]);
                return ClipboardAction2;
              }();
              var clipboard_action = ClipboardAction;
              ;
              function clipboard_typeof(obj) {
                "@babel/helpers - typeof";
                if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                  clipboard_typeof = function _typeof37(obj2) {
                    return typeof obj2;
                  };
                } else {
                  clipboard_typeof = function _typeof37(obj2) {
                    return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                  };
                }
                return clipboard_typeof(obj);
              }
              function clipboard_classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function clipboard_defineProperties(target, props) {
                for (var i3 = 0; i3 < props.length; i3++) {
                  var descriptor = props[i3];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              function clipboard_createClass(Constructor, protoProps, staticProps) {
                if (protoProps)
                  clipboard_defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  clipboard_defineProperties(Constructor, staticProps);
                return Constructor;
              }
              function _inherits34(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                  throw new TypeError("Super expression must either be null or a function");
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
                if (superClass)
                  _setPrototypeOf34(subClass, superClass);
              }
              function _setPrototypeOf34(o2, p) {
                _setPrototypeOf34 = Object.setPrototypeOf || function _setPrototypeOf35(o3, p2) {
                  o3.__proto__ = p2;
                  return o3;
                };
                return _setPrototypeOf34(o2, p);
              }
              function _createSuper34(Derived) {
                var hasNativeReflectConstruct = _isNativeReflectConstruct34();
                return function _createSuperInternal() {
                  var Super = _getPrototypeOf34(Derived), result;
                  if (hasNativeReflectConstruct) {
                    var NewTarget = _getPrototypeOf34(this).constructor;
                    result = Reflect.construct(Super, arguments, NewTarget);
                  } else {
                    result = Super.apply(this, arguments);
                  }
                  return _possibleConstructorReturn34(this, result);
                };
              }
              function _possibleConstructorReturn34(self2, call) {
                if (call && (clipboard_typeof(call) === "object" || typeof call === "function")) {
                  return call;
                }
                return _assertThisInitialized34(self2);
              }
              function _assertThisInitialized34(self2) {
                if (self2 === void 0) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return self2;
              }
              function _isNativeReflectConstruct34() {
                if (typeof Reflect === "undefined" || !Reflect.construct)
                  return false;
                if (Reflect.construct.sham)
                  return false;
                if (typeof Proxy === "function")
                  return true;
                try {
                  Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                  }));
                  return true;
                } catch (e3) {
                  return false;
                }
              }
              function _getPrototypeOf34(o2) {
                _getPrototypeOf34 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf35(o3) {
                  return o3.__proto__ || Object.getPrototypeOf(o3);
                };
                return _getPrototypeOf34(o2);
              }
              function getAttributeValue(suffix, element) {
                var attribute = "data-clipboard-".concat(suffix);
                if (!element.hasAttribute(attribute)) {
                  return;
                }
                return element.getAttribute(attribute);
              }
              var Clipboard = /* @__PURE__ */ function(_Emitter) {
                _inherits34(Clipboard2, _Emitter);
                var _super = _createSuper34(Clipboard2);
                function Clipboard2(trigger, options2) {
                  var _this;
                  clipboard_classCallCheck(this, Clipboard2);
                  _this = _super.call(this);
                  _this.resolveOptions(options2);
                  _this.listenClick(trigger);
                  return _this;
                }
                clipboard_createClass(Clipboard2, [{
                  key: "resolveOptions",
                  value: function resolveOptions() {
                    var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                    this.action = typeof options2.action === "function" ? options2.action : this.defaultAction;
                    this.target = typeof options2.target === "function" ? options2.target : this.defaultTarget;
                    this.text = typeof options2.text === "function" ? options2.text : this.defaultText;
                    this.container = clipboard_typeof(options2.container) === "object" ? options2.container : document.body;
                  }
                }, {
                  key: "listenClick",
                  value: function listenClick(trigger) {
                    var _this2 = this;
                    this.listener = listen_default()(trigger, "click", function(e3) {
                      return _this2.onClick(e3);
                    });
                  }
                }, {
                  key: "onClick",
                  value: function onClick(e3) {
                    var trigger = e3.delegateTarget || e3.currentTarget;
                    if (this.clipboardAction) {
                      this.clipboardAction = null;
                    }
                    this.clipboardAction = new clipboard_action({
                      action: this.action(trigger),
                      target: this.target(trigger),
                      text: this.text(trigger),
                      container: this.container,
                      trigger,
                      emitter: this
                    });
                  }
                }, {
                  key: "defaultAction",
                  value: function defaultAction(trigger) {
                    return getAttributeValue("action", trigger);
                  }
                }, {
                  key: "defaultTarget",
                  value: function defaultTarget(trigger) {
                    var selector = getAttributeValue("target", trigger);
                    if (selector) {
                      return document.querySelector(selector);
                    }
                  }
                }, {
                  key: "defaultText",
                  value: function defaultText(trigger) {
                    return getAttributeValue("text", trigger);
                  }
                }, {
                  key: "destroy",
                  value: function destroy6() {
                    this.listener.destroy();
                    if (this.clipboardAction) {
                      this.clipboardAction.destroy();
                      this.clipboardAction = null;
                    }
                  }
                }], [{
                  key: "isSupported",
                  value: function isSupported() {
                    var action = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ["copy", "cut"];
                    var actions = typeof action === "string" ? [action] : action;
                    var support = !!document.queryCommandSupported;
                    actions.forEach(function(action2) {
                      support = support && !!document.queryCommandSupported(action2);
                    });
                    return support;
                  }
                }]);
                return Clipboard2;
              }(tiny_emitter_default());
              var clipboard = Clipboard;
            },
            828: function(module5) {
              var DOCUMENT_NODE_TYPE = 9;
              if (typeof Element !== "undefined" && !Element.prototype.matches) {
                var proto = Element.prototype;
                proto.matches = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector || proto.webkitMatchesSelector;
              }
              function closest(element, selector) {
                while (element && element.nodeType !== DOCUMENT_NODE_TYPE) {
                  if (typeof element.matches === "function" && element.matches(selector)) {
                    return element;
                  }
                  element = element.parentNode;
                }
              }
              module5.exports = closest;
            },
            438: function(module5, __unused_webpack_exports, __webpack_require__2) {
              var closest = __webpack_require__2(828);
              function _delegate(element, selector, type, callback2, useCapture) {
                var listenerFn = listener.apply(this, arguments);
                element.addEventListener(type, listenerFn, useCapture);
                return {
                  destroy: function() {
                    element.removeEventListener(type, listenerFn, useCapture);
                  }
                };
              }
              function delegate(elements3, selector, type, callback2, useCapture) {
                if (typeof elements3.addEventListener === "function") {
                  return _delegate.apply(null, arguments);
                }
                if (typeof type === "function") {
                  return _delegate.bind(null, document).apply(null, arguments);
                }
                if (typeof elements3 === "string") {
                  elements3 = document.querySelectorAll(elements3);
                }
                return Array.prototype.map.call(elements3, function(element) {
                  return _delegate(element, selector, type, callback2, useCapture);
                });
              }
              function listener(element, selector, type, callback2) {
                return function(e3) {
                  e3.delegateTarget = closest(e3.target, selector);
                  if (e3.delegateTarget) {
                    callback2.call(element, e3);
                  }
                };
              }
              module5.exports = delegate;
            },
            879: function(__unused_webpack_module, exports3) {
              exports3.node = function(value) {
                return value !== void 0 && value instanceof HTMLElement && value.nodeType === 1;
              };
              exports3.nodeList = function(value) {
                var type = Object.prototype.toString.call(value);
                return value !== void 0 && (type === "[object NodeList]" || type === "[object HTMLCollection]") && "length" in value && (value.length === 0 || exports3.node(value[0]));
              };
              exports3.string = function(value) {
                return typeof value === "string" || value instanceof String;
              };
              exports3.fn = function(value) {
                var type = Object.prototype.toString.call(value);
                return type === "[object Function]";
              };
            },
            370: function(module5, __unused_webpack_exports, __webpack_require__2) {
              var is = __webpack_require__2(879);
              var delegate = __webpack_require__2(438);
              function listen(target, type, callback2) {
                if (!target && !type && !callback2) {
                  throw new Error("Missing required arguments");
                }
                if (!is.string(type)) {
                  throw new TypeError("Second argument must be a String");
                }
                if (!is.fn(callback2)) {
                  throw new TypeError("Third argument must be a Function");
                }
                if (is.node(target)) {
                  return listenNode(target, type, callback2);
                } else if (is.nodeList(target)) {
                  return listenNodeList(target, type, callback2);
                } else if (is.string(target)) {
                  return listenSelector(target, type, callback2);
                } else {
                  throw new TypeError("First argument must be a String, HTMLElement, HTMLCollection, or NodeList");
                }
              }
              function listenNode(node, type, callback2) {
                node.addEventListener(type, callback2);
                return {
                  destroy: function() {
                    node.removeEventListener(type, callback2);
                  }
                };
              }
              function listenNodeList(nodeList, type, callback2) {
                Array.prototype.forEach.call(nodeList, function(node) {
                  node.addEventListener(type, callback2);
                });
                return {
                  destroy: function() {
                    Array.prototype.forEach.call(nodeList, function(node) {
                      node.removeEventListener(type, callback2);
                    });
                  }
                };
              }
              function listenSelector(selector, type, callback2) {
                return delegate(document.body, selector, type, callback2);
              }
              module5.exports = listen;
            },
            817: function(module5) {
              function select(element) {
                var selectedText;
                if (element.nodeName === "SELECT") {
                  element.focus();
                  selectedText = element.value;
                } else if (element.nodeName === "INPUT" || element.nodeName === "TEXTAREA") {
                  var isReadOnly = element.hasAttribute("readonly");
                  if (!isReadOnly) {
                    element.setAttribute("readonly", "");
                  }
                  element.select();
                  element.setSelectionRange(0, element.value.length);
                  if (!isReadOnly) {
                    element.removeAttribute("readonly");
                  }
                  selectedText = element.value;
                } else {
                  if (element.hasAttribute("contenteditable")) {
                    element.focus();
                  }
                  var selection = window.getSelection();
                  var range = document.createRange();
                  range.selectNodeContents(element);
                  selection.removeAllRanges();
                  selection.addRange(range);
                  selectedText = selection.toString();
                }
                return selectedText;
              }
              module5.exports = select;
            },
            279: function(module5) {
              function E2() {
              }
              E2.prototype = {
                on: function(name2, callback2, ctx) {
                  var e3 = this.e || (this.e = {});
                  (e3[name2] || (e3[name2] = [])).push({
                    fn: callback2,
                    ctx
                  });
                  return this;
                },
                once: function(name2, callback2, ctx) {
                  var self2 = this;
                  function listener() {
                    self2.off(name2, listener);
                    callback2.apply(ctx, arguments);
                  }
                  ;
                  listener._ = callback2;
                  return this.on(name2, listener, ctx);
                },
                emit: function(name2) {
                  var data = [].slice.call(arguments, 1);
                  var evtArr = ((this.e || (this.e = {}))[name2] || []).slice();
                  var i3 = 0;
                  var len = evtArr.length;
                  for (i3; i3 < len; i3++) {
                    evtArr[i3].fn.apply(evtArr[i3].ctx, data);
                  }
                  return this;
                },
                off: function(name2, callback2) {
                  var e3 = this.e || (this.e = {});
                  var evts = e3[name2];
                  var liveEvents = [];
                  if (evts && callback2) {
                    for (var i3 = 0, len = evts.length; i3 < len; i3++) {
                      if (evts[i3].fn !== callback2 && evts[i3].fn._ !== callback2)
                        liveEvents.push(evts[i3]);
                    }
                  }
                  liveEvents.length ? e3[name2] = liveEvents : delete e3[name2];
                  return this;
                }
              };
              module5.exports = E2;
              module5.exports.TinyEmitter = E2;
            }
          };
          var __webpack_module_cache__ = {};
          function __webpack_require__(moduleId) {
            if (__webpack_module_cache__[moduleId]) {
              return __webpack_module_cache__[moduleId].exports;
            }
            var module5 = __webpack_module_cache__[moduleId] = {
              exports: {}
            };
            __webpack_modules__[moduleId](module5, module5.exports, __webpack_require__);
            return module5.exports;
          }
          !function() {
            __webpack_require__.n = function(module5) {
              var getter = module5 && module5.__esModule ? function() {
                return module5["default"];
              } : function() {
                return module5;
              };
              __webpack_require__.d(getter, { a: getter });
              return getter;
            };
          }();
          !function() {
            __webpack_require__.d = function(exports3, definition) {
              for (var key in definition) {
                if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports3, key)) {
                  Object.defineProperty(exports3, key, { enumerable: true, get: definition[key] });
                }
              }
            };
          }();
          !function() {
            __webpack_require__.o = function(obj, prop) {
              return Object.prototype.hasOwnProperty.call(obj, prop);
            };
          }();
          return __webpack_require__(134);
        }().default;
      });
    }
  });

  // ../../node_modules/tributejs/dist/tribute.min.js
  var require_tribute_min = __commonJS({
    "../../node_modules/tributejs/dist/tribute.min.js"(exports2, module4) {
      !function(e3, t2) {
        typeof exports2 == "object" && typeof module4 != "undefined" ? module4.exports = t2() : typeof define == "function" && define.amd ? define(t2) : (e3 = e3 || self).Tribute = t2();
      }(exports2, function() {
        "use strict";
        function e3(e4, t3) {
          if (!(e4 instanceof t3))
            throw new TypeError("Cannot call a class as a function");
        }
        function t2(e4, t3) {
          for (var n3 = 0; n3 < t3.length; n3++) {
            var i4 = t3[n3];
            i4.enumerable = i4.enumerable || false, i4.configurable = true, "value" in i4 && (i4.writable = true), Object.defineProperty(e4, i4.key, i4);
          }
        }
        function n2(e4, n3, i4) {
          return n3 && t2(e4.prototype, n3), i4 && t2(e4, i4), e4;
        }
        function i3(e4, t3) {
          return function(e5) {
            if (Array.isArray(e5))
              return e5;
          }(e4) || function(e5, t4) {
            if (!(Symbol.iterator in Object(e5) || Object.prototype.toString.call(e5) === "[object Arguments]"))
              return;
            var n3 = [], i4 = true, r3 = false, o3 = void 0;
            try {
              for (var u3, l3 = e5[Symbol.iterator](); !(i4 = (u3 = l3.next()).done) && (n3.push(u3.value), !t4 || n3.length !== t4); i4 = true)
                ;
            } catch (e6) {
              r3 = true, o3 = e6;
            } finally {
              try {
                i4 || l3.return == null || l3.return();
              } finally {
                if (r3)
                  throw o3;
              }
            }
            return n3;
          }(e4, t3) || function() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }();
        }
        if (Array.prototype.find || (Array.prototype.find = function(e4) {
          if (this === null)
            throw new TypeError("Array.prototype.find called on null or undefined");
          if (typeof e4 != "function")
            throw new TypeError("predicate must be a function");
          for (var t3, n3 = Object(this), i4 = n3.length >>> 0, r3 = arguments[1], o3 = 0; o3 < i4; o3++)
            if (t3 = n3[o3], e4.call(r3, t3, o3, n3))
              return t3;
        }), window && typeof window.CustomEvent != "function") {
          var r2 = function(e4, t3) {
            t3 = t3 || { bubbles: false, cancelable: false, detail: void 0 };
            var n3 = document.createEvent("CustomEvent");
            return n3.initCustomEvent(e4, t3.bubbles, t3.cancelable, t3.detail), n3;
          };
          window.Event !== void 0 && (r2.prototype = window.Event.prototype), window.CustomEvent = r2;
        }
        var o2 = function() {
          function t3(n3) {
            e3(this, t3), this.tribute = n3, this.tribute.events = this;
          }
          return n2(t3, [{ key: "bind", value: function(e4) {
            e4.boundKeydown = this.keydown.bind(e4, this), e4.boundKeyup = this.keyup.bind(e4, this), e4.boundInput = this.input.bind(e4, this), e4.addEventListener("keydown", e4.boundKeydown, false), e4.addEventListener("keyup", e4.boundKeyup, false), e4.addEventListener("input", e4.boundInput, false);
          } }, { key: "unbind", value: function(e4) {
            e4.removeEventListener("keydown", e4.boundKeydown, false), e4.removeEventListener("keyup", e4.boundKeyup, false), e4.removeEventListener("input", e4.boundInput, false), delete e4.boundKeydown, delete e4.boundKeyup, delete e4.boundInput;
          } }, { key: "keydown", value: function(e4, n3) {
            e4.shouldDeactivate(n3) && (e4.tribute.isActive = false, e4.tribute.hideMenu());
            var i4 = this;
            e4.commandEvent = false, t3.keys().forEach(function(t4) {
              t4.key === n3.keyCode && (e4.commandEvent = true, e4.callbacks()[t4.value.toLowerCase()](n3, i4));
            });
          } }, { key: "input", value: function(e4, t4) {
            e4.inputEvent = true, e4.keyup.call(this, e4, t4);
          } }, { key: "click", value: function(e4, t4) {
            var n3 = e4.tribute;
            if (n3.menu && n3.menu.contains(t4.target)) {
              var i4 = t4.target;
              for (t4.preventDefault(), t4.stopPropagation(); i4.nodeName.toLowerCase() !== "li"; )
                if (!(i4 = i4.parentNode) || i4 === n3.menu)
                  throw new Error("cannot find the <li> container for the click");
              n3.selectItemAtIndex(i4.getAttribute("data-index"), t4), n3.hideMenu();
            } else
              n3.current.element && !n3.current.externalTrigger && (n3.current.externalTrigger = false, setTimeout(function() {
                return n3.hideMenu();
              }));
          } }, { key: "keyup", value: function(e4, t4) {
            if (e4.inputEvent && (e4.inputEvent = false), e4.updateSelection(this), t4.keyCode !== 27) {
              if (!e4.tribute.allowSpaces && e4.tribute.hasTrailingSpace)
                return e4.tribute.hasTrailingSpace = false, e4.commandEvent = true, void e4.callbacks().space(t4, this);
              if (!e4.tribute.isActive)
                if (e4.tribute.autocompleteMode)
                  e4.callbacks().triggerChar(t4, this, "");
                else {
                  var n3 = e4.getKeyCode(e4, this, t4);
                  if (isNaN(n3) || !n3)
                    return;
                  var i4 = e4.tribute.triggers().find(function(e5) {
                    return e5.charCodeAt(0) === n3;
                  });
                  i4 !== void 0 && e4.callbacks().triggerChar(t4, this, i4);
                }
              e4.tribute.current.mentionText.length < e4.tribute.current.collection.menuShowMinLength || ((e4.tribute.current.trigger || e4.tribute.autocompleteMode) && e4.commandEvent === false || e4.tribute.isActive && t4.keyCode === 8) && e4.tribute.showMenuFor(this, true);
            }
          } }, { key: "shouldDeactivate", value: function(e4) {
            if (!this.tribute.isActive)
              return false;
            if (this.tribute.current.mentionText.length === 0) {
              var n3 = false;
              return t3.keys().forEach(function(t4) {
                e4.keyCode === t4.key && (n3 = true);
              }), !n3;
            }
            return false;
          } }, { key: "getKeyCode", value: function(e4, t4, n3) {
            var i4 = e4.tribute, r3 = i4.range.getTriggerInfo(false, i4.hasTrailingSpace, true, i4.allowSpaces, i4.autocompleteMode);
            return !!r3 && r3.mentionTriggerChar.charCodeAt(0);
          } }, { key: "updateSelection", value: function(e4) {
            this.tribute.current.element = e4;
            var t4 = this.tribute.range.getTriggerInfo(false, this.tribute.hasTrailingSpace, true, this.tribute.allowSpaces, this.tribute.autocompleteMode);
            t4 && (this.tribute.current.selectedPath = t4.mentionSelectedPath, this.tribute.current.mentionText = t4.mentionText, this.tribute.current.selectedOffset = t4.mentionSelectedOffset);
          } }, { key: "callbacks", value: function() {
            var e4 = this;
            return { triggerChar: function(t4, n3, i4) {
              var r3 = e4.tribute;
              r3.current.trigger = i4;
              var o3 = r3.collection.find(function(e5) {
                return e5.trigger === i4;
              });
              r3.current.collection = o3, r3.current.mentionText.length >= r3.current.collection.menuShowMinLength && r3.inputEvent && r3.showMenuFor(n3, true);
            }, enter: function(t4, n3) {
              e4.tribute.isActive && e4.tribute.current.filteredItems && (t4.preventDefault(), t4.stopPropagation(), setTimeout(function() {
                e4.tribute.selectItemAtIndex(e4.tribute.menuSelected, t4), e4.tribute.hideMenu();
              }, 0));
            }, escape: function(t4, n3) {
              e4.tribute.isActive && (t4.preventDefault(), t4.stopPropagation(), e4.tribute.isActive = false, e4.tribute.hideMenu());
            }, tab: function(t4, n3) {
              e4.callbacks().enter(t4, n3);
            }, space: function(t4, n3) {
              e4.tribute.isActive && (e4.tribute.spaceSelectsMatch ? e4.callbacks().enter(t4, n3) : e4.tribute.allowSpaces || (t4.stopPropagation(), setTimeout(function() {
                e4.tribute.hideMenu(), e4.tribute.isActive = false;
              }, 0)));
            }, up: function(t4, n3) {
              if (e4.tribute.isActive && e4.tribute.current.filteredItems) {
                t4.preventDefault(), t4.stopPropagation();
                var i4 = e4.tribute.current.filteredItems.length, r3 = e4.tribute.menuSelected;
                i4 > r3 && r3 > 0 ? (e4.tribute.menuSelected--, e4.setActiveLi()) : r3 === 0 && (e4.tribute.menuSelected = i4 - 1, e4.setActiveLi(), e4.tribute.menu.scrollTop = e4.tribute.menu.scrollHeight);
              }
            }, down: function(t4, n3) {
              if (e4.tribute.isActive && e4.tribute.current.filteredItems) {
                t4.preventDefault(), t4.stopPropagation();
                var i4 = e4.tribute.current.filteredItems.length - 1, r3 = e4.tribute.menuSelected;
                i4 > r3 ? (e4.tribute.menuSelected++, e4.setActiveLi()) : i4 === r3 && (e4.tribute.menuSelected = 0, e4.setActiveLi(), e4.tribute.menu.scrollTop = 0);
              }
            }, delete: function(t4, n3) {
              e4.tribute.isActive && e4.tribute.current.mentionText.length < 1 ? e4.tribute.hideMenu() : e4.tribute.isActive && e4.tribute.showMenuFor(n3);
            } };
          } }, { key: "setActiveLi", value: function(e4) {
            var t4 = this.tribute.menu.querySelectorAll("li"), n3 = t4.length >>> 0;
            e4 && (this.tribute.menuSelected = parseInt(e4));
            for (var i4 = 0; i4 < n3; i4++) {
              var r3 = t4[i4];
              if (i4 === this.tribute.menuSelected) {
                r3.classList.add(this.tribute.current.collection.selectClass);
                var o3 = r3.getBoundingClientRect(), u3 = this.tribute.menu.getBoundingClientRect();
                if (o3.bottom > u3.bottom) {
                  var l3 = o3.bottom - u3.bottom;
                  this.tribute.menu.scrollTop += l3;
                } else if (o3.top < u3.top) {
                  var s5 = u3.top - o3.top;
                  this.tribute.menu.scrollTop -= s5;
                }
              } else
                r3.classList.remove(this.tribute.current.collection.selectClass);
            }
          } }, { key: "getFullHeight", value: function(e4, t4) {
            var n3 = e4.getBoundingClientRect().height;
            if (t4) {
              var i4 = e4.currentStyle || window.getComputedStyle(e4);
              return n3 + parseFloat(i4.marginTop) + parseFloat(i4.marginBottom);
            }
            return n3;
          } }], [{ key: "keys", value: function() {
            return [{ key: 9, value: "TAB" }, { key: 8, value: "DELETE" }, { key: 13, value: "ENTER" }, { key: 27, value: "ESCAPE" }, { key: 32, value: "SPACE" }, { key: 38, value: "UP" }, { key: 40, value: "DOWN" }];
          } }]), t3;
        }(), u2 = function() {
          function t3(n3) {
            e3(this, t3), this.tribute = n3, this.tribute.menuEvents = this, this.menu = this.tribute.menu;
          }
          return n2(t3, [{ key: "bind", value: function(e4) {
            var t4 = this;
            this.menuClickEvent = this.tribute.events.click.bind(null, this), this.menuContainerScrollEvent = this.debounce(function() {
              t4.tribute.isActive && t4.tribute.showMenuFor(t4.tribute.current.element, false);
            }, 300, false), this.windowResizeEvent = this.debounce(function() {
              t4.tribute.isActive && t4.tribute.range.positionMenuAtCaret(true);
            }, 300, false), this.tribute.range.getDocument().addEventListener("MSPointerDown", this.menuClickEvent, false), this.tribute.range.getDocument().addEventListener("mousedown", this.menuClickEvent, false), window.addEventListener("resize", this.windowResizeEvent), this.menuContainer ? this.menuContainer.addEventListener("scroll", this.menuContainerScrollEvent, false) : window.addEventListener("scroll", this.menuContainerScrollEvent);
          } }, { key: "unbind", value: function(e4) {
            this.tribute.range.getDocument().removeEventListener("mousedown", this.menuClickEvent, false), this.tribute.range.getDocument().removeEventListener("MSPointerDown", this.menuClickEvent, false), window.removeEventListener("resize", this.windowResizeEvent), this.menuContainer ? this.menuContainer.removeEventListener("scroll", this.menuContainerScrollEvent, false) : window.removeEventListener("scroll", this.menuContainerScrollEvent);
          } }, { key: "debounce", value: function(e4, t4, n3) {
            var i4, r3 = arguments, o3 = this;
            return function() {
              var u3 = o3, l3 = r3, s5 = n3 && !i4;
              clearTimeout(i4), i4 = setTimeout(function() {
                i4 = null, n3 || e4.apply(u3, l3);
              }, t4), s5 && e4.apply(u3, l3);
            };
          } }]), t3;
        }(), l2 = function() {
          function t3(n3) {
            e3(this, t3), this.tribute = n3, this.tribute.range = this;
          }
          return n2(t3, [{ key: "getDocument", value: function() {
            var e4;
            return this.tribute.current.collection && (e4 = this.tribute.current.collection.iframe), e4 ? e4.contentWindow.document : document;
          } }, { key: "positionMenuAtCaret", value: function(e4) {
            var t4, n3 = this, i4 = this.tribute.current, r3 = this.getTriggerInfo(false, this.tribute.hasTrailingSpace, true, this.tribute.allowSpaces, this.tribute.autocompleteMode);
            if (r3 !== void 0) {
              if (!this.tribute.positionMenu)
                return void (this.tribute.menu.style.cssText = "display: block;");
              t4 = this.isContentEditable(i4.element) ? this.getContentEditableCaretPosition(r3.mentionPosition) : this.getTextAreaOrInputUnderlinePosition(this.tribute.current.element, r3.mentionPosition), this.tribute.menu.style.cssText = "top: ".concat(t4.top, "px;\n                                     left: ").concat(t4.left, "px;\n                                     right: ").concat(t4.right, "px;\n                                     bottom: ").concat(t4.bottom, "px;\n                                     position: absolute;\n                                     display: block;"), t4.left === "auto" && (this.tribute.menu.style.left = "auto"), t4.top === "auto" && (this.tribute.menu.style.top = "auto"), e4 && this.scrollIntoView(), window.setTimeout(function() {
                var i5 = { width: n3.tribute.menu.offsetWidth, height: n3.tribute.menu.offsetHeight }, r4 = n3.isMenuOffScreen(t4, i5), o3 = window.innerWidth > i5.width && (r4.left || r4.right), u3 = window.innerHeight > i5.height && (r4.top || r4.bottom);
                (o3 || u3) && (n3.tribute.menu.style.cssText = "display: none", n3.positionMenuAtCaret(e4));
              }, 0);
            } else
              this.tribute.menu.style.cssText = "display: none";
          } }, { key: "selectElement", value: function(e4, t4, n3) {
            var i4, r3 = e4;
            if (t4)
              for (var o3 = 0; o3 < t4.length; o3++) {
                if ((r3 = r3.childNodes[t4[o3]]) === void 0)
                  return;
                for (; r3.length < n3; )
                  n3 -= r3.length, r3 = r3.nextSibling;
                r3.childNodes.length !== 0 || r3.length || (r3 = r3.previousSibling);
              }
            var u3 = this.getWindowSelection();
            (i4 = this.getDocument().createRange()).setStart(r3, n3), i4.setEnd(r3, n3), i4.collapse(true);
            try {
              u3.removeAllRanges();
            } catch (e5) {
            }
            u3.addRange(i4), e4.focus();
          } }, { key: "replaceTriggerText", value: function(e4, t4, n3, i4, r3) {
            var o3 = this.getTriggerInfo(true, n3, t4, this.tribute.allowSpaces, this.tribute.autocompleteMode);
            if (o3 !== void 0) {
              var u3 = this.tribute.current, l3 = new CustomEvent("tribute-replaced", { detail: { item: r3, instance: u3, context: o3, event: i4 } });
              if (this.isContentEditable(u3.element)) {
                e4 += typeof this.tribute.replaceTextSuffix == "string" ? this.tribute.replaceTextSuffix : "\xA0";
                var s5 = o3.mentionPosition + o3.mentionText.length;
                this.tribute.autocompleteMode || (s5 += o3.mentionTriggerChar.length), this.pasteHtml(e4, o3.mentionPosition, s5);
              } else {
                var a4 = this.tribute.current.element, c2 = typeof this.tribute.replaceTextSuffix == "string" ? this.tribute.replaceTextSuffix : " ";
                e4 += c2;
                var h5 = o3.mentionPosition, d3 = o3.mentionPosition + o3.mentionText.length + c2.length;
                this.tribute.autocompleteMode || (d3 += o3.mentionTriggerChar.length - 1), a4.value = a4.value.substring(0, h5) + e4 + a4.value.substring(d3, a4.value.length), a4.selectionStart = h5 + e4.length, a4.selectionEnd = h5 + e4.length;
              }
              u3.element.dispatchEvent(new CustomEvent("input", { bubbles: true })), u3.element.dispatchEvent(l3);
            }
          } }, { key: "pasteHtml", value: function(e4, t4, n3) {
            var i4, r3;
            r3 = this.getWindowSelection(), (i4 = this.getDocument().createRange()).setStart(r3.anchorNode, t4), i4.setEnd(r3.anchorNode, n3), i4.deleteContents();
            var o3 = this.getDocument().createElement("div");
            o3.innerHTML = e4;
            for (var u3, l3, s5 = this.getDocument().createDocumentFragment(); u3 = o3.firstChild; )
              l3 = s5.appendChild(u3);
            i4.insertNode(s5), l3 && ((i4 = i4.cloneRange()).setStartAfter(l3), i4.collapse(true), r3.removeAllRanges(), r3.addRange(i4));
          } }, { key: "getWindowSelection", value: function() {
            return this.tribute.collection.iframe ? this.tribute.collection.iframe.contentWindow.getSelection() : window.getSelection();
          } }, { key: "getNodePositionInParent", value: function(e4) {
            if (e4.parentNode === null)
              return 0;
            for (var t4 = 0; t4 < e4.parentNode.childNodes.length; t4++) {
              if (e4.parentNode.childNodes[t4] === e4)
                return t4;
            }
          } }, { key: "getContentEditableSelectedPath", value: function(e4) {
            var t4 = this.getWindowSelection(), n3 = t4.anchorNode, i4 = [];
            if (n3 != null) {
              for (var r3, o3 = n3.contentEditable; n3 !== null && o3 !== "true"; )
                r3 = this.getNodePositionInParent(n3), i4.push(r3), (n3 = n3.parentNode) !== null && (o3 = n3.contentEditable);
              return i4.reverse(), { selected: n3, path: i4, offset: t4.getRangeAt(0).startOffset };
            }
          } }, { key: "getTextPrecedingCurrentSelection", value: function() {
            var e4 = this.tribute.current, t4 = "";
            if (this.isContentEditable(e4.element)) {
              var n3 = this.getWindowSelection().anchorNode;
              if (n3 != null) {
                var i4 = n3.textContent, r3 = this.getWindowSelection().getRangeAt(0).startOffset;
                i4 && r3 >= 0 && (t4 = i4.substring(0, r3));
              }
            } else {
              var o3 = this.tribute.current.element;
              if (o3) {
                var u3 = o3.selectionStart;
                o3.value && u3 >= 0 && (t4 = o3.value.substring(0, u3));
              }
            }
            return t4;
          } }, { key: "getLastWordInText", value: function(e4) {
            var t4 = (e4 = e4.replace(/\u00A0/g, " ")).split(/\s+/);
            return t4[t4.length - 1].trim();
          } }, { key: "getTriggerInfo", value: function(e4, t4, n3, i4, r3) {
            var o3, u3, l3, s5 = this, a4 = this.tribute.current;
            if (this.isContentEditable(a4.element)) {
              var c2 = this.getContentEditableSelectedPath(a4);
              c2 && (o3 = c2.selected, u3 = c2.path, l3 = c2.offset);
            } else
              o3 = this.tribute.current.element;
            var h5 = this.getTextPrecedingCurrentSelection(), d3 = this.getLastWordInText(h5);
            if (r3)
              return { mentionPosition: h5.length - d3.length, mentionText: d3, mentionSelectedElement: o3, mentionSelectedPath: u3, mentionSelectedOffset: l3 };
            if (h5 != null) {
              var f, m3 = -1;
              if (this.tribute.collection.forEach(function(e5) {
                var t5 = e5.trigger, i5 = e5.requireLeadingSpace ? s5.lastIndexWithLeadingSpace(h5, t5) : h5.lastIndexOf(t5);
                i5 > m3 && (m3 = i5, f = t5, n3 = e5.requireLeadingSpace);
              }), m3 >= 0 && (m3 === 0 || !n3 || /[\xA0\s]/g.test(h5.substring(m3 - 1, m3)))) {
                var p = h5.substring(m3 + f.length, h5.length);
                f = h5.substring(m3, m3 + f.length);
                var v = p.substring(0, 1), g = p.length > 0 && (v === " " || v === "\xA0");
                t4 && (p = p.trim());
                var b2 = i4 ? /[^\S ]/g : /[\xA0\s]/g;
                if (this.tribute.hasTrailingSpace = b2.test(p), !g && (e4 || !b2.test(p)))
                  return { mentionPosition: m3, mentionText: p, mentionSelectedElement: o3, mentionSelectedPath: u3, mentionSelectedOffset: l3, mentionTriggerChar: f };
              }
            }
          } }, { key: "lastIndexWithLeadingSpace", value: function(e4, t4) {
            for (var n3 = e4.split("").reverse().join(""), i4 = -1, r3 = 0, o3 = e4.length; r3 < o3; r3++) {
              for (var u3 = r3 === e4.length - 1, l3 = /\s/.test(n3[r3 + 1]), s5 = true, a4 = t4.length - 1; a4 >= 0; a4--)
                if (t4[a4] !== n3[r3 - a4]) {
                  s5 = false;
                  break;
                }
              if (s5 && (u3 || l3)) {
                i4 = e4.length - 1 - r3;
                break;
              }
            }
            return i4;
          } }, { key: "isContentEditable", value: function(e4) {
            return e4.nodeName !== "INPUT" && e4.nodeName !== "TEXTAREA";
          } }, { key: "isMenuOffScreen", value: function(e4, t4) {
            var n3 = window.innerWidth, i4 = window.innerHeight, r3 = document.documentElement, o3 = (window.pageXOffset || r3.scrollLeft) - (r3.clientLeft || 0), u3 = (window.pageYOffset || r3.scrollTop) - (r3.clientTop || 0), l3 = typeof e4.top == "number" ? e4.top : u3 + i4 - e4.bottom - t4.height, s5 = typeof e4.right == "number" ? e4.right : e4.left + t4.width, a4 = typeof e4.bottom == "number" ? e4.bottom : e4.top + t4.height, c2 = typeof e4.left == "number" ? e4.left : o3 + n3 - e4.right - t4.width;
            return { top: l3 < Math.floor(u3), right: s5 > Math.ceil(o3 + n3), bottom: a4 > Math.ceil(u3 + i4), left: c2 < Math.floor(o3) };
          } }, { key: "getMenuDimensions", value: function() {
            var e4 = { width: null, height: null };
            return this.tribute.menu.style.cssText = "top: 0px;\n                                 left: 0px;\n                                 position: fixed;\n                                 display: block;\n                                 visibility; hidden;", e4.width = this.tribute.menu.offsetWidth, e4.height = this.tribute.menu.offsetHeight, this.tribute.menu.style.cssText = "display: none;", e4;
          } }, { key: "getTextAreaOrInputUnderlinePosition", value: function(e4, t4, n3) {
            var i4 = window.mozInnerScreenX !== null, r3 = this.getDocument().createElement("div");
            r3.id = "input-textarea-caret-position-mirror-div", this.getDocument().body.appendChild(r3);
            var o3 = r3.style, u3 = window.getComputedStyle ? getComputedStyle(e4) : e4.currentStyle;
            o3.whiteSpace = "pre-wrap", e4.nodeName !== "INPUT" && (o3.wordWrap = "break-word"), o3.position = "absolute", o3.visibility = "hidden", ["direction", "boxSizing", "width", "height", "overflowX", "overflowY", "borderTopWidth", "borderRightWidth", "borderBottomWidth", "borderLeftWidth", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "fontStyle", "fontVariant", "fontWeight", "fontStretch", "fontSize", "fontSizeAdjust", "lineHeight", "fontFamily", "textAlign", "textTransform", "textIndent", "textDecoration", "letterSpacing", "wordSpacing"].forEach(function(e5) {
              o3[e5] = u3[e5];
            }), i4 ? (o3.width = "".concat(parseInt(u3.width) - 2, "px"), e4.scrollHeight > parseInt(u3.height) && (o3.overflowY = "scroll")) : o3.overflow = "hidden", r3.textContent = e4.value.substring(0, t4), e4.nodeName === "INPUT" && (r3.textContent = r3.textContent.replace(/\s/g, "\xA0"));
            var l3 = this.getDocument().createElement("span");
            l3.textContent = e4.value.substring(t4) || ".", r3.appendChild(l3);
            var s5 = e4.getBoundingClientRect(), a4 = document.documentElement, c2 = (window.pageXOffset || a4.scrollLeft) - (a4.clientLeft || 0), h5 = (window.pageYOffset || a4.scrollTop) - (a4.clientTop || 0), d3 = 0, f = 0;
            this.menuContainerIsBody && (d3 = s5.top, f = s5.left);
            var m3 = { top: d3 + h5 + l3.offsetTop + parseInt(u3.borderTopWidth) + parseInt(u3.fontSize) - e4.scrollTop, left: f + c2 + l3.offsetLeft + parseInt(u3.borderLeftWidth) }, p = window.innerWidth, v = window.innerHeight, g = this.getMenuDimensions(), b2 = this.isMenuOffScreen(m3, g);
            b2.right && (m3.right = p - m3.left, m3.left = "auto");
            var y3 = this.tribute.menuContainer ? this.tribute.menuContainer.offsetHeight : this.getDocument().body.offsetHeight;
            if (b2.bottom) {
              var w2 = y3 - (v - (this.tribute.menuContainer ? this.tribute.menuContainer.getBoundingClientRect() : this.getDocument().body.getBoundingClientRect()).top);
              m3.bottom = w2 + (v - s5.top - l3.offsetTop), m3.top = "auto";
            }
            return (b2 = this.isMenuOffScreen(m3, g)).left && (m3.left = p > g.width ? c2 + p - g.width : c2, delete m3.right), b2.top && (m3.top = v > g.height ? h5 + v - g.height : h5, delete m3.bottom), this.getDocument().body.removeChild(r3), m3;
          } }, { key: "getContentEditableCaretPosition", value: function(e4) {
            var t4, n3 = this.getWindowSelection();
            (t4 = this.getDocument().createRange()).setStart(n3.anchorNode, e4), t4.setEnd(n3.anchorNode, e4), t4.collapse(false);
            var i4 = t4.getBoundingClientRect(), r3 = document.documentElement, o3 = (window.pageXOffset || r3.scrollLeft) - (r3.clientLeft || 0), u3 = (window.pageYOffset || r3.scrollTop) - (r3.clientTop || 0), l3 = { left: i4.left + o3, top: i4.top + i4.height + u3 }, s5 = window.innerWidth, a4 = window.innerHeight, c2 = this.getMenuDimensions(), h5 = this.isMenuOffScreen(l3, c2);
            h5.right && (l3.left = "auto", l3.right = s5 - i4.left - o3);
            var d3 = this.tribute.menuContainer ? this.tribute.menuContainer.offsetHeight : this.getDocument().body.offsetHeight;
            if (h5.bottom) {
              var f = d3 - (a4 - (this.tribute.menuContainer ? this.tribute.menuContainer.getBoundingClientRect() : this.getDocument().body.getBoundingClientRect()).top);
              l3.top = "auto", l3.bottom = f + (a4 - i4.top);
            }
            return (h5 = this.isMenuOffScreen(l3, c2)).left && (l3.left = s5 > c2.width ? o3 + s5 - c2.width : o3, delete l3.right), h5.top && (l3.top = a4 > c2.height ? u3 + a4 - c2.height : u3, delete l3.bottom), this.menuContainerIsBody || (l3.left = l3.left ? l3.left - this.tribute.menuContainer.offsetLeft : l3.left, l3.top = l3.top ? l3.top - this.tribute.menuContainer.offsetTop : l3.top), l3;
          } }, { key: "scrollIntoView", value: function(e4) {
            var t4, n3 = this.menu;
            if (n3 !== void 0) {
              for (; t4 === void 0 || t4.height === 0; )
                if ((t4 = n3.getBoundingClientRect()).height === 0 && ((n3 = n3.childNodes[0]) === void 0 || !n3.getBoundingClientRect))
                  return;
              var i4 = t4.top, r3 = i4 + t4.height;
              if (i4 < 0)
                window.scrollTo(0, window.pageYOffset + t4.top - 20);
              else if (r3 > window.innerHeight) {
                var o3 = window.pageYOffset + t4.top - 20;
                o3 - window.pageYOffset > 100 && (o3 = window.pageYOffset + 100);
                var u3 = window.pageYOffset - (window.innerHeight - r3);
                u3 > o3 && (u3 = o3), window.scrollTo(0, u3);
              }
            }
          } }, { key: "menuContainerIsBody", get: function() {
            return this.tribute.menuContainer === document.body || !this.tribute.menuContainer;
          } }]), t3;
        }(), s4 = function() {
          function t3(n3) {
            e3(this, t3), this.tribute = n3, this.tribute.search = this;
          }
          return n2(t3, [{ key: "simpleFilter", value: function(e4, t4) {
            var n3 = this;
            return t4.filter(function(t5) {
              return n3.test(e4, t5);
            });
          } }, { key: "test", value: function(e4, t4) {
            return this.match(e4, t4) !== null;
          } }, { key: "match", value: function(e4, t4, n3) {
            n3 = n3 || {};
            t4.length;
            var i4 = n3.pre || "", r3 = n3.post || "", o3 = n3.caseSensitive && t4 || t4.toLowerCase();
            if (n3.skip)
              return { rendered: t4, score: 0 };
            e4 = n3.caseSensitive && e4 || e4.toLowerCase();
            var u3 = this.traverse(o3, e4, 0, 0, []);
            return u3 ? { rendered: this.render(t4, u3.cache, i4, r3), score: u3.score } : null;
          } }, { key: "traverse", value: function(e4, t4, n3, i4, r3) {
            if (t4.length === i4)
              return { score: this.calculateScore(r3), cache: r3.slice() };
            if (!(e4.length === n3 || t4.length - i4 > e4.length - n3)) {
              for (var o3, u3, l3 = t4[i4], s5 = e4.indexOf(l3, n3); s5 > -1; ) {
                if (r3.push(s5), u3 = this.traverse(e4, t4, s5 + 1, i4 + 1, r3), r3.pop(), !u3)
                  return o3;
                (!o3 || o3.score < u3.score) && (o3 = u3), s5 = e4.indexOf(l3, s5 + 1);
              }
              return o3;
            }
          } }, { key: "calculateScore", value: function(e4) {
            var t4 = 0, n3 = 1;
            return e4.forEach(function(i4, r3) {
              r3 > 0 && (e4[r3 - 1] + 1 === i4 ? n3 += n3 + 1 : n3 = 1), t4 += n3;
            }), t4;
          } }, { key: "render", value: function(e4, t4, n3, i4) {
            var r3 = e4.substring(0, t4[0]);
            return t4.forEach(function(o3, u3) {
              r3 += n3 + e4[o3] + i4 + e4.substring(o3 + 1, t4[u3 + 1] ? t4[u3 + 1] : e4.length);
            }), r3;
          } }, { key: "filter", value: function(e4, t4, n3) {
            var i4 = this;
            return n3 = n3 || {}, t4.reduce(function(t5, r3, o3, u3) {
              var l3 = r3;
              n3.extract && ((l3 = n3.extract(r3)) || (l3 = ""));
              var s5 = i4.match(e4, l3, n3);
              return s5 != null && (t5[t5.length] = { string: s5.rendered, score: s5.score, index: o3, original: r3 }), t5;
            }, []).sort(function(e5, t5) {
              var n4 = t5.score - e5.score;
              return n4 || e5.index - t5.index;
            });
          } }]), t3;
        }();
        return function() {
          function t3(n3) {
            var i4, r3 = this, a4 = n3.values, c2 = a4 === void 0 ? null : a4, h5 = n3.iframe, d3 = h5 === void 0 ? null : h5, f = n3.selectClass, m3 = f === void 0 ? "highlight" : f, p = n3.containerClass, v = p === void 0 ? "tribute-container" : p, g = n3.itemClass, b2 = g === void 0 ? "" : g, y3 = n3.trigger, w2 = y3 === void 0 ? "@" : y3, T2 = n3.autocompleteMode, C = T2 !== void 0 && T2, S3 = n3.selectTemplate, E2 = S3 === void 0 ? null : S3, k2 = n3.menuItemTemplate, x2 = k2 === void 0 ? null : k2, M3 = n3.lookup, A = M3 === void 0 ? "key" : M3, L2 = n3.fillAttr, I2 = L2 === void 0 ? "value" : L2, N = n3.collection, O2 = N === void 0 ? null : N, D2 = n3.menuContainer, P = D2 === void 0 ? null : D2, R2 = n3.noMatchTemplate, W = R2 === void 0 ? null : R2, H3 = n3.requireLeadingSpace, B2 = H3 === void 0 || H3, F = n3.allowSpaces, _ = F !== void 0 && F, j = n3.replaceTextSuffix, Y2 = j === void 0 ? null : j, z2 = n3.positionMenu, K2 = z2 === void 0 || z2, q2 = n3.spaceSelectsMatch, U = q2 !== void 0 && q2, X2 = n3.searchOpts, Q2 = X2 === void 0 ? {} : X2, V = n3.menuItemLimit, G2 = V === void 0 ? null : V, J = n3.menuShowMinLength, Z = J === void 0 ? 0 : J;
            if (e3(this, t3), this.autocompleteMode = C, this.menuSelected = 0, this.current = {}, this.inputEvent = false, this.isActive = false, this.menuContainer = P, this.allowSpaces = _, this.replaceTextSuffix = Y2, this.positionMenu = K2, this.hasTrailingSpace = false, this.spaceSelectsMatch = U, this.autocompleteMode && (w2 = "", _ = false), c2)
              this.collection = [{ trigger: w2, iframe: d3, selectClass: m3, containerClass: v, itemClass: b2, selectTemplate: (E2 || t3.defaultSelectTemplate).bind(this), menuItemTemplate: (x2 || t3.defaultMenuItemTemplate).bind(this), noMatchTemplate: (i4 = W, typeof i4 == "string" ? i4.trim() === "" ? null : i4 : typeof i4 == "function" ? i4.bind(r3) : W || function() {
                return "<li>No Match Found!</li>";
              }.bind(r3)), lookup: A, fillAttr: I2, values: c2, requireLeadingSpace: B2, searchOpts: Q2, menuItemLimit: G2, menuShowMinLength: Z }];
            else {
              if (!O2)
                throw new Error("[Tribute] No collection specified.");
              this.autocompleteMode && console.warn("Tribute in autocomplete mode does not work for collections"), this.collection = O2.map(function(e4) {
                return { trigger: e4.trigger || w2, iframe: e4.iframe || d3, selectClass: e4.selectClass || m3, containerClass: e4.containerClass || v, itemClass: e4.itemClass || b2, selectTemplate: (e4.selectTemplate || t3.defaultSelectTemplate).bind(r3), menuItemTemplate: (e4.menuItemTemplate || t3.defaultMenuItemTemplate).bind(r3), noMatchTemplate: function(e5) {
                  return typeof e5 == "string" ? e5.trim() === "" ? null : e5 : typeof e5 == "function" ? e5.bind(r3) : W || function() {
                    return "<li>No Match Found!</li>";
                  }.bind(r3);
                }(W), lookup: e4.lookup || A, fillAttr: e4.fillAttr || I2, values: e4.values, requireLeadingSpace: e4.requireLeadingSpace, searchOpts: e4.searchOpts || Q2, menuItemLimit: e4.menuItemLimit || G2, menuShowMinLength: e4.menuShowMinLength || Z };
              });
            }
            new l2(this), new o2(this), new u2(this), new s4(this);
          }
          return n2(t3, [{ key: "triggers", value: function() {
            return this.collection.map(function(e4) {
              return e4.trigger;
            });
          } }, { key: "attach", value: function(e4) {
            if (!e4)
              throw new Error("[Tribute] Must pass in a DOM node or NodeList.");
            if (typeof jQuery != "undefined" && e4 instanceof jQuery && (e4 = e4.get()), e4.constructor === NodeList || e4.constructor === HTMLCollection || e4.constructor === Array)
              for (var t4 = e4.length, n3 = 0; n3 < t4; ++n3)
                this._attach(e4[n3]);
            else
              this._attach(e4);
          } }, { key: "_attach", value: function(e4) {
            e4.hasAttribute("data-tribute") && console.warn("Tribute was already bound to " + e4.nodeName), this.ensureEditable(e4), this.events.bind(e4), e4.setAttribute("data-tribute", true);
          } }, { key: "ensureEditable", value: function(e4) {
            if (t3.inputTypes().indexOf(e4.nodeName) === -1) {
              if (!e4.contentEditable)
                throw new Error("[Tribute] Cannot bind to " + e4.nodeName);
              e4.contentEditable = true;
            }
          } }, { key: "createMenu", value: function(e4) {
            var t4 = this.range.getDocument().createElement("div"), n3 = this.range.getDocument().createElement("ul");
            return t4.className = e4, t4.appendChild(n3), this.menuContainer ? this.menuContainer.appendChild(t4) : this.range.getDocument().body.appendChild(t4);
          } }, { key: "showMenuFor", value: function(e4, t4) {
            var n3 = this;
            if (!this.isActive || this.current.element !== e4 || this.current.mentionText !== this.currentMentionTextSnapshot) {
              this.currentMentionTextSnapshot = this.current.mentionText, this.menu || (this.menu = this.createMenu(this.current.collection.containerClass), e4.tributeMenu = this.menu, this.menuEvents.bind(this.menu)), this.isActive = true, this.menuSelected = 0, this.current.mentionText || (this.current.mentionText = "");
              var r3 = function(e5) {
                if (n3.isActive) {
                  var r4 = n3.search.filter(n3.current.mentionText, e5, { pre: n3.current.collection.searchOpts.pre || "<span>", post: n3.current.collection.searchOpts.post || "</span>", skip: n3.current.collection.searchOpts.skip, extract: function(e6) {
                    if (typeof n3.current.collection.lookup == "string")
                      return e6[n3.current.collection.lookup];
                    if (typeof n3.current.collection.lookup == "function")
                      return n3.current.collection.lookup(e6, n3.current.mentionText);
                    throw new Error("Invalid lookup attribute, lookup must be string or function.");
                  } });
                  n3.current.collection.menuItemLimit && (r4 = r4.slice(0, n3.current.collection.menuItemLimit)), n3.current.filteredItems = r4;
                  var o3 = n3.menu.querySelector("ul");
                  if (n3.range.positionMenuAtCaret(t4), !r4.length) {
                    var u3 = new CustomEvent("tribute-no-match", { detail: n3.menu });
                    return n3.current.element.dispatchEvent(u3), void (typeof n3.current.collection.noMatchTemplate == "function" && !n3.current.collection.noMatchTemplate() || !n3.current.collection.noMatchTemplate ? n3.hideMenu() : typeof n3.current.collection.noMatchTemplate == "function" ? o3.innerHTML = n3.current.collection.noMatchTemplate() : o3.innerHTML = n3.current.collection.noMatchTemplate);
                  }
                  o3.innerHTML = "";
                  var l3 = n3.range.getDocument().createDocumentFragment();
                  r4.forEach(function(e6, t5) {
                    var r5 = n3.range.getDocument().createElement("li");
                    r5.setAttribute("data-index", t5), r5.className = n3.current.collection.itemClass, r5.addEventListener("mousemove", function(e7) {
                      var t6 = i3(n3._findLiTarget(e7.target), 2), r6 = (t6[0], t6[1]);
                      e7.movementY !== 0 && n3.events.setActiveLi(r6);
                    }), n3.menuSelected === t5 && r5.classList.add(n3.current.collection.selectClass), r5.innerHTML = n3.current.collection.menuItemTemplate(e6), l3.appendChild(r5);
                  }), o3.appendChild(l3);
                }
              };
              typeof this.current.collection.values == "function" ? this.current.collection.values(this.current.mentionText, r3) : r3(this.current.collection.values);
            }
          } }, { key: "_findLiTarget", value: function(e4) {
            if (!e4)
              return [];
            var t4 = e4.getAttribute("data-index");
            return t4 ? [e4, t4] : this._findLiTarget(e4.parentNode);
          } }, { key: "showMenuForCollection", value: function(e4, t4) {
            e4 !== document.activeElement && this.placeCaretAtEnd(e4), this.current.collection = this.collection[t4 || 0], this.current.externalTrigger = true, this.current.element = e4, e4.isContentEditable ? this.insertTextAtCursor(this.current.collection.trigger) : this.insertAtCaret(e4, this.current.collection.trigger), this.showMenuFor(e4);
          } }, { key: "placeCaretAtEnd", value: function(e4) {
            if (e4.focus(), window.getSelection !== void 0 && document.createRange !== void 0) {
              var t4 = document.createRange();
              t4.selectNodeContents(e4), t4.collapse(false);
              var n3 = window.getSelection();
              n3.removeAllRanges(), n3.addRange(t4);
            } else if (document.body.createTextRange !== void 0) {
              var i4 = document.body.createTextRange();
              i4.moveToElementText(e4), i4.collapse(false), i4.select();
            }
          } }, { key: "insertTextAtCursor", value: function(e4) {
            var t4, n3;
            (n3 = (t4 = window.getSelection()).getRangeAt(0)).deleteContents();
            var i4 = document.createTextNode(e4);
            n3.insertNode(i4), n3.selectNodeContents(i4), n3.collapse(false), t4.removeAllRanges(), t4.addRange(n3);
          } }, { key: "insertAtCaret", value: function(e4, t4) {
            var n3 = e4.scrollTop, i4 = e4.selectionStart, r3 = e4.value.substring(0, i4), o3 = e4.value.substring(e4.selectionEnd, e4.value.length);
            e4.value = r3 + t4 + o3, i4 += t4.length, e4.selectionStart = i4, e4.selectionEnd = i4, e4.focus(), e4.scrollTop = n3;
          } }, { key: "hideMenu", value: function() {
            this.menu && (this.menu.style.cssText = "display: none;", this.isActive = false, this.menuSelected = 0, this.current = {});
          } }, { key: "selectItemAtIndex", value: function(e4, t4) {
            if (typeof (e4 = parseInt(e4)) == "number" && !isNaN(e4)) {
              var n3 = this.current.filteredItems[e4], i4 = this.current.collection.selectTemplate(n3);
              i4 !== null && this.replaceText(i4, t4, n3);
            }
          } }, { key: "replaceText", value: function(e4, t4, n3) {
            this.range.replaceTriggerText(e4, true, true, t4, n3);
          } }, { key: "_append", value: function(e4, t4, n3) {
            if (typeof e4.values == "function")
              throw new Error("Unable to append to values, as it is a function.");
            e4.values = n3 ? t4 : e4.values.concat(t4);
          } }, { key: "append", value: function(e4, t4, n3) {
            var i4 = parseInt(e4);
            if (typeof i4 != "number")
              throw new Error("please provide an index for the collection to update.");
            var r3 = this.collection[i4];
            this._append(r3, t4, n3);
          } }, { key: "appendCurrent", value: function(e4, t4) {
            if (!this.isActive)
              throw new Error("No active state. Please use append instead and pass an index.");
            this._append(this.current.collection, e4, t4);
          } }, { key: "detach", value: function(e4) {
            if (!e4)
              throw new Error("[Tribute] Must pass in a DOM node or NodeList.");
            if (typeof jQuery != "undefined" && e4 instanceof jQuery && (e4 = e4.get()), e4.constructor === NodeList || e4.constructor === HTMLCollection || e4.constructor === Array)
              for (var t4 = e4.length, n3 = 0; n3 < t4; ++n3)
                this._detach(e4[n3]);
            else
              this._detach(e4);
          } }, { key: "_detach", value: function(e4) {
            var t4 = this;
            this.events.unbind(e4), e4.tributeMenu && this.menuEvents.unbind(e4.tributeMenu), setTimeout(function() {
              e4.removeAttribute("data-tribute"), t4.isActive = false, e4.tributeMenu && e4.tributeMenu.remove();
            });
          } }, { key: "isActive", get: function() {
            return this._isActive;
          }, set: function(e4) {
            if (this._isActive != e4 && (this._isActive = e4, this.current.element)) {
              var t4 = new CustomEvent("tribute-active-".concat(e4));
              this.current.element.dispatchEvent(t4);
            }
          } }], [{ key: "defaultSelectTemplate", value: function(e4) {
            return e4 === void 0 ? "".concat(this.current.collection.trigger).concat(this.current.mentionText) : this.range.isContentEditable(this.current.element) ? '<span class="tribute-mention">' + (this.current.collection.trigger + e4.original[this.current.collection.fillAttr]) + "</span>" : this.current.collection.trigger + e4.original[this.current.collection.fillAttr];
          } }, { key: "defaultMenuItemTemplate", value: function(e4) {
            return e4.string;
          } }, { key: "inputTypes", value: function() {
            return ["TEXTAREA", "INPUT"];
          } }]), t3;
        }();
      });
    }
  });

  // ../../node_modules/trix/dist/trix.js
  var require_trix = __commonJS({
    "../../node_modules/trix/dist/trix.js"(exports2, module4) {
      (function() {
      }).call(exports2), function() {
        var t2;
        window.Set == null && (window.Set = t2 = function() {
          function t3() {
            this.clear();
          }
          return t3.prototype.clear = function() {
            return this.values = [];
          }, t3.prototype.has = function(t4) {
            return this.values.indexOf(t4) !== -1;
          }, t3.prototype.add = function(t4) {
            return this.has(t4) || this.values.push(t4), this;
          }, t3.prototype["delete"] = function(t4) {
            var e3;
            return (e3 = this.values.indexOf(t4)) === -1 ? false : (this.values.splice(e3, 1), true);
          }, t3.prototype.forEach = function() {
            var t4;
            return (t4 = this.values).forEach.apply(t4, arguments);
          }, t3;
        }());
      }.call(exports2), function(t2) {
        function e3() {
        }
        function n2(t3, e4) {
          return function() {
            t3.apply(e4, arguments);
          };
        }
        function i3(t3) {
          if (typeof this != "object")
            throw new TypeError("Promises must be constructed via new");
          if (typeof t3 != "function")
            throw new TypeError("not a function");
          this._state = 0, this._handled = false, this._value = void 0, this._deferreds = [], c2(t3, this);
        }
        function o2(t3, e4) {
          for (; t3._state === 3; )
            t3 = t3._value;
          return t3._state === 0 ? void t3._deferreds.push(e4) : (t3._handled = true, void h5(function() {
            var n3 = t3._state === 1 ? e4.onFulfilled : e4.onRejected;
            if (n3 === null)
              return void (t3._state === 1 ? r2 : s4)(e4.promise, t3._value);
            var i4;
            try {
              i4 = n3(t3._value);
            } catch (o3) {
              return void s4(e4.promise, o3);
            }
            r2(e4.promise, i4);
          }));
        }
        function r2(t3, e4) {
          try {
            if (e4 === t3)
              throw new TypeError("A promise cannot be resolved with itself.");
            if (e4 && (typeof e4 == "object" || typeof e4 == "function")) {
              var o3 = e4.then;
              if (e4 instanceof i3)
                return t3._state = 3, t3._value = e4, void a4(t3);
              if (typeof o3 == "function")
                return void c2(n2(o3, e4), t3);
            }
            t3._state = 1, t3._value = e4, a4(t3);
          } catch (r3) {
            s4(t3, r3);
          }
        }
        function s4(t3, e4) {
          t3._state = 2, t3._value = e4, a4(t3);
        }
        function a4(t3) {
          t3._state === 2 && t3._deferreds.length === 0 && setTimeout(function() {
            t3._handled || p(t3._value);
          }, 1);
          for (var e4 = 0, n3 = t3._deferreds.length; n3 > e4; e4++)
            o2(t3, t3._deferreds[e4]);
          t3._deferreds = null;
        }
        function u2(t3, e4, n3) {
          this.onFulfilled = typeof t3 == "function" ? t3 : null, this.onRejected = typeof e4 == "function" ? e4 : null, this.promise = n3;
        }
        function c2(t3, e4) {
          var n3 = false;
          try {
            t3(function(t4) {
              n3 || (n3 = true, r2(e4, t4));
            }, function(t4) {
              n3 || (n3 = true, s4(e4, t4));
            });
          } catch (i4) {
            if (n3)
              return;
            n3 = true, s4(e4, i4);
          }
        }
        var l2 = setTimeout, h5 = typeof setImmediate == "function" && setImmediate || function(t3) {
          l2(t3, 1);
        }, p = function(t3) {
          typeof console != "undefined" && console && console.warn("Possible Unhandled Promise Rejection:", t3);
        };
        i3.prototype["catch"] = function(t3) {
          return this.then(null, t3);
        }, i3.prototype.then = function(t3, n3) {
          var r3 = new i3(e3);
          return o2(this, new u2(t3, n3, r3)), r3;
        }, i3.all = function(t3) {
          var e4 = Array.prototype.slice.call(t3);
          return new i3(function(t4, n3) {
            function i4(r4, s5) {
              try {
                if (s5 && (typeof s5 == "object" || typeof s5 == "function")) {
                  var a5 = s5.then;
                  if (typeof a5 == "function")
                    return void a5.call(s5, function(t5) {
                      i4(r4, t5);
                    }, n3);
                }
                e4[r4] = s5, --o3 === 0 && t4(e4);
              } catch (u3) {
                n3(u3);
              }
            }
            if (e4.length === 0)
              return t4([]);
            for (var o3 = e4.length, r3 = 0; r3 < e4.length; r3++)
              i4(r3, e4[r3]);
          });
        }, i3.resolve = function(t3) {
          return t3 && typeof t3 == "object" && t3.constructor === i3 ? t3 : new i3(function(e4) {
            e4(t3);
          });
        }, i3.reject = function(t3) {
          return new i3(function(e4, n3) {
            n3(t3);
          });
        }, i3.race = function(t3) {
          return new i3(function(e4, n3) {
            for (var i4 = 0, o3 = t3.length; o3 > i4; i4++)
              t3[i4].then(e4, n3);
          });
        }, i3._setImmediateFn = function(t3) {
          h5 = t3;
        }, i3._setUnhandledRejectionFn = function(t3) {
          p = t3;
        }, typeof module4 != "undefined" && module4.exports ? module4.exports = i3 : t2.Promise || (t2.Promise = i3);
      }(exports2), function() {
        var t2 = typeof window.customElements == "object", e3 = typeof document.registerElement == "function", n2 = t2 || e3;
        n2 || (typeof WeakMap == "undefined" && !function() {
          var t3 = Object.defineProperty, e4 = Date.now() % 1e9, n3 = function() {
            this.name = "__st" + (1e9 * Math.random() >>> 0) + (e4++ + "__");
          };
          n3.prototype = { set: function(e5, n4) {
            var i3 = e5[this.name];
            return i3 && i3[0] === e5 ? i3[1] = n4 : t3(e5, this.name, { value: [e5, n4], writable: true }), this;
          }, get: function(t4) {
            var e5;
            return (e5 = t4[this.name]) && e5[0] === t4 ? e5[1] : void 0;
          }, "delete": function(t4) {
            var e5 = t4[this.name];
            return e5 && e5[0] === t4 ? (e5[0] = e5[1] = void 0, true) : false;
          }, has: function(t4) {
            var e5 = t4[this.name];
            return e5 ? e5[0] === t4 : false;
          } }, window.WeakMap = n3;
        }(), function(t3) {
          function e4(t4) {
            A.push(t4), b2 || (b2 = true, g(i3));
          }
          function n3(t4) {
            return window.ShadowDOMPolyfill && window.ShadowDOMPolyfill.wrapIfNeeded(t4) || t4;
          }
          function i3() {
            b2 = false;
            var t4 = A;
            A = [], t4.sort(function(t5, e6) {
              return t5.uid_ - e6.uid_;
            });
            var e5 = false;
            t4.forEach(function(t5) {
              var n4 = t5.takeRecords();
              o2(t5), n4.length && (t5.callback_(n4, t5), e5 = true);
            }), e5 && i3();
          }
          function o2(t4) {
            t4.nodes_.forEach(function(e5) {
              var n4 = m3.get(e5);
              n4 && n4.forEach(function(e6) {
                e6.observer === t4 && e6.removeTransientObservers();
              });
            });
          }
          function r2(t4, e5) {
            for (var n4 = t4; n4; n4 = n4.parentNode) {
              var i4 = m3.get(n4);
              if (i4)
                for (var o3 = 0; o3 < i4.length; o3++) {
                  var r3 = i4[o3], s5 = r3.options;
                  if (n4 === t4 || s5.subtree) {
                    var a5 = e5(s5);
                    a5 && r3.enqueue(a5);
                  }
                }
            }
          }
          function s4(t4) {
            this.callback_ = t4, this.nodes_ = [], this.records_ = [], this.uid_ = ++C;
          }
          function a4(t4, e5) {
            this.type = t4, this.target = e5, this.addedNodes = [], this.removedNodes = [], this.previousSibling = null, this.nextSibling = null, this.attributeName = null, this.attributeNamespace = null, this.oldValue = null;
          }
          function u2(t4) {
            var e5 = new a4(t4.type, t4.target);
            return e5.addedNodes = t4.addedNodes.slice(), e5.removedNodes = t4.removedNodes.slice(), e5.previousSibling = t4.previousSibling, e5.nextSibling = t4.nextSibling, e5.attributeName = t4.attributeName, e5.attributeNamespace = t4.attributeNamespace, e5.oldValue = t4.oldValue, e5;
          }
          function c2(t4, e5) {
            return x2 = new a4(t4, e5);
          }
          function l2(t4) {
            return w2 ? w2 : (w2 = u2(x2), w2.oldValue = t4, w2);
          }
          function h5() {
            x2 = w2 = void 0;
          }
          function p(t4) {
            return t4 === w2 || t4 === x2;
          }
          function d3(t4, e5) {
            return t4 === e5 ? t4 : w2 && p(t4) ? w2 : null;
          }
          function f(t4, e5, n4) {
            this.observer = t4, this.target = e5, this.options = n4, this.transientObservedNodes = [];
          }
          if (!t3.JsMutationObserver) {
            var g, m3 = /* @__PURE__ */ new WeakMap();
            if (/Trident|Edge/.test(navigator.userAgent))
              g = setTimeout;
            else if (window.setImmediate)
              g = window.setImmediate;
            else {
              var v = [], y3 = String(Math.random());
              window.addEventListener("message", function(t4) {
                if (t4.data === y3) {
                  var e5 = v;
                  v = [], e5.forEach(function(t5) {
                    t5();
                  });
                }
              }), g = function(t4) {
                v.push(t4), window.postMessage(y3, "*");
              };
            }
            var b2 = false, A = [], C = 0;
            s4.prototype = { observe: function(t4, e5) {
              if (t4 = n3(t4), !e5.childList && !e5.attributes && !e5.characterData || e5.attributeOldValue && !e5.attributes || e5.attributeFilter && e5.attributeFilter.length && !e5.attributes || e5.characterDataOldValue && !e5.characterData)
                throw new SyntaxError();
              var i4 = m3.get(t4);
              i4 || m3.set(t4, i4 = []);
              for (var o3, r3 = 0; r3 < i4.length; r3++)
                if (i4[r3].observer === this) {
                  o3 = i4[r3], o3.removeListeners(), o3.options = e5;
                  break;
                }
              o3 || (o3 = new f(this, t4, e5), i4.push(o3), this.nodes_.push(t4)), o3.addListeners();
            }, disconnect: function() {
              this.nodes_.forEach(function(t4) {
                for (var e5 = m3.get(t4), n4 = 0; n4 < e5.length; n4++) {
                  var i4 = e5[n4];
                  if (i4.observer === this) {
                    i4.removeListeners(), e5.splice(n4, 1);
                    break;
                  }
                }
              }, this), this.records_ = [];
            }, takeRecords: function() {
              var t4 = this.records_;
              return this.records_ = [], t4;
            } };
            var x2, w2;
            f.prototype = { enqueue: function(t4) {
              var n4 = this.observer.records_, i4 = n4.length;
              if (n4.length > 0) {
                var o3 = n4[i4 - 1], r3 = d3(o3, t4);
                if (r3)
                  return void (n4[i4 - 1] = r3);
              } else
                e4(this.observer);
              n4[i4] = t4;
            }, addListeners: function() {
              this.addListeners_(this.target);
            }, addListeners_: function(t4) {
              var e5 = this.options;
              e5.attributes && t4.addEventListener("DOMAttrModified", this, true), e5.characterData && t4.addEventListener("DOMCharacterDataModified", this, true), e5.childList && t4.addEventListener("DOMNodeInserted", this, true), (e5.childList || e5.subtree) && t4.addEventListener("DOMNodeRemoved", this, true);
            }, removeListeners: function() {
              this.removeListeners_(this.target);
            }, removeListeners_: function(t4) {
              var e5 = this.options;
              e5.attributes && t4.removeEventListener("DOMAttrModified", this, true), e5.characterData && t4.removeEventListener("DOMCharacterDataModified", this, true), e5.childList && t4.removeEventListener("DOMNodeInserted", this, true), (e5.childList || e5.subtree) && t4.removeEventListener("DOMNodeRemoved", this, true);
            }, addTransientObserver: function(t4) {
              if (t4 !== this.target) {
                this.addListeners_(t4), this.transientObservedNodes.push(t4);
                var e5 = m3.get(t4);
                e5 || m3.set(t4, e5 = []), e5.push(this);
              }
            }, removeTransientObservers: function() {
              var t4 = this.transientObservedNodes;
              this.transientObservedNodes = [], t4.forEach(function(t5) {
                this.removeListeners_(t5);
                for (var e5 = m3.get(t5), n4 = 0; n4 < e5.length; n4++)
                  if (e5[n4] === this) {
                    e5.splice(n4, 1);
                    break;
                  }
              }, this);
            }, handleEvent: function(t4) {
              switch (t4.stopImmediatePropagation(), t4.type) {
                case "DOMAttrModified":
                  var e5 = t4.attrName, n4 = t4.relatedNode.namespaceURI, i4 = t4.target, o3 = new c2("attributes", i4);
                  o3.attributeName = e5, o3.attributeNamespace = n4;
                  var s5 = t4.attrChange === MutationEvent.ADDITION ? null : t4.prevValue;
                  r2(i4, function(t5) {
                    return !t5.attributes || t5.attributeFilter && t5.attributeFilter.length && t5.attributeFilter.indexOf(e5) === -1 && t5.attributeFilter.indexOf(n4) === -1 ? void 0 : t5.attributeOldValue ? l2(s5) : o3;
                  });
                  break;
                case "DOMCharacterDataModified":
                  var i4 = t4.target, o3 = c2("characterData", i4), s5 = t4.prevValue;
                  r2(i4, function(t5) {
                    return t5.characterData ? t5.characterDataOldValue ? l2(s5) : o3 : void 0;
                  });
                  break;
                case "DOMNodeRemoved":
                  this.addTransientObserver(t4.target);
                case "DOMNodeInserted":
                  var a5, u3, p2 = t4.target;
                  t4.type === "DOMNodeInserted" ? (a5 = [p2], u3 = []) : (a5 = [], u3 = [p2]);
                  var d4 = p2.previousSibling, f2 = p2.nextSibling, o3 = c2("childList", t4.target.parentNode);
                  o3.addedNodes = a5, o3.removedNodes = u3, o3.previousSibling = d4, o3.nextSibling = f2, r2(t4.relatedNode, function(t5) {
                    return t5.childList ? o3 : void 0;
                  });
              }
              h5();
            } }, t3.JsMutationObserver = s4, t3.MutationObserver || (t3.MutationObserver = s4, s4._isPolyfilled = true);
          }
        }(self), function() {
          "use strict";
          if (!window.performance || !window.performance.now) {
            var t3 = Date.now();
            window.performance = { now: function() {
              return Date.now() - t3;
            } };
          }
          window.requestAnimationFrame || (window.requestAnimationFrame = function() {
            var t4 = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame;
            return t4 ? function(e5) {
              return t4(function() {
                e5(performance.now());
              });
            } : function(t5) {
              return window.setTimeout(t5, 1e3 / 60);
            };
          }()), window.cancelAnimationFrame || (window.cancelAnimationFrame = function() {
            return window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || function(t4) {
              clearTimeout(t4);
            };
          }());
          var e4 = function() {
            var t4 = document.createEvent("Event");
            return t4.initEvent("foo", true, true), t4.preventDefault(), t4.defaultPrevented;
          }();
          if (!e4) {
            var n3 = Event.prototype.preventDefault;
            Event.prototype.preventDefault = function() {
              this.cancelable && (n3.call(this), Object.defineProperty(this, "defaultPrevented", { get: function() {
                return true;
              }, configurable: true }));
            };
          }
          var i3 = /Trident/.test(navigator.userAgent);
          if ((!window.CustomEvent || i3 && typeof window.CustomEvent != "function") && (window.CustomEvent = function(t4, e5) {
            e5 = e5 || {};
            var n4 = document.createEvent("CustomEvent");
            return n4.initCustomEvent(t4, Boolean(e5.bubbles), Boolean(e5.cancelable), e5.detail), n4;
          }, window.CustomEvent.prototype = window.Event.prototype), !window.Event || i3 && typeof window.Event != "function") {
            var o2 = window.Event;
            window.Event = function(t4, e5) {
              e5 = e5 || {};
              var n4 = document.createEvent("Event");
              return n4.initEvent(t4, Boolean(e5.bubbles), Boolean(e5.cancelable)), n4;
            }, window.Event.prototype = o2.prototype;
          }
        }(window.WebComponents), window.CustomElements = window.CustomElements || { flags: {} }, function(t3) {
          var e4 = t3.flags, n3 = [], i3 = function(t4) {
            n3.push(t4);
          }, o2 = function() {
            n3.forEach(function(e5) {
              e5(t3);
            });
          };
          t3.addModule = i3, t3.initializeModules = o2, t3.hasNative = Boolean(document.registerElement), t3.isIE = /Trident/.test(navigator.userAgent), t3.useNative = !e4.register && t3.hasNative && !window.ShadowDOMPolyfill && (!window.HTMLImports || window.HTMLImports.useNative);
        }(window.CustomElements), window.CustomElements.addModule(function(t3) {
          function e4(t4, e5) {
            n3(t4, function(t5) {
              return e5(t5) ? true : void i3(t5, e5);
            }), i3(t4, e5);
          }
          function n3(t4, e5, i4) {
            var o3 = t4.firstElementChild;
            if (!o3)
              for (o3 = t4.firstChild; o3 && o3.nodeType !== Node.ELEMENT_NODE; )
                o3 = o3.nextSibling;
            for (; o3; )
              e5(o3, i4) !== true && n3(o3, e5, i4), o3 = o3.nextElementSibling;
            return null;
          }
          function i3(t4, n4) {
            for (var i4 = t4.shadowRoot; i4; )
              e4(i4, n4), i4 = i4.olderShadowRoot;
          }
          function o2(t4, e5) {
            r2(t4, e5, []);
          }
          function r2(t4, e5, n4) {
            if (t4 = window.wrap(t4), !(n4.indexOf(t4) >= 0)) {
              n4.push(t4);
              for (var i4, o3 = t4.querySelectorAll("link[rel=" + s4 + "]"), a4 = 0, u2 = o3.length; u2 > a4 && (i4 = o3[a4]); a4++)
                i4.import && r2(i4.import, e5, n4);
              e5(t4);
            }
          }
          var s4 = window.HTMLImports ? window.HTMLImports.IMPORT_LINK_TYPE : "none";
          t3.forDocumentTree = o2, t3.forSubtree = e4;
        }), window.CustomElements.addModule(function(t3) {
          function e4(t4, e5) {
            return n3(t4, e5) || i3(t4, e5);
          }
          function n3(e5, n4) {
            return t3.upgrade(e5, n4) ? true : void (n4 && s4(e5));
          }
          function i3(t4, e5) {
            b2(t4, function(t5) {
              return n3(t5, e5) ? true : void 0;
            });
          }
          function o2(t4) {
            w2.push(t4), x2 || (x2 = true, setTimeout(r2));
          }
          function r2() {
            x2 = false;
            for (var t4, e5 = w2, n4 = 0, i4 = e5.length; i4 > n4 && (t4 = e5[n4]); n4++)
              t4();
            w2 = [];
          }
          function s4(t4) {
            C ? o2(function() {
              a4(t4);
            }) : a4(t4);
          }
          function a4(t4) {
            t4.__upgraded__ && !t4.__attached && (t4.__attached = true, t4.attachedCallback && t4.attachedCallback());
          }
          function u2(t4) {
            c2(t4), b2(t4, function(t5) {
              c2(t5);
            });
          }
          function c2(t4) {
            C ? o2(function() {
              l2(t4);
            }) : l2(t4);
          }
          function l2(t4) {
            t4.__upgraded__ && t4.__attached && (t4.__attached = false, t4.detachedCallback && t4.detachedCallback());
          }
          function h5(t4) {
            for (var e5 = t4, n4 = window.wrap(document); e5; ) {
              if (e5 == n4)
                return true;
              e5 = e5.parentNode || e5.nodeType === Node.DOCUMENT_FRAGMENT_NODE && e5.host;
            }
          }
          function p(t4) {
            if (t4.shadowRoot && !t4.shadowRoot.__watched) {
              y3.dom && console.log("watching shadow-root for: ", t4.localName);
              for (var e5 = t4.shadowRoot; e5; )
                g(e5), e5 = e5.olderShadowRoot;
            }
          }
          function d3(t4, n4) {
            if (y3.dom) {
              var i4 = n4[0];
              if (i4 && i4.type === "childList" && i4.addedNodes && i4.addedNodes) {
                for (var o3 = i4.addedNodes[0]; o3 && o3 !== document && !o3.host; )
                  o3 = o3.parentNode;
                var r3 = o3 && (o3.URL || o3._URL || o3.host && o3.host.localName) || "";
                r3 = r3.split("/?").shift().split("/").pop();
              }
              console.group("mutations (%d) [%s]", n4.length, r3 || "");
            }
            var s5 = h5(t4);
            n4.forEach(function(t5) {
              t5.type === "childList" && (E2(t5.addedNodes, function(t6) {
                t6.localName && e4(t6, s5);
              }), E2(t5.removedNodes, function(t6) {
                t6.localName && u2(t6);
              }));
            }), y3.dom && console.groupEnd();
          }
          function f(t4) {
            for (t4 = window.wrap(t4), t4 || (t4 = window.wrap(document)); t4.parentNode; )
              t4 = t4.parentNode;
            var e5 = t4.__observer;
            e5 && (d3(t4, e5.takeRecords()), r2());
          }
          function g(t4) {
            if (!t4.__observer) {
              var e5 = new MutationObserver(d3.bind(this, t4));
              e5.observe(t4, { childList: true, subtree: true }), t4.__observer = e5;
            }
          }
          function m3(t4) {
            t4 = window.wrap(t4), y3.dom && console.group("upgradeDocument: ", t4.baseURI.split("/").pop());
            var n4 = t4 === window.wrap(document);
            e4(t4, n4), g(t4), y3.dom && console.groupEnd();
          }
          function v(t4) {
            A(t4, m3);
          }
          var y3 = t3.flags, b2 = t3.forSubtree, A = t3.forDocumentTree, C = window.MutationObserver._isPolyfilled && y3["throttle-attached"];
          t3.hasPolyfillMutations = C, t3.hasThrottledAttached = C;
          var x2 = false, w2 = [], E2 = Array.prototype.forEach.call.bind(Array.prototype.forEach), S3 = Element.prototype.createShadowRoot;
          S3 && (Element.prototype.createShadowRoot = function() {
            var t4 = S3.call(this);
            return window.CustomElements.watchShadow(this), t4;
          }), t3.watchShadow = p, t3.upgradeDocumentTree = v, t3.upgradeDocument = m3, t3.upgradeSubtree = i3, t3.upgradeAll = e4, t3.attached = s4, t3.takeRecords = f;
        }), window.CustomElements.addModule(function(t3) {
          function e4(e5, i4) {
            if (e5.localName === "template" && window.HTMLTemplateElement && HTMLTemplateElement.decorate && HTMLTemplateElement.decorate(e5), !e5.__upgraded__ && e5.nodeType === Node.ELEMENT_NODE) {
              var o3 = e5.getAttribute("is"), r3 = t3.getRegisteredDefinition(e5.localName) || t3.getRegisteredDefinition(o3);
              if (r3 && (o3 && r3.tag == e5.localName || !o3 && !r3.extends))
                return n3(e5, r3, i4);
            }
          }
          function n3(e5, n4, o3) {
            return s4.upgrade && console.group("upgrade:", e5.localName), n4.is && e5.setAttribute("is", n4.is), i3(e5, n4), e5.__upgraded__ = true, r2(e5), o3 && t3.attached(e5), t3.upgradeSubtree(e5, o3), s4.upgrade && console.groupEnd(), e5;
          }
          function i3(t4, e5) {
            Object.__proto__ ? t4.__proto__ = e5.prototype : (o2(t4, e5.prototype, e5.native), t4.__proto__ = e5.prototype);
          }
          function o2(t4, e5, n4) {
            for (var i4 = {}, o3 = e5; o3 !== n4 && o3 !== HTMLElement.prototype; ) {
              for (var r3, s5 = Object.getOwnPropertyNames(o3), a4 = 0; r3 = s5[a4]; a4++)
                i4[r3] || (Object.defineProperty(t4, r3, Object.getOwnPropertyDescriptor(o3, r3)), i4[r3] = 1);
              o3 = Object.getPrototypeOf(o3);
            }
          }
          function r2(t4) {
            t4.createdCallback && t4.createdCallback();
          }
          var s4 = t3.flags;
          t3.upgrade = e4, t3.upgradeWithDefinition = n3, t3.implementPrototype = i3;
        }), window.CustomElements.addModule(function(t3) {
          function e4(e5, i4) {
            var u3 = i4 || {};
            if (!e5)
              throw new Error("document.registerElement: first argument `name` must not be empty");
            if (e5.indexOf("-") < 0)
              throw new Error("document.registerElement: first argument ('name') must contain a dash ('-'). Argument provided was '" + String(e5) + "'.");
            if (o2(e5))
              throw new Error("Failed to execute 'registerElement' on 'Document': Registration failed for type '" + String(e5) + "'. The type name is invalid.");
            if (c2(e5))
              throw new Error("DuplicateDefinitionError: a type with name '" + String(e5) + "' is already registered");
            return u3.prototype || (u3.prototype = Object.create(HTMLElement.prototype)), u3.__name = e5.toLowerCase(), u3.extends && (u3.extends = u3.extends.toLowerCase()), u3.lifecycle = u3.lifecycle || {}, u3.ancestry = r2(u3.extends), s4(u3), a4(u3), n3(u3.prototype), l2(u3.__name, u3), u3.ctor = h5(u3), u3.ctor.prototype = u3.prototype, u3.prototype.constructor = u3.ctor, t3.ready && m3(document), u3.ctor;
          }
          function n3(t4) {
            if (!t4.setAttribute._polyfilled) {
              var e5 = t4.setAttribute;
              t4.setAttribute = function(t5, n5) {
                i3.call(this, t5, n5, e5);
              };
              var n4 = t4.removeAttribute;
              t4.removeAttribute = function(t5) {
                i3.call(this, t5, null, n4);
              }, t4.setAttribute._polyfilled = true;
            }
          }
          function i3(t4, e5, n4) {
            t4 = t4.toLowerCase();
            var i4 = this.getAttribute(t4);
            n4.apply(this, arguments);
            var o3 = this.getAttribute(t4);
            this.attributeChangedCallback && o3 !== i4 && this.attributeChangedCallback(t4, i4, o3);
          }
          function o2(t4) {
            for (var e5 = 0; e5 < C.length; e5++)
              if (t4 === C[e5])
                return true;
          }
          function r2(t4) {
            var e5 = c2(t4);
            return e5 ? r2(e5.extends).concat([e5]) : [];
          }
          function s4(t4) {
            for (var e5, n4 = t4.extends, i4 = 0; e5 = t4.ancestry[i4]; i4++)
              n4 = e5.is && e5.tag;
            t4.tag = n4 || t4.__name, n4 && (t4.is = t4.__name);
          }
          function a4(t4) {
            if (!Object.__proto__) {
              var e5 = HTMLElement.prototype;
              if (t4.is) {
                var n4 = document.createElement(t4.tag);
                e5 = Object.getPrototypeOf(n4);
              }
              for (var i4, o3 = t4.prototype, r3 = false; o3; )
                o3 == e5 && (r3 = true), i4 = Object.getPrototypeOf(o3), i4 && (o3.__proto__ = i4), o3 = i4;
              r3 || console.warn(t4.tag + " prototype not found in prototype chain for " + t4.is), t4.native = e5;
            }
          }
          function u2(t4) {
            return y3(E2(t4.tag), t4);
          }
          function c2(t4) {
            return t4 ? x2[t4.toLowerCase()] : void 0;
          }
          function l2(t4, e5) {
            x2[t4] = e5;
          }
          function h5(t4) {
            return function() {
              return u2(t4);
            };
          }
          function p(t4, e5, n4) {
            return t4 === w2 ? d3(e5, n4) : S3(t4, e5);
          }
          function d3(t4, e5) {
            t4 && (t4 = t4.toLowerCase()), e5 && (e5 = e5.toLowerCase());
            var n4 = c2(e5 || t4);
            if (n4) {
              if (t4 == n4.tag && e5 == n4.is)
                return new n4.ctor();
              if (!e5 && !n4.is)
                return new n4.ctor();
            }
            var i4;
            return e5 ? (i4 = d3(t4), i4.setAttribute("is", e5), i4) : (i4 = E2(t4), t4.indexOf("-") >= 0 && b2(i4, HTMLElement), i4);
          }
          function f(t4, e5) {
            var n4 = t4[e5];
            t4[e5] = function() {
              var t5 = n4.apply(this, arguments);
              return v(t5), t5;
            };
          }
          var g, m3 = (t3.isIE, t3.upgradeDocumentTree), v = t3.upgradeAll, y3 = t3.upgradeWithDefinition, b2 = t3.implementPrototype, A = t3.useNative, C = ["annotation-xml", "color-profile", "font-face", "font-face-src", "font-face-uri", "font-face-format", "font-face-name", "missing-glyph"], x2 = {}, w2 = "http://www.w3.org/1999/xhtml", E2 = document.createElement.bind(document), S3 = document.createElementNS.bind(document);
          g = Object.__proto__ || A ? function(t4, e5) {
            return t4 instanceof e5;
          } : function(t4, e5) {
            if (t4 instanceof e5)
              return true;
            for (var n4 = t4; n4; ) {
              if (n4 === e5.prototype)
                return true;
              n4 = n4.__proto__;
            }
            return false;
          }, f(Node.prototype, "cloneNode"), f(document, "importNode"), document.registerElement = e4, document.createElement = d3, document.createElementNS = p, t3.registry = x2, t3.instanceof = g, t3.reservedTagList = C, t3.getRegisteredDefinition = c2, document.register = document.registerElement;
        }), function(t3) {
          function e4() {
            r2(window.wrap(document)), window.CustomElements.ready = true;
            var t4 = window.requestAnimationFrame || function(t5) {
              setTimeout(t5, 16);
            };
            t4(function() {
              setTimeout(function() {
                window.CustomElements.readyTime = Date.now(), window.HTMLImports && (window.CustomElements.elapsed = window.CustomElements.readyTime - window.HTMLImports.readyTime), document.dispatchEvent(new CustomEvent("WebComponentsReady", { bubbles: true }));
              });
            });
          }
          var n3 = t3.useNative, i3 = t3.initializeModules;
          if (t3.isIE, n3) {
            var o2 = function() {
            };
            t3.watchShadow = o2, t3.upgrade = o2, t3.upgradeAll = o2, t3.upgradeDocumentTree = o2, t3.upgradeSubtree = o2, t3.takeRecords = o2, t3.instanceof = function(t4, e5) {
              return t4 instanceof e5;
            };
          } else
            i3();
          var r2 = t3.upgradeDocumentTree, s4 = t3.upgradeDocument;
          if (window.wrap || (window.ShadowDOMPolyfill ? (window.wrap = window.ShadowDOMPolyfill.wrapIfNeeded, window.unwrap = window.ShadowDOMPolyfill.unwrapIfNeeded) : window.wrap = window.unwrap = function(t4) {
            return t4;
          }), window.HTMLImports && (window.HTMLImports.__importsParsingHook = function(t4) {
            t4.import && s4(wrap(t4.import));
          }), document.readyState === "complete" || t3.flags.eager)
            e4();
          else if (document.readyState !== "interactive" || window.attachEvent || window.HTMLImports && !window.HTMLImports.ready) {
            var a4 = window.HTMLImports && !window.HTMLImports.ready ? "HTMLImportsLoaded" : "DOMContentLoaded";
            window.addEventListener(a4, e4);
          } else
            e4();
        }(window.CustomElements));
      }.call(exports2), function() {
      }.call(exports2), function() {
        var t2 = this;
        (function() {
          (function() {
            this.Trix = { VERSION: "1.3.1", ZERO_WIDTH_SPACE: "\uFEFF", NON_BREAKING_SPACE: "\xA0", OBJECT_REPLACEMENT_CHARACTER: "\uFFFC", browser: { composesExistingText: /Android.*Chrome/.test(navigator.userAgent), forcesObjectResizing: /Trident.*rv:11/.test(navigator.userAgent), supportsInputEvents: function() {
              var t3, e4, n2, i3;
              if (typeof InputEvent == "undefined")
                return false;
              for (i3 = ["data", "getTargetRanges", "inputType"], t3 = 0, e4 = i3.length; e4 > t3; t3++)
                if (n2 = i3[t3], !(n2 in InputEvent.prototype))
                  return false;
              return true;
            }() }, config: {} };
          }).call(this);
        }).call(t2);
        var e3 = t2.Trix;
        (function() {
          (function() {
            e3.BasicObject = function() {
              function t3() {
              }
              var e4, n2, i3;
              return t3.proxyMethod = function(t4) {
                var i4, o2, r2, s4, a4;
                return r2 = n2(t4), i4 = r2.name, s4 = r2.toMethod, a4 = r2.toProperty, o2 = r2.optional, this.prototype[i4] = function() {
                  var t5, n3;
                  return t5 = s4 != null ? o2 ? typeof this[s4] == "function" ? this[s4]() : void 0 : this[s4]() : a4 != null ? this[a4] : void 0, o2 ? (n3 = t5 != null ? t5[i4] : void 0, n3 != null ? e4.call(n3, t5, arguments) : void 0) : (n3 = t5[i4], e4.call(n3, t5, arguments));
                };
              }, n2 = function(t4) {
                var e5, n3;
                if (!(n3 = t4.match(i3)))
                  throw new Error("can't parse @proxyMethod expression: " + t4);
                return e5 = { name: n3[4] }, n3[2] != null ? e5.toMethod = n3[1] : e5.toProperty = n3[1], n3[3] != null && (e5.optional = true), e5;
              }, e4 = Function.prototype.apply, i3 = /^(.+?)(\(\))?(\?)?\.(.+?)$/, t3;
            }();
          }).call(this), function() {
            var t3 = function(t4, e4) {
              function i3() {
                this.constructor = t4;
              }
              for (var o2 in e4)
                n2.call(e4, o2) && (t4[o2] = e4[o2]);
              return i3.prototype = e4.prototype, t4.prototype = new i3(), t4.__super__ = e4.prototype, t4;
            }, n2 = {}.hasOwnProperty;
            e3.Object = function(n3) {
              function i3() {
                this.id = ++o2;
              }
              var o2;
              return t3(i3, n3), o2 = 0, i3.fromJSONString = function(t4) {
                return this.fromJSON(JSON.parse(t4));
              }, i3.prototype.hasSameConstructorAs = function(t4) {
                return this.constructor === (t4 != null ? t4.constructor : void 0);
              }, i3.prototype.isEqualTo = function(t4) {
                return this === t4;
              }, i3.prototype.inspect = function() {
                var t4, e4, n4;
                return t4 = function() {
                  var t5, i4, o3;
                  i4 = (t5 = this.contentsForInspection()) != null ? t5 : {}, o3 = [];
                  for (e4 in i4)
                    n4 = i4[e4], o3.push(e4 + "=" + n4);
                  return o3;
                }.call(this), "#<" + this.constructor.name + ":" + this.id + (t4.length ? " " + t4.join(", ") : "") + ">";
              }, i3.prototype.contentsForInspection = function() {
              }, i3.prototype.toJSONString = function() {
                return JSON.stringify(this);
              }, i3.prototype.toUTF16String = function() {
                return e3.UTF16String.box(this);
              }, i3.prototype.getCacheKey = function() {
                return this.id.toString();
              }, i3;
            }(e3.BasicObject);
          }.call(this), function() {
            e3.extend = function(t3) {
              var e4, n2;
              for (e4 in t3)
                n2 = t3[e4], this[e4] = n2;
              return this;
            };
          }.call(this), function() {
            e3.extend({ defer: function(t3) {
              return setTimeout(t3, 1);
            } });
          }.call(this), function() {
            var t3, n2;
            e3.extend({ normalizeSpaces: function(t4) {
              return t4.replace(RegExp("" + e3.ZERO_WIDTH_SPACE, "g"), "").replace(RegExp("" + e3.NON_BREAKING_SPACE, "g"), " ");
            }, normalizeNewlines: function(t4) {
              return t4.replace(/\r\n/g, "\n");
            }, breakableWhitespacePattern: RegExp("[^\\S" + e3.NON_BREAKING_SPACE + "]"), squishBreakableWhitespace: function(t4) {
              return t4.replace(RegExp("" + e3.breakableWhitespacePattern.source, "g"), " ").replace(/\ {2,}/g, " ");
            }, summarizeStringChange: function(t4, i3) {
              var o2, r2, s4, a4;
              return t4 = e3.UTF16String.box(t4), i3 = e3.UTF16String.box(i3), i3.length < t4.length ? (r2 = n2(t4, i3), a4 = r2[0], o2 = r2[1]) : (s4 = n2(i3, t4), o2 = s4[0], a4 = s4[1]), { added: o2, removed: a4 };
            } }), n2 = function(n3, i3) {
              var o2, r2, s4, a4, u2;
              return n3.isEqualTo(i3) ? ["", ""] : (r2 = t3(n3, i3), a4 = r2.utf16String.length, s4 = a4 ? (u2 = r2.offset, r2, o2 = n3.codepoints.slice(0, u2).concat(n3.codepoints.slice(u2 + a4)), t3(i3, e3.UTF16String.fromCodepoints(o2))) : t3(i3, n3), [r2.utf16String.toString(), s4.utf16String.toString()]);
            }, t3 = function(t4, e4) {
              var n3, i3, o2;
              for (n3 = 0, i3 = t4.length, o2 = e4.length; i3 > n3 && t4.charAt(n3).isEqualTo(e4.charAt(n3)); )
                n3++;
              for (; i3 > n3 + 1 && t4.charAt(i3 - 1).isEqualTo(e4.charAt(o2 - 1)); )
                i3--, o2--;
              return { utf16String: t4.slice(n3, i3), offset: n3 };
            };
          }.call(this), function() {
            e3.extend({ copyObject: function(t3) {
              var e4, n2, i3;
              t3 == null && (t3 = {}), n2 = {};
              for (e4 in t3)
                i3 = t3[e4], n2[e4] = i3;
              return n2;
            }, objectsAreEqual: function(t3, e4) {
              var n2, i3;
              if (t3 == null && (t3 = {}), e4 == null && (e4 = {}), Object.keys(t3).length !== Object.keys(e4).length)
                return false;
              for (n2 in t3)
                if (i3 = t3[n2], i3 !== e4[n2])
                  return false;
              return true;
            } });
          }.call(this), function() {
            var t3 = [].slice;
            e3.extend({ arraysAreEqual: function(t4, e4) {
              var n2, i3, o2, r2;
              if (t4 == null && (t4 = []), e4 == null && (e4 = []), t4.length !== e4.length)
                return false;
              for (i3 = n2 = 0, o2 = t4.length; o2 > n2; i3 = ++n2)
                if (r2 = t4[i3], r2 !== e4[i3])
                  return false;
              return true;
            }, arrayStartsWith: function(t4, n2) {
              return t4 == null && (t4 = []), n2 == null && (n2 = []), e3.arraysAreEqual(t4.slice(0, n2.length), n2);
            }, spliceArray: function() {
              var e4, n2, i3;
              return n2 = arguments[0], e4 = 2 <= arguments.length ? t3.call(arguments, 1) : [], i3 = n2.slice(0), i3.splice.apply(i3, e4), i3;
            }, summarizeArrayChange: function(t4, e4) {
              var n2, i3, o2, r2, s4, a4, u2, c2, l2, h5, p;
              for (t4 == null && (t4 = []), e4 == null && (e4 = []), n2 = [], h5 = [], o2 = /* @__PURE__ */ new Set(), r2 = 0, u2 = t4.length; u2 > r2; r2++)
                p = t4[r2], o2.add(p);
              for (i3 = /* @__PURE__ */ new Set(), s4 = 0, c2 = e4.length; c2 > s4; s4++)
                p = e4[s4], i3.add(p), o2.has(p) || n2.push(p);
              for (a4 = 0, l2 = t4.length; l2 > a4; a4++)
                p = t4[a4], i3.has(p) || h5.push(p);
              return { added: n2, removed: h5 };
            } });
          }.call(this), function() {
            var t3, n2, i3, o2;
            t3 = null, n2 = null, o2 = null, i3 = null, e3.extend({ getAllAttributeNames: function() {
              return t3 != null ? t3 : t3 = e3.getTextAttributeNames().concat(e3.getBlockAttributeNames());
            }, getBlockConfig: function(t4) {
              return e3.config.blockAttributes[t4];
            }, getBlockAttributeNames: function() {
              return n2 != null ? n2 : n2 = Object.keys(e3.config.blockAttributes);
            }, getTextConfig: function(t4) {
              return e3.config.textAttributes[t4];
            }, getTextAttributeNames: function() {
              return o2 != null ? o2 : o2 = Object.keys(e3.config.textAttributes);
            }, getListAttributeNames: function() {
              var t4, n3;
              return i3 != null ? i3 : i3 = function() {
                var i4, o3;
                i4 = e3.config.blockAttributes, o3 = [];
                for (t4 in i4)
                  n3 = i4[t4].listAttribute, n3 != null && o3.push(n3);
                return o3;
              }();
            } });
          }.call(this), function() {
            var t3, n2, i3, o2, r2, s4 = [].indexOf || function(t4) {
              for (var e4 = 0, n3 = this.length; n3 > e4; e4++)
                if (e4 in this && this[e4] === t4)
                  return e4;
              return -1;
            };
            t3 = document.documentElement, n2 = (i3 = (o2 = (r2 = t3.matchesSelector) != null ? r2 : t3.webkitMatchesSelector) != null ? o2 : t3.msMatchesSelector) != null ? i3 : t3.mozMatchesSelector, e3.extend({ handleEvent: function(n3, i4) {
              var o3, r3, s5, a4, u2, c2, l2, h5, p, d3, f, g;
              return h5 = i4 != null ? i4 : {}, c2 = h5.onElement, u2 = h5.matchingSelector, g = h5.withCallback, a4 = h5.inPhase, l2 = h5.preventDefault, d3 = h5.times, r3 = c2 != null ? c2 : t3, p = u2, o3 = g, f = a4 === "capturing", s5 = function(t4) {
                var n4;
                return d3 != null && --d3 === 0 && s5.destroy(), n4 = e3.findClosestElementFromNode(t4.target, { matchingSelector: p }), n4 != null && (g != null && g.call(n4, t4, n4), l2) ? t4.preventDefault() : void 0;
              }, s5.destroy = function() {
                return r3.removeEventListener(n3, s5, f);
              }, r3.addEventListener(n3, s5, f), s5;
            }, handleEventOnce: function(t4, n3) {
              return n3 == null && (n3 = {}), n3.times = 1, e3.handleEvent(t4, n3);
            }, triggerEvent: function(n3, i4) {
              var o3, r3, s5, a4, u2, c2, l2;
              return l2 = i4 != null ? i4 : {}, c2 = l2.onElement, r3 = l2.bubbles, s5 = l2.cancelable, o3 = l2.attributes, a4 = c2 != null ? c2 : t3, r3 = r3 !== false, s5 = s5 !== false, u2 = document.createEvent("Events"), u2.initEvent(n3, r3, s5), o3 != null && e3.extend.call(u2, o3), a4.dispatchEvent(u2);
            }, elementMatchesSelector: function(t4, e4) {
              return (t4 != null ? t4.nodeType : void 0) === 1 ? n2.call(t4, e4) : void 0;
            }, findClosestElementFromNode: function(t4, n3) {
              var i4, o3, r3;
              for (o3 = n3 != null ? n3 : {}, i4 = o3.matchingSelector, r3 = o3.untilNode; t4 != null && t4.nodeType !== Node.ELEMENT_NODE; )
                t4 = t4.parentNode;
              if (t4 != null) {
                if (i4 == null)
                  return t4;
                if (t4.closest && r3 == null)
                  return t4.closest(i4);
                for (; t4 && t4 !== r3; ) {
                  if (e3.elementMatchesSelector(t4, i4))
                    return t4;
                  t4 = t4.parentNode;
                }
              }
            }, findInnerElement: function(t4) {
              for (; t4 != null ? t4.firstElementChild : void 0; )
                t4 = t4.firstElementChild;
              return t4;
            }, innerElementIsActive: function(t4) {
              return document.activeElement !== t4 && e3.elementContainsNode(t4, document.activeElement);
            }, elementContainsNode: function(t4, e4) {
              if (t4 && e4)
                for (; e4; ) {
                  if (e4 === t4)
                    return true;
                  e4 = e4.parentNode;
                }
            }, findNodeFromContainerAndOffset: function(t4, e4) {
              var n3;
              if (t4)
                return t4.nodeType === Node.TEXT_NODE ? t4 : e4 === 0 ? (n3 = t4.firstChild) != null ? n3 : t4 : t4.childNodes.item(e4 - 1);
            }, findElementFromContainerAndOffset: function(t4, n3) {
              var i4;
              return i4 = e3.findNodeFromContainerAndOffset(t4, n3), e3.findClosestElementFromNode(i4);
            }, findChildIndexOfNode: function(t4) {
              var e4;
              if (t4 != null ? t4.parentNode : void 0) {
                for (e4 = 0; t4 = t4.previousSibling; )
                  e4++;
                return e4;
              }
            }, removeNode: function(t4) {
              var e4;
              return t4 != null && (e4 = t4.parentNode) != null ? e4.removeChild(t4) : void 0;
            }, walkTree: function(t4, e4) {
              var n3, i4, o3, r3, s5;
              return o3 = e4 != null ? e4 : {}, i4 = o3.onlyNodesOfType, r3 = o3.usingFilter, n3 = o3.expandEntityReferences, s5 = function() {
                switch (i4) {
                  case "element":
                    return NodeFilter.SHOW_ELEMENT;
                  case "text":
                    return NodeFilter.SHOW_TEXT;
                  case "comment":
                    return NodeFilter.SHOW_COMMENT;
                  default:
                    return NodeFilter.SHOW_ALL;
                }
              }(), document.createTreeWalker(t4, s5, r3 != null ? r3 : null, n3 === true);
            }, tagName: function(t4) {
              var e4;
              return t4 != null && (e4 = t4.tagName) != null ? e4.toLowerCase() : void 0;
            }, makeElement: function(t4, e4) {
              var n3, i4, o3, r3, s5, a4, u2, c2, l2, h5, p, d3, f, g;
              if (e4 == null && (e4 = {}), typeof t4 == "object" ? (e4 = t4, t4 = e4.tagName) : e4 = { attributes: e4 }, o3 = document.createElement(t4), e4.editable != null && (e4.attributes == null && (e4.attributes = {}), e4.attributes.contenteditable = e4.editable), e4.attributes) {
                l2 = e4.attributes;
                for (a4 in l2)
                  g = l2[a4], o3.setAttribute(a4, g);
              }
              if (e4.style) {
                h5 = e4.style;
                for (a4 in h5)
                  g = h5[a4], o3.style[a4] = g;
              }
              if (e4.data) {
                p = e4.data;
                for (a4 in p)
                  g = p[a4], o3.dataset[a4] = g;
              }
              if (e4.className)
                for (d3 = e4.className.split(" "), r3 = 0, u2 = d3.length; u2 > r3; r3++)
                  i4 = d3[r3], o3.classList.add(i4);
              if (e4.textContent && (o3.textContent = e4.textContent), e4.childNodes)
                for (f = [].concat(e4.childNodes), s5 = 0, c2 = f.length; c2 > s5; s5++)
                  n3 = f[s5], o3.appendChild(n3);
              return o3;
            }, getBlockTagNames: function() {
              var t4, n3;
              return e3.blockTagNames != null ? e3.blockTagNames : e3.blockTagNames = function() {
                var i4, o3;
                i4 = e3.config.blockAttributes, o3 = [];
                for (t4 in i4)
                  n3 = i4[t4].tagName, n3 && o3.push(n3);
                return o3;
              }();
            }, nodeIsBlockContainer: function(t4) {
              return e3.nodeIsBlockStartComment(t4 != null ? t4.firstChild : void 0);
            }, nodeProbablyIsBlockContainer: function(t4) {
              var n3, i4;
              return n3 = e3.tagName(t4), s4.call(e3.getBlockTagNames(), n3) >= 0 && (i4 = e3.tagName(t4.firstChild), s4.call(e3.getBlockTagNames(), i4) < 0);
            }, nodeIsBlockStart: function(t4, n3) {
              var i4;
              return i4 = (n3 != null ? n3 : { strict: true }).strict, i4 ? e3.nodeIsBlockStartComment(t4) : e3.nodeIsBlockStartComment(t4) || !e3.nodeIsBlockStartComment(t4.firstChild) && e3.nodeProbablyIsBlockContainer(t4);
            }, nodeIsBlockStartComment: function(t4) {
              return e3.nodeIsCommentNode(t4) && (t4 != null ? t4.data : void 0) === "block";
            }, nodeIsCommentNode: function(t4) {
              return (t4 != null ? t4.nodeType : void 0) === Node.COMMENT_NODE;
            }, nodeIsCursorTarget: function(t4, n3) {
              var i4;
              return i4 = (n3 != null ? n3 : {}).name, t4 ? e3.nodeIsTextNode(t4) ? t4.data === e3.ZERO_WIDTH_SPACE ? i4 ? t4.parentNode.dataset.trixCursorTarget === i4 : true : void 0 : e3.nodeIsCursorTarget(t4.firstChild) : void 0;
            }, nodeIsAttachmentElement: function(t4) {
              return e3.elementMatchesSelector(t4, e3.AttachmentView.attachmentSelector);
            }, nodeIsEmptyTextNode: function(t4) {
              return e3.nodeIsTextNode(t4) && (t4 != null ? t4.data : void 0) === "";
            }, nodeIsTextNode: function(t4) {
              return (t4 != null ? t4.nodeType : void 0) === Node.TEXT_NODE;
            } });
          }.call(this), function() {
            var t3, n2, i3, o2, r2;
            t3 = e3.copyObject, o2 = e3.objectsAreEqual, e3.extend({ normalizeRange: i3 = function(t4) {
              var e4;
              if (t4 != null)
                return Array.isArray(t4) || (t4 = [t4, t4]), [n2(t4[0]), n2((e4 = t4[1]) != null ? e4 : t4[0])];
            }, rangeIsCollapsed: function(t4) {
              var e4, n3, o3;
              if (t4 != null)
                return n3 = i3(t4), o3 = n3[0], e4 = n3[1], r2(o3, e4);
            }, rangesAreEqual: function(t4, e4) {
              var n3, o3, s4, a4, u2, c2;
              if (t4 != null && e4 != null)
                return s4 = i3(t4), o3 = s4[0], n3 = s4[1], a4 = i3(e4), c2 = a4[0], u2 = a4[1], r2(o3, c2) && r2(n3, u2);
            } }), n2 = function(e4) {
              return typeof e4 == "number" ? e4 : t3(e4);
            }, r2 = function(t4, e4) {
              return typeof t4 == "number" ? t4 === e4 : o2(t4, e4);
            };
          }.call(this), function() {
            var t3, n2, i3, o2, r2, s4, a4;
            e3.registerElement = function(t4, e4) {
              var n3, i4;
              return e4 == null && (e4 = {}), t4 = t4.toLowerCase(), e4 = a4(e4), i4 = s4(e4), (n3 = i4.defaultCSS) && (delete i4.defaultCSS, o2(n3, t4)), r2(t4, i4);
            }, o2 = function(t4, e4) {
              var n3;
              return n3 = i3(e4), n3.textContent = t4.replace(/%t/g, e4);
            }, i3 = function(e4) {
              var n3, i4;
              return n3 = document.createElement("style"), n3.setAttribute("type", "text/css"), n3.setAttribute("data-tag-name", e4.toLowerCase()), (i4 = t3()) && n3.setAttribute("nonce", i4), document.head.insertBefore(n3, document.head.firstChild), n3;
            }, t3 = function() {
              var t4;
              return (t4 = n2("trix-csp-nonce") || n2("csp-nonce")) ? t4.getAttribute("content") : void 0;
            }, n2 = function(t4) {
              return document.head.querySelector("meta[name=" + t4 + "]");
            }, s4 = function(t4) {
              var e4, n3, i4;
              n3 = {};
              for (e4 in t4)
                i4 = t4[e4], n3[e4] = typeof i4 == "function" ? { value: i4 } : i4;
              return n3;
            }, a4 = function() {
              var t4;
              return t4 = function(t5) {
                var e4, n3, i4, o3, r3;
                for (e4 = {}, r3 = ["initialize", "connect", "disconnect"], n3 = 0, o3 = r3.length; o3 > n3; n3++)
                  i4 = r3[n3], e4[i4] = t5[i4], delete t5[i4];
                return e4;
              }, window.customElements ? function(e4) {
                var n3, i4, o3, r3, s5;
                return s5 = t4(e4), o3 = s5.initialize, n3 = s5.connect, i4 = s5.disconnect, o3 && (r3 = n3, n3 = function() {
                  return this.initialized || (this.initialized = true, o3.call(this)), r3 != null ? r3.call(this) : void 0;
                }), n3 && (e4.connectedCallback = n3), i4 && (e4.disconnectedCallback = i4), e4;
              } : function(e4) {
                var n3, i4, o3, r3;
                return r3 = t4(e4), o3 = r3.initialize, n3 = r3.connect, i4 = r3.disconnect, o3 && (e4.createdCallback = o3), n3 && (e4.attachedCallback = n3), i4 && (e4.detachedCallback = i4), e4;
              };
            }(), r2 = function() {
              return window.customElements ? function(t4, e4) {
                var n3;
                return n3 = function() {
                  return typeof Reflect == "object" ? Reflect.construct(HTMLElement, [], n3) : HTMLElement.apply(this);
                }, Object.setPrototypeOf(n3.prototype, HTMLElement.prototype), Object.setPrototypeOf(n3, HTMLElement), Object.defineProperties(n3.prototype, e4), window.customElements.define(t4, n3), n3;
              } : function(t4, e4) {
                var n3, i4;
                return i4 = Object.create(HTMLElement.prototype, e4), n3 = document.registerElement(t4, { prototype: i4 }), Object.defineProperty(i4, "constructor", { value: n3 }), n3;
              };
            }();
          }.call(this), function() {
            var t3, n2;
            e3.extend({ getDOMSelection: function() {
              var t4;
              return t4 = window.getSelection(), t4.rangeCount > 0 ? t4 : void 0;
            }, getDOMRange: function() {
              var n3, i3;
              return (n3 = (i3 = e3.getDOMSelection()) != null ? i3.getRangeAt(0) : void 0) && !t3(n3) ? n3 : void 0;
            }, setDOMRange: function(t4) {
              var n3;
              return n3 = window.getSelection(), n3.removeAllRanges(), n3.addRange(t4), e3.selectionChangeObserver.update();
            } }), t3 = function(t4) {
              return n2(t4.startContainer) || n2(t4.endContainer);
            }, n2 = function(t4) {
              return !Object.getPrototypeOf(t4);
            };
          }.call(this), function() {
            var t3;
            t3 = { "application/x-trix-feature-detection": "test" }, e3.extend({ dataTransferIsPlainText: function(t4) {
              var e4, n2, i3;
              return i3 = t4.getData("text/plain"), n2 = t4.getData("text/html"), i3 && n2 ? (e4 = new DOMParser().parseFromString(n2, "text/html").body, e4.textContent === i3 ? !e4.querySelector("*") : void 0) : i3 != null ? i3.length : void 0;
            }, dataTransferIsWritable: function(e4) {
              var n2, i3;
              if ((e4 != null ? e4.setData : void 0) != null) {
                for (n2 in t3)
                  if (i3 = t3[n2], !function() {
                    try {
                      return e4.setData(n2, i3), e4.getData(n2) === i3;
                    } catch (t4) {
                    }
                  }())
                    return;
                return true;
              }
            }, keyEventIsKeyboardCommand: function() {
              return /Mac|^iP/.test(navigator.platform) ? function(t4) {
                return t4.metaKey;
              } : function(t4) {
                return t4.ctrlKey;
              };
            }() });
          }.call(this), function() {
            e3.extend({ RTL_PATTERN: /[\u05BE\u05C0\u05C3\u05D0-\u05EA\u05F0-\u05F4\u061B\u061F\u0621-\u063A\u0640-\u064A\u066D\u0671-\u06B7\u06BA-\u06BE\u06C0-\u06CE\u06D0-\u06D5\u06E5\u06E6\u200F\u202B\u202E\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE72\uFE74\uFE76-\uFEFC]/, getDirection: function() {
              var t3, n2, i3, o2;
              return n2 = e3.makeElement("input", { dir: "auto", name: "x", dirName: "x.dir" }), t3 = e3.makeElement("form"), t3.appendChild(n2), i3 = function() {
                try {
                  return new FormData(t3).has(n2.dirName);
                } catch (e4) {
                }
              }(), o2 = function() {
                try {
                  return n2.matches(":dir(ltr),:dir(rtl)");
                } catch (t4) {
                }
              }(), i3 ? function(e4) {
                return n2.value = e4, new FormData(t3).get(n2.dirName);
              } : o2 ? function(t4) {
                return n2.value = t4, n2.matches(":dir(rtl)") ? "rtl" : "ltr";
              } : function(t4) {
                var n3;
                return n3 = t4.trim().charAt(0), e3.RTL_PATTERN.test(n3) ? "rtl" : "ltr";
              };
            }() });
          }.call(this), function() {
          }.call(this), function() {
            var t3, n2 = function(t4, e4) {
              function n3() {
                this.constructor = t4;
              }
              for (var o2 in e4)
                i3.call(e4, o2) && (t4[o2] = e4[o2]);
              return n3.prototype = e4.prototype, t4.prototype = new n3(), t4.__super__ = e4.prototype, t4;
            }, i3 = {}.hasOwnProperty;
            t3 = e3.arraysAreEqual, e3.Hash = function(i4) {
              function o2(t4) {
                t4 == null && (t4 = {}), this.values = s4(t4), o2.__super__.constructor.apply(this, arguments);
              }
              var r2, s4, a4, u2, c2;
              return n2(o2, i4), o2.fromCommonAttributesOfObjects = function(t4) {
                var e4, n3, i5, o3, s5, a5;
                if (t4 == null && (t4 = []), !t4.length)
                  return new this();
                for (e4 = r2(t4[0]), i5 = e4.getKeys(), a5 = t4.slice(1), n3 = 0, o3 = a5.length; o3 > n3; n3++)
                  s5 = a5[n3], i5 = e4.getKeysCommonToHash(r2(s5)), e4 = e4.slice(i5);
                return e4;
              }, o2.box = function(t4) {
                return r2(t4);
              }, o2.prototype.add = function(t4, e4) {
                return this.merge(u2(t4, e4));
              }, o2.prototype.remove = function(t4) {
                return new e3.Hash(s4(this.values, t4));
              }, o2.prototype.get = function(t4) {
                return this.values[t4];
              }, o2.prototype.has = function(t4) {
                return t4 in this.values;
              }, o2.prototype.merge = function(t4) {
                return new e3.Hash(a4(this.values, c2(t4)));
              }, o2.prototype.slice = function(t4) {
                var n3, i5, o3, r3;
                for (r3 = {}, n3 = 0, o3 = t4.length; o3 > n3; n3++)
                  i5 = t4[n3], this.has(i5) && (r3[i5] = this.values[i5]);
                return new e3.Hash(r3);
              }, o2.prototype.getKeys = function() {
                return Object.keys(this.values);
              }, o2.prototype.getKeysCommonToHash = function(t4) {
                var e4, n3, i5, o3, s5;
                for (t4 = r2(t4), o3 = this.getKeys(), s5 = [], e4 = 0, i5 = o3.length; i5 > e4; e4++)
                  n3 = o3[e4], this.values[n3] === t4.values[n3] && s5.push(n3);
                return s5;
              }, o2.prototype.isEqualTo = function(e4) {
                return t3(this.toArray(), r2(e4).toArray());
              }, o2.prototype.isEmpty = function() {
                return this.getKeys().length === 0;
              }, o2.prototype.toArray = function() {
                var t4, e4, n3;
                return (this.array != null ? this.array : this.array = function() {
                  var i5;
                  e4 = [], i5 = this.values;
                  for (t4 in i5)
                    n3 = i5[t4], e4.push(t4, n3);
                  return e4;
                }.call(this)).slice(0);
              }, o2.prototype.toObject = function() {
                return s4(this.values);
              }, o2.prototype.toJSON = function() {
                return this.toObject();
              }, o2.prototype.contentsForInspection = function() {
                return { values: JSON.stringify(this.values) };
              }, u2 = function(t4, e4) {
                var n3;
                return n3 = {}, n3[t4] = e4, n3;
              }, a4 = function(t4, e4) {
                var n3, i5, o3;
                i5 = s4(t4);
                for (n3 in e4)
                  o3 = e4[n3], i5[n3] = o3;
                return i5;
              }, s4 = function(t4, e4) {
                var n3, i5, o3, r3, s5;
                for (r3 = {}, s5 = Object.keys(t4).sort(), n3 = 0, o3 = s5.length; o3 > n3; n3++)
                  i5 = s5[n3], i5 !== e4 && (r3[i5] = t4[i5]);
                return r3;
              }, r2 = function(t4) {
                return t4 instanceof e3.Hash ? t4 : new e3.Hash(t4);
              }, c2 = function(t4) {
                return t4 instanceof e3.Hash ? t4.values : t4;
              }, o2;
            }(e3.Object);
          }.call(this), function() {
            e3.ObjectGroup = function() {
              function t3(t4, e4) {
                var n2, i3;
                this.objects = t4 != null ? t4 : [], i3 = e4.depth, n2 = e4.asTree, n2 && (this.depth = i3, this.objects = this.constructor.groupObjects(this.objects, { asTree: n2, depth: this.depth + 1 }));
              }
              return t3.groupObjects = function(t4, e4) {
                var n2, i3, o2, r2, s4, a4, u2, c2, l2;
                for (t4 == null && (t4 = []), l2 = e4 != null ? e4 : {}, o2 = l2.depth, n2 = l2.asTree, n2 && o2 == null && (o2 = 0), c2 = [], s4 = 0, a4 = t4.length; a4 > s4; s4++) {
                  if (u2 = t4[s4], r2) {
                    if ((typeof u2.canBeGrouped == "function" ? u2.canBeGrouped(o2) : void 0) && (typeof (i3 = r2[r2.length - 1]).canBeGroupedWith == "function" ? i3.canBeGroupedWith(u2, o2) : void 0)) {
                      r2.push(u2);
                      continue;
                    }
                    c2.push(new this(r2, { depth: o2, asTree: n2 })), r2 = null;
                  }
                  (typeof u2.canBeGrouped == "function" ? u2.canBeGrouped(o2) : void 0) ? r2 = [u2] : c2.push(u2);
                }
                return r2 && c2.push(new this(r2, { depth: o2, asTree: n2 })), c2;
              }, t3.prototype.getObjects = function() {
                return this.objects;
              }, t3.prototype.getDepth = function() {
                return this.depth;
              }, t3.prototype.getCacheKey = function() {
                var t4, e4, n2, i3, o2;
                for (e4 = ["objectGroup"], o2 = this.getObjects(), t4 = 0, n2 = o2.length; n2 > t4; t4++)
                  i3 = o2[t4], e4.push(i3.getCacheKey());
                return e4.join("/");
              }, t3;
            }();
          }.call(this), function() {
            var t3 = function(t4, e4) {
              function i3() {
                this.constructor = t4;
              }
              for (var o2 in e4)
                n2.call(e4, o2) && (t4[o2] = e4[o2]);
              return i3.prototype = e4.prototype, t4.prototype = new i3(), t4.__super__ = e4.prototype, t4;
            }, n2 = {}.hasOwnProperty;
            e3.ObjectMap = function(e4) {
              function n3(t4) {
                var e5, n4, i3, o2, r2;
                for (t4 == null && (t4 = []), this.objects = {}, i3 = 0, o2 = t4.length; o2 > i3; i3++)
                  r2 = t4[i3], n4 = JSON.stringify(r2), (e5 = this.objects)[n4] == null && (e5[n4] = r2);
              }
              return t3(n3, e4), n3.prototype.find = function(t4) {
                var e5;
                return e5 = JSON.stringify(t4), this.objects[e5];
              }, n3;
            }(e3.BasicObject);
          }.call(this), function() {
            e3.ElementStore = function() {
              function t3(t4) {
                this.reset(t4);
              }
              var e4;
              return t3.prototype.add = function(t4) {
                var n2;
                return n2 = e4(t4), this.elements[n2] = t4;
              }, t3.prototype.remove = function(t4) {
                var n2, i3;
                return n2 = e4(t4), (i3 = this.elements[n2]) ? (delete this.elements[n2], i3) : void 0;
              }, t3.prototype.reset = function(t4) {
                var e5, n2, i3;
                for (t4 == null && (t4 = []), this.elements = {}, n2 = 0, i3 = t4.length; i3 > n2; n2++)
                  e5 = t4[n2], this.add(e5);
                return t4;
              }, e4 = function(t4) {
                return t4.dataset.trixStoreKey;
              }, t3;
            }();
          }.call(this), function() {
          }.call(this), function() {
            var t3 = function(t4, e4) {
              function i3() {
                this.constructor = t4;
              }
              for (var o2 in e4)
                n2.call(e4, o2) && (t4[o2] = e4[o2]);
              return i3.prototype = e4.prototype, t4.prototype = new i3(), t4.__super__ = e4.prototype, t4;
            }, n2 = {}.hasOwnProperty;
            e3.Operation = function(e4) {
              function n3() {
                return n3.__super__.constructor.apply(this, arguments);
              }
              return t3(n3, e4), n3.prototype.isPerforming = function() {
                return this.performing === true;
              }, n3.prototype.hasPerformed = function() {
                return this.performed === true;
              }, n3.prototype.hasSucceeded = function() {
                return this.performed && this.succeeded;
              }, n3.prototype.hasFailed = function() {
                return this.performed && !this.succeeded;
              }, n3.prototype.getPromise = function() {
                return this.promise != null ? this.promise : this.promise = new Promise(function(t4) {
                  return function(e5, n4) {
                    return t4.performing = true, t4.perform(function(i3, o2) {
                      return t4.succeeded = i3, t4.performing = false, t4.performed = true, t4.succeeded ? e5(o2) : n4(o2);
                    });
                  };
                }(this));
              }, n3.prototype.perform = function(t4) {
                return t4(false);
              }, n3.prototype.release = function() {
                var t4;
                return (t4 = this.promise) != null && typeof t4.cancel == "function" && t4.cancel(), this.promise = null, this.performing = null, this.performed = null, this.succeeded = null;
              }, n3.proxyMethod("getPromise().then"), n3.proxyMethod("getPromise().catch"), n3;
            }(e3.BasicObject);
          }.call(this), function() {
            var t3, n2, i3, o2, r2, s4 = function(t4, e4) {
              function n3() {
                this.constructor = t4;
              }
              for (var i4 in e4)
                a4.call(e4, i4) && (t4[i4] = e4[i4]);
              return n3.prototype = e4.prototype, t4.prototype = new n3(), t4.__super__ = e4.prototype, t4;
            }, a4 = {}.hasOwnProperty;
            e3.UTF16String = function(t4) {
              function e4(t5, e5) {
                this.ucs2String = t5, this.codepoints = e5, this.length = this.codepoints.length, this.ucs2Length = this.ucs2String.length;
              }
              return s4(e4, t4), e4.box = function(t5) {
                return t5 == null && (t5 = ""), t5 instanceof this ? t5 : this.fromUCS2String(t5 != null ? t5.toString() : void 0);
              }, e4.fromUCS2String = function(t5) {
                return new this(t5, o2(t5));
              }, e4.fromCodepoints = function(t5) {
                return new this(r2(t5), t5);
              }, e4.prototype.offsetToUCS2Offset = function(t5) {
                return r2(this.codepoints.slice(0, Math.max(0, t5))).length;
              }, e4.prototype.offsetFromUCS2Offset = function(t5) {
                return o2(this.ucs2String.slice(0, Math.max(0, t5))).length;
              }, e4.prototype.slice = function() {
                var t5;
                return this.constructor.fromCodepoints((t5 = this.codepoints).slice.apply(t5, arguments));
              }, e4.prototype.charAt = function(t5) {
                return this.slice(t5, t5 + 1);
              }, e4.prototype.isEqualTo = function(t5) {
                return this.constructor.box(t5).ucs2String === this.ucs2String;
              }, e4.prototype.toJSON = function() {
                return this.ucs2String;
              }, e4.prototype.getCacheKey = function() {
                return this.ucs2String;
              }, e4.prototype.toString = function() {
                return this.ucs2String;
              }, e4;
            }(e3.BasicObject), t3 = (typeof Array.from == "function" ? Array.from("\u{1F47C}").length : void 0) === 1, n2 = (typeof " ".codePointAt == "function" ? " ".codePointAt(0) : void 0) != null, i3 = (typeof String.fromCodePoint == "function" ? String.fromCodePoint(32, 128124) : void 0) === " \u{1F47C}", o2 = t3 && n2 ? function(t4) {
              return Array.from(t4).map(function(t5) {
                return t5.codePointAt(0);
              });
            } : function(t4) {
              var e4, n3, i4, o3, r3;
              for (o3 = [], e4 = 0, i4 = t4.length; i4 > e4; )
                r3 = t4.charCodeAt(e4++), r3 >= 55296 && 56319 >= r3 && i4 > e4 && (n3 = t4.charCodeAt(e4++), (64512 & n3) === 56320 ? r3 = ((1023 & r3) << 10) + (1023 & n3) + 65536 : e4--), o3.push(r3);
              return o3;
            }, r2 = i3 ? function(t4) {
              return String.fromCodePoint.apply(String, t4);
            } : function(t4) {
              var e4, n3, i4;
              return e4 = function() {
                var e5, o3, r3;
                for (r3 = [], e5 = 0, o3 = t4.length; o3 > e5; e5++)
                  i4 = t4[e5], n3 = "", i4 > 65535 && (i4 -= 65536, n3 += String.fromCharCode(i4 >>> 10 & 1023 | 55296), i4 = 56320 | 1023 & i4), r3.push(n3 + String.fromCharCode(i4));
                return r3;
              }(), e4.join("");
            };
          }.call(this), function() {
          }.call(this), function() {
          }.call(this), function() {
            e3.config.lang = { attachFiles: "Attach Files", bold: "Bold", bullets: "Bullets", "byte": "Byte", bytes: "Bytes", captionPlaceholder: "Add a caption\u2026", code: "Code", heading1: "Heading", indent: "Increase Level", italic: "Italic", link: "Link", numbers: "Numbers", outdent: "Decrease Level", quote: "Quote", redo: "Redo", remove: "Remove", strike: "Strikethrough", undo: "Undo", unlink: "Unlink", url: "URL", urlPlaceholder: "Enter a URL\u2026", GB: "GB", KB: "KB", MB: "MB", PB: "PB", TB: "TB" };
          }.call(this), function() {
            e3.config.css = { attachment: "attachment", attachmentCaption: "attachment__caption", attachmentCaptionEditor: "attachment__caption-editor", attachmentMetadata: "attachment__metadata", attachmentMetadataContainer: "attachment__metadata-container", attachmentName: "attachment__name", attachmentProgress: "attachment__progress", attachmentSize: "attachment__size", attachmentToolbar: "attachment__toolbar", attachmentGallery: "attachment-gallery" };
          }.call(this), function() {
            var t3;
            e3.config.blockAttributes = t3 = { "default": { tagName: "div", parse: false }, quote: { tagName: "blockquote", nestable: true }, heading1: { tagName: "h1", terminal: true, breakOnReturn: true, group: false }, code: { tagName: "pre", terminal: true, text: { plaintext: true } }, bulletList: { tagName: "ul", parse: false }, bullet: { tagName: "li", listAttribute: "bulletList", group: false, nestable: true, test: function(n2) {
              return e3.tagName(n2.parentNode) === t3[this.listAttribute].tagName;
            } }, numberList: { tagName: "ol", parse: false }, number: { tagName: "li", listAttribute: "numberList", group: false, nestable: true, test: function(n2) {
              return e3.tagName(n2.parentNode) === t3[this.listAttribute].tagName;
            } }, attachmentGallery: { tagName: "div", exclusive: true, terminal: true, parse: false, group: false } };
          }.call(this), function() {
            var t3, n2;
            t3 = e3.config.lang, n2 = [t3.bytes, t3.KB, t3.MB, t3.GB, t3.TB, t3.PB], e3.config.fileSize = { prefix: "IEC", precision: 2, formatter: function(e4) {
              var i3, o2, r2, s4, a4;
              switch (e4) {
                case 0:
                  return "0 " + t3.bytes;
                case 1:
                  return "1 " + t3.byte;
                default:
                  return i3 = function() {
                    switch (this.prefix) {
                      case "SI":
                        return 1e3;
                      case "IEC":
                        return 1024;
                    }
                  }.call(this), o2 = Math.floor(Math.log(e4) / Math.log(i3)), r2 = e4 / Math.pow(i3, o2), s4 = r2.toFixed(this.precision), a4 = s4.replace(/0*$/, "").replace(/\.$/, ""), a4 + " " + n2[o2];
              }
            } };
          }.call(this), function() {
            e3.config.textAttributes = { bold: { tagName: "strong", inheritable: true, parser: function(t3) {
              var e4;
              return e4 = window.getComputedStyle(t3), e4.fontWeight === "bold" || e4.fontWeight >= 600;
            } }, italic: { tagName: "em", inheritable: true, parser: function(t3) {
              var e4;
              return e4 = window.getComputedStyle(t3), e4.fontStyle === "italic";
            } }, href: { groupTagName: "a", parser: function(t3) {
              var n2, i3, o2;
              return n2 = e3.AttachmentView.attachmentSelector, o2 = "a:not(" + n2 + ")", (i3 = e3.findClosestElementFromNode(t3, { matchingSelector: o2 })) ? i3.getAttribute("href") : void 0;
            } }, strike: { tagName: "del", inheritable: true }, frozen: { style: { backgroundColor: "highlight" } } };
          }.call(this), function() {
            var t3, n2, i3, o2, r2;
            r2 = "[data-trix-serialize=false]", o2 = ["contenteditable", "data-trix-id", "data-trix-store-key", "data-trix-mutable", "data-trix-placeholder", "tabindex"], n2 = "data-trix-serialized-attributes", i3 = "[" + n2 + "]", t3 = new RegExp("<!--block-->", "g"), e3.extend({ serializers: { "application/json": function(t4) {
              var n3;
              if (t4 instanceof e3.Document)
                n3 = t4;
              else {
                if (!(t4 instanceof HTMLElement))
                  throw new Error("unserializable object");
                n3 = e3.Document.fromHTML(t4.innerHTML);
              }
              return n3.toSerializableDocument().toJSONString();
            }, "text/html": function(s4) {
              var a4, u2, c2, l2, h5, p, d3, f, g, m3, v, y3, b2, A, C, x2, w2;
              if (s4 instanceof e3.Document)
                l2 = e3.DocumentView.render(s4);
              else {
                if (!(s4 instanceof HTMLElement))
                  throw new Error("unserializable object");
                l2 = s4.cloneNode(true);
              }
              for (A = l2.querySelectorAll(r2), h5 = 0, g = A.length; g > h5; h5++)
                c2 = A[h5], e3.removeNode(c2);
              for (p = 0, m3 = o2.length; m3 > p; p++)
                for (a4 = o2[p], C = l2.querySelectorAll("[" + a4 + "]"), d3 = 0, v = C.length; v > d3; d3++)
                  c2 = C[d3], c2.removeAttribute(a4);
              for (x2 = l2.querySelectorAll(i3), f = 0, y3 = x2.length; y3 > f; f++) {
                c2 = x2[f];
                try {
                  u2 = JSON.parse(c2.getAttribute(n2)), c2.removeAttribute(n2);
                  for (b2 in u2)
                    w2 = u2[b2], c2.setAttribute(b2, w2);
                } catch (E2) {
                }
              }
              return l2.innerHTML.replace(t3, "");
            } }, deserializers: { "application/json": function(t4) {
              return e3.Document.fromJSONString(t4);
            }, "text/html": function(t4) {
              return e3.Document.fromHTML(t4);
            } }, serializeToContentType: function(t4, n3) {
              var i4;
              if (i4 = e3.serializers[n3])
                return i4(t4);
              throw new Error("unknown content type: " + n3);
            }, deserializeFromContentType: function(t4, n3) {
              var i4;
              if (i4 = e3.deserializers[n3])
                return i4(t4);
              throw new Error("unknown content type: " + n3);
            } });
          }.call(this), function() {
            var t3;
            t3 = e3.config.lang, e3.config.toolbar = { getDefaultHTML: function() {
              return '<div class="trix-button-row">\n  <span class="trix-button-group trix-button-group--text-tools" data-trix-button-group="text-tools">\n    <button type="button" class="trix-button trix-button--icon trix-button--icon-bold" data-trix-attribute="bold" data-trix-key="b" title="' + t3.bold + '" tabindex="-1">' + t3.bold + '</button>\n    <button type="button" class="trix-button trix-button--icon trix-button--icon-italic" data-trix-attribute="italic" data-trix-key="i" title="' + t3.italic + '" tabindex="-1">' + t3.italic + '</button>\n    <button type="button" class="trix-button trix-button--icon trix-button--icon-strike" data-trix-attribute="strike" title="' + t3.strike + '" tabindex="-1">' + t3.strike + '</button>\n    <button type="button" class="trix-button trix-button--icon trix-button--icon-link" data-trix-attribute="href" data-trix-action="link" data-trix-key="k" title="' + t3.link + '" tabindex="-1">' + t3.link + '</button>\n  </span>\n\n  <span class="trix-button-group trix-button-group--block-tools" data-trix-button-group="block-tools">\n    <button type="button" class="trix-button trix-button--icon trix-button--icon-heading-1" data-trix-attribute="heading1" title="' + t3.heading1 + '" tabindex="-1">' + t3.heading1 + '</button>\n    <button type="button" class="trix-button trix-button--icon trix-button--icon-quote" data-trix-attribute="quote" title="' + t3.quote + '" tabindex="-1">' + t3.quote + '</button>\n    <button type="button" class="trix-button trix-button--icon trix-button--icon-code" data-trix-attribute="code" title="' + t3.code + '" tabindex="-1">' + t3.code + '</button>\n    <button type="button" class="trix-button trix-button--icon trix-button--icon-bullet-list" data-trix-attribute="bullet" title="' + t3.bullets + '" tabindex="-1">' + t3.bullets + '</button>\n    <button type="button" class="trix-button trix-button--icon trix-button--icon-number-list" data-trix-attribute="number" title="' + t3.numbers + '" tabindex="-1">' + t3.numbers + '</button>\n    <button type="button" class="trix-button trix-button--icon trix-button--icon-decrease-nesting-level" data-trix-action="decreaseNestingLevel" title="' + t3.outdent + '" tabindex="-1">' + t3.outdent + '</button>\n    <button type="button" class="trix-button trix-button--icon trix-button--icon-increase-nesting-level" data-trix-action="increaseNestingLevel" title="' + t3.indent + '" tabindex="-1">' + t3.indent + '</button>\n  </span>\n\n  <span class="trix-button-group trix-button-group--file-tools" data-trix-button-group="file-tools">\n    <button type="button" class="trix-button trix-button--icon trix-button--icon-attach" data-trix-action="attachFiles" title="' + t3.attachFiles + '" tabindex="-1">' + t3.attachFiles + '</button>\n  </span>\n\n  <span class="trix-button-group-spacer"></span>\n\n  <span class="trix-button-group trix-button-group--history-tools" data-trix-button-group="history-tools">\n    <button type="button" class="trix-button trix-button--icon trix-button--icon-undo" data-trix-action="undo" data-trix-key="z" title="' + t3.undo + '" tabindex="-1">' + t3.undo + '</button>\n    <button type="button" class="trix-button trix-button--icon trix-button--icon-redo" data-trix-action="redo" data-trix-key="shift+z" title="' + t3.redo + '" tabindex="-1">' + t3.redo + '</button>\n  </span>\n</div>\n\n<div class="trix-dialogs" data-trix-dialogs>\n  <div class="trix-dialog trix-dialog--link" data-trix-dialog="href" data-trix-dialog-attribute="href">\n    <div class="trix-dialog__link-fields">\n      <input type="url" name="href" class="trix-input trix-input--dialog" placeholder="' + t3.urlPlaceholder + '" aria-label="' + t3.url + '" required data-trix-input>\n      <div class="trix-button-group">\n        <input type="button" class="trix-button trix-button--dialog" value="' + t3.link + '" data-trix-method="setAttribute">\n        <input type="button" class="trix-button trix-button--dialog" value="' + t3.unlink + '" data-trix-method="removeAttribute">\n      </div>\n    </div>\n  </div>\n</div>';
            } };
          }.call(this), function() {
            e3.config.undoInterval = 5e3;
          }.call(this), function() {
            e3.config.attachments = { preview: { presentation: "gallery", caption: { name: true, size: true } }, file: { caption: { size: true } } };
          }.call(this), function() {
            e3.config.keyNames = { 8: "backspace", 9: "tab", 13: "return", 27: "escape", 37: "left", 39: "right", 46: "delete", 68: "d", 72: "h", 79: "o" };
          }.call(this), function() {
            e3.config.input = { level2Enabled: true, getLevel: function() {
              return this.level2Enabled && e3.browser.supportsInputEvents ? 2 : 0;
            }, pickFiles: function(t3) {
              var n2;
              return n2 = e3.makeElement("input", { type: "file", multiple: true, hidden: true, id: this.fileInputId }), n2.addEventListener("change", function() {
                return t3(n2.files), e3.removeNode(n2);
              }), e3.removeNode(document.getElementById(this.fileInputId)), document.body.appendChild(n2), n2.click();
            }, fileInputId: "trix-file-input-" + Date.now().toString(16) };
          }.call(this), function() {
          }.call(this), function() {
            e3.registerElement("trix-toolbar", { defaultCSS: "%t {\n  display: block;\n}\n\n%t {\n  white-space: nowrap;\n}\n\n%t [data-trix-dialog] {\n  display: none;\n}\n\n%t [data-trix-dialog][data-trix-active] {\n  display: block;\n}\n\n%t [data-trix-dialog] [data-trix-validate]:invalid {\n  background-color: #ffdddd;\n}", initialize: function() {
              return this.innerHTML === "" ? this.innerHTML = e3.config.toolbar.getDefaultHTML() : void 0;
            } });
          }.call(this), function() {
            var t3 = function(t4, e4) {
              function i4() {
                this.constructor = t4;
              }
              for (var o2 in e4)
                n2.call(e4, o2) && (t4[o2] = e4[o2]);
              return i4.prototype = e4.prototype, t4.prototype = new i4(), t4.__super__ = e4.prototype, t4;
            }, n2 = {}.hasOwnProperty, i3 = [].indexOf || function(t4) {
              for (var e4 = 0, n3 = this.length; n3 > e4; e4++)
                if (e4 in this && this[e4] === t4)
                  return e4;
              return -1;
            };
            e3.ObjectView = function(n3) {
              function o2(t4, e4) {
                this.object = t4, this.options = e4 != null ? e4 : {}, this.childViews = [], this.rootView = this;
              }
              return t3(o2, n3), o2.prototype.getNodes = function() {
                var t4, e4, n4, i4, o3;
                for (this.nodes == null && (this.nodes = this.createNodes()), i4 = this.nodes, o3 = [], t4 = 0, e4 = i4.length; e4 > t4; t4++)
                  n4 = i4[t4], o3.push(n4.cloneNode(true));
                return o3;
              }, o2.prototype.invalidate = function() {
                var t4;
                return this.nodes = null, this.childViews = [], (t4 = this.parentView) != null ? t4.invalidate() : void 0;
              }, o2.prototype.invalidateViewForObject = function(t4) {
                var e4;
                return (e4 = this.findViewForObject(t4)) != null ? e4.invalidate() : void 0;
              }, o2.prototype.findOrCreateCachedChildView = function(t4, e4) {
                var n4;
                return (n4 = this.getCachedViewForObject(e4)) ? this.recordChildView(n4) : (n4 = this.createChildView.apply(this, arguments), this.cacheViewForObject(n4, e4)), n4;
              }, o2.prototype.createChildView = function(t4, n4, i4) {
                var o3;
                return i4 == null && (i4 = {}), n4 instanceof e3.ObjectGroup && (i4.viewClass = t4, t4 = e3.ObjectGroupView), o3 = new t4(n4, i4), this.recordChildView(o3);
              }, o2.prototype.recordChildView = function(t4) {
                return t4.parentView = this, t4.rootView = this.rootView, this.childViews.push(t4), t4;
              }, o2.prototype.getAllChildViews = function() {
                var t4, e4, n4, i4, o3;
                for (o3 = [], i4 = this.childViews, e4 = 0, n4 = i4.length; n4 > e4; e4++)
                  t4 = i4[e4], o3.push(t4), o3 = o3.concat(t4.getAllChildViews());
                return o3;
              }, o2.prototype.findElement = function() {
                return this.findElementForObject(this.object);
              }, o2.prototype.findElementForObject = function(t4) {
                var e4;
                return (e4 = t4 != null ? t4.id : void 0) ? this.rootView.element.querySelector("[data-trix-id='" + e4 + "']") : void 0;
              }, o2.prototype.findViewForObject = function(t4) {
                var e4, n4, i4, o3;
                for (i4 = this.getAllChildViews(), e4 = 0, n4 = i4.length; n4 > e4; e4++)
                  if (o3 = i4[e4], o3.object === t4)
                    return o3;
              }, o2.prototype.getViewCache = function() {
                return this.rootView !== this ? this.rootView.getViewCache() : this.isViewCachingEnabled() ? this.viewCache != null ? this.viewCache : this.viewCache = {} : void 0;
              }, o2.prototype.isViewCachingEnabled = function() {
                return this.shouldCacheViews !== false;
              }, o2.prototype.enableViewCaching = function() {
                return this.shouldCacheViews = true;
              }, o2.prototype.disableViewCaching = function() {
                return this.shouldCacheViews = false;
              }, o2.prototype.getCachedViewForObject = function(t4) {
                var e4;
                return (e4 = this.getViewCache()) != null ? e4[t4.getCacheKey()] : void 0;
              }, o2.prototype.cacheViewForObject = function(t4, e4) {
                var n4;
                return (n4 = this.getViewCache()) != null ? n4[e4.getCacheKey()] = t4 : void 0;
              }, o2.prototype.garbageCollectCachedViews = function() {
                var t4, e4, n4, o3, r2, s4;
                if (t4 = this.getViewCache()) {
                  s4 = this.getAllChildViews().concat(this), n4 = function() {
                    var t5, e5, n5;
                    for (n5 = [], t5 = 0, e5 = s4.length; e5 > t5; t5++)
                      r2 = s4[t5], n5.push(r2.object.getCacheKey());
                    return n5;
                  }(), o3 = [];
                  for (e4 in t4)
                    i3.call(n4, e4) < 0 && o3.push(delete t4[e4]);
                  return o3;
                }
              }, o2;
            }(e3.BasicObject);
          }.call(this), function() {
            var t3 = function(t4, e4) {
              function i3() {
                this.constructor = t4;
              }
              for (var o2 in e4)
                n2.call(e4, o2) && (t4[o2] = e4[o2]);
              return i3.prototype = e4.prototype, t4.prototype = new i3(), t4.__super__ = e4.prototype, t4;
            }, n2 = {}.hasOwnProperty;
            e3.ObjectGroupView = function(e4) {
              function n3() {
                n3.__super__.constructor.apply(this, arguments), this.objectGroup = this.object, this.viewClass = this.options.viewClass, delete this.options.viewClass;
              }
              return t3(n3, e4), n3.prototype.getChildViews = function() {
                var t4, e5, n4, i3;
                if (!this.childViews.length)
                  for (i3 = this.objectGroup.getObjects(), t4 = 0, e5 = i3.length; e5 > t4; t4++)
                    n4 = i3[t4], this.findOrCreateCachedChildView(this.viewClass, n4, this.options);
                return this.childViews;
              }, n3.prototype.createNodes = function() {
                var t4, e5, n4, i3, o2, r2, s4, a4, u2;
                for (t4 = this.createContainerElement(), s4 = this.getChildViews(), e5 = 0, i3 = s4.length; i3 > e5; e5++)
                  for (u2 = s4[e5], a4 = u2.getNodes(), n4 = 0, o2 = a4.length; o2 > n4; n4++)
                    r2 = a4[n4], t4.appendChild(r2);
                return [t4];
              }, n3.prototype.createContainerElement = function(t4) {
                return t4 == null && (t4 = this.objectGroup.getDepth()), this.getChildViews()[0].createContainerElement(t4);
              }, n3;
            }(e3.ObjectView);
          }.call(this), function() {
            var t3 = function(t4, e4) {
              function i3() {
                this.constructor = t4;
              }
              for (var o2 in e4)
                n2.call(e4, o2) && (t4[o2] = e4[o2]);
              return i3.prototype = e4.prototype, t4.prototype = new i3(), t4.__super__ = e4.prototype, t4;
            }, n2 = {}.hasOwnProperty;
            e3.Controller = function(e4) {
              function n3() {
                return n3.__super__.constructor.apply(this, arguments);
              }
              return t3(n3, e4), n3;
            }(e3.BasicObject);
          }.call(this), function() {
            var t3, n2, i3, o2, r2, s4, a4 = function(t4, e4) {
              return function() {
                return t4.apply(e4, arguments);
              };
            }, u2 = function(t4, e4) {
              function n3() {
                this.constructor = t4;
              }
              for (var i4 in e4)
                c2.call(e4, i4) && (t4[i4] = e4[i4]);
              return n3.prototype = e4.prototype, t4.prototype = new n3(), t4.__super__ = e4.prototype, t4;
            }, c2 = {}.hasOwnProperty, l2 = [].indexOf || function(t4) {
              for (var e4 = 0, n3 = this.length; n3 > e4; e4++)
                if (e4 in this && this[e4] === t4)
                  return e4;
              return -1;
            };
            t3 = e3.findClosestElementFromNode, i3 = e3.nodeIsEmptyTextNode, n2 = e3.nodeIsBlockStartComment, o2 = e3.normalizeSpaces, r2 = e3.summarizeStringChange, s4 = e3.tagName, e3.MutationObserver = function(e4) {
              function c3(t4) {
                this.element = t4, this.didMutate = a4(this.didMutate, this), this.observer = new window.MutationObserver(this.didMutate), this.start();
              }
              var h5, p, d3, f;
              return u2(c3, e4), p = "data-trix-mutable", d3 = "[" + p + "]", f = { attributes: true, childList: true, characterData: true, characterDataOldValue: true, subtree: true }, c3.prototype.start = function() {
                return this.reset(), this.observer.observe(this.element, f);
              }, c3.prototype.stop = function() {
                return this.observer.disconnect();
              }, c3.prototype.didMutate = function(t4) {
                var e5, n3;
                return (e5 = this.mutations).push.apply(e5, this.findSignificantMutations(t4)), this.mutations.length ? ((n3 = this.delegate) != null && typeof n3.elementDidMutate == "function" && n3.elementDidMutate(this.getMutationSummary()), this.reset()) : void 0;
              }, c3.prototype.reset = function() {
                return this.mutations = [];
              }, c3.prototype.findSignificantMutations = function(t4) {
                var e5, n3, i4, o3;
                for (o3 = [], e5 = 0, n3 = t4.length; n3 > e5; e5++)
                  i4 = t4[e5], this.mutationIsSignificant(i4) && o3.push(i4);
                return o3;
              }, c3.prototype.mutationIsSignificant = function(t4) {
                var e5, n3, i4, o3;
                if (this.nodeIsMutable(t4.target))
                  return false;
                for (o3 = this.nodesModifiedByMutation(t4), e5 = 0, n3 = o3.length; n3 > e5; e5++)
                  if (i4 = o3[e5], this.nodeIsSignificant(i4))
                    return true;
                return false;
              }, c3.prototype.nodeIsSignificant = function(t4) {
                return t4 !== this.element && !this.nodeIsMutable(t4) && !i3(t4);
              }, c3.prototype.nodeIsMutable = function(e5) {
                return t3(e5, { matchingSelector: d3 });
              }, c3.prototype.nodesModifiedByMutation = function(t4) {
                var e5;
                switch (e5 = [], t4.type) {
                  case "attributes":
                    t4.attributeName !== p && e5.push(t4.target);
                    break;
                  case "characterData":
                    e5.push(t4.target.parentNode), e5.push(t4.target);
                    break;
                  case "childList":
                    e5.push.apply(e5, t4.addedNodes), e5.push.apply(e5, t4.removedNodes);
                }
                return e5;
              }, c3.prototype.getMutationSummary = function() {
                return this.getTextMutationSummary();
              }, c3.prototype.getTextMutationSummary = function() {
                var t4, e5, n3, i4, o3, r3, s5, a5, u3, c4, h6;
                for (a5 = this.getTextChangesFromCharacterData(), n3 = a5.additions, o3 = a5.deletions, h6 = this.getTextChangesFromChildList(), u3 = h6.additions, r3 = 0, s5 = u3.length; s5 > r3; r3++)
                  e5 = u3[r3], l2.call(n3, e5) < 0 && n3.push(e5);
                return o3.push.apply(o3, h6.deletions), c4 = {}, (t4 = n3.join("")) && (c4.textAdded = t4), (i4 = o3.join("")) && (c4.textDeleted = i4), c4;
              }, c3.prototype.getMutationsByType = function(t4) {
                var e5, n3, i4, o3, r3;
                for (o3 = this.mutations, r3 = [], e5 = 0, n3 = o3.length; n3 > e5; e5++)
                  i4 = o3[e5], i4.type === t4 && r3.push(i4);
                return r3;
              }, c3.prototype.getTextChangesFromChildList = function() {
                var t4, e5, i4, r3, s5, a5, u3, c4, l3, p2, d4;
                for (t4 = [], u3 = [], a5 = this.getMutationsByType("childList"), e5 = 0, r3 = a5.length; r3 > e5; e5++)
                  s5 = a5[e5], t4.push.apply(t4, s5.addedNodes), u3.push.apply(u3, s5.removedNodes);
                return c4 = t4.length === 0 && u3.length === 1 && n2(u3[0]), c4 ? (p2 = [], d4 = ["\n"]) : (p2 = h5(t4), d4 = h5(u3)), { additions: function() {
                  var t5, e6, n3;
                  for (n3 = [], i4 = t5 = 0, e6 = p2.length; e6 > t5; i4 = ++t5)
                    l3 = p2[i4], l3 !== d4[i4] && n3.push(o2(l3));
                  return n3;
                }(), deletions: function() {
                  var t5, e6, n3;
                  for (n3 = [], i4 = t5 = 0, e6 = d4.length; e6 > t5; i4 = ++t5)
                    l3 = d4[i4], l3 !== p2[i4] && n3.push(o2(l3));
                  return n3;
                }() };
              }, c3.prototype.getTextChangesFromCharacterData = function() {
                var t4, e5, n3, i4, s5, a5, u3, c4;
                return e5 = this.getMutationsByType("characterData"), e5.length && (c4 = e5[0], n3 = e5[e5.length - 1], s5 = o2(c4.oldValue), i4 = o2(n3.target.data), a5 = r2(s5, i4), t4 = a5.added, u3 = a5.removed), { additions: t4 ? [t4] : [], deletions: u3 ? [u3] : [] };
              }, h5 = function(t4) {
                var e5, n3, i4, o3;
                for (t4 == null && (t4 = []), o3 = [], e5 = 0, n3 = t4.length; n3 > e5; e5++)
                  switch (i4 = t4[e5], i4.nodeType) {
                    case Node.TEXT_NODE:
                      o3.push(i4.data);
                      break;
                    case Node.ELEMENT_NODE:
                      s4(i4) === "br" ? o3.push("\n") : o3.push.apply(o3, h5(i4.childNodes));
                  }
                return o3;
              }, c3;
            }(e3.BasicObject);
          }.call(this), function() {
            var t3 = function(t4, e4) {
              function i3() {
                this.constructor = t4;
              }
              for (var o2 in e4)
                n2.call(e4, o2) && (t4[o2] = e4[o2]);
              return i3.prototype = e4.prototype, t4.prototype = new i3(), t4.__super__ = e4.prototype, t4;
            }, n2 = {}.hasOwnProperty;
            e3.FileVerificationOperation = function(e4) {
              function n3(t4) {
                this.file = t4;
              }
              return t3(n3, e4), n3.prototype.perform = function(t4) {
                var e5;
                return e5 = new FileReader(), e5.onerror = function() {
                  return t4(false);
                }, e5.onload = function(n4) {
                  return function() {
                    e5.onerror = null;
                    try {
                      e5.abort();
                    } catch (i3) {
                    }
                    return t4(true, n4.file);
                  };
                }(this), e5.readAsArrayBuffer(this.file);
              }, n3;
            }(e3.Operation);
          }.call(this), function() {
            var t3, n2, i3 = function(t4, e4) {
              function n3() {
                this.constructor = t4;
              }
              for (var i4 in e4)
                o2.call(e4, i4) && (t4[i4] = e4[i4]);
              return n3.prototype = e4.prototype, t4.prototype = new n3(), t4.__super__ = e4.prototype, t4;
            }, o2 = {}.hasOwnProperty;
            t3 = e3.handleEvent, n2 = e3.innerElementIsActive, e3.InputController = function(o3) {
              function r2(n3) {
                var i4;
                this.element = n3, this.mutationObserver = new e3.MutationObserver(this.element), this.mutationObserver.delegate = this;
                for (i4 in this.events)
                  t3(i4, { onElement: this.element, withCallback: this.handlerFor(i4) });
              }
              return i3(r2, o3), r2.prototype.events = {}, r2.prototype.elementDidMutate = function() {
              }, r2.prototype.editorWillSyncDocumentView = function() {
                return this.mutationObserver.stop();
              }, r2.prototype.editorDidSyncDocumentView = function() {
                return this.mutationObserver.start();
              }, r2.prototype.requestRender = function() {
                var t4;
                return (t4 = this.delegate) != null && typeof t4.inputControllerDidRequestRender == "function" ? t4.inputControllerDidRequestRender() : void 0;
              }, r2.prototype.requestReparse = function() {
                var t4;
                return (t4 = this.delegate) != null && typeof t4.inputControllerDidRequestReparse == "function" && t4.inputControllerDidRequestReparse(), this.requestRender();
              }, r2.prototype.attachFiles = function(t4) {
                var n3, i4;
                return i4 = function() {
                  var i5, o4, r3;
                  for (r3 = [], i5 = 0, o4 = t4.length; o4 > i5; i5++)
                    n3 = t4[i5], r3.push(new e3.FileVerificationOperation(n3));
                  return r3;
                }(), Promise.all(i4).then(function(t5) {
                  return function(e4) {
                    return t5.handleInput(function() {
                      var t6, n4;
                      return (t6 = this.delegate) != null && t6.inputControllerWillAttachFiles(), (n4 = this.responder) != null && n4.insertFiles(e4), this.requestRender();
                    });
                  };
                }(this));
              }, r2.prototype.handlerFor = function(t4) {
                return function(e4) {
                  return function(i4) {
                    return i4.defaultPrevented ? void 0 : e4.handleInput(function() {
                      return n2(this.element) ? void 0 : (this.eventName = t4, this.events[t4].call(this, i4));
                    });
                  };
                }(this);
              }, r2.prototype.handleInput = function(t4) {
                var e4, n3;
                try {
                  return (e4 = this.delegate) != null && e4.inputControllerWillHandleInput(), t4.call(this);
                } finally {
                  (n3 = this.delegate) != null && n3.inputControllerDidHandleInput();
                }
              }, r2.prototype.createLinkHTML = function(t4, e4) {
                var n3;
                return n3 = document.createElement("a"), n3.href = t4, n3.textContent = e4 != null ? e4 : t4, n3.outerHTML;
              }, r2;
            }(e3.BasicObject);
          }.call(this), function() {
            var t3, n2, i3, o2, r2, s4, a4, u2, c2, l2, h5, p, d3, f = function(t4, e4) {
              function n3() {
                this.constructor = t4;
              }
              for (var i4 in e4)
                g.call(e4, i4) && (t4[i4] = e4[i4]);
              return n3.prototype = e4.prototype, t4.prototype = new n3(), t4.__super__ = e4.prototype, t4;
            }, g = {}.hasOwnProperty, m3 = [].indexOf || function(t4) {
              for (var e4 = 0, n3 = this.length; n3 > e4; e4++)
                if (e4 in this && this[e4] === t4)
                  return e4;
              return -1;
            };
            c2 = e3.makeElement, l2 = e3.objectsAreEqual, d3 = e3.tagName, n2 = e3.browser, a4 = e3.keyEventIsKeyboardCommand, o2 = e3.dataTransferIsWritable, i3 = e3.dataTransferIsPlainText, u2 = e3.config.keyNames, e3.Level0InputController = function(n3) {
              function s5() {
                s5.__super__.constructor.apply(this, arguments), this.resetInputSummary();
              }
              var d4;
              return f(s5, n3), d4 = 0, s5.prototype.setInputSummary = function(t4) {
                var e4, n4;
                t4 == null && (t4 = {}), this.inputSummary.eventName = this.eventName;
                for (e4 in t4)
                  n4 = t4[e4], this.inputSummary[e4] = n4;
                return this.inputSummary;
              }, s5.prototype.resetInputSummary = function() {
                return this.inputSummary = {};
              }, s5.prototype.reset = function() {
                return this.resetInputSummary(), e3.selectionChangeObserver.reset();
              }, s5.prototype.elementDidMutate = function(t4) {
                var e4;
                return this.isComposing() ? (e4 = this.delegate) != null && typeof e4.inputControllerDidAllowUnhandledInput == "function" ? e4.inputControllerDidAllowUnhandledInput() : void 0 : this.handleInput(function() {
                  return this.mutationIsSignificant(t4) && (this.mutationIsExpected(t4) ? this.requestRender() : this.requestReparse()), this.reset();
                });
              }, s5.prototype.mutationIsExpected = function(t4) {
                var e4, n4, i4, o3, r3, s6, a5, u3, c3, l3;
                return a5 = t4.textAdded, u3 = t4.textDeleted, this.inputSummary.preferDocument ? true : (e4 = a5 != null ? a5 === this.inputSummary.textAdded : !this.inputSummary.textAdded, n4 = u3 != null ? this.inputSummary.didDelete : !this.inputSummary.didDelete, c3 = (a5 === "\n" || a5 === " \n") && !e4, l3 = u3 === "\n" && !n4, s6 = c3 && !l3 || l3 && !c3, s6 && (o3 = this.getSelectedRange()) && (i4 = c3 ? a5.replace(/\n$/, "").length || -1 : (a5 != null ? a5.length : void 0) || 1, (r3 = this.responder) != null ? r3.positionIsBlockBreak(o3[1] + i4) : void 0) ? true : e4 && n4);
              }, s5.prototype.mutationIsSignificant = function(t4) {
                var e4, n4, i4;
                return i4 = Object.keys(t4).length > 0, e4 = ((n4 = this.compositionInput) != null ? n4.getEndData() : void 0) === "", i4 || !e4;
              }, s5.prototype.events = { keydown: function(t4) {
                var n4, i4, o3, r3, s6, c3, l3, h6, p2;
                if (this.isComposing() || this.resetInputSummary(), this.inputSummary.didInput = true, r3 = u2[t4.keyCode]) {
                  for (i4 = this.keys, h6 = ["ctrl", "alt", "shift", "meta"], o3 = 0, c3 = h6.length; c3 > o3; o3++)
                    l3 = h6[o3], t4[l3 + "Key"] && (l3 === "ctrl" && (l3 = "control"), i4 = i4 != null ? i4[l3] : void 0);
                  (i4 != null ? i4[r3] : void 0) != null && (this.setInputSummary({ keyName: r3 }), e3.selectionChangeObserver.reset(), i4[r3].call(this, t4));
                }
                return a4(t4) && (n4 = String.fromCharCode(t4.keyCode).toLowerCase()) && (s6 = function() {
                  var e4, n5, i5, o4;
                  for (i5 = ["alt", "shift"], o4 = [], e4 = 0, n5 = i5.length; n5 > e4; e4++)
                    l3 = i5[e4], t4[l3 + "Key"] && o4.push(l3);
                  return o4;
                }(), s6.push(n4), (p2 = this.delegate) != null ? p2.inputControllerDidReceiveKeyboardCommand(s6) : void 0) ? t4.preventDefault() : void 0;
              }, keypress: function(t4) {
                var e4, n4, i4;
                if (this.inputSummary.eventName == null && !t4.metaKey && (!t4.ctrlKey || t4.altKey))
                  return (i4 = p(t4)) ? ((e4 = this.delegate) != null && e4.inputControllerWillPerformTyping(), (n4 = this.responder) != null && n4.insertString(i4), this.setInputSummary({ textAdded: i4, didDelete: this.selectionIsExpanded() })) : void 0;
              }, textInput: function(t4) {
                var e4, n4, i4, o3;
                return e4 = t4.data, o3 = this.inputSummary.textAdded, o3 && o3 !== e4 && o3.toUpperCase() === e4 ? (n4 = this.getSelectedRange(), this.setSelectedRange([n4[0], n4[1] + o3.length]), (i4 = this.responder) != null && i4.insertString(e4), this.setInputSummary({ textAdded: e4 }), this.setSelectedRange(n4)) : void 0;
              }, dragenter: function(t4) {
                return t4.preventDefault();
              }, dragstart: function(t4) {
                var e4, n4;
                return n4 = t4.target, this.serializeSelectionToDataTransfer(t4.dataTransfer), this.draggedRange = this.getSelectedRange(), (e4 = this.delegate) != null && typeof e4.inputControllerDidStartDrag == "function" ? e4.inputControllerDidStartDrag() : void 0;
              }, dragover: function(t4) {
                var e4, n4;
                return !this.draggedRange && !this.canAcceptDataTransfer(t4.dataTransfer) || (t4.preventDefault(), e4 = { x: t4.clientX, y: t4.clientY }, l2(e4, this.draggingPoint)) ? void 0 : (this.draggingPoint = e4, (n4 = this.delegate) != null && typeof n4.inputControllerDidReceiveDragOverPoint == "function" ? n4.inputControllerDidReceiveDragOverPoint(this.draggingPoint) : void 0);
              }, dragend: function() {
                var t4;
                return (t4 = this.delegate) != null && typeof t4.inputControllerDidCancelDrag == "function" && t4.inputControllerDidCancelDrag(), this.draggedRange = null, this.draggingPoint = null;
              }, drop: function(t4) {
                var n4, i4, o3, r3, s6, a5, u3, c3, l3;
                return t4.preventDefault(), o3 = (s6 = t4.dataTransfer) != null ? s6.files : void 0, r3 = { x: t4.clientX, y: t4.clientY }, (a5 = this.responder) != null && a5.setLocationRangeFromPointRange(r3), (o3 != null ? o3.length : void 0) ? this.attachFiles(o3) : this.draggedRange ? ((u3 = this.delegate) != null && u3.inputControllerWillMoveText(), (c3 = this.responder) != null && c3.moveTextFromRange(this.draggedRange), this.draggedRange = null, this.requestRender()) : (i4 = t4.dataTransfer.getData("application/x-trix-document")) && (n4 = e3.Document.fromJSONString(i4), (l3 = this.responder) != null && l3.insertDocument(n4), this.requestRender()), this.draggedRange = null, this.draggingPoint = null;
              }, cut: function(t4) {
                var e4, n4;
                return ((e4 = this.responder) != null ? e4.selectionIsExpanded() : void 0) && (this.serializeSelectionToDataTransfer(t4.clipboardData) && t4.preventDefault(), (n4 = this.delegate) != null && n4.inputControllerWillCutText(), this.deleteInDirection("backward"), t4.defaultPrevented) ? this.requestRender() : void 0;
              }, copy: function(t4) {
                var e4;
                return ((e4 = this.responder) != null ? e4.selectionIsExpanded() : void 0) && this.serializeSelectionToDataTransfer(t4.clipboardData) ? t4.preventDefault() : void 0;
              }, paste: function(t4) {
                var n4, o3, s6, a5, u3, c3, l3, p2, f2, g2, v, y3, b2, A, C, x2, w2, E2, S3, R2, k2, D2, L2;
                return n4 = (p2 = t4.clipboardData) != null ? p2 : t4.testClipboardData, l3 = { clipboard: n4 }, n4 == null || h5(t4) ? void this.getPastedHTMLUsingHiddenElement(function(t5) {
                  return function(e4) {
                    var n5, i4, o4;
                    return l3.type = "text/html", l3.html = e4, (n5 = t5.delegate) != null && n5.inputControllerWillPaste(l3), (i4 = t5.responder) != null && i4.insertHTML(l3.html), t5.requestRender(), (o4 = t5.delegate) != null ? o4.inputControllerDidPaste(l3) : void 0;
                  };
                }(this)) : ((a5 = n4.getData("URL")) ? (l3.type = "text/html", L2 = (c3 = n4.getData("public.url-name")) ? e3.squishBreakableWhitespace(c3).trim() : a5, l3.html = this.createLinkHTML(a5, L2), (f2 = this.delegate) != null && f2.inputControllerWillPaste(l3), this.setInputSummary({ textAdded: L2, didDelete: this.selectionIsExpanded() }), (C = this.responder) != null && C.insertHTML(l3.html), this.requestRender(), (x2 = this.delegate) != null && x2.inputControllerDidPaste(l3)) : i3(n4) ? (l3.type = "text/plain", l3.string = n4.getData("text/plain"), (w2 = this.delegate) != null && w2.inputControllerWillPaste(l3), this.setInputSummary({ textAdded: l3.string, didDelete: this.selectionIsExpanded() }), (E2 = this.responder) != null && E2.insertString(l3.string), this.requestRender(), (S3 = this.delegate) != null && S3.inputControllerDidPaste(l3)) : (u3 = n4.getData("text/html")) ? (l3.type = "text/html", l3.html = u3, (R2 = this.delegate) != null && R2.inputControllerWillPaste(l3), (k2 = this.responder) != null && k2.insertHTML(l3.html), this.requestRender(), (D2 = this.delegate) != null && D2.inputControllerDidPaste(l3)) : m3.call(n4.types, "Files") >= 0 && (s6 = (g2 = n4.items) != null && (v = g2[0]) != null && typeof v.getAsFile == "function" ? v.getAsFile() : void 0) && (!s6.name && (o3 = r2(s6)) && (s6.name = "pasted-file-" + ++d4 + "." + o3), l3.type = "File", l3.file = s6, (y3 = this.delegate) != null && y3.inputControllerWillAttachFiles(), (b2 = this.responder) != null && b2.insertFile(l3.file), this.requestRender(), (A = this.delegate) != null && A.inputControllerDidPaste(l3)), t4.preventDefault());
              }, compositionstart: function(t4) {
                return this.getCompositionInput().start(t4.data);
              }, compositionupdate: function(t4) {
                return this.getCompositionInput().update(t4.data);
              }, compositionend: function(t4) {
                return this.getCompositionInput().end(t4.data);
              }, beforeinput: function() {
                return this.inputSummary.didInput = true;
              }, input: function(t4) {
                return this.inputSummary.didInput = true, t4.stopPropagation();
              } }, s5.prototype.keys = { backspace: function(t4) {
                var e4;
                return (e4 = this.delegate) != null && e4.inputControllerWillPerformTyping(), this.deleteInDirection("backward", t4);
              }, "delete": function(t4) {
                var e4;
                return (e4 = this.delegate) != null && e4.inputControllerWillPerformTyping(), this.deleteInDirection("forward", t4);
              }, "return": function() {
                var t4, e4;
                return this.setInputSummary({ preferDocument: true }), (t4 = this.delegate) != null && t4.inputControllerWillPerformTyping(), (e4 = this.responder) != null ? e4.insertLineBreak() : void 0;
              }, tab: function(t4) {
                var e4, n4;
                return ((e4 = this.responder) != null ? e4.canIncreaseNestingLevel() : void 0) ? ((n4 = this.responder) != null && n4.increaseNestingLevel(), this.requestRender(), t4.preventDefault()) : void 0;
              }, left: function(t4) {
                var e4;
                return this.selectionIsInCursorTarget() ? (t4.preventDefault(), (e4 = this.responder) != null ? e4.moveCursorInDirection("backward") : void 0) : void 0;
              }, right: function(t4) {
                var e4;
                return this.selectionIsInCursorTarget() ? (t4.preventDefault(), (e4 = this.responder) != null ? e4.moveCursorInDirection("forward") : void 0) : void 0;
              }, control: { d: function(t4) {
                var e4;
                return (e4 = this.delegate) != null && e4.inputControllerWillPerformTyping(), this.deleteInDirection("forward", t4);
              }, h: function(t4) {
                var e4;
                return (e4 = this.delegate) != null && e4.inputControllerWillPerformTyping(), this.deleteInDirection("backward", t4);
              }, o: function(t4) {
                var e4, n4;
                return t4.preventDefault(), (e4 = this.delegate) != null && e4.inputControllerWillPerformTyping(), (n4 = this.responder) != null && n4.insertString("\n", { updatePosition: false }), this.requestRender();
              } }, shift: { "return": function(t4) {
                var e4, n4;
                return (e4 = this.delegate) != null && e4.inputControllerWillPerformTyping(), (n4 = this.responder) != null && n4.insertString("\n"), this.requestRender(), t4.preventDefault();
              }, tab: function(t4) {
                var e4, n4;
                return ((e4 = this.responder) != null ? e4.canDecreaseNestingLevel() : void 0) ? ((n4 = this.responder) != null && n4.decreaseNestingLevel(), this.requestRender(), t4.preventDefault()) : void 0;
              }, left: function(t4) {
                return this.selectionIsInCursorTarget() ? (t4.preventDefault(), this.expandSelectionInDirection("backward")) : void 0;
              }, right: function(t4) {
                return this.selectionIsInCursorTarget() ? (t4.preventDefault(), this.expandSelectionInDirection("forward")) : void 0;
              } }, alt: { backspace: function() {
                var t4;
                return this.setInputSummary({ preferDocument: false }), (t4 = this.delegate) != null ? t4.inputControllerWillPerformTyping() : void 0;
              } }, meta: { backspace: function() {
                var t4;
                return this.setInputSummary({ preferDocument: false }), (t4 = this.delegate) != null ? t4.inputControllerWillPerformTyping() : void 0;
              } } }, s5.prototype.getCompositionInput = function() {
                return this.isComposing() ? this.compositionInput : this.compositionInput = new t3(this);
              }, s5.prototype.isComposing = function() {
                return this.compositionInput != null && !this.compositionInput.isEnded();
              }, s5.prototype.deleteInDirection = function(t4, e4) {
                var n4;
                return ((n4 = this.responder) != null ? n4.deleteInDirection(t4) : void 0) !== false ? this.setInputSummary({ didDelete: true }) : e4 ? (e4.preventDefault(), this.requestRender()) : void 0;
              }, s5.prototype.serializeSelectionToDataTransfer = function(t4) {
                var n4, i4;
                if (o2(t4))
                  return n4 = (i4 = this.responder) != null ? i4.getSelectedDocument().toSerializableDocument() : void 0, t4.setData("application/x-trix-document", JSON.stringify(n4)), t4.setData("text/html", e3.DocumentView.render(n4).innerHTML), t4.setData("text/plain", n4.toString().replace(/\n$/, "")), true;
              }, s5.prototype.canAcceptDataTransfer = function(t4) {
                var e4, n4, i4, o3, r3, s6;
                for (s6 = {}, o3 = (i4 = t4 != null ? t4.types : void 0) != null ? i4 : [], e4 = 0, n4 = o3.length; n4 > e4; e4++)
                  r3 = o3[e4], s6[r3] = true;
                return s6.Files || s6["application/x-trix-document"] || s6["text/html"] || s6["text/plain"];
              }, s5.prototype.getPastedHTMLUsingHiddenElement = function(t4) {
                var n4, i4, o3;
                return i4 = this.getSelectedRange(), o3 = { position: "absolute", left: window.pageXOffset + "px", top: window.pageYOffset + "px", opacity: 0 }, n4 = c2({ style: o3, tagName: "div", editable: true }), document.body.appendChild(n4), n4.focus(), requestAnimationFrame(function(o4) {
                  return function() {
                    var r3;
                    return r3 = n4.innerHTML, e3.removeNode(n4), o4.setSelectedRange(i4), t4(r3);
                  };
                }(this));
              }, s5.proxyMethod("responder?.getSelectedRange"), s5.proxyMethod("responder?.setSelectedRange"), s5.proxyMethod("responder?.expandSelectionInDirection"), s5.proxyMethod("responder?.selectionIsInCursorTarget"), s5.proxyMethod("responder?.selectionIsExpanded"), s5;
            }(e3.InputController), r2 = function(t4) {
              var e4, n3;
              return (e4 = t4.type) != null && (n3 = e4.match(/\/(\w+)$/)) != null ? n3[1] : void 0;
            }, s4 = (typeof " ".codePointAt == "function" ? " ".codePointAt(0) : void 0) != null, p = function(t4) {
              var n3;
              return t4.key && s4 && t4.key.codePointAt(0) === t4.keyCode ? t4.key : (t4.which === null ? n3 = t4.keyCode : t4.which !== 0 && t4.charCode !== 0 && (n3 = t4.charCode), n3 != null && u2[n3] !== "escape" ? e3.UTF16String.fromCodepoints([n3]).toString() : void 0);
            }, h5 = function(t4) {
              var e4, n3, i4, o3, r3, s5, a5, u3, c3, l3;
              if (u3 = t4.clipboardData) {
                if (m3.call(u3.types, "text/html") >= 0) {
                  for (c3 = u3.types, i4 = 0, s5 = c3.length; s5 > i4; i4++)
                    if (l3 = c3[i4], e4 = /^CorePasteboardFlavorType/.test(l3), n3 = /^dyn\./.test(l3) && u3.getData(l3), a5 = e4 || n3)
                      return true;
                  return false;
                }
                return o3 = m3.call(u3.types, "com.apple.webarchive") >= 0, r3 = m3.call(u3.types, "com.apple.flat-rtfd") >= 0, o3 || r3;
              }
            }, t3 = function(t4) {
              function e4(t5) {
                var e5;
                this.inputController = t5, e5 = this.inputController, this.responder = e5.responder, this.delegate = e5.delegate, this.inputSummary = e5.inputSummary, this.data = {};
              }
              return f(e4, t4), e4.prototype.start = function(t5) {
                var e5, n3;
                return this.data.start = t5, this.isSignificant() ? (this.inputSummary.eventName === "keypress" && this.inputSummary.textAdded && (e5 = this.responder) != null && e5.deleteInDirection("left"), this.selectionIsExpanded() || (this.insertPlaceholder(), this.requestRender()), this.range = (n3 = this.responder) != null ? n3.getSelectedRange() : void 0) : void 0;
              }, e4.prototype.update = function(t5) {
                var e5;
                return this.data.update = t5, this.isSignificant() && (e5 = this.selectPlaceholder()) ? (this.forgetPlaceholder(), this.range = e5) : void 0;
              }, e4.prototype.end = function(t5) {
                var e5, n3, i4, o3;
                return this.data.end = t5, this.isSignificant() ? (this.forgetPlaceholder(), this.canApplyToDocument() ? (this.setInputSummary({ preferDocument: true, didInput: false }), (e5 = this.delegate) != null && e5.inputControllerWillPerformTyping(), (n3 = this.responder) != null && n3.setSelectedRange(this.range), (i4 = this.responder) != null && i4.insertString(this.data.end), (o3 = this.responder) != null ? o3.setSelectedRange(this.range[0] + this.data.end.length) : void 0) : this.data.start != null || this.data.update != null ? (this.requestReparse(), this.inputController.reset()) : void 0) : this.inputController.reset();
              }, e4.prototype.getEndData = function() {
                return this.data.end;
              }, e4.prototype.isEnded = function() {
                return this.getEndData() != null;
              }, e4.prototype.isSignificant = function() {
                return n2.composesExistingText ? this.inputSummary.didInput : true;
              }, e4.prototype.canApplyToDocument = function() {
                var t5, e5;
                return ((t5 = this.data.start) != null ? t5.length : void 0) === 0 && ((e5 = this.data.end) != null ? e5.length : void 0) > 0 && this.range != null;
              }, e4.proxyMethod("inputController.setInputSummary"), e4.proxyMethod("inputController.requestRender"), e4.proxyMethod("inputController.requestReparse"), e4.proxyMethod("responder?.selectionIsExpanded"), e4.proxyMethod("responder?.insertPlaceholder"), e4.proxyMethod("responder?.selectPlaceholder"), e4.proxyMethod("responder?.forgetPlaceholder"), e4;
            }(e3.BasicObject);
          }.call(this), function() {
            var t3, n2, i3, o2 = function(t4, e4) {
              return function() {
                return t4.apply(e4, arguments);
              };
            }, r2 = function(t4, e4) {
              function n3() {
                this.constructor = t4;
              }
              for (var i4 in e4)
                s4.call(e4, i4) && (t4[i4] = e4[i4]);
              return n3.prototype = e4.prototype, t4.prototype = new n3(), t4.__super__ = e4.prototype, t4;
            }, s4 = {}.hasOwnProperty, a4 = [].indexOf || function(t4) {
              for (var e4 = 0, n3 = this.length; n3 > e4; e4++)
                if (e4 in this && this[e4] === t4)
                  return e4;
              return -1;
            };
            t3 = e3.dataTransferIsPlainText, n2 = e3.keyEventIsKeyboardCommand, i3 = e3.objectsAreEqual, e3.Level2InputController = function(s5) {
              function u2() {
                return this.render = o2(this.render, this), u2.__super__.constructor.apply(this, arguments);
              }
              var c2, l2, h5, p, d3, f;
              return r2(u2, s5), u2.prototype.elementDidMutate = function() {
                var t4;
                return this.scheduledRender ? this.composing && (t4 = this.delegate) != null && typeof t4.inputControllerDidAllowUnhandledInput == "function" ? t4.inputControllerDidAllowUnhandledInput() : void 0 : this.reparse();
              }, u2.prototype.scheduleRender = function() {
                return this.scheduledRender != null ? this.scheduledRender : this.scheduledRender = requestAnimationFrame(this.render);
              }, u2.prototype.render = function() {
                var t4;
                return cancelAnimationFrame(this.scheduledRender), this.scheduledRender = null, this.composing || (t4 = this.delegate) != null && t4.render(), typeof this.afterRender == "function" && this.afterRender(), this.afterRender = null;
              }, u2.prototype.reparse = function() {
                var t4;
                return (t4 = this.delegate) != null ? t4.reparse() : void 0;
              }, u2.prototype.events = { keydown: function(t4) {
                var e4, i4, o3, r3;
                if (n2(t4)) {
                  if (e4 = l2(t4), (r3 = this.delegate) != null ? r3.inputControllerDidReceiveKeyboardCommand(e4) : void 0)
                    return t4.preventDefault();
                } else if (o3 = t4.key, t4.altKey && (o3 += "+Alt"), t4.shiftKey && (o3 += "+Shift"), i4 = this.keys[o3])
                  return this.withEvent(t4, i4);
              }, paste: function(t4) {
                var e4, n3, i4, o3, r3, s6, a5, u3, c3;
                return h5(t4) ? (t4.preventDefault(), this.attachFiles(t4.clipboardData.files)) : p(t4) ? (t4.preventDefault(), n3 = { type: "text/plain", string: t4.clipboardData.getData("text/plain") }, (i4 = this.delegate) != null && i4.inputControllerWillPaste(n3), (o3 = this.responder) != null && o3.insertString(n3.string), this.render(), (r3 = this.delegate) != null ? r3.inputControllerDidPaste(n3) : void 0) : (e4 = (s6 = t4.clipboardData) != null ? s6.getData("URL") : void 0) ? (t4.preventDefault(), n3 = { type: "text/html", html: this.createLinkHTML(e4) }, (a5 = this.delegate) != null && a5.inputControllerWillPaste(n3), (u3 = this.responder) != null && u3.insertHTML(n3.html), this.render(), (c3 = this.delegate) != null ? c3.inputControllerDidPaste(n3) : void 0) : void 0;
              }, beforeinput: function(t4) {
                var e4;
                return (e4 = this.inputTypes[t4.inputType]) ? (this.withEvent(t4, e4), this.scheduleRender()) : void 0;
              }, input: function() {
                return e3.selectionChangeObserver.reset();
              }, dragstart: function(t4) {
                var e4, n3;
                return ((e4 = this.responder) != null ? e4.selectionContainsAttachments() : void 0) ? (t4.dataTransfer.setData("application/x-trix-dragging", true), this.dragging = { range: (n3 = this.responder) != null ? n3.getSelectedRange() : void 0, point: d3(t4) }) : void 0;
              }, dragenter: function(t4) {
                return c2(t4) ? t4.preventDefault() : void 0;
              }, dragover: function(t4) {
                var e4, n3;
                if (this.dragging) {
                  if (t4.preventDefault(), e4 = d3(t4), !i3(e4, this.dragging.point))
                    return this.dragging.point = e4, (n3 = this.responder) != null ? n3.setLocationRangeFromPointRange(e4) : void 0;
                } else if (c2(t4))
                  return t4.preventDefault();
              }, drop: function(t4) {
                var e4, n3, i4, o3;
                return this.dragging ? (t4.preventDefault(), (n3 = this.delegate) != null && n3.inputControllerWillMoveText(), (i4 = this.responder) != null && i4.moveTextFromRange(this.dragging.range), this.dragging = null, this.scheduleRender()) : c2(t4) ? (t4.preventDefault(), e4 = d3(t4), (o3 = this.responder) != null && o3.setLocationRangeFromPointRange(e4), this.attachFiles(t4.dataTransfer.files)) : void 0;
              }, dragend: function() {
                var t4;
                return this.dragging ? ((t4 = this.responder) != null && t4.setSelectedRange(this.dragging.range), this.dragging = null) : void 0;
              }, compositionend: function() {
                return this.composing ? (this.composing = false, this.scheduleRender()) : void 0;
              } }, u2.prototype.keys = { ArrowLeft: function() {
                var t4, e4;
                return ((t4 = this.responder) != null ? t4.shouldManageMovingCursorInDirection("backward") : void 0) ? (this.event.preventDefault(), (e4 = this.responder) != null ? e4.moveCursorInDirection("backward") : void 0) : void 0;
              }, ArrowRight: function() {
                var t4, e4;
                return ((t4 = this.responder) != null ? t4.shouldManageMovingCursorInDirection("forward") : void 0) ? (this.event.preventDefault(), (e4 = this.responder) != null ? e4.moveCursorInDirection("forward") : void 0) : void 0;
              }, Backspace: function() {
                var t4, e4, n3;
                return ((t4 = this.responder) != null ? t4.shouldManageDeletingInDirection("backward") : void 0) ? (this.event.preventDefault(), (e4 = this.delegate) != null && e4.inputControllerWillPerformTyping(), (n3 = this.responder) != null && n3.deleteInDirection("backward"), this.render()) : void 0;
              }, Tab: function() {
                var t4, e4;
                return ((t4 = this.responder) != null ? t4.canIncreaseNestingLevel() : void 0) ? (this.event.preventDefault(), (e4 = this.responder) != null && e4.increaseNestingLevel(), this.render()) : void 0;
              }, "Tab+Shift": function() {
                var t4, e4;
                return ((t4 = this.responder) != null ? t4.canDecreaseNestingLevel() : void 0) ? (this.event.preventDefault(), (e4 = this.responder) != null && e4.decreaseNestingLevel(), this.render()) : void 0;
              } }, u2.prototype.inputTypes = { deleteByComposition: function() {
                return this.deleteInDirection("backward", { recordUndoEntry: false });
              }, deleteByCut: function() {
                return this.deleteInDirection("backward");
              }, deleteByDrag: function() {
                return this.event.preventDefault(), this.withTargetDOMRange(function() {
                  var t4;
                  return this.deleteByDragRange = (t4 = this.responder) != null ? t4.getSelectedRange() : void 0;
                });
              }, deleteCompositionText: function() {
                return this.deleteInDirection("backward", { recordUndoEntry: false });
              }, deleteContent: function() {
                return this.deleteInDirection("backward");
              }, deleteContentBackward: function() {
                return this.deleteInDirection("backward");
              }, deleteContentForward: function() {
                return this.deleteInDirection("forward");
              }, deleteEntireSoftLine: function() {
                return this.deleteInDirection("forward");
              }, deleteHardLineBackward: function() {
                return this.deleteInDirection("backward");
              }, deleteHardLineForward: function() {
                return this.deleteInDirection("forward");
              }, deleteSoftLineBackward: function() {
                return this.deleteInDirection("backward");
              }, deleteSoftLineForward: function() {
                return this.deleteInDirection("forward");
              }, deleteWordBackward: function() {
                return this.deleteInDirection("backward");
              }, deleteWordForward: function() {
                return this.deleteInDirection("forward");
              }, formatBackColor: function() {
                return this.activateAttributeIfSupported("backgroundColor", this.event.data);
              }, formatBold: function() {
                return this.toggleAttributeIfSupported("bold");
              }, formatFontColor: function() {
                return this.activateAttributeIfSupported("color", this.event.data);
              }, formatFontName: function() {
                return this.activateAttributeIfSupported("font", this.event.data);
              }, formatIndent: function() {
                var t4;
                return ((t4 = this.responder) != null ? t4.canIncreaseNestingLevel() : void 0) ? this.withTargetDOMRange(function() {
                  var t5;
                  return (t5 = this.responder) != null ? t5.increaseNestingLevel() : void 0;
                }) : void 0;
              }, formatItalic: function() {
                return this.toggleAttributeIfSupported("italic");
              }, formatJustifyCenter: function() {
                return this.toggleAttributeIfSupported("justifyCenter");
              }, formatJustifyFull: function() {
                return this.toggleAttributeIfSupported("justifyFull");
              }, formatJustifyLeft: function() {
                return this.toggleAttributeIfSupported("justifyLeft");
              }, formatJustifyRight: function() {
                return this.toggleAttributeIfSupported("justifyRight");
              }, formatOutdent: function() {
                var t4;
                return ((t4 = this.responder) != null ? t4.canDecreaseNestingLevel() : void 0) ? this.withTargetDOMRange(function() {
                  var t5;
                  return (t5 = this.responder) != null ? t5.decreaseNestingLevel() : void 0;
                }) : void 0;
              }, formatRemove: function() {
                return this.withTargetDOMRange(function() {
                  var t4, e4, n3, i4;
                  i4 = [];
                  for (t4 in (e4 = this.responder) != null ? e4.getCurrentAttributes() : void 0)
                    i4.push((n3 = this.responder) != null ? n3.removeCurrentAttribute(t4) : void 0);
                  return i4;
                });
              }, formatSetBlockTextDirection: function() {
                return this.activateAttributeIfSupported("blockDir", this.event.data);
              }, formatSetInlineTextDirection: function() {
                return this.activateAttributeIfSupported("textDir", this.event.data);
              }, formatStrikeThrough: function() {
                return this.toggleAttributeIfSupported("strike");
              }, formatSubscript: function() {
                return this.toggleAttributeIfSupported("sub");
              }, formatSuperscript: function() {
                return this.toggleAttributeIfSupported("sup");
              }, formatUnderline: function() {
                return this.toggleAttributeIfSupported("underline");
              }, historyRedo: function() {
                var t4;
                return (t4 = this.delegate) != null ? t4.inputControllerWillPerformRedo() : void 0;
              }, historyUndo: function() {
                var t4;
                return (t4 = this.delegate) != null ? t4.inputControllerWillPerformUndo() : void 0;
              }, insertCompositionText: function() {
                return this.composing = true, this.insertString(this.event.data);
              }, insertFromComposition: function() {
                return this.composing = false, this.insertString(this.event.data);
              }, insertFromDrop: function() {
                var t4, e4;
                return (t4 = this.deleteByDragRange) ? (this.deleteByDragRange = null, (e4 = this.delegate) != null && e4.inputControllerWillMoveText(), this.withTargetDOMRange(function() {
                  var e5;
                  return (e5 = this.responder) != null ? e5.moveTextFromRange(t4) : void 0;
                })) : void 0;
              }, insertFromPaste: function() {
                var n3, i4, o3, r3, s6, a5, u3, c3, l3, h6, p2;
                return n3 = this.event.dataTransfer, s6 = { dataTransfer: n3 }, (i4 = n3.getData("URL")) ? (this.event.preventDefault(), s6.type = "text/html", p2 = (r3 = n3.getData("public.url-name")) ? e3.squishBreakableWhitespace(r3).trim() : i4, s6.html = this.createLinkHTML(i4, p2), (a5 = this.delegate) != null && a5.inputControllerWillPaste(s6), this.withTargetDOMRange(function() {
                  var t4;
                  return (t4 = this.responder) != null ? t4.insertHTML(s6.html) : void 0;
                }), this.afterRender = function(t4) {
                  return function() {
                    var e4;
                    return (e4 = t4.delegate) != null ? e4.inputControllerDidPaste(s6) : void 0;
                  };
                }(this)) : t3(n3) ? (s6.type = "text/plain", s6.string = n3.getData("text/plain"), (u3 = this.delegate) != null && u3.inputControllerWillPaste(s6), this.withTargetDOMRange(function() {
                  var t4;
                  return (t4 = this.responder) != null ? t4.insertString(s6.string) : void 0;
                }), this.afterRender = function(t4) {
                  return function() {
                    var e4;
                    return (e4 = t4.delegate) != null ? e4.inputControllerDidPaste(s6) : void 0;
                  };
                }(this)) : (o3 = n3.getData("text/html")) ? (this.event.preventDefault(), s6.type = "text/html", s6.html = o3, (c3 = this.delegate) != null && c3.inputControllerWillPaste(s6), this.withTargetDOMRange(function() {
                  var t4;
                  return (t4 = this.responder) != null ? t4.insertHTML(s6.html) : void 0;
                }), this.afterRender = function(t4) {
                  return function() {
                    var e4;
                    return (e4 = t4.delegate) != null ? e4.inputControllerDidPaste(s6) : void 0;
                  };
                }(this)) : ((l3 = n3.files) != null ? l3.length : void 0) ? (s6.type = "File", s6.file = n3.files[0], (h6 = this.delegate) != null && h6.inputControllerWillPaste(s6), this.withTargetDOMRange(function() {
                  var t4;
                  return (t4 = this.responder) != null ? t4.insertFile(s6.file) : void 0;
                }), this.afterRender = function(t4) {
                  return function() {
                    var e4;
                    return (e4 = t4.delegate) != null ? e4.inputControllerDidPaste(s6) : void 0;
                  };
                }(this)) : void 0;
              }, insertFromYank: function() {
                return this.insertString(this.event.data);
              }, insertLineBreak: function() {
                return this.insertString("\n");
              }, insertLink: function() {
                return this.activateAttributeIfSupported("href", this.event.data);
              }, insertOrderedList: function() {
                return this.toggleAttributeIfSupported("number");
              }, insertParagraph: function() {
                var t4;
                return (t4 = this.delegate) != null && t4.inputControllerWillPerformTyping(), this.withTargetDOMRange(function() {
                  var t5;
                  return (t5 = this.responder) != null ? t5.insertLineBreak() : void 0;
                });
              }, insertReplacementText: function() {
                return this.insertString(this.event.dataTransfer.getData("text/plain"), { updatePosition: false });
              }, insertText: function() {
                var t4, e4;
                return this.insertString((t4 = this.event.data) != null ? t4 : (e4 = this.event.dataTransfer) != null ? e4.getData("text/plain") : void 0);
              }, insertTranspose: function() {
                return this.insertString(this.event.data);
              }, insertUnorderedList: function() {
                return this.toggleAttributeIfSupported("bullet");
              } }, u2.prototype.insertString = function(t4, e4) {
                var n3;
                return t4 == null && (t4 = ""), (n3 = this.delegate) != null && n3.inputControllerWillPerformTyping(), this.withTargetDOMRange(function() {
                  var n4;
                  return (n4 = this.responder) != null ? n4.insertString(t4, e4) : void 0;
                });
              }, u2.prototype.toggleAttributeIfSupported = function(t4) {
                var n3;
                return a4.call(e3.getAllAttributeNames(), t4) >= 0 ? ((n3 = this.delegate) != null && n3.inputControllerWillPerformFormatting(t4), this.withTargetDOMRange(function() {
                  var e4;
                  return (e4 = this.responder) != null ? e4.toggleCurrentAttribute(t4) : void 0;
                })) : void 0;
              }, u2.prototype.activateAttributeIfSupported = function(t4, n3) {
                var i4;
                return a4.call(e3.getAllAttributeNames(), t4) >= 0 ? ((i4 = this.delegate) != null && i4.inputControllerWillPerformFormatting(t4), this.withTargetDOMRange(function() {
                  var e4;
                  return (e4 = this.responder) != null ? e4.setCurrentAttribute(t4, n3) : void 0;
                })) : void 0;
              }, u2.prototype.deleteInDirection = function(t4, e4) {
                var n3, i4, o3, r3;
                return o3 = (e4 != null ? e4 : { recordUndoEntry: true }).recordUndoEntry, o3 && (r3 = this.delegate) != null && r3.inputControllerWillPerformTyping(), i4 = function(e5) {
                  return function() {
                    var n4;
                    return (n4 = e5.responder) != null ? n4.deleteInDirection(t4) : void 0;
                  };
                }(this), (n3 = this.getTargetDOMRange({ minLength: 2 })) ? this.withTargetDOMRange(n3, i4) : i4();
              }, u2.prototype.withTargetDOMRange = function(t4, n3) {
                var i4;
                return typeof t4 == "function" && (n3 = t4, t4 = this.getTargetDOMRange()), t4 ? (i4 = this.responder) != null ? i4.withTargetDOMRange(t4, n3.bind(this)) : void 0 : (e3.selectionChangeObserver.reset(), n3.call(this));
              }, u2.prototype.getTargetDOMRange = function(t4) {
                var e4, n3, i4, o3;
                return i4 = (t4 != null ? t4 : { minLength: 0 }).minLength, (o3 = typeof (e4 = this.event).getTargetRanges == "function" ? e4.getTargetRanges() : void 0) && o3.length && (n3 = f(o3[0]), i4 === 0 || n3.toString().length >= i4) ? n3 : void 0;
              }, f = function(t4) {
                var e4;
                return e4 = document.createRange(), e4.setStart(t4.startContainer, t4.startOffset), e4.setEnd(t4.endContainer, t4.endOffset), e4;
              }, u2.prototype.withEvent = function(t4, e4) {
                var n3;
                this.event = t4;
                try {
                  n3 = e4.call(this);
                } finally {
                  this.event = null;
                }
                return n3;
              }, c2 = function(t4) {
                var e4, n3;
                return a4.call((e4 = (n3 = t4.dataTransfer) != null ? n3.types : void 0) != null ? e4 : [], "Files") >= 0;
              }, h5 = function(t4) {
                var e4;
                return (e4 = t4.clipboardData) ? a4.call(e4.types, "Files") >= 0 && e4.types.length === 1 && e4.files.length >= 1 : void 0;
              }, p = function(t4) {
                var e4;
                return (e4 = t4.clipboardData) ? a4.call(e4.types, "text/plain") >= 0 && e4.types.length === 1 : void 0;
              }, l2 = function(t4) {
                var e4;
                return e4 = [], t4.altKey && e4.push("alt"), t4.shiftKey && e4.push("shift"), e4.push(t4.key), e4;
              }, d3 = function(t4) {
                return { x: t4.clientX, y: t4.clientY };
              }, u2;
            }(e3.InputController);
          }.call(this), function() {
            var t3, n2, i3, o2, r2, s4, a4, u2, c2 = function(t4, e4) {
              return function() {
                return t4.apply(e4, arguments);
              };
            }, l2 = function(t4, e4) {
              function n3() {
                this.constructor = t4;
              }
              for (var i4 in e4)
                h5.call(e4, i4) && (t4[i4] = e4[i4]);
              return n3.prototype = e4.prototype, t4.prototype = new n3(), t4.__super__ = e4.prototype, t4;
            }, h5 = {}.hasOwnProperty;
            n2 = e3.defer, i3 = e3.handleEvent, s4 = e3.makeElement, u2 = e3.tagName, a4 = e3.config, r2 = a4.lang, t3 = a4.css, o2 = a4.keyNames, e3.AttachmentEditorController = function(a5) {
              function h6(t4, e4, n3, i4) {
                this.attachmentPiece = t4, this.element = e4, this.container = n3, this.options = i4 != null ? i4 : {}, this.didBlurCaption = c2(this.didBlurCaption, this), this.didChangeCaption = c2(this.didChangeCaption, this), this.didInputCaption = c2(this.didInputCaption, this), this.didKeyDownCaption = c2(this.didKeyDownCaption, this), this.didClickActionButton = c2(this.didClickActionButton, this), this.didClickToolbar = c2(this.didClickToolbar, this), this.attachment = this.attachmentPiece.attachment, u2(this.element) === "a" && (this.element = this.element.firstChild), this.install();
              }
              var p;
              return l2(h6, a5), p = function(t4) {
                return function() {
                  var e4;
                  return e4 = t4.apply(this, arguments), e4["do"](), this.undos == null && (this.undos = []), this.undos.push(e4.undo);
                };
              }, h6.prototype.install = function() {
                return this.makeElementMutable(), this.addToolbar(), this.attachment.isPreviewable() ? this.installCaptionEditor() : void 0;
              }, h6.prototype.uninstall = function() {
                var t4, e4;
                for (this.savePendingCaption(); e4 = this.undos.pop(); )
                  e4();
                return (t4 = this.delegate) != null ? t4.didUninstallAttachmentEditor(this) : void 0;
              }, h6.prototype.savePendingCaption = function() {
                var t4, e4, n3;
                return this.pendingCaption != null ? (t4 = this.pendingCaption, this.pendingCaption = null, t4 ? (e4 = this.delegate) != null && typeof e4.attachmentEditorDidRequestUpdatingAttributesForAttachment == "function" ? e4.attachmentEditorDidRequestUpdatingAttributesForAttachment({ caption: t4 }, this.attachment) : void 0 : (n3 = this.delegate) != null && typeof n3.attachmentEditorDidRequestRemovingAttributeForAttachment == "function" ? n3.attachmentEditorDidRequestRemovingAttributeForAttachment("caption", this.attachment) : void 0) : void 0;
              }, h6.prototype.makeElementMutable = p(function() {
                return { "do": function(t4) {
                  return function() {
                    return t4.element.dataset.trixMutable = true;
                  };
                }(this), undo: function(t4) {
                  return function() {
                    return delete t4.element.dataset.trixMutable;
                  };
                }(this) };
              }), h6.prototype.addToolbar = p(function() {
                var n3;
                return n3 = s4({ tagName: "div", className: t3.attachmentToolbar, data: { trixMutable: true }, childNodes: s4({ tagName: "div", className: "trix-button-row", childNodes: s4({ tagName: "span", className: "trix-button-group trix-button-group--actions", childNodes: s4({ tagName: "button", className: "trix-button trix-button--remove", textContent: r2.remove, attributes: { title: r2.remove }, data: { trixAction: "remove" } }) }) }) }), this.attachment.isPreviewable() && n3.appendChild(s4({ tagName: "div", className: t3.attachmentMetadataContainer, childNodes: s4({ tagName: "span", className: t3.attachmentMetadata, childNodes: [s4({ tagName: "span", className: t3.attachmentName, textContent: this.attachment.getFilename(), attributes: { title: this.attachment.getFilename() } }), s4({ tagName: "span", className: t3.attachmentSize, textContent: this.attachment.getFormattedFilesize() })] }) })), i3("click", { onElement: n3, withCallback: this.didClickToolbar }), i3("click", { onElement: n3, matchingSelector: "[data-trix-action]", withCallback: this.didClickActionButton }), { "do": function(t4) {
                  return function() {
                    return t4.element.appendChild(n3);
                  };
                }(this), undo: function() {
                  return function() {
                    return e3.removeNode(n3);
                  };
                }(this) };
              }), h6.prototype.installCaptionEditor = p(function() {
                var o3, a6, u3, c3, l3;
                return c3 = s4({ tagName: "textarea", className: t3.attachmentCaptionEditor, attributes: { placeholder: r2.captionPlaceholder }, data: { trixMutable: true } }), c3.value = this.attachmentPiece.getCaption(), l3 = c3.cloneNode(), l3.classList.add("trix-autoresize-clone"), l3.tabIndex = -1, o3 = function() {
                  return l3.value = c3.value, c3.style.height = l3.scrollHeight + "px";
                }, i3("input", { onElement: c3, withCallback: o3 }), i3("input", { onElement: c3, withCallback: this.didInputCaption }), i3("keydown", { onElement: c3, withCallback: this.didKeyDownCaption }), i3("change", { onElement: c3, withCallback: this.didChangeCaption }), i3("blur", { onElement: c3, withCallback: this.didBlurCaption }), u3 = this.element.querySelector("figcaption"), a6 = u3.cloneNode(), { "do": function(e4) {
                  return function() {
                    return u3.style.display = "none", a6.appendChild(c3), a6.appendChild(l3), a6.classList.add(t3.attachmentCaption + "--editing"), u3.parentElement.insertBefore(a6, u3), o3(), e4.options.editCaption ? n2(function() {
                      return c3.focus();
                    }) : void 0;
                  };
                }(this), undo: function() {
                  return e3.removeNode(a6), u3.style.display = null;
                } };
              }), h6.prototype.didClickToolbar = function(t4) {
                return t4.preventDefault(), t4.stopPropagation();
              }, h6.prototype.didClickActionButton = function(t4) {
                var e4, n3;
                switch (e4 = t4.target.getAttribute("data-trix-action")) {
                  case "remove":
                    return (n3 = this.delegate) != null ? n3.attachmentEditorDidRequestRemovalOfAttachment(this.attachment) : void 0;
                }
              }, h6.prototype.didKeyDownCaption = function(t4) {
                var e4;
                return o2[t4.keyCode] === "return" ? (t4.preventDefault(), this.savePendingCaption(), (e4 = this.delegate) != null && typeof e4.attachmentEditorDidRequestDeselectingAttachment == "function" ? e4.attachmentEditorDidRequestDeselectingAttachment(this.attachment) : void 0) : void 0;
              }, h6.prototype.didInputCaption = function(t4) {
                return this.pendingCaption = t4.target.value.replace(/\s/g, " ").trim();
              }, h6.prototype.didChangeCaption = function() {
                return this.savePendingCaption();
              }, h6.prototype.didBlurCaption = function() {
                return this.savePendingCaption();
              }, h6;
            }(e3.BasicObject);
          }.call(this), function() {
            var t3, n2, i3, o2 = function(t4, e4) {
              function n3() {
                this.constructor = t4;
              }
              for (var i4 in e4)
                r2.call(e4, i4) && (t4[i4] = e4[i4]);
              return n3.prototype = e4.prototype, t4.prototype = new n3(), t4.__super__ = e4.prototype, t4;
            }, r2 = {}.hasOwnProperty;
            i3 = e3.makeElement, t3 = e3.config.css, e3.AttachmentView = function(r3) {
              function s4() {
                s4.__super__.constructor.apply(this, arguments), this.attachment = this.object, this.attachment.uploadProgressDelegate = this, this.attachmentPiece = this.options.piece;
              }
              var a4;
              return o2(s4, r3), s4.attachmentSelector = "[data-trix-attachment]", s4.prototype.createContentNodes = function() {
                return [];
              }, s4.prototype.createNodes = function() {
                var e4, n3, o3, r4, s5, u2, c2;
                if (e4 = r4 = i3({ tagName: "figure", className: this.getClassName(), data: this.getData(), editable: false }), (n3 = this.getHref()) && (r4 = i3({ tagName: "a", editable: false, attributes: { href: n3, tabindex: -1 } }), e4.appendChild(r4)), this.attachment.hasContent())
                  r4.innerHTML = this.attachment.getContent();
                else
                  for (c2 = this.createContentNodes(), o3 = 0, s5 = c2.length; s5 > o3; o3++)
                    u2 = c2[o3], r4.appendChild(u2);
                return r4.appendChild(this.createCaptionElement()), this.attachment.isPending() && (this.progressElement = i3({ tagName: "progress", attributes: { "class": t3.attachmentProgress, value: this.attachment.getUploadProgress(), max: 100 }, data: { trixMutable: true, trixStoreKey: ["progressElement", this.attachment.id].join("/") } }), e4.appendChild(this.progressElement)), [a4("left"), e4, a4("right")];
              }, s4.prototype.createCaptionElement = function() {
                var e4, n3, o3, r4, s5, a5, u2;
                return o3 = i3({ tagName: "figcaption", className: t3.attachmentCaption }), (e4 = this.attachmentPiece.getCaption()) ? (o3.classList.add(t3.attachmentCaption + "--edited"), o3.textContent = e4) : (n3 = this.getCaptionConfig(), n3.name && (r4 = this.attachment.getFilename()), n3.size && (a5 = this.attachment.getFormattedFilesize()), r4 && (s5 = i3({ tagName: "span", className: t3.attachmentName, textContent: r4 }), o3.appendChild(s5)), a5 && (r4 && o3.appendChild(document.createTextNode(" ")), u2 = i3({ tagName: "span", className: t3.attachmentSize, textContent: a5 }), o3.appendChild(u2))), o3;
              }, s4.prototype.getClassName = function() {
                var e4, n3;
                return n3 = [t3.attachment, t3.attachment + "--" + this.attachment.getType()], (e4 = this.attachment.getExtension()) && n3.push(t3.attachment + "--" + e4), n3.join(" ");
              }, s4.prototype.getData = function() {
                var t4, e4;
                return e4 = { trixAttachment: JSON.stringify(this.attachment), trixContentType: this.attachment.getContentType(), trixId: this.attachment.id }, t4 = this.attachmentPiece.attributes, t4.isEmpty() || (e4.trixAttributes = JSON.stringify(t4)), this.attachment.isPending() && (e4.trixSerialize = false), e4;
              }, s4.prototype.getHref = function() {
                return n2(this.attachment.getContent(), "a") ? void 0 : this.attachment.getHref();
              }, s4.prototype.getCaptionConfig = function() {
                var t4, n3, i4;
                return i4 = this.attachment.getType(), t4 = e3.copyObject((n3 = e3.config.attachments[i4]) != null ? n3.caption : void 0), i4 === "file" && (t4.name = true), t4;
              }, s4.prototype.findProgressElement = function() {
                var t4;
                return (t4 = this.findElement()) != null ? t4.querySelector("progress") : void 0;
              }, a4 = function(t4) {
                return i3({ tagName: "span", textContent: e3.ZERO_WIDTH_SPACE, data: { trixCursorTarget: t4, trixSerialize: false } });
              }, s4.prototype.attachmentDidChangeUploadProgress = function() {
                var t4, e4;
                return e4 = this.attachment.getUploadProgress(), (t4 = this.findProgressElement()) != null ? t4.value = e4 : void 0;
              }, s4;
            }(e3.ObjectView), n2 = function(t4, e4) {
              var n3;
              return n3 = i3("div"), n3.innerHTML = t4 != null ? t4 : "", n3.querySelector(e4);
            };
          }.call(this), function() {
            var t3, n2 = function(t4, e4) {
              function n3() {
                this.constructor = t4;
              }
              for (var o2 in e4)
                i3.call(e4, o2) && (t4[o2] = e4[o2]);
              return n3.prototype = e4.prototype, t4.prototype = new n3(), t4.__super__ = e4.prototype, t4;
            }, i3 = {}.hasOwnProperty;
            t3 = e3.makeElement, e3.PreviewableAttachmentView = function(i4) {
              function o2() {
                o2.__super__.constructor.apply(this, arguments), this.attachment.previewDelegate = this;
              }
              return n2(o2, i4), o2.prototype.createContentNodes = function() {
                return this.image = t3({ tagName: "img", attributes: { src: "" }, data: { trixMutable: true } }), this.refresh(this.image), [this.image];
              }, o2.prototype.createCaptionElement = function() {
                var t4;
                return t4 = o2.__super__.createCaptionElement.apply(this, arguments), t4.textContent || t4.setAttribute("data-trix-placeholder", e3.config.lang.captionPlaceholder), t4;
              }, o2.prototype.refresh = function(t4) {
                var e4;
                return t4 == null && (t4 = (e4 = this.findElement()) != null ? e4.querySelector("img") : void 0), t4 ? this.updateAttributesForImage(t4) : void 0;
              }, o2.prototype.updateAttributesForImage = function(t4) {
                var e4, n3, i5, o3, r2, s4;
                return r2 = this.attachment.getURL(), n3 = this.attachment.getPreviewURL(), t4.src = n3 || r2, n3 === r2 ? t4.removeAttribute("data-trix-serialized-attributes") : (i5 = JSON.stringify({ src: r2 }), t4.setAttribute("data-trix-serialized-attributes", i5)), s4 = this.attachment.getWidth(), e4 = this.attachment.getHeight(), s4 != null && (t4.width = s4), e4 != null && (t4.height = e4), o3 = ["imageElement", this.attachment.id, t4.src, t4.width, t4.height].join("/"), t4.dataset.trixStoreKey = o3;
              }, o2.prototype.attachmentDidChangeAttributes = function() {
                return this.refresh(this.image), this.refresh();
              }, o2;
            }(e3.AttachmentView);
          }.call(this), function() {
            var t3, n2, i3, o2 = function(t4, e4) {
              function n3() {
                this.constructor = t4;
              }
              for (var i4 in e4)
                r2.call(e4, i4) && (t4[i4] = e4[i4]);
              return n3.prototype = e4.prototype, t4.prototype = new n3(), t4.__super__ = e4.prototype, t4;
            }, r2 = {}.hasOwnProperty;
            i3 = e3.makeElement, t3 = e3.findInnerElement, n2 = e3.getTextConfig, e3.PieceView = function(r3) {
              function s4() {
                var t4;
                s4.__super__.constructor.apply(this, arguments), this.piece = this.object, this.attributes = this.piece.getAttributes(), t4 = this.options, this.textConfig = t4.textConfig, this.context = t4.context, this.piece.attachment ? this.attachment = this.piece.attachment : this.string = this.piece.toString();
              }
              var a4;
              return o2(s4, r3), s4.prototype.createNodes = function() {
                var e4, n3, i4, o3, r4, s5;
                if (s5 = this.attachment ? this.createAttachmentNodes() : this.createStringNodes(), e4 = this.createElement()) {
                  for (i4 = t3(e4), n3 = 0, o3 = s5.length; o3 > n3; n3++)
                    r4 = s5[n3], i4.appendChild(r4);
                  s5 = [e4];
                }
                return s5;
              }, s4.prototype.createAttachmentNodes = function() {
                var t4, n3;
                return t4 = this.attachment.isPreviewable() ? e3.PreviewableAttachmentView : e3.AttachmentView, n3 = this.createChildView(t4, this.piece.attachment, { piece: this.piece }), n3.getNodes();
              }, s4.prototype.createStringNodes = function() {
                var t4, e4, n3, o3, r4, s5, a5, u2, c2, l2;
                if ((u2 = this.textConfig) != null ? u2.plaintext : void 0)
                  return [document.createTextNode(this.string)];
                for (a5 = [], c2 = this.string.split("\n"), n3 = e4 = 0, o3 = c2.length; o3 > e4; n3 = ++e4)
                  l2 = c2[n3], n3 > 0 && (t4 = i3("br"), a5.push(t4)), (r4 = l2.length) && (s5 = document.createTextNode(this.preserveSpaces(l2)), a5.push(s5));
                return a5;
              }, s4.prototype.createElement = function() {
                var t4, e4, o3, r4, s5, a5, u2, c2, l2;
                c2 = {}, a5 = this.attributes;
                for (r4 in a5)
                  if (l2 = a5[r4], (t4 = n2(r4)) && (t4.tagName && (s5 = i3(t4.tagName), o3 ? (o3.appendChild(s5), o3 = s5) : e4 = o3 = s5), t4.styleProperty && (c2[t4.styleProperty] = l2), t4.style)) {
                    u2 = t4.style;
                    for (r4 in u2)
                      l2 = u2[r4], c2[r4] = l2;
                  }
                if (Object.keys(c2).length) {
                  e4 == null && (e4 = i3("span"));
                  for (r4 in c2)
                    l2 = c2[r4], e4.style[r4] = l2;
                }
                return e4;
              }, s4.prototype.createContainerElement = function() {
                var t4, e4, o3, r4, s5;
                r4 = this.attributes;
                for (o3 in r4)
                  if (s5 = r4[o3], (e4 = n2(o3)) && e4.groupTagName)
                    return t4 = {}, t4[o3] = s5, i3(e4.groupTagName, t4);
              }, a4 = e3.NON_BREAKING_SPACE, s4.prototype.preserveSpaces = function(t4) {
                return this.context.isLast && (t4 = t4.replace(/\ $/, a4)), t4 = t4.replace(/(\S)\ {3}(\S)/g, "$1 " + a4 + " $2").replace(/\ {2}/g, a4 + " ").replace(/\ {2}/g, " " + a4), (this.context.isFirst || this.context.followsWhitespace) && (t4 = t4.replace(/^\ /, a4)), t4;
              }, s4;
            }(e3.ObjectView);
          }.call(this), function() {
            var t3 = function(t4, e4) {
              function i3() {
                this.constructor = t4;
              }
              for (var o2 in e4)
                n2.call(e4, o2) && (t4[o2] = e4[o2]);
              return i3.prototype = e4.prototype, t4.prototype = new i3(), t4.__super__ = e4.prototype, t4;
            }, n2 = {}.hasOwnProperty;
            e3.TextView = function(n3) {
              function i3() {
                i3.__super__.constructor.apply(this, arguments), this.text = this.object, this.textConfig = this.options.textConfig;
              }
              var o2;
              return t3(i3, n3), i3.prototype.createNodes = function() {
                var t4, n4, i4, r2, s4, a4, u2, c2, l2, h5;
                for (a4 = [], c2 = e3.ObjectGroup.groupObjects(this.getPieces()), r2 = c2.length - 1, i4 = n4 = 0, s4 = c2.length; s4 > n4; i4 = ++n4)
                  u2 = c2[i4], t4 = {}, i4 === 0 && (t4.isFirst = true), i4 === r2 && (t4.isLast = true), o2(l2) && (t4.followsWhitespace = true), h5 = this.findOrCreateCachedChildView(e3.PieceView, u2, { textConfig: this.textConfig, context: t4 }), a4.push.apply(a4, h5.getNodes()), l2 = u2;
                return a4;
              }, i3.prototype.getPieces = function() {
                var t4, e4, n4, i4, o3;
                for (i4 = this.text.getPieces(), o3 = [], t4 = 0, e4 = i4.length; e4 > t4; t4++)
                  n4 = i4[t4], n4.hasAttribute("blockBreak") || o3.push(n4);
                return o3;
              }, o2 = function(t4) {
                return /\s$/.test(t4 != null ? t4.toString() : void 0);
              }, i3;
            }(e3.ObjectView);
          }.call(this), function() {
            var t3, n2, i3, o2 = function(t4, e4) {
              function n3() {
                this.constructor = t4;
              }
              for (var i4 in e4)
                r2.call(e4, i4) && (t4[i4] = e4[i4]);
              return n3.prototype = e4.prototype, t4.prototype = new n3(), t4.__super__ = e4.prototype, t4;
            }, r2 = {}.hasOwnProperty;
            i3 = e3.makeElement, n2 = e3.getBlockConfig, t3 = e3.config.css, e3.BlockView = function(r3) {
              function s4() {
                s4.__super__.constructor.apply(this, arguments), this.block = this.object, this.attributes = this.block.getAttributes();
              }
              return o2(s4, r3), s4.prototype.createNodes = function() {
                var t4, o3, r4, s5, a4, u2, c2, l2, h5, p, d3;
                if (o3 = document.createComment("block"), c2 = [o3], this.block.isEmpty() ? c2.push(i3("br")) : (p = (l2 = n2(this.block.getLastAttribute())) != null ? l2.text : void 0, d3 = this.findOrCreateCachedChildView(e3.TextView, this.block.text, { textConfig: p }), c2.push.apply(c2, d3.getNodes()), this.shouldAddExtraNewlineElement() && c2.push(i3("br"))), this.attributes.length)
                  return c2;
                for (h5 = e3.config.blockAttributes["default"].tagName, this.block.isRTL() && (t4 = { dir: "rtl" }), r4 = i3({ tagName: h5, attributes: t4 }), s5 = 0, a4 = c2.length; a4 > s5; s5++)
                  u2 = c2[s5], r4.appendChild(u2);
                return [r4];
              }, s4.prototype.createContainerElement = function(e4) {
                var o3, r4, s5, a4, u2;
                return o3 = this.attributes[e4], u2 = n2(o3).tagName, e4 === 0 && this.block.isRTL() && (r4 = { dir: "rtl" }), o3 === "attachmentGallery" && (a4 = this.block.getBlockBreakPosition(), s5 = t3.attachmentGallery + " " + t3.attachmentGallery + "--" + a4), i3({ tagName: u2, className: s5, attributes: r4 });
              }, s4.prototype.shouldAddExtraNewlineElement = function() {
                return /\n\n$/.test(this.block.toString());
              }, s4;
            }(e3.ObjectView);
          }.call(this), function() {
            var t3, n2, i3 = function(t4, e4) {
              function n3() {
                this.constructor = t4;
              }
              for (var i4 in e4)
                o2.call(e4, i4) && (t4[i4] = e4[i4]);
              return n3.prototype = e4.prototype, t4.prototype = new n3(), t4.__super__ = e4.prototype, t4;
            }, o2 = {}.hasOwnProperty;
            t3 = e3.defer, n2 = e3.makeElement, e3.DocumentView = function(o3) {
              function r2() {
                r2.__super__.constructor.apply(this, arguments), this.element = this.options.element, this.elementStore = new e3.ElementStore(), this.setDocument(this.object);
              }
              var s4, a4, u2;
              return i3(r2, o3), r2.render = function(t4) {
                var e4, i4;
                return e4 = n2("div"), i4 = new this(t4, { element: e4 }), i4.render(), i4.sync(), e4;
              }, r2.prototype.setDocument = function(t4) {
                return t4.isEqualTo(this.document) ? void 0 : this.document = this.object = t4;
              }, r2.prototype.render = function() {
                var t4, i4, o4, r3, s5, a5, u3;
                if (this.childViews = [], this.shadowElement = n2("div"), !this.document.isEmpty()) {
                  for (s5 = e3.ObjectGroup.groupObjects(this.document.getBlocks(), { asTree: true }), a5 = [], t4 = 0, i4 = s5.length; i4 > t4; t4++)
                    r3 = s5[t4], u3 = this.findOrCreateCachedChildView(e3.BlockView, r3), a5.push(function() {
                      var t5, e4, n3, i5;
                      for (n3 = u3.getNodes(), i5 = [], t5 = 0, e4 = n3.length; e4 > t5; t5++)
                        o4 = n3[t5], i5.push(this.shadowElement.appendChild(o4));
                      return i5;
                    }.call(this));
                  return a5;
                }
              }, r2.prototype.isSynced = function() {
                return s4(this.shadowElement, this.element);
              }, r2.prototype.sync = function() {
                var t4;
                for (t4 = this.createDocumentFragmentForSync(); this.element.lastChild; )
                  this.element.removeChild(this.element.lastChild);
                return this.element.appendChild(t4), this.didSync();
              }, r2.prototype.didSync = function() {
                return this.elementStore.reset(a4(this.element)), t3(function(t4) {
                  return function() {
                    return t4.garbageCollectCachedViews();
                  };
                }(this));
              }, r2.prototype.createDocumentFragmentForSync = function() {
                var t4, e4, n3, i4, o4, r3, s5, u3, c2, l2;
                for (e4 = document.createDocumentFragment(), u3 = this.shadowElement.childNodes, n3 = 0, o4 = u3.length; o4 > n3; n3++)
                  s5 = u3[n3], e4.appendChild(s5.cloneNode(true));
                for (c2 = a4(e4), i4 = 0, r3 = c2.length; r3 > i4; i4++)
                  t4 = c2[i4], (l2 = this.elementStore.remove(t4)) && t4.parentNode.replaceChild(l2, t4);
                return e4;
              }, a4 = function(t4) {
                return t4.querySelectorAll("[data-trix-store-key]");
              }, s4 = function(t4, e4) {
                return u2(t4.innerHTML) === u2(e4.innerHTML);
              }, u2 = function(t4) {
                return t4.replace(/&nbsp;/g, " ");
              }, r2;
            }(e3.ObjectView);
          }.call(this), function() {
            var t3, n2, i3, o2, r2, s4 = function(t4, e4) {
              return function() {
                return t4.apply(e4, arguments);
              };
            }, a4 = function(t4, e4) {
              function n3() {
                this.constructor = t4;
              }
              for (var i4 in e4)
                u2.call(e4, i4) && (t4[i4] = e4[i4]);
              return n3.prototype = e4.prototype, t4.prototype = new n3(), t4.__super__ = e4.prototype, t4;
            }, u2 = {}.hasOwnProperty;
            i3 = e3.findClosestElementFromNode, o2 = e3.handleEvent, r2 = e3.innerElementIsActive, n2 = e3.defer, t3 = e3.AttachmentView.attachmentSelector, e3.CompositionController = function(u3) {
              function c2(n3, i4) {
                this.element = n3, this.composition = i4, this.didClickAttachment = s4(this.didClickAttachment, this), this.didBlur = s4(this.didBlur, this), this.didFocus = s4(this.didFocus, this), this.documentView = new e3.DocumentView(this.composition.document, { element: this.element }), o2("focus", { onElement: this.element, withCallback: this.didFocus }), o2("blur", { onElement: this.element, withCallback: this.didBlur }), o2("click", { onElement: this.element, matchingSelector: "a[contenteditable=false]", preventDefault: true }), o2("mousedown", { onElement: this.element, matchingSelector: t3, withCallback: this.didClickAttachment }), o2("click", { onElement: this.element, matchingSelector: "a" + t3, preventDefault: true });
              }
              return a4(c2, u3), c2.prototype.didFocus = function() {
                var t4, e4, n3;
                return t4 = function(t5) {
                  return function() {
                    var e5;
                    return t5.focused ? void 0 : (t5.focused = true, (e5 = t5.delegate) != null && typeof e5.compositionControllerDidFocus == "function" ? e5.compositionControllerDidFocus() : void 0);
                  };
                }(this), (e4 = (n3 = this.blurPromise) != null ? n3.then(t4) : void 0) != null ? e4 : t4();
              }, c2.prototype.didBlur = function() {
                return this.blurPromise = new Promise(function(t4) {
                  return function(e4) {
                    return n2(function() {
                      var n3;
                      return r2(t4.element) || (t4.focused = null, (n3 = t4.delegate) != null && typeof n3.compositionControllerDidBlur == "function" && n3.compositionControllerDidBlur()), t4.blurPromise = null, e4();
                    });
                  };
                }(this));
              }, c2.prototype.didClickAttachment = function(t4, e4) {
                var n3, o3, r3;
                return n3 = this.findAttachmentForElement(e4), o3 = i3(t4.target, { matchingSelector: "figcaption" }) != null, (r3 = this.delegate) != null && typeof r3.compositionControllerDidSelectAttachment == "function" ? r3.compositionControllerDidSelectAttachment(n3, { editCaption: o3 }) : void 0;
              }, c2.prototype.getSerializableElement = function() {
                return this.isEditingAttachment() ? this.documentView.shadowElement : this.element;
              }, c2.prototype.render = function() {
                var t4, e4, n3;
                return this.revision !== this.composition.revision && (this.documentView.setDocument(this.composition.document), this.documentView.render(), this.revision = this.composition.revision), this.canSyncDocumentView() && !this.documentView.isSynced() && ((t4 = this.delegate) != null && typeof t4.compositionControllerWillSyncDocumentView == "function" && t4.compositionControllerWillSyncDocumentView(), this.documentView.sync(), (e4 = this.delegate) != null && typeof e4.compositionControllerDidSyncDocumentView == "function" && e4.compositionControllerDidSyncDocumentView()), (n3 = this.delegate) != null && typeof n3.compositionControllerDidRender == "function" ? n3.compositionControllerDidRender() : void 0;
              }, c2.prototype.rerenderViewForObject = function(t4) {
                return this.invalidateViewForObject(t4), this.render();
              }, c2.prototype.invalidateViewForObject = function(t4) {
                return this.documentView.invalidateViewForObject(t4);
              }, c2.prototype.isViewCachingEnabled = function() {
                return this.documentView.isViewCachingEnabled();
              }, c2.prototype.enableViewCaching = function() {
                return this.documentView.enableViewCaching();
              }, c2.prototype.disableViewCaching = function() {
                return this.documentView.disableViewCaching();
              }, c2.prototype.refreshViewCache = function() {
                return this.documentView.garbageCollectCachedViews();
              }, c2.prototype.isEditingAttachment = function() {
                return this.attachmentEditor != null;
              }, c2.prototype.installAttachmentEditorForAttachment = function(t4, n3) {
                var i4, o3, r3;
                if (((r3 = this.attachmentEditor) != null ? r3.attachment : void 0) !== t4 && (o3 = this.documentView.findElementForObject(t4)))
                  return this.uninstallAttachmentEditor(), i4 = this.composition.document.getAttachmentPieceForAttachment(t4), this.attachmentEditor = new e3.AttachmentEditorController(i4, o3, this.element, n3), this.attachmentEditor.delegate = this;
              }, c2.prototype.uninstallAttachmentEditor = function() {
                var t4;
                return (t4 = this.attachmentEditor) != null ? t4.uninstall() : void 0;
              }, c2.prototype.didUninstallAttachmentEditor = function() {
                return this.attachmentEditor = null, this.render();
              }, c2.prototype.attachmentEditorDidRequestUpdatingAttributesForAttachment = function(t4, e4) {
                var n3;
                return (n3 = this.delegate) != null && typeof n3.compositionControllerWillUpdateAttachment == "function" && n3.compositionControllerWillUpdateAttachment(e4), this.composition.updateAttributesForAttachment(t4, e4);
              }, c2.prototype.attachmentEditorDidRequestRemovingAttributeForAttachment = function(t4, e4) {
                var n3;
                return (n3 = this.delegate) != null && typeof n3.compositionControllerWillUpdateAttachment == "function" && n3.compositionControllerWillUpdateAttachment(e4), this.composition.removeAttributeForAttachment(t4, e4);
              }, c2.prototype.attachmentEditorDidRequestRemovalOfAttachment = function(t4) {
                var e4;
                return (e4 = this.delegate) != null && typeof e4.compositionControllerDidRequestRemovalOfAttachment == "function" ? e4.compositionControllerDidRequestRemovalOfAttachment(t4) : void 0;
              }, c2.prototype.attachmentEditorDidRequestDeselectingAttachment = function(t4) {
                var e4;
                return (e4 = this.delegate) != null && typeof e4.compositionControllerDidRequestDeselectingAttachment == "function" ? e4.compositionControllerDidRequestDeselectingAttachment(t4) : void 0;
              }, c2.prototype.canSyncDocumentView = function() {
                return !this.isEditingAttachment();
              }, c2.prototype.findAttachmentForElement = function(t4) {
                return this.composition.document.getAttachmentById(parseInt(t4.dataset.trixId, 10));
              }, c2;
            }(e3.BasicObject);
          }.call(this), function() {
            var t3, n2, i3, o2 = function(t4, e4) {
              return function() {
                return t4.apply(e4, arguments);
              };
            }, r2 = function(t4, e4) {
              function n3() {
                this.constructor = t4;
              }
              for (var i4 in e4)
                s4.call(e4, i4) && (t4[i4] = e4[i4]);
              return n3.prototype = e4.prototype, t4.prototype = new n3(), t4.__super__ = e4.prototype, t4;
            }, s4 = {}.hasOwnProperty;
            n2 = e3.handleEvent, i3 = e3.triggerEvent, t3 = e3.findClosestElementFromNode, e3.ToolbarController = function(e4) {
              function s5(t4) {
                this.element = t4, this.didKeyDownDialogInput = o2(this.didKeyDownDialogInput, this), this.didClickDialogButton = o2(this.didClickDialogButton, this), this.didClickAttributeButton = o2(this.didClickAttributeButton, this), this.didClickActionButton = o2(this.didClickActionButton, this), this.attributes = {}, this.actions = {}, this.resetDialogInputs(), n2("mousedown", { onElement: this.element, matchingSelector: a4, withCallback: this.didClickActionButton }), n2("mousedown", { onElement: this.element, matchingSelector: c2, withCallback: this.didClickAttributeButton }), n2("click", { onElement: this.element, matchingSelector: v, preventDefault: true }), n2("click", { onElement: this.element, matchingSelector: l2, withCallback: this.didClickDialogButton }), n2("keydown", { onElement: this.element, matchingSelector: h5, withCallback: this.didKeyDownDialogInput });
              }
              var a4, u2, c2, l2, h5, p, d3, f, g, m3, v;
              return r2(s5, e4), c2 = "[data-trix-attribute]", a4 = "[data-trix-action]", v = c2 + ", " + a4, p = "[data-trix-dialog]", u2 = p + "[data-trix-active]", l2 = p + " [data-trix-method]", h5 = p + " [data-trix-input]", s5.prototype.didClickActionButton = function(t4, e5) {
                var n3, i4, o3;
                return (i4 = this.delegate) != null && i4.toolbarDidClickButton(), t4.preventDefault(), n3 = d3(e5), this.getDialog(n3) ? this.toggleDialog(n3) : (o3 = this.delegate) != null ? o3.toolbarDidInvokeAction(n3) : void 0;
              }, s5.prototype.didClickAttributeButton = function(t4, e5) {
                var n3, i4, o3;
                return (i4 = this.delegate) != null && i4.toolbarDidClickButton(), t4.preventDefault(), n3 = f(e5), this.getDialog(n3) ? this.toggleDialog(n3) : (o3 = this.delegate) != null && o3.toolbarDidToggleAttribute(n3), this.refreshAttributeButtons();
              }, s5.prototype.didClickDialogButton = function(e5, n3) {
                var i4, o3;
                return i4 = t3(n3, { matchingSelector: p }), o3 = n3.getAttribute("data-trix-method"), this[o3].call(this, i4);
              }, s5.prototype.didKeyDownDialogInput = function(t4, e5) {
                var n3, i4;
                return t4.keyCode === 13 && (t4.preventDefault(), n3 = e5.getAttribute("name"), i4 = this.getDialog(n3), this.setAttribute(i4)), t4.keyCode === 27 ? (t4.preventDefault(), this.hideDialog()) : void 0;
              }, s5.prototype.updateActions = function(t4) {
                return this.actions = t4, this.refreshActionButtons();
              }, s5.prototype.refreshActionButtons = function() {
                return this.eachActionButton(function(t4) {
                  return function(e5, n3) {
                    return e5.disabled = t4.actions[n3] === false;
                  };
                }(this));
              }, s5.prototype.eachActionButton = function(t4) {
                var e5, n3, i4, o3, r3;
                for (o3 = this.element.querySelectorAll(a4), r3 = [], n3 = 0, i4 = o3.length; i4 > n3; n3++)
                  e5 = o3[n3], r3.push(t4(e5, d3(e5)));
                return r3;
              }, s5.prototype.updateAttributes = function(t4) {
                return this.attributes = t4, this.refreshAttributeButtons();
              }, s5.prototype.refreshAttributeButtons = function() {
                return this.eachAttributeButton(function(t4) {
                  return function(e5, n3) {
                    return e5.disabled = t4.attributes[n3] === false, t4.attributes[n3] || t4.dialogIsVisible(n3) ? (e5.setAttribute("data-trix-active", ""), e5.classList.add("trix-active")) : (e5.removeAttribute("data-trix-active"), e5.classList.remove("trix-active"));
                  };
                }(this));
              }, s5.prototype.eachAttributeButton = function(t4) {
                var e5, n3, i4, o3, r3;
                for (o3 = this.element.querySelectorAll(c2), r3 = [], n3 = 0, i4 = o3.length; i4 > n3; n3++)
                  e5 = o3[n3], r3.push(t4(e5, f(e5)));
                return r3;
              }, s5.prototype.applyKeyboardCommand = function(t4) {
                var e5, n3, o3, r3, s6, a5, u3;
                for (s6 = JSON.stringify(t4.sort()), u3 = this.element.querySelectorAll("[data-trix-key]"), r3 = 0, a5 = u3.length; a5 > r3; r3++)
                  if (e5 = u3[r3], o3 = e5.getAttribute("data-trix-key").split("+"), n3 = JSON.stringify(o3.sort()), n3 === s6)
                    return i3("mousedown", { onElement: e5 }), true;
                return false;
              }, s5.prototype.dialogIsVisible = function(t4) {
                var e5;
                return (e5 = this.getDialog(t4)) ? e5.hasAttribute("data-trix-active") : void 0;
              }, s5.prototype.toggleDialog = function(t4) {
                return this.dialogIsVisible(t4) ? this.hideDialog() : this.showDialog(t4);
              }, s5.prototype.showDialog = function(t4) {
                var e5, n3, i4, o3, r3, s6, a5, u3, c3, l3;
                for (this.hideDialog(), (a5 = this.delegate) != null && a5.toolbarWillShowDialog(), i4 = this.getDialog(t4), i4.setAttribute("data-trix-active", ""), i4.classList.add("trix-active"), u3 = i4.querySelectorAll("input[disabled]"), o3 = 0, s6 = u3.length; s6 > o3; o3++)
                  n3 = u3[o3], n3.removeAttribute("disabled");
                return (e5 = f(i4)) && (r3 = m3(i4, t4)) && (r3.value = (c3 = this.attributes[e5]) != null ? c3 : "", r3.select()), (l3 = this.delegate) != null ? l3.toolbarDidShowDialog(t4) : void 0;
              }, s5.prototype.setAttribute = function(t4) {
                var e5, n3, i4;
                return e5 = f(t4), n3 = m3(t4, e5), n3.willValidate && !n3.checkValidity() ? (n3.setAttribute("data-trix-validate", ""), n3.classList.add("trix-validate"), n3.focus()) : ((i4 = this.delegate) != null && i4.toolbarDidUpdateAttribute(e5, n3.value), this.hideDialog());
              }, s5.prototype.removeAttribute = function(t4) {
                var e5, n3;
                return e5 = f(t4), (n3 = this.delegate) != null && n3.toolbarDidRemoveAttribute(e5), this.hideDialog();
              }, s5.prototype.hideDialog = function() {
                var t4, e5;
                return (t4 = this.element.querySelector(u2)) ? (t4.removeAttribute("data-trix-active"), t4.classList.remove("trix-active"), this.resetDialogInputs(), (e5 = this.delegate) != null ? e5.toolbarDidHideDialog(g(t4)) : void 0) : void 0;
              }, s5.prototype.resetDialogInputs = function() {
                var t4, e5, n3, i4, o3;
                for (i4 = this.element.querySelectorAll(h5), o3 = [], t4 = 0, n3 = i4.length; n3 > t4; t4++)
                  e5 = i4[t4], e5.setAttribute("disabled", "disabled"), e5.removeAttribute("data-trix-validate"), o3.push(e5.classList.remove("trix-validate"));
                return o3;
              }, s5.prototype.getDialog = function(t4) {
                return this.element.querySelector("[data-trix-dialog=" + t4 + "]");
              }, m3 = function(t4, e5) {
                return e5 == null && (e5 = f(t4)), t4.querySelector("[data-trix-input][name='" + e5 + "']");
              }, d3 = function(t4) {
                return t4.getAttribute("data-trix-action");
              }, f = function(t4) {
                var e5;
                return (e5 = t4.getAttribute("data-trix-attribute")) != null ? e5 : t4.getAttribute("data-trix-dialog-attribute");
              }, g = function(t4) {
                return t4.getAttribute("data-trix-dialog");
              }, s5;
            }(e3.BasicObject);
          }.call(this), function() {
            var t3 = function(t4, e4) {
              function i3() {
                this.constructor = t4;
              }
              for (var o2 in e4)
                n2.call(e4, o2) && (t4[o2] = e4[o2]);
              return i3.prototype = e4.prototype, t4.prototype = new i3(), t4.__super__ = e4.prototype, t4;
            }, n2 = {}.hasOwnProperty;
            e3.ImagePreloadOperation = function(e4) {
              function n3(t4) {
                this.url = t4;
              }
              return t3(n3, e4), n3.prototype.perform = function(t4) {
                var e5;
                return e5 = new Image(), e5.onload = function(n4) {
                  return function() {
                    return e5.width = n4.width = e5.naturalWidth, e5.height = n4.height = e5.naturalHeight, t4(true, e5);
                  };
                }(this), e5.onerror = function() {
                  return t4(false);
                }, e5.src = this.url;
              }, n3;
            }(e3.Operation);
          }.call(this), function() {
            var t3 = function(t4, e4) {
              return function() {
                return t4.apply(e4, arguments);
              };
            }, n2 = function(t4, e4) {
              function n3() {
                this.constructor = t4;
              }
              for (var o2 in e4)
                i3.call(e4, o2) && (t4[o2] = e4[o2]);
              return n3.prototype = e4.prototype, t4.prototype = new n3(), t4.__super__ = e4.prototype, t4;
            }, i3 = {}.hasOwnProperty;
            e3.Attachment = function(i4) {
              function o2(n3) {
                n3 == null && (n3 = {}), this.releaseFile = t3(this.releaseFile, this), o2.__super__.constructor.apply(this, arguments), this.attributes = e3.Hash.box(n3), this.didChangeAttributes();
              }
              return n2(o2, i4), o2.previewablePattern = /^image(\/(gif|png|jpe?g)|$)/, o2.attachmentForFile = function(t4) {
                var e4, n3;
                return n3 = this.attributesForFile(t4), e4 = new this(n3), e4.setFile(t4), e4;
              }, o2.attributesForFile = function(t4) {
                return new e3.Hash({ filename: t4.name, filesize: t4.size, contentType: t4.type });
              }, o2.fromJSON = function(t4) {
                return new this(t4);
              }, o2.prototype.getAttribute = function(t4) {
                return this.attributes.get(t4);
              }, o2.prototype.hasAttribute = function(t4) {
                return this.attributes.has(t4);
              }, o2.prototype.getAttributes = function() {
                return this.attributes.toObject();
              }, o2.prototype.setAttributes = function(t4) {
                var e4, n3, i5;
                return t4 == null && (t4 = {}), e4 = this.attributes.merge(t4), this.attributes.isEqualTo(e4) ? void 0 : (this.attributes = e4, this.didChangeAttributes(), (n3 = this.previewDelegate) != null && typeof n3.attachmentDidChangeAttributes == "function" && n3.attachmentDidChangeAttributes(this), (i5 = this.delegate) != null && typeof i5.attachmentDidChangeAttributes == "function" ? i5.attachmentDidChangeAttributes(this) : void 0);
              }, o2.prototype.didChangeAttributes = function() {
                return this.isPreviewable() ? this.preloadURL() : void 0;
              }, o2.prototype.isPending = function() {
                return this.file != null && !(this.getURL() || this.getHref());
              }, o2.prototype.isPreviewable = function() {
                return this.attributes.has("previewable") ? this.attributes.get("previewable") : this.constructor.previewablePattern.test(this.getContentType());
              }, o2.prototype.getType = function() {
                return this.hasContent() ? "content" : this.isPreviewable() ? "preview" : "file";
              }, o2.prototype.getURL = function() {
                return this.attributes.get("url");
              }, o2.prototype.getHref = function() {
                return this.attributes.get("href");
              }, o2.prototype.getFilename = function() {
                var t4;
                return (t4 = this.attributes.get("filename")) != null ? t4 : "";
              }, o2.prototype.getFilesize = function() {
                return this.attributes.get("filesize");
              }, o2.prototype.getFormattedFilesize = function() {
                var t4;
                return t4 = this.attributes.get("filesize"), typeof t4 == "number" ? e3.config.fileSize.formatter(t4) : "";
              }, o2.prototype.getExtension = function() {
                var t4;
                return (t4 = this.getFilename().match(/\.(\w+)$/)) != null ? t4[1].toLowerCase() : void 0;
              }, o2.prototype.getContentType = function() {
                return this.attributes.get("contentType");
              }, o2.prototype.hasContent = function() {
                return this.attributes.has("content");
              }, o2.prototype.getContent = function() {
                return this.attributes.get("content");
              }, o2.prototype.getWidth = function() {
                return this.attributes.get("width");
              }, o2.prototype.getHeight = function() {
                return this.attributes.get("height");
              }, o2.prototype.getFile = function() {
                return this.file;
              }, o2.prototype.setFile = function(t4) {
                return this.file = t4, this.isPreviewable() ? this.preloadFile() : void 0;
              }, o2.prototype.releaseFile = function() {
                return this.releasePreloadedFile(), this.file = null;
              }, o2.prototype.getUploadProgress = function() {
                var t4;
                return (t4 = this.uploadProgress) != null ? t4 : 0;
              }, o2.prototype.setUploadProgress = function(t4) {
                var e4;
                return this.uploadProgress !== t4 ? (this.uploadProgress = t4, (e4 = this.uploadProgressDelegate) != null && typeof e4.attachmentDidChangeUploadProgress == "function" ? e4.attachmentDidChangeUploadProgress(this) : void 0) : void 0;
              }, o2.prototype.toJSON = function() {
                return this.getAttributes();
              }, o2.prototype.getCacheKey = function() {
                return [o2.__super__.getCacheKey.apply(this, arguments), this.attributes.getCacheKey(), this.getPreviewURL()].join("/");
              }, o2.prototype.getPreviewURL = function() {
                return this.previewURL || this.preloadingURL;
              }, o2.prototype.setPreviewURL = function(t4) {
                var e4, n3;
                return t4 !== this.getPreviewURL() ? (this.previewURL = t4, (e4 = this.previewDelegate) != null && typeof e4.attachmentDidChangeAttributes == "function" && e4.attachmentDidChangeAttributes(this), (n3 = this.delegate) != null && typeof n3.attachmentDidChangePreviewURL == "function" ? n3.attachmentDidChangePreviewURL(this) : void 0) : void 0;
              }, o2.prototype.preloadURL = function() {
                return this.preload(this.getURL(), this.releaseFile);
              }, o2.prototype.preloadFile = function() {
                return this.file ? (this.fileObjectURL = URL.createObjectURL(this.file), this.preload(this.fileObjectURL)) : void 0;
              }, o2.prototype.releasePreloadedFile = function() {
                return this.fileObjectURL ? (URL.revokeObjectURL(this.fileObjectURL), this.fileObjectURL = null) : void 0;
              }, o2.prototype.preload = function(t4, n3) {
                var i5;
                return t4 && t4 !== this.getPreviewURL() ? (this.preloadingURL = t4, i5 = new e3.ImagePreloadOperation(t4), i5.then(function(e4) {
                  return function(i6) {
                    var o3, r2;
                    return r2 = i6.width, o3 = i6.height, e4.getWidth() && e4.getHeight() || e4.setAttributes({ width: r2, height: o3 }), e4.preloadingURL = null, e4.setPreviewURL(t4), typeof n3 == "function" ? n3() : void 0;
                  };
                }(this))["catch"](function(t5) {
                  return function() {
                    return t5.preloadingURL = null, typeof n3 == "function" ? n3() : void 0;
                  };
                }(this))) : void 0;
              }, o2;
            }(e3.Object);
          }.call(this), function() {
            var t3 = function(t4, e4) {
              function i3() {
                this.constructor = t4;
              }
              for (var o2 in e4)
                n2.call(e4, o2) && (t4[o2] = e4[o2]);
              return i3.prototype = e4.prototype, t4.prototype = new i3(), t4.__super__ = e4.prototype, t4;
            }, n2 = {}.hasOwnProperty;
            e3.Piece = function(n3) {
              function i3(t4, n4) {
                n4 == null && (n4 = {}), i3.__super__.constructor.apply(this, arguments), this.attributes = e3.Hash.box(n4);
              }
              return t3(i3, n3), i3.types = {}, i3.registerType = function(t4, e4) {
                return e4.type = t4, this.types[t4] = e4;
              }, i3.fromJSON = function(t4) {
                var e4;
                return (e4 = this.types[t4.type]) ? e4.fromJSON(t4) : void 0;
              }, i3.prototype.copyWithAttributes = function(t4) {
                return new this.constructor(this.getValue(), t4);
              }, i3.prototype.copyWithAdditionalAttributes = function(t4) {
                return this.copyWithAttributes(this.attributes.merge(t4));
              }, i3.prototype.copyWithoutAttribute = function(t4) {
                return this.copyWithAttributes(this.attributes.remove(t4));
              }, i3.prototype.copy = function() {
                return this.copyWithAttributes(this.attributes);
              }, i3.prototype.getAttribute = function(t4) {
                return this.attributes.get(t4);
              }, i3.prototype.getAttributesHash = function() {
                return this.attributes;
              }, i3.prototype.getAttributes = function() {
                return this.attributes.toObject();
              }, i3.prototype.getCommonAttributes = function() {
                var t4, e4, n4;
                return (n4 = pieceList.getPieceAtIndex(0)) ? (t4 = n4.attributes, e4 = t4.getKeys(), pieceList.eachPiece(function(n5) {
                  return e4 = t4.getKeysCommonToHash(n5.attributes), t4 = t4.slice(e4);
                }), t4.toObject()) : {};
              }, i3.prototype.hasAttribute = function(t4) {
                return this.attributes.has(t4);
              }, i3.prototype.hasSameStringValueAsPiece = function(t4) {
                return t4 != null && this.toString() === t4.toString();
              }, i3.prototype.hasSameAttributesAsPiece = function(t4) {
                return t4 != null && (this.attributes === t4.attributes || this.attributes.isEqualTo(t4.attributes));
              }, i3.prototype.isBlockBreak = function() {
                return false;
              }, i3.prototype.isEqualTo = function(t4) {
                return i3.__super__.isEqualTo.apply(this, arguments) || this.hasSameConstructorAs(t4) && this.hasSameStringValueAsPiece(t4) && this.hasSameAttributesAsPiece(t4);
              }, i3.prototype.isEmpty = function() {
                return this.length === 0;
              }, i3.prototype.isSerializable = function() {
                return true;
              }, i3.prototype.toJSON = function() {
                return { type: this.constructor.type, attributes: this.getAttributes() };
              }, i3.prototype.contentsForInspection = function() {
                return { type: this.constructor.type, attributes: this.attributes.inspect() };
              }, i3.prototype.canBeGrouped = function() {
                return this.hasAttribute("href");
              }, i3.prototype.canBeGroupedWith = function(t4) {
                return this.getAttribute("href") === t4.getAttribute("href");
              }, i3.prototype.getLength = function() {
                return this.length;
              }, i3.prototype.canBeConsolidatedWith = function() {
                return false;
              }, i3;
            }(e3.Object);
          }.call(this), function() {
            var t3 = function(t4, e4) {
              function i3() {
                this.constructor = t4;
              }
              for (var o2 in e4)
                n2.call(e4, o2) && (t4[o2] = e4[o2]);
              return i3.prototype = e4.prototype, t4.prototype = new i3(), t4.__super__ = e4.prototype, t4;
            }, n2 = {}.hasOwnProperty;
            e3.Piece.registerType("attachment", e3.AttachmentPiece = function(n3) {
              function i3(t4) {
                this.attachment = t4, i3.__super__.constructor.apply(this, arguments), this.length = 1, this.ensureAttachmentExclusivelyHasAttribute("href"), this.attachment.hasContent() || this.removeProhibitedAttributes();
              }
              return t3(i3, n3), i3.fromJSON = function(t4) {
                return new this(e3.Attachment.fromJSON(t4.attachment), t4.attributes);
              }, i3.permittedAttributes = ["caption", "presentation"], i3.prototype.ensureAttachmentExclusivelyHasAttribute = function(t4) {
                return this.hasAttribute(t4) ? (this.attachment.hasAttribute(t4) || this.attachment.setAttributes(this.attributes.slice(t4)), this.attributes = this.attributes.remove(t4)) : void 0;
              }, i3.prototype.removeProhibitedAttributes = function() {
                var t4;
                return t4 = this.attributes.slice(this.constructor.permittedAttributes), t4.isEqualTo(this.attributes) ? void 0 : this.attributes = t4;
              }, i3.prototype.getValue = function() {
                return this.attachment;
              }, i3.prototype.isSerializable = function() {
                return !this.attachment.isPending();
              }, i3.prototype.getCaption = function() {
                var t4;
                return (t4 = this.attributes.get("caption")) != null ? t4 : "";
              }, i3.prototype.isEqualTo = function(t4) {
                var e4;
                return i3.__super__.isEqualTo.apply(this, arguments) && this.attachment.id === (t4 != null && (e4 = t4.attachment) != null ? e4.id : void 0);
              }, i3.prototype.toString = function() {
                return e3.OBJECT_REPLACEMENT_CHARACTER;
              }, i3.prototype.toJSON = function() {
                var t4;
                return t4 = i3.__super__.toJSON.apply(this, arguments), t4.attachment = this.attachment, t4;
              }, i3.prototype.getCacheKey = function() {
                return [i3.__super__.getCacheKey.apply(this, arguments), this.attachment.getCacheKey()].join("/");
              }, i3.prototype.toConsole = function() {
                return JSON.stringify(this.toString());
              }, i3;
            }(e3.Piece));
          }.call(this), function() {
            var t3, n2 = function(t4, e4) {
              function n3() {
                this.constructor = t4;
              }
              for (var o2 in e4)
                i3.call(e4, o2) && (t4[o2] = e4[o2]);
              return n3.prototype = e4.prototype, t4.prototype = new n3(), t4.__super__ = e4.prototype, t4;
            }, i3 = {}.hasOwnProperty;
            t3 = e3.normalizeNewlines, e3.Piece.registerType("string", e3.StringPiece = function(e4) {
              function i4(e5) {
                i4.__super__.constructor.apply(this, arguments), this.string = t3(e5), this.length = this.string.length;
              }
              return n2(i4, e4), i4.fromJSON = function(t4) {
                return new this(t4.string, t4.attributes);
              }, i4.prototype.getValue = function() {
                return this.string;
              }, i4.prototype.toString = function() {
                return this.string.toString();
              }, i4.prototype.isBlockBreak = function() {
                return this.toString() === "\n" && this.getAttribute("blockBreak") === true;
              }, i4.prototype.toJSON = function() {
                var t4;
                return t4 = i4.__super__.toJSON.apply(this, arguments), t4.string = this.string, t4;
              }, i4.prototype.canBeConsolidatedWith = function(t4) {
                return t4 != null && this.hasSameConstructorAs(t4) && this.hasSameAttributesAsPiece(t4);
              }, i4.prototype.consolidateWith = function(t4) {
                return new this.constructor(this.toString() + t4.toString(), this.attributes);
              }, i4.prototype.splitAtOffset = function(t4) {
                var e5, n3;
                return t4 === 0 ? (e5 = null, n3 = this) : t4 === this.length ? (e5 = this, n3 = null) : (e5 = new this.constructor(this.string.slice(0, t4), this.attributes), n3 = new this.constructor(this.string.slice(t4), this.attributes)), [e5, n3];
              }, i4.prototype.toConsole = function() {
                var t4;
                return t4 = this.string, t4.length > 15 && (t4 = t4.slice(0, 14) + "\u2026"), JSON.stringify(t4.toString());
              }, i4;
            }(e3.Piece));
          }.call(this), function() {
            var t3, n2 = function(t4, e4) {
              function n3() {
                this.constructor = t4;
              }
              for (var o3 in e4)
                i3.call(e4, o3) && (t4[o3] = e4[o3]);
              return n3.prototype = e4.prototype, t4.prototype = new n3(), t4.__super__ = e4.prototype, t4;
            }, i3 = {}.hasOwnProperty, o2 = [].slice;
            t3 = e3.spliceArray, e3.SplittableList = function(e4) {
              function i4(t4) {
                t4 == null && (t4 = []), i4.__super__.constructor.apply(this, arguments), this.objects = t4.slice(0), this.length = this.objects.length;
              }
              var r2, s4, a4;
              return n2(i4, e4), i4.box = function(t4) {
                return t4 instanceof this ? t4 : new this(t4);
              }, i4.prototype.indexOf = function(t4) {
                return this.objects.indexOf(t4);
              }, i4.prototype.splice = function() {
                var e5;
                return e5 = 1 <= arguments.length ? o2.call(arguments, 0) : [], new this.constructor(t3.apply(null, [this.objects].concat(o2.call(e5))));
              }, i4.prototype.eachObject = function(t4) {
                var e5, n3, i5, o3, r3, s5;
                for (r3 = this.objects, s5 = [], n3 = e5 = 0, i5 = r3.length; i5 > e5; n3 = ++e5)
                  o3 = r3[n3], s5.push(t4(o3, n3));
                return s5;
              }, i4.prototype.insertObjectAtIndex = function(t4, e5) {
                return this.splice(e5, 0, t4);
              }, i4.prototype.insertSplittableListAtIndex = function(t4, e5) {
                return this.splice.apply(this, [e5, 0].concat(o2.call(t4.objects)));
              }, i4.prototype.insertSplittableListAtPosition = function(t4, e5) {
                var n3, i5, o3;
                return o3 = this.splitObjectAtPosition(e5), i5 = o3[0], n3 = o3[1], new this.constructor(i5).insertSplittableListAtIndex(t4, n3);
              }, i4.prototype.editObjectAtIndex = function(t4, e5) {
                return this.replaceObjectAtIndex(e5(this.objects[t4]), t4);
              }, i4.prototype.replaceObjectAtIndex = function(t4, e5) {
                return this.splice(e5, 1, t4);
              }, i4.prototype.removeObjectAtIndex = function(t4) {
                return this.splice(t4, 1);
              }, i4.prototype.getObjectAtIndex = function(t4) {
                return this.objects[t4];
              }, i4.prototype.getSplittableListInRange = function(t4) {
                var e5, n3, i5, o3;
                return i5 = this.splitObjectsAtRange(t4), n3 = i5[0], e5 = i5[1], o3 = i5[2], new this.constructor(n3.slice(e5, o3 + 1));
              }, i4.prototype.selectSplittableList = function(t4) {
                var e5, n3;
                return n3 = function() {
                  var n4, i5, o3, r3;
                  for (o3 = this.objects, r3 = [], n4 = 0, i5 = o3.length; i5 > n4; n4++)
                    e5 = o3[n4], t4(e5) && r3.push(e5);
                  return r3;
                }.call(this), new this.constructor(n3);
              }, i4.prototype.removeObjectsInRange = function(t4) {
                var e5, n3, i5, o3;
                return i5 = this.splitObjectsAtRange(t4), n3 = i5[0], e5 = i5[1], o3 = i5[2], new this.constructor(n3).splice(e5, o3 - e5 + 1);
              }, i4.prototype.transformObjectsInRange = function(t4, e5) {
                var n3, i5, o3, r3, s5, a5, u2;
                return s5 = this.splitObjectsAtRange(t4), r3 = s5[0], i5 = s5[1], a5 = s5[2], u2 = function() {
                  var t5, s6, u3;
                  for (u3 = [], n3 = t5 = 0, s6 = r3.length; s6 > t5; n3 = ++t5)
                    o3 = r3[n3], u3.push(n3 >= i5 && a5 >= n3 ? e5(o3) : o3);
                  return u3;
                }(), new this.constructor(u2);
              }, i4.prototype.splitObjectsAtRange = function(t4) {
                var e5, n3, i5, o3, s5, u2;
                return o3 = this.splitObjectAtPosition(a4(t4)), n3 = o3[0], e5 = o3[1], i5 = o3[2], s5 = new this.constructor(n3).splitObjectAtPosition(r2(t4) + i5), n3 = s5[0], u2 = s5[1], [n3, e5, u2 - 1];
              }, i4.prototype.getObjectAtPosition = function(t4) {
                var e5, n3, i5;
                return i5 = this.findIndexAndOffsetAtPosition(t4), e5 = i5.index, n3 = i5.offset, this.objects[e5];
              }, i4.prototype.splitObjectAtPosition = function(t4) {
                var e5, n3, i5, o3, r3, s5, a5, u2, c2, l2;
                return s5 = this.findIndexAndOffsetAtPosition(t4), e5 = s5.index, r3 = s5.offset, o3 = this.objects.slice(0), e5 != null ? r3 === 0 ? (c2 = e5, l2 = 0) : (i5 = this.getObjectAtIndex(e5), a5 = i5.splitAtOffset(r3), n3 = a5[0], u2 = a5[1], o3.splice(e5, 1, n3, u2), c2 = e5 + 1, l2 = n3.getLength() - r3) : (c2 = o3.length, l2 = 0), [o3, c2, l2];
              }, i4.prototype.consolidate = function() {
                var t4, e5, n3, i5, o3, r3;
                for (i5 = [], o3 = this.objects[0], r3 = this.objects.slice(1), t4 = 0, e5 = r3.length; e5 > t4; t4++)
                  n3 = r3[t4], (typeof o3.canBeConsolidatedWith == "function" ? o3.canBeConsolidatedWith(n3) : void 0) ? o3 = o3.consolidateWith(n3) : (i5.push(o3), o3 = n3);
                return o3 != null && i5.push(o3), new this.constructor(i5);
              }, i4.prototype.consolidateFromIndexToIndex = function(t4, e5) {
                var n3, i5, r3;
                return i5 = this.objects.slice(0), r3 = i5.slice(t4, e5 + 1), n3 = new this.constructor(r3).consolidate().toArray(), this.splice.apply(this, [t4, r3.length].concat(o2.call(n3)));
              }, i4.prototype.findIndexAndOffsetAtPosition = function(t4) {
                var e5, n3, i5, o3, r3, s5, a5;
                for (e5 = 0, a5 = this.objects, i5 = n3 = 0, o3 = a5.length; o3 > n3; i5 = ++n3) {
                  if (s5 = a5[i5], r3 = e5 + s5.getLength(), t4 >= e5 && r3 > t4)
                    return { index: i5, offset: t4 - e5 };
                  e5 = r3;
                }
                return { index: null, offset: null };
              }, i4.prototype.findPositionAtIndexAndOffset = function(t4, e5) {
                var n3, i5, o3, r3, s5, a5;
                for (s5 = 0, a5 = this.objects, n3 = i5 = 0, o3 = a5.length; o3 > i5; n3 = ++i5)
                  if (r3 = a5[n3], t4 > n3)
                    s5 += r3.getLength();
                  else if (n3 === t4) {
                    s5 += e5;
                    break;
                  }
                return s5;
              }, i4.prototype.getEndPosition = function() {
                var t4, e5;
                return this.endPosition != null ? this.endPosition : this.endPosition = function() {
                  var n3, i5, o3;
                  for (e5 = 0, o3 = this.objects, n3 = 0, i5 = o3.length; i5 > n3; n3++)
                    t4 = o3[n3], e5 += t4.getLength();
                  return e5;
                }.call(this);
              }, i4.prototype.toString = function() {
                return this.objects.join("");
              }, i4.prototype.toArray = function() {
                return this.objects.slice(0);
              }, i4.prototype.toJSON = function() {
                return this.toArray();
              }, i4.prototype.isEqualTo = function(t4) {
                return i4.__super__.isEqualTo.apply(this, arguments) || s4(this.objects, t4 != null ? t4.objects : void 0);
              }, s4 = function(t4, e5) {
                var n3, i5, o3, r3, s5;
                if (e5 == null && (e5 = []), t4.length !== e5.length)
                  return false;
                for (s5 = true, i5 = n3 = 0, o3 = t4.length; o3 > n3; i5 = ++n3)
                  r3 = t4[i5], s5 && !r3.isEqualTo(e5[i5]) && (s5 = false);
                return s5;
              }, i4.prototype.contentsForInspection = function() {
                var t4;
                return { objects: "[" + function() {
                  var e5, n3, i5, o3;
                  for (i5 = this.objects, o3 = [], e5 = 0, n3 = i5.length; n3 > e5; e5++)
                    t4 = i5[e5], o3.push(t4.inspect());
                  return o3;
                }.call(this).join(", ") + "]" };
              }, a4 = function(t4) {
                return t4[0];
              }, r2 = function(t4) {
                return t4[1];
              }, i4;
            }(e3.Object);
          }.call(this), function() {
            var t3 = function(t4, e4) {
              function i3() {
                this.constructor = t4;
              }
              for (var o2 in e4)
                n2.call(e4, o2) && (t4[o2] = e4[o2]);
              return i3.prototype = e4.prototype, t4.prototype = new i3(), t4.__super__ = e4.prototype, t4;
            }, n2 = {}.hasOwnProperty;
            e3.Text = function(n3) {
              function i3(t4) {
                var n4;
                t4 == null && (t4 = []), i3.__super__.constructor.apply(this, arguments), this.pieceList = new e3.SplittableList(function() {
                  var e4, i4, o2;
                  for (o2 = [], e4 = 0, i4 = t4.length; i4 > e4; e4++)
                    n4 = t4[e4], n4.isEmpty() || o2.push(n4);
                  return o2;
                }());
              }
              return t3(i3, n3), i3.textForAttachmentWithAttributes = function(t4, n4) {
                var i4;
                return i4 = new e3.AttachmentPiece(t4, n4), new this([i4]);
              }, i3.textForStringWithAttributes = function(t4, n4) {
                var i4;
                return i4 = new e3.StringPiece(t4, n4), new this([i4]);
              }, i3.fromJSON = function(t4) {
                var n4, i4;
                return i4 = function() {
                  var i5, o2, r2;
                  for (r2 = [], i5 = 0, o2 = t4.length; o2 > i5; i5++)
                    n4 = t4[i5], r2.push(e3.Piece.fromJSON(n4));
                  return r2;
                }(), new this(i4);
              }, i3.prototype.copy = function() {
                return this.copyWithPieceList(this.pieceList);
              }, i3.prototype.copyWithPieceList = function(t4) {
                return new this.constructor(t4.consolidate().toArray());
              }, i3.prototype.copyUsingObjectMap = function(t4) {
                var e4, n4;
                return n4 = function() {
                  var n5, i4, o2, r2, s4;
                  for (o2 = this.getPieces(), s4 = [], n5 = 0, i4 = o2.length; i4 > n5; n5++)
                    e4 = o2[n5], s4.push((r2 = t4.find(e4)) != null ? r2 : e4);
                  return s4;
                }.call(this), new this.constructor(n4);
              }, i3.prototype.appendText = function(t4) {
                return this.insertTextAtPosition(t4, this.getLength());
              }, i3.prototype.insertTextAtPosition = function(t4, e4) {
                return this.copyWithPieceList(this.pieceList.insertSplittableListAtPosition(t4.pieceList, e4));
              }, i3.prototype.removeTextAtRange = function(t4) {
                return this.copyWithPieceList(this.pieceList.removeObjectsInRange(t4));
              }, i3.prototype.replaceTextAtRange = function(t4, e4) {
                return this.removeTextAtRange(e4).insertTextAtPosition(t4, e4[0]);
              }, i3.prototype.moveTextFromRangeToPosition = function(t4, e4) {
                var n4, i4;
                if (!(t4[0] <= e4 && e4 <= t4[1]))
                  return i4 = this.getTextAtRange(t4), n4 = i4.getLength(), t4[0] < e4 && (e4 -= n4), this.removeTextAtRange(t4).insertTextAtPosition(i4, e4);
              }, i3.prototype.addAttributeAtRange = function(t4, e4, n4) {
                var i4;
                return i4 = {}, i4[t4] = e4, this.addAttributesAtRange(i4, n4);
              }, i3.prototype.addAttributesAtRange = function(t4, e4) {
                return this.copyWithPieceList(this.pieceList.transformObjectsInRange(e4, function(e5) {
                  return e5.copyWithAdditionalAttributes(t4);
                }));
              }, i3.prototype.removeAttributeAtRange = function(t4, e4) {
                return this.copyWithPieceList(this.pieceList.transformObjectsInRange(e4, function(e5) {
                  return e5.copyWithoutAttribute(t4);
                }));
              }, i3.prototype.setAttributesAtRange = function(t4, e4) {
                return this.copyWithPieceList(this.pieceList.transformObjectsInRange(e4, function(e5) {
                  return e5.copyWithAttributes(t4);
                }));
              }, i3.prototype.getAttributesAtPosition = function(t4) {
                var e4, n4;
                return (e4 = (n4 = this.pieceList.getObjectAtPosition(t4)) != null ? n4.getAttributes() : void 0) != null ? e4 : {};
              }, i3.prototype.getCommonAttributes = function() {
                var t4, n4;
                return t4 = function() {
                  var t5, e4, i4, o2;
                  for (i4 = this.pieceList.toArray(), o2 = [], t5 = 0, e4 = i4.length; e4 > t5; t5++)
                    n4 = i4[t5], o2.push(n4.getAttributes());
                  return o2;
                }.call(this), e3.Hash.fromCommonAttributesOfObjects(t4).toObject();
              }, i3.prototype.getCommonAttributesAtRange = function(t4) {
                var e4;
                return (e4 = this.getTextAtRange(t4).getCommonAttributes()) != null ? e4 : {};
              }, i3.prototype.getExpandedRangeForAttributeAtOffset = function(t4, e4) {
                var n4, i4, o2;
                for (n4 = o2 = e4, i4 = this.getLength(); n4 > 0 && this.getCommonAttributesAtRange([n4 - 1, o2])[t4]; )
                  n4--;
                for (; i4 > o2 && this.getCommonAttributesAtRange([e4, o2 + 1])[t4]; )
                  o2++;
                return [n4, o2];
              }, i3.prototype.getTextAtRange = function(t4) {
                return this.copyWithPieceList(this.pieceList.getSplittableListInRange(t4));
              }, i3.prototype.getStringAtRange = function(t4) {
                return this.pieceList.getSplittableListInRange(t4).toString();
              }, i3.prototype.getStringAtPosition = function(t4) {
                return this.getStringAtRange([t4, t4 + 1]);
              }, i3.prototype.startsWithString = function(t4) {
                return this.getStringAtRange([0, t4.length]) === t4;
              }, i3.prototype.endsWithString = function(t4) {
                var e4;
                return e4 = this.getLength(), this.getStringAtRange([e4 - t4.length, e4]) === t4;
              }, i3.prototype.getAttachmentPieces = function() {
                var t4, e4, n4, i4, o2;
                for (i4 = this.pieceList.toArray(), o2 = [], t4 = 0, e4 = i4.length; e4 > t4; t4++)
                  n4 = i4[t4], n4.attachment != null && o2.push(n4);
                return o2;
              }, i3.prototype.getAttachments = function() {
                var t4, e4, n4, i4, o2;
                for (i4 = this.getAttachmentPieces(), o2 = [], t4 = 0, e4 = i4.length; e4 > t4; t4++)
                  n4 = i4[t4], o2.push(n4.attachment);
                return o2;
              }, i3.prototype.getAttachmentAndPositionById = function(t4) {
                var e4, n4, i4, o2, r2, s4;
                for (o2 = 0, r2 = this.pieceList.toArray(), e4 = 0, n4 = r2.length; n4 > e4; e4++) {
                  if (i4 = r2[e4], ((s4 = i4.attachment) != null ? s4.id : void 0) === t4)
                    return { attachment: i4.attachment, position: o2 };
                  o2 += i4.length;
                }
                return { attachment: null, position: null };
              }, i3.prototype.getAttachmentById = function(t4) {
                var e4, n4, i4;
                return i4 = this.getAttachmentAndPositionById(t4), e4 = i4.attachment, n4 = i4.position, e4;
              }, i3.prototype.getRangeOfAttachment = function(t4) {
                var e4, n4;
                return n4 = this.getAttachmentAndPositionById(t4.id), t4 = n4.attachment, e4 = n4.position, t4 != null ? [e4, e4 + 1] : void 0;
              }, i3.prototype.updateAttributesForAttachment = function(t4, e4) {
                var n4;
                return (n4 = this.getRangeOfAttachment(e4)) ? this.addAttributesAtRange(t4, n4) : this;
              }, i3.prototype.getLength = function() {
                return this.pieceList.getEndPosition();
              }, i3.prototype.isEmpty = function() {
                return this.getLength() === 0;
              }, i3.prototype.isEqualTo = function(t4) {
                var e4;
                return i3.__super__.isEqualTo.apply(this, arguments) || (t4 != null && (e4 = t4.pieceList) != null ? e4.isEqualTo(this.pieceList) : void 0);
              }, i3.prototype.isBlockBreak = function() {
                return this.getLength() === 1 && this.pieceList.getObjectAtIndex(0).isBlockBreak();
              }, i3.prototype.eachPiece = function(t4) {
                return this.pieceList.eachObject(t4);
              }, i3.prototype.getPieces = function() {
                return this.pieceList.toArray();
              }, i3.prototype.getPieceAtPosition = function(t4) {
                return this.pieceList.getObjectAtPosition(t4);
              }, i3.prototype.contentsForInspection = function() {
                return { pieceList: this.pieceList.inspect() };
              }, i3.prototype.toSerializableText = function() {
                var t4;
                return t4 = this.pieceList.selectSplittableList(function(t5) {
                  return t5.isSerializable();
                }), this.copyWithPieceList(t4);
              }, i3.prototype.toString = function() {
                return this.pieceList.toString();
              }, i3.prototype.toJSON = function() {
                return this.pieceList.toJSON();
              }, i3.prototype.toConsole = function() {
                var t4;
                return JSON.stringify(function() {
                  var e4, n4, i4, o2;
                  for (i4 = this.pieceList.toArray(), o2 = [], e4 = 0, n4 = i4.length; n4 > e4; e4++)
                    t4 = i4[e4], o2.push(JSON.parse(t4.toConsole()));
                  return o2;
                }.call(this));
              }, i3.prototype.getDirection = function() {
                return e3.getDirection(this.toString());
              }, i3.prototype.isRTL = function() {
                return this.getDirection() === "rtl";
              }, i3;
            }(e3.Object);
          }.call(this), function() {
            var t3, n2, i3, o2, r2, s4 = function(t4, e4) {
              function n3() {
                this.constructor = t4;
              }
              for (var i4 in e4)
                a4.call(e4, i4) && (t4[i4] = e4[i4]);
              return n3.prototype = e4.prototype, t4.prototype = new n3(), t4.__super__ = e4.prototype, t4;
            }, a4 = {}.hasOwnProperty, u2 = [].indexOf || function(t4) {
              for (var e4 = 0, n3 = this.length; n3 > e4; e4++)
                if (e4 in this && this[e4] === t4)
                  return e4;
              return -1;
            }, c2 = [].slice;
            t3 = e3.arraysAreEqual, r2 = e3.spliceArray, i3 = e3.getBlockConfig, n2 = e3.getBlockAttributeNames, o2 = e3.getListAttributeNames, e3.Block = function(n3) {
              function a5(t4, n4) {
                t4 == null && (t4 = new e3.Text()), n4 == null && (n4 = []), a5.__super__.constructor.apply(this, arguments), this.text = h5(t4), this.attributes = n4;
              }
              var l2, h5, p, d3, f, g, m3, v, y3;
              return s4(a5, n3), a5.fromJSON = function(t4) {
                var n4;
                return n4 = e3.Text.fromJSON(t4.text), new this(n4, t4.attributes);
              }, a5.prototype.isEmpty = function() {
                return this.text.isBlockBreak();
              }, a5.prototype.isEqualTo = function(e4) {
                return a5.__super__.isEqualTo.apply(this, arguments) || this.text.isEqualTo(e4 != null ? e4.text : void 0) && t3(this.attributes, e4 != null ? e4.attributes : void 0);
              }, a5.prototype.copyWithText = function(t4) {
                return new this.constructor(t4, this.attributes);
              }, a5.prototype.copyWithoutText = function() {
                return this.copyWithText(null);
              }, a5.prototype.copyWithAttributes = function(t4) {
                return new this.constructor(this.text, t4);
              }, a5.prototype.copyWithoutAttributes = function() {
                return this.copyWithAttributes(null);
              }, a5.prototype.copyUsingObjectMap = function(t4) {
                var e4;
                return this.copyWithText((e4 = t4.find(this.text)) ? e4 : this.text.copyUsingObjectMap(t4));
              }, a5.prototype.addAttribute = function(t4) {
                var e4;
                return e4 = this.attributes.concat(d3(t4)), this.copyWithAttributes(e4);
              }, a5.prototype.removeAttribute = function(t4) {
                var e4, n4;
                return n4 = i3(t4).listAttribute, e4 = g(g(this.attributes, t4), n4), this.copyWithAttributes(e4);
              }, a5.prototype.removeLastAttribute = function() {
                return this.removeAttribute(this.getLastAttribute());
              }, a5.prototype.getLastAttribute = function() {
                return f(this.attributes);
              }, a5.prototype.getAttributes = function() {
                return this.attributes.slice(0);
              }, a5.prototype.getAttributeLevel = function() {
                return this.attributes.length;
              }, a5.prototype.getAttributeAtLevel = function(t4) {
                return this.attributes[t4 - 1];
              }, a5.prototype.hasAttribute = function(t4) {
                return u2.call(this.attributes, t4) >= 0;
              }, a5.prototype.hasAttributes = function() {
                return this.getAttributeLevel() > 0;
              }, a5.prototype.getLastNestableAttribute = function() {
                return f(this.getNestableAttributes());
              }, a5.prototype.getNestableAttributes = function() {
                var t4, e4, n4, o3, r3;
                for (o3 = this.attributes, r3 = [], e4 = 0, n4 = o3.length; n4 > e4; e4++)
                  t4 = o3[e4], i3(t4).nestable && r3.push(t4);
                return r3;
              }, a5.prototype.getNestingLevel = function() {
                return this.getNestableAttributes().length;
              }, a5.prototype.decreaseNestingLevel = function() {
                var t4;
                return (t4 = this.getLastNestableAttribute()) ? this.removeAttribute(t4) : this;
              }, a5.prototype.increaseNestingLevel = function() {
                var t4, e4, n4;
                return (t4 = this.getLastNestableAttribute()) ? (n4 = this.attributes.lastIndexOf(t4), e4 = r2.apply(null, [this.attributes, n4 + 1, 0].concat(c2.call(d3(t4)))), this.copyWithAttributes(e4)) : this;
              }, a5.prototype.getListItemAttributes = function() {
                var t4, e4, n4, o3, r3;
                for (o3 = this.attributes, r3 = [], e4 = 0, n4 = o3.length; n4 > e4; e4++)
                  t4 = o3[e4], i3(t4).listAttribute && r3.push(t4);
                return r3;
              }, a5.prototype.isListItem = function() {
                var t4;
                return (t4 = i3(this.getLastAttribute())) != null ? t4.listAttribute : void 0;
              }, a5.prototype.isTerminalBlock = function() {
                var t4;
                return (t4 = i3(this.getLastAttribute())) != null ? t4.terminal : void 0;
              }, a5.prototype.breaksOnReturn = function() {
                var t4;
                return (t4 = i3(this.getLastAttribute())) != null ? t4.breakOnReturn : void 0;
              }, a5.prototype.findLineBreakInDirectionFromPosition = function(t4, e4) {
                var n4, i4;
                return i4 = this.toString(), n4 = function() {
                  switch (t4) {
                    case "forward":
                      return i4.indexOf("\n", e4);
                    case "backward":
                      return i4.slice(0, e4).lastIndexOf("\n");
                  }
                }(), n4 !== -1 ? n4 : void 0;
              }, a5.prototype.contentsForInspection = function() {
                return { text: this.text.inspect(), attributes: this.attributes };
              }, a5.prototype.toString = function() {
                return this.text.toString();
              }, a5.prototype.toJSON = function() {
                return { text: this.text, attributes: this.attributes };
              }, a5.prototype.getDirection = function() {
                return this.text.getDirection();
              }, a5.prototype.isRTL = function() {
                return this.text.isRTL();
              }, a5.prototype.getLength = function() {
                return this.text.getLength();
              }, a5.prototype.canBeConsolidatedWith = function(t4) {
                return !this.hasAttributes() && !t4.hasAttributes() && this.getDirection() === t4.getDirection();
              }, a5.prototype.consolidateWith = function(t4) {
                var n4, i4;
                return n4 = e3.Text.textForStringWithAttributes("\n"), i4 = this.getTextWithoutBlockBreak().appendText(n4), this.copyWithText(i4.appendText(t4.text));
              }, a5.prototype.splitAtOffset = function(t4) {
                var e4, n4;
                return t4 === 0 ? (e4 = null, n4 = this) : t4 === this.getLength() ? (e4 = this, n4 = null) : (e4 = this.copyWithText(this.text.getTextAtRange([0, t4])), n4 = this.copyWithText(this.text.getTextAtRange([t4, this.getLength()]))), [e4, n4];
              }, a5.prototype.getBlockBreakPosition = function() {
                return this.text.getLength() - 1;
              }, a5.prototype.getTextWithoutBlockBreak = function() {
                return m3(this.text) ? this.text.getTextAtRange([0, this.getBlockBreakPosition()]) : this.text.copy();
              }, a5.prototype.canBeGrouped = function(t4) {
                return this.attributes[t4];
              }, a5.prototype.canBeGroupedWith = function(t4, e4) {
                var n4, r3, s5, a6;
                return s5 = t4.getAttributes(), r3 = s5[e4], n4 = this.attributes[e4], !(n4 !== r3 || i3(n4).group === false && (a6 = s5[e4 + 1], u2.call(o2(), a6) < 0) || this.getDirection() !== t4.getDirection() && !t4.isEmpty());
              }, h5 = function(t4) {
                return t4 = y3(t4), t4 = l2(t4);
              }, y3 = function(t4) {
                var n4, i4, o3, r3, s5, a6;
                return r3 = false, a6 = t4.getPieces(), i4 = 2 <= a6.length ? c2.call(a6, 0, n4 = a6.length - 1) : (n4 = 0, []), o3 = a6[n4++], o3 == null ? t4 : (i4 = function() {
                  var t5, e4, n5;
                  for (n5 = [], t5 = 0, e4 = i4.length; e4 > t5; t5++)
                    s5 = i4[t5], s5.isBlockBreak() ? (r3 = true, n5.push(v(s5))) : n5.push(s5);
                  return n5;
                }(), r3 ? new e3.Text(c2.call(i4).concat([o3])) : t4);
              }, p = e3.Text.textForStringWithAttributes("\n", { blockBreak: true }), l2 = function(t4) {
                return m3(t4) ? t4 : t4.appendText(p);
              }, m3 = function(t4) {
                var e4, n4;
                return n4 = t4.getLength(), n4 === 0 ? false : (e4 = t4.getTextAtRange([n4 - 1, n4]), e4.isBlockBreak());
              }, v = function(t4) {
                return t4.copyWithoutAttribute("blockBreak");
              }, d3 = function(t4) {
                var e4;
                return e4 = i3(t4).listAttribute, e4 != null ? [e4, t4] : [t4];
              }, f = function(t4) {
                return t4.slice(-1)[0];
              }, g = function(t4, e4) {
                var n4;
                return n4 = t4.lastIndexOf(e4), n4 === -1 ? t4 : r2(t4, n4, 1);
              }, a5;
            }(e3.Object);
          }.call(this), function() {
            var t3, n2, i3, o2 = function(t4, e4) {
              function n3() {
                this.constructor = t4;
              }
              for (var i4 in e4)
                r2.call(e4, i4) && (t4[i4] = e4[i4]);
              return n3.prototype = e4.prototype, t4.prototype = new n3(), t4.__super__ = e4.prototype, t4;
            }, r2 = {}.hasOwnProperty, s4 = [].indexOf || function(t4) {
              for (var e4 = 0, n3 = this.length; n3 > e4; e4++)
                if (e4 in this && this[e4] === t4)
                  return e4;
              return -1;
            }, a4 = [].slice;
            n2 = e3.tagName, i3 = e3.walkTree, t3 = e3.nodeIsAttachmentElement, e3.HTMLSanitizer = function(r3) {
              function u2(t4, e4) {
                var n3;
                n3 = e4 != null ? e4 : {}, this.allowedAttributes = n3.allowedAttributes, this.forbiddenProtocols = n3.forbiddenProtocols, this.forbiddenElements = n3.forbiddenElements, this.allowedAttributes == null && (this.allowedAttributes = c2), this.forbiddenProtocols == null && (this.forbiddenProtocols = h5), this.forbiddenElements == null && (this.forbiddenElements = l2), this.body = p(t4);
              }
              var c2, l2, h5, p;
              return o2(u2, r3), c2 = "style href src width height class".split(" "), h5 = "javascript:".split(" "), l2 = "script iframe".split(" "), u2.sanitize = function(t4, e4) {
                var n3;
                return n3 = new this(t4, e4), n3.sanitize(), n3;
              }, u2.prototype.sanitize = function() {
                return this.sanitizeElements(), this.normalizeListElementNesting();
              }, u2.prototype.getHTML = function() {
                return this.body.innerHTML;
              }, u2.prototype.getBody = function() {
                return this.body;
              }, u2.prototype.sanitizeElements = function() {
                var t4, n3, o3, r4, s5;
                for (s5 = i3(this.body), r4 = []; s5.nextNode(); )
                  switch (o3 = s5.currentNode, o3.nodeType) {
                    case Node.ELEMENT_NODE:
                      this.elementIsRemovable(o3) ? r4.push(o3) : this.sanitizeElement(o3);
                      break;
                    case Node.COMMENT_NODE:
                      r4.push(o3);
                  }
                for (t4 = 0, n3 = r4.length; n3 > t4; t4++)
                  o3 = r4[t4], e3.removeNode(o3);
                return this.body;
              }, u2.prototype.sanitizeElement = function(t4) {
                var e4, n3, i4, o3, r4;
                for (t4.hasAttribute("href") && (o3 = t4.protocol, s4.call(this.forbiddenProtocols, o3) >= 0 && t4.removeAttribute("href")), r4 = a4.call(t4.attributes), e4 = 0, n3 = r4.length; n3 > e4; e4++)
                  i4 = r4[e4].name, s4.call(this.allowedAttributes, i4) >= 0 || i4.indexOf("data-trix") === 0 || t4.removeAttribute(i4);
                return t4;
              }, u2.prototype.normalizeListElementNesting = function() {
                var t4, e4, i4, o3, r4;
                for (r4 = a4.call(this.body.querySelectorAll("ul,ol")), t4 = 0, e4 = r4.length; e4 > t4; t4++)
                  i4 = r4[t4], (o3 = i4.previousElementSibling) && n2(o3) === "li" && o3.appendChild(i4);
                return this.body;
              }, u2.prototype.elementIsRemovable = function(t4) {
                return (t4 != null ? t4.nodeType : void 0) === Node.ELEMENT_NODE ? this.elementIsForbidden(t4) || this.elementIsntSerializable(t4) : void 0;
              }, u2.prototype.elementIsForbidden = function(t4) {
                var e4;
                return e4 = n2(t4), s4.call(this.forbiddenElements, e4) >= 0;
              }, u2.prototype.elementIsntSerializable = function(e4) {
                return e4.getAttribute("data-trix-serialize") === "false" && !t3(e4);
              }, p = function(t4) {
                var e4, n3, i4, o3, r4;
                for (t4 == null && (t4 = ""), t4 = t4.replace(/<\/html[^>]*>[^]*$/i, "</html>"), e4 = document.implementation.createHTMLDocument(""), e4.documentElement.innerHTML = t4, r4 = e4.head.querySelectorAll("style"), i4 = 0, o3 = r4.length; o3 > i4; i4++)
                  n3 = r4[i4], e4.body.appendChild(n3);
                return e4.body;
              }, u2;
            }(e3.BasicObject);
          }.call(this), function() {
            var t3, n2, i3, o2, r2, s4, a4, u2, c2, l2, h5, p = function(t4, e4) {
              function n3() {
                this.constructor = t4;
              }
              for (var i4 in e4)
                d3.call(e4, i4) && (t4[i4] = e4[i4]);
              return n3.prototype = e4.prototype, t4.prototype = new n3(), t4.__super__ = e4.prototype, t4;
            }, d3 = {}.hasOwnProperty, f = [].indexOf || function(t4) {
              for (var e4 = 0, n3 = this.length; n3 > e4; e4++)
                if (e4 in this && this[e4] === t4)
                  return e4;
              return -1;
            };
            t3 = e3.arraysAreEqual, s4 = e3.makeElement, l2 = e3.tagName, r2 = e3.getBlockTagNames, h5 = e3.walkTree, o2 = e3.findClosestElementFromNode, i3 = e3.elementContainsNode, a4 = e3.nodeIsAttachmentElement, u2 = e3.normalizeSpaces, n2 = e3.breakableWhitespacePattern, c2 = e3.squishBreakableWhitespace, e3.HTMLParser = function(d4) {
              function g(t4, e4) {
                this.html = t4, this.referenceElement = (e4 != null ? e4 : {}).referenceElement, this.blocks = [], this.blockElements = [], this.processedElements = [];
              }
              var m3, v, y3, b2, A, C, x2, w2, E2, S3, R2, k2;
              return p(g, d4), g.parse = function(t4, e4) {
                var n3;
                return n3 = new this(t4, e4), n3.parse(), n3;
              }, g.prototype.getDocument = function() {
                return e3.Document.fromJSON(this.blocks);
              }, g.prototype.parse = function() {
                var t4, n3;
                try {
                  for (this.createHiddenContainer(), t4 = e3.HTMLSanitizer.sanitize(this.html).getHTML(), this.containerElement.innerHTML = t4, n3 = h5(this.containerElement, { usingFilter: x2 }); n3.nextNode(); )
                    this.processNode(n3.currentNode);
                  return this.translateBlockElementMarginsToNewlines();
                } finally {
                  this.removeHiddenContainer();
                }
              }, g.prototype.createHiddenContainer = function() {
                return this.referenceElement ? (this.containerElement = this.referenceElement.cloneNode(false), this.containerElement.removeAttribute("id"), this.containerElement.setAttribute("data-trix-internal", ""), this.containerElement.style.display = "none", this.referenceElement.parentNode.insertBefore(this.containerElement, this.referenceElement.nextSibling)) : (this.containerElement = s4({ tagName: "div", style: { display: "none" } }), document.body.appendChild(this.containerElement));
              }, g.prototype.removeHiddenContainer = function() {
                return e3.removeNode(this.containerElement);
              }, x2 = function(t4) {
                return l2(t4) === "style" ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;
              }, g.prototype.processNode = function(t4) {
                switch (t4.nodeType) {
                  case Node.TEXT_NODE:
                    if (!this.isInsignificantTextNode(t4))
                      return this.appendBlockForTextNode(t4), this.processTextNode(t4);
                    break;
                  case Node.ELEMENT_NODE:
                    return this.appendBlockForElement(t4), this.processElement(t4);
                }
              }, g.prototype.appendBlockForTextNode = function(e4) {
                var n3, i4, o3;
                return i4 = e4.parentNode, i4 === this.currentBlockElement && this.isBlockElement(e4.previousSibling) ? this.appendStringWithAttributes("\n") : i4 !== this.containerElement && !this.isBlockElement(i4) || (n3 = this.getBlockAttributes(i4), t3(n3, (o3 = this.currentBlock) != null ? o3.attributes : void 0)) ? void 0 : (this.currentBlock = this.appendBlockForAttributesWithElement(n3, i4), this.currentBlockElement = i4);
              }, g.prototype.appendBlockForElement = function(e4) {
                var n3, o3, r3, s5;
                if (r3 = this.isBlockElement(e4), o3 = i3(this.currentBlockElement, e4), r3 && !this.isBlockElement(e4.firstChild)) {
                  if ((!this.isInsignificantTextNode(e4.firstChild) || !this.isBlockElement(e4.firstElementChild)) && (n3 = this.getBlockAttributes(e4), e4.firstChild))
                    return o3 && t3(n3, this.currentBlock.attributes) ? this.appendStringWithAttributes("\n") : (this.currentBlock = this.appendBlockForAttributesWithElement(n3, e4), this.currentBlockElement = e4);
                } else if (this.currentBlockElement && !o3 && !r3)
                  return (s5 = this.findParentBlockElement(e4)) ? this.appendBlockForElement(s5) : (this.currentBlock = this.appendEmptyBlock(), this.currentBlockElement = null);
              }, g.prototype.findParentBlockElement = function(t4) {
                var e4;
                for (e4 = t4.parentElement; e4 && e4 !== this.containerElement; ) {
                  if (this.isBlockElement(e4) && f.call(this.blockElements, e4) >= 0)
                    return e4;
                  e4 = e4.parentElement;
                }
                return null;
              }, g.prototype.processTextNode = function(t4) {
                var e4, n3;
                return n3 = t4.data, v(t4.parentNode) || (n3 = c2(n3), R2((e4 = t4.previousSibling) != null ? e4.textContent : void 0) && (n3 = A(n3))), this.appendStringWithAttributes(n3, this.getTextAttributes(t4.parentNode));
              }, g.prototype.processElement = function(t4) {
                var e4, n3, i4, o3, r3;
                if (a4(t4))
                  return e4 = w2(t4, "attachment"), Object.keys(e4).length && (o3 = this.getTextAttributes(t4), this.appendAttachmentWithAttributes(e4, o3), t4.innerHTML = ""), this.processedElements.push(t4);
                switch (l2(t4)) {
                  case "br":
                    return this.isExtraBR(t4) || this.isBlockElement(t4.nextSibling) || this.appendStringWithAttributes("\n", this.getTextAttributes(t4)), this.processedElements.push(t4);
                  case "img":
                    e4 = { url: t4.getAttribute("src"), contentType: "image" }, i4 = b2(t4);
                    for (n3 in i4)
                      r3 = i4[n3], e4[n3] = r3;
                    return this.appendAttachmentWithAttributes(e4, this.getTextAttributes(t4)), this.processedElements.push(t4);
                  case "tr":
                    if (t4.parentNode.firstChild !== t4)
                      return this.appendStringWithAttributes("\n");
                    break;
                  case "td":
                    if (t4.parentNode.firstChild !== t4)
                      return this.appendStringWithAttributes(" | ");
                }
              }, g.prototype.appendBlockForAttributesWithElement = function(t4, e4) {
                var n3;
                return this.blockElements.push(e4), n3 = m3(t4), this.blocks.push(n3), n3;
              }, g.prototype.appendEmptyBlock = function() {
                return this.appendBlockForAttributesWithElement([], null);
              }, g.prototype.appendStringWithAttributes = function(t4, e4) {
                return this.appendPiece(S3(t4, e4));
              }, g.prototype.appendAttachmentWithAttributes = function(t4, e4) {
                return this.appendPiece(E2(t4, e4));
              }, g.prototype.appendPiece = function(t4) {
                return this.blocks.length === 0 && this.appendEmptyBlock(), this.blocks[this.blocks.length - 1].text.push(t4);
              }, g.prototype.appendStringToTextAtIndex = function(t4, e4) {
                var n3, i4;
                return i4 = this.blocks[e4].text, n3 = i4[i4.length - 1], (n3 != null ? n3.type : void 0) === "string" ? n3.string += t4 : i4.push(S3(t4));
              }, g.prototype.prependStringToTextAtIndex = function(t4, e4) {
                var n3, i4;
                return i4 = this.blocks[e4].text, n3 = i4[0], (n3 != null ? n3.type : void 0) === "string" ? n3.string = t4 + n3.string : i4.unshift(S3(t4));
              }, S3 = function(t4, e4) {
                var n3;
                return e4 == null && (e4 = {}), n3 = "string", t4 = u2(t4), { string: t4, attributes: e4, type: n3 };
              }, E2 = function(t4, e4) {
                var n3;
                return e4 == null && (e4 = {}), n3 = "attachment", { attachment: t4, attributes: e4, type: n3 };
              }, m3 = function(t4) {
                var e4;
                return t4 == null && (t4 = {}), e4 = [], { text: e4, attributes: t4 };
              }, g.prototype.getTextAttributes = function(t4) {
                var n3, i4, r3, s5, u3, c3, l3, h6, p2, d5, f2, g2;
                r3 = {}, p2 = e3.config.textAttributes;
                for (n3 in p2)
                  if (u3 = p2[n3], u3.tagName && o2(t4, { matchingSelector: u3.tagName, untilNode: this.containerElement }))
                    r3[n3] = true;
                  else if (u3.parser) {
                    if (g2 = u3.parser(t4)) {
                      for (i4 = false, d5 = this.findBlockElementAncestors(t4), c3 = 0, h6 = d5.length; h6 > c3; c3++)
                        if (s5 = d5[c3], u3.parser(s5) === g2) {
                          i4 = true;
                          break;
                        }
                      i4 || (r3[n3] = g2);
                    }
                  } else
                    u3.styleProperty && (g2 = t4.style[u3.styleProperty]) && (r3[n3] = g2);
                if (a4(t4)) {
                  f2 = w2(t4, "attributes");
                  for (l3 in f2)
                    g2 = f2[l3], r3[l3] = g2;
                }
                return r3;
              }, g.prototype.getBlockAttributes = function(t4) {
                var n3, i4, o3, r3;
                for (i4 = []; t4 && t4 !== this.containerElement; ) {
                  r3 = e3.config.blockAttributes;
                  for (n3 in r3)
                    o3 = r3[n3], o3.parse !== false && l2(t4) === o3.tagName && ((typeof o3.test == "function" ? o3.test(t4) : void 0) || !o3.test) && (i4.push(n3), o3.listAttribute && i4.push(o3.listAttribute));
                  t4 = t4.parentNode;
                }
                return i4.reverse();
              }, g.prototype.findBlockElementAncestors = function(t4) {
                var e4, n3;
                for (e4 = []; t4 && t4 !== this.containerElement; )
                  n3 = l2(t4), f.call(r2(), n3) >= 0 && e4.push(t4), t4 = t4.parentNode;
                return e4;
              }, w2 = function(t4, e4) {
                try {
                  return JSON.parse(t4.getAttribute("data-trix-" + e4));
                } catch (n3) {
                  return {};
                }
              }, b2 = function(t4) {
                var e4, n3, i4;
                return i4 = t4.getAttribute("width"), n3 = t4.getAttribute("height"), e4 = {}, i4 && (e4.width = parseInt(i4, 10)), n3 && (e4.height = parseInt(n3, 10)), e4;
              }, g.prototype.isBlockElement = function(t4) {
                var e4;
                if ((t4 != null ? t4.nodeType : void 0) === Node.ELEMENT_NODE && !a4(t4) && !o2(t4, { matchingSelector: "td", untilNode: this.containerElement }))
                  return e4 = l2(t4), f.call(r2(), e4) >= 0 || window.getComputedStyle(t4).display === "block";
              }, g.prototype.isInsignificantTextNode = function(t4) {
                var e4, n3, i4;
                if ((t4 != null ? t4.nodeType : void 0) === Node.TEXT_NODE && k2(t4.data) && (n3 = t4.parentNode, i4 = t4.previousSibling, e4 = t4.nextSibling, (!C(n3.previousSibling) || this.isBlockElement(n3.previousSibling)) && !v(n3)))
                  return !i4 || this.isBlockElement(i4) || !e4 || this.isBlockElement(e4);
              }, g.prototype.isExtraBR = function(t4) {
                return l2(t4) === "br" && this.isBlockElement(t4.parentNode) && t4.parentNode.lastChild === t4;
              }, v = function(t4) {
                var e4;
                return e4 = window.getComputedStyle(t4).whiteSpace, e4 === "pre" || e4 === "pre-wrap" || e4 === "pre-line";
              }, C = function(t4) {
                return t4 && !R2(t4.textContent);
              }, g.prototype.translateBlockElementMarginsToNewlines = function() {
                var t4, e4, n3, i4, o3, r3, s5, a5;
                for (e4 = this.getMarginOfDefaultBlockElement(), s5 = this.blocks, a5 = [], i4 = n3 = 0, o3 = s5.length; o3 > n3; i4 = ++n3)
                  t4 = s5[i4], (r3 = this.getMarginOfBlockElementAtIndex(i4)) && (r3.top > 2 * e4.top && this.prependStringToTextAtIndex("\n", i4), a5.push(r3.bottom > 2 * e4.bottom ? this.appendStringToTextAtIndex("\n", i4) : void 0));
                return a5;
              }, g.prototype.getMarginOfBlockElementAtIndex = function(t4) {
                var e4, n3;
                return !(e4 = this.blockElements[t4]) || !e4.textContent || (n3 = l2(e4), f.call(r2(), n3) >= 0 || f.call(this.processedElements, e4) >= 0) ? void 0 : y3(e4);
              }, g.prototype.getMarginOfDefaultBlockElement = function() {
                var t4;
                return t4 = s4(e3.config.blockAttributes["default"].tagName), this.containerElement.appendChild(t4), y3(t4);
              }, y3 = function(t4) {
                var e4;
                return e4 = window.getComputedStyle(t4), e4.display === "block" ? { top: parseInt(e4.marginTop), bottom: parseInt(e4.marginBottom) } : void 0;
              }, A = function(t4) {
                return t4.replace(RegExp("^" + n2.source + "+"), "");
              }, k2 = function(t4) {
                return RegExp("^" + n2.source + "*$").test(t4);
              }, R2 = function(t4) {
                return /\s$/.test(t4);
              }, g;
            }(e3.BasicObject);
          }.call(this), function() {
            var t3, n2, i3, o2, r2 = function(t4, e4) {
              function n3() {
                this.constructor = t4;
              }
              for (var i4 in e4)
                s4.call(e4, i4) && (t4[i4] = e4[i4]);
              return n3.prototype = e4.prototype, t4.prototype = new n3(), t4.__super__ = e4.prototype, t4;
            }, s4 = {}.hasOwnProperty, a4 = [].slice, u2 = [].indexOf || function(t4) {
              for (var e4 = 0, n3 = this.length; n3 > e4; e4++)
                if (e4 in this && this[e4] === t4)
                  return e4;
              return -1;
            };
            t3 = e3.arraysAreEqual, i3 = e3.normalizeRange, o2 = e3.rangeIsCollapsed, n2 = e3.getBlockConfig, e3.Document = function(s5) {
              function c2(t4) {
                t4 == null && (t4 = []), c2.__super__.constructor.apply(this, arguments), t4.length === 0 && (t4 = [new e3.Block()]), this.blockList = e3.SplittableList.box(t4);
              }
              var l2;
              return r2(c2, s5), c2.fromJSON = function(t4) {
                var n3, i4;
                return i4 = function() {
                  var i5, o3, r3;
                  for (r3 = [], i5 = 0, o3 = t4.length; o3 > i5; i5++)
                    n3 = t4[i5], r3.push(e3.Block.fromJSON(n3));
                  return r3;
                }(), new this(i4);
              }, c2.fromHTML = function(t4, n3) {
                return e3.HTMLParser.parse(t4, n3).getDocument();
              }, c2.fromString = function(t4, n3) {
                var i4;
                return i4 = e3.Text.textForStringWithAttributes(t4, n3), new this([new e3.Block(i4)]);
              }, c2.prototype.isEmpty = function() {
                var t4;
                return this.blockList.length === 1 && (t4 = this.getBlockAtIndex(0), t4.isEmpty() && !t4.hasAttributes());
              }, c2.prototype.copy = function(t4) {
                var e4;
                return t4 == null && (t4 = {}), e4 = t4.consolidateBlocks ? this.blockList.consolidate().toArray() : this.blockList.toArray(), new this.constructor(e4);
              }, c2.prototype.copyUsingObjectsFromDocument = function(t4) {
                var n3;
                return n3 = new e3.ObjectMap(t4.getObjects()), this.copyUsingObjectMap(n3);
              }, c2.prototype.copyUsingObjectMap = function(t4) {
                var e4, n3, i4;
                return n3 = function() {
                  var n4, o3, r3, s6;
                  for (r3 = this.getBlocks(), s6 = [], n4 = 0, o3 = r3.length; o3 > n4; n4++)
                    e4 = r3[n4], s6.push((i4 = t4.find(e4)) ? i4 : e4.copyUsingObjectMap(t4));
                  return s6;
                }.call(this), new this.constructor(n3);
              }, c2.prototype.copyWithBaseBlockAttributes = function(t4) {
                var e4, n3, i4;
                return t4 == null && (t4 = []), i4 = function() {
                  var i5, o3, r3, s6;
                  for (r3 = this.getBlocks(), s6 = [], i5 = 0, o3 = r3.length; o3 > i5; i5++)
                    n3 = r3[i5], e4 = t4.concat(n3.getAttributes()), s6.push(n3.copyWithAttributes(e4));
                  return s6;
                }.call(this), new this.constructor(i4);
              }, c2.prototype.replaceBlock = function(t4, e4) {
                var n3;
                return n3 = this.blockList.indexOf(t4), n3 === -1 ? this : new this.constructor(this.blockList.replaceObjectAtIndex(e4, n3));
              }, c2.prototype.insertDocumentAtRange = function(t4, e4) {
                var n3, r3, s6, a5, u3, c3, l3;
                return r3 = t4.blockList, u3 = (e4 = i3(e4))[0], c3 = this.locationFromPosition(u3), s6 = c3.index, a5 = c3.offset, l3 = this, n3 = this.getBlockAtPosition(u3), o2(e4) && n3.isEmpty() && !n3.hasAttributes() ? l3 = new this.constructor(l3.blockList.removeObjectAtIndex(s6)) : n3.getBlockBreakPosition() === a5 && u3++, l3 = l3.removeTextAtRange(e4), new this.constructor(l3.blockList.insertSplittableListAtPosition(r3, u3));
              }, c2.prototype.mergeDocumentAtRange = function(e4, n3) {
                var o3, r3, s6, a5, u3, c3, l3, h5, p, d3, f, g;
                return f = (n3 = i3(n3))[0], d3 = this.locationFromPosition(f), r3 = this.getBlockAtIndex(d3.index).getAttributes(), o3 = e4.getBaseBlockAttributes(), g = r3.slice(-o3.length), t3(o3, g) ? (l3 = r3.slice(0, -o3.length), c3 = e4.copyWithBaseBlockAttributes(l3)) : c3 = e4.copy({ consolidateBlocks: true }).copyWithBaseBlockAttributes(r3), s6 = c3.getBlockCount(), a5 = c3.getBlockAtIndex(0), t3(r3, a5.getAttributes()) ? (u3 = a5.getTextWithoutBlockBreak(), p = this.insertTextAtRange(u3, n3), s6 > 1 && (c3 = new this.constructor(c3.getBlocks().slice(1)), h5 = f + u3.getLength(), p = p.insertDocumentAtRange(c3, h5))) : p = this.insertDocumentAtRange(c3, n3), p;
              }, c2.prototype.insertTextAtRange = function(t4, e4) {
                var n3, o3, r3, s6, a5;
                return a5 = (e4 = i3(e4))[0], s6 = this.locationFromPosition(a5), o3 = s6.index, r3 = s6.offset, n3 = this.removeTextAtRange(e4), new this.constructor(n3.blockList.editObjectAtIndex(o3, function(e5) {
                  return e5.copyWithText(e5.text.insertTextAtPosition(t4, r3));
                }));
              }, c2.prototype.removeTextAtRange = function(t4) {
                var e4, n3, r3, s6, a5, u3, c3, l3, h5, p, d3, f, g, m3, v, y3, b2, A, C, x2, w2;
                return p = t4 = i3(t4), l3 = p[0], A = p[1], o2(t4) ? this : (d3 = this.locationRangeFromRange(t4), u3 = d3[0], y3 = d3[1], a5 = u3.index, c3 = u3.offset, s6 = this.getBlockAtIndex(a5), v = y3.index, b2 = y3.offset, m3 = this.getBlockAtIndex(v), f = A - l3 === 1 && s6.getBlockBreakPosition() === c3 && m3.getBlockBreakPosition() !== b2 && m3.text.getStringAtPosition(b2) === "\n", f ? r3 = this.blockList.editObjectAtIndex(v, function(t5) {
                  return t5.copyWithText(t5.text.removeTextAtRange([b2, b2 + 1]));
                }) : (h5 = s6.text.getTextAtRange([0, c3]), C = m3.text.getTextAtRange([b2, m3.getLength()]), x2 = h5.appendText(C), g = a5 !== v && c3 === 0, w2 = g && s6.getAttributeLevel() >= m3.getAttributeLevel(), n3 = w2 ? m3.copyWithText(x2) : s6.copyWithText(x2), e4 = v + 1 - a5, r3 = this.blockList.splice(a5, e4, n3)), new this.constructor(r3));
              }, c2.prototype.moveTextFromRangeToPosition = function(t4, e4) {
                var n3, o3, r3, s6, u3, c3, l3, h5, p, d3;
                return c3 = t4 = i3(t4), p = c3[0], r3 = c3[1], e4 >= p && r3 >= e4 ? this : (o3 = this.getDocumentAtRange(t4), h5 = this.removeTextAtRange(t4), u3 = e4 > p, u3 && (e4 -= o3.getLength()), l3 = o3.getBlocks(), s6 = l3[0], n3 = 2 <= l3.length ? a4.call(l3, 1) : [], n3.length === 0 ? (d3 = s6.getTextWithoutBlockBreak(), u3 && (e4 += 1)) : d3 = s6.text, h5 = h5.insertTextAtRange(d3, e4), n3.length === 0 ? h5 : (o3 = new this.constructor(n3), e4 += d3.getLength(), h5.insertDocumentAtRange(o3, e4)));
              }, c2.prototype.addAttributeAtRange = function(t4, e4, i4) {
                var o3;
                return o3 = this.blockList, this.eachBlockAtRange(i4, function(i5, r3, s6) {
                  return o3 = o3.editObjectAtIndex(s6, function() {
                    return n2(t4) ? i5.addAttribute(t4, e4) : r3[0] === r3[1] ? i5 : i5.copyWithText(i5.text.addAttributeAtRange(t4, e4, r3));
                  });
                }), new this.constructor(o3);
              }, c2.prototype.addAttribute = function(t4, e4) {
                var n3;
                return n3 = this.blockList, this.eachBlock(function(i4, o3) {
                  return n3 = n3.editObjectAtIndex(o3, function() {
                    return i4.addAttribute(t4, e4);
                  });
                }), new this.constructor(n3);
              }, c2.prototype.removeAttributeAtRange = function(t4, e4) {
                var i4;
                return i4 = this.blockList, this.eachBlockAtRange(e4, function(e5, o3, r3) {
                  return n2(t4) ? i4 = i4.editObjectAtIndex(r3, function() {
                    return e5.removeAttribute(t4);
                  }) : o3[0] !== o3[1] ? i4 = i4.editObjectAtIndex(r3, function() {
                    return e5.copyWithText(e5.text.removeAttributeAtRange(t4, o3));
                  }) : void 0;
                }), new this.constructor(i4);
              }, c2.prototype.updateAttributesForAttachment = function(t4, e4) {
                var n3, i4, o3, r3;
                return o3 = (i4 = this.getRangeOfAttachment(e4))[0], n3 = this.locationFromPosition(o3).index, r3 = this.getTextAtIndex(n3), new this.constructor(this.blockList.editObjectAtIndex(n3, function(n4) {
                  return n4.copyWithText(r3.updateAttributesForAttachment(t4, e4));
                }));
              }, c2.prototype.removeAttributeForAttachment = function(t4, e4) {
                var n3;
                return n3 = this.getRangeOfAttachment(e4), this.removeAttributeAtRange(t4, n3);
              }, c2.prototype.insertBlockBreakAtRange = function(t4) {
                var n3, o3, r3, s6;
                return s6 = (t4 = i3(t4))[0], r3 = this.locationFromPosition(s6).offset, o3 = this.removeTextAtRange(t4), r3 === 0 && (n3 = [new e3.Block()]), new this.constructor(o3.blockList.insertSplittableListAtPosition(new e3.SplittableList(n3), s6));
              }, c2.prototype.applyBlockAttributeAtRange = function(t4, e4, i4) {
                var o3, r3, s6, a5;
                return s6 = this.expandRangeToLineBreaksAndSplitBlocks(i4), r3 = s6.document, i4 = s6.range, o3 = n2(t4), o3.listAttribute ? (r3 = r3.removeLastListAttributeAtRange(i4, { exceptAttributeName: t4 }), a5 = r3.convertLineBreaksToBlockBreaksInRange(i4), r3 = a5.document, i4 = a5.range) : r3 = o3.exclusive ? r3.removeBlockAttributesAtRange(i4) : o3.terminal ? r3.removeLastTerminalAttributeAtRange(i4) : r3.consolidateBlocksAtRange(i4), r3.addAttributeAtRange(t4, e4, i4);
              }, c2.prototype.removeLastListAttributeAtRange = function(t4, e4) {
                var i4;
                return e4 == null && (e4 = {}), i4 = this.blockList, this.eachBlockAtRange(t4, function(t5, o3, r3) {
                  var s6;
                  if ((s6 = t5.getLastAttribute()) && n2(s6).listAttribute && s6 !== e4.exceptAttributeName)
                    return i4 = i4.editObjectAtIndex(r3, function() {
                      return t5.removeAttribute(s6);
                    });
                }), new this.constructor(i4);
              }, c2.prototype.removeLastTerminalAttributeAtRange = function(t4) {
                var e4;
                return e4 = this.blockList, this.eachBlockAtRange(t4, function(t5, i4, o3) {
                  var r3;
                  if ((r3 = t5.getLastAttribute()) && n2(r3).terminal)
                    return e4 = e4.editObjectAtIndex(o3, function() {
                      return t5.removeAttribute(r3);
                    });
                }), new this.constructor(e4);
              }, c2.prototype.removeBlockAttributesAtRange = function(t4) {
                var e4;
                return e4 = this.blockList, this.eachBlockAtRange(t4, function(t5, n3, i4) {
                  return t5.hasAttributes() ? e4 = e4.editObjectAtIndex(i4, function() {
                    return t5.copyWithoutAttributes();
                  }) : void 0;
                }), new this.constructor(e4);
              }, c2.prototype.expandRangeToLineBreaksAndSplitBlocks = function(t4) {
                var e4, n3, o3, r3, s6, a5, u3, c3, l3;
                return a5 = t4 = i3(t4), l3 = a5[0], r3 = a5[1], c3 = this.locationFromPosition(l3), o3 = this.locationFromPosition(r3), e4 = this, u3 = e4.getBlockAtIndex(c3.index), (c3.offset = u3.findLineBreakInDirectionFromPosition("backward", c3.offset)) != null && (s6 = e4.positionFromLocation(c3), e4 = e4.insertBlockBreakAtRange([s6, s6 + 1]), o3.index += 1, o3.offset -= e4.getBlockAtIndex(c3.index).getLength(), c3.index += 1), c3.offset = 0, o3.offset === 0 && o3.index > c3.index ? (o3.index -= 1, o3.offset = e4.getBlockAtIndex(o3.index).getBlockBreakPosition()) : (n3 = e4.getBlockAtIndex(o3.index), n3.text.getStringAtRange([o3.offset - 1, o3.offset]) === "\n" ? o3.offset -= 1 : o3.offset = n3.findLineBreakInDirectionFromPosition("forward", o3.offset), o3.offset !== n3.getBlockBreakPosition() && (s6 = e4.positionFromLocation(o3), e4 = e4.insertBlockBreakAtRange([s6, s6 + 1]))), l3 = e4.positionFromLocation(c3), r3 = e4.positionFromLocation(o3), t4 = i3([l3, r3]), { document: e4, range: t4 };
              }, c2.prototype.convertLineBreaksToBlockBreaksInRange = function(t4) {
                var e4, n3, o3;
                return n3 = (t4 = i3(t4))[0], o3 = this.getStringAtRange(t4).slice(0, -1), e4 = this, o3.replace(/.*?\n/g, function(t5) {
                  return n3 += t5.length, e4 = e4.insertBlockBreakAtRange([n3 - 1, n3]);
                }), { document: e4, range: t4 };
              }, c2.prototype.consolidateBlocksAtRange = function(t4) {
                var e4, n3, o3, r3, s6;
                return o3 = t4 = i3(t4), s6 = o3[0], n3 = o3[1], r3 = this.locationFromPosition(s6).index, e4 = this.locationFromPosition(n3).index, new this.constructor(this.blockList.consolidateFromIndexToIndex(r3, e4));
              }, c2.prototype.getDocumentAtRange = function(t4) {
                var e4;
                return t4 = i3(t4), e4 = this.blockList.getSplittableListInRange(t4).toArray(), new this.constructor(e4);
              }, c2.prototype.getStringAtRange = function(t4) {
                var e4, n3, o3;
                return o3 = t4 = i3(t4), n3 = o3[o3.length - 1], n3 !== this.getLength() && (e4 = -1), this.getDocumentAtRange(t4).toString().slice(0, e4);
              }, c2.prototype.getBlockAtIndex = function(t4) {
                return this.blockList.getObjectAtIndex(t4);
              }, c2.prototype.getBlockAtPosition = function(t4) {
                var e4;
                return e4 = this.locationFromPosition(t4).index, this.getBlockAtIndex(e4);
              }, c2.prototype.getTextAtIndex = function(t4) {
                var e4;
                return (e4 = this.getBlockAtIndex(t4)) != null ? e4.text : void 0;
              }, c2.prototype.getTextAtPosition = function(t4) {
                var e4;
                return e4 = this.locationFromPosition(t4).index, this.getTextAtIndex(e4);
              }, c2.prototype.getPieceAtPosition = function(t4) {
                var e4, n3, i4;
                return i4 = this.locationFromPosition(t4), e4 = i4.index, n3 = i4.offset, this.getTextAtIndex(e4).getPieceAtPosition(n3);
              }, c2.prototype.getCharacterAtPosition = function(t4) {
                var e4, n3, i4;
                return i4 = this.locationFromPosition(t4), e4 = i4.index, n3 = i4.offset, this.getTextAtIndex(e4).getStringAtRange([n3, n3 + 1]);
              }, c2.prototype.getLength = function() {
                return this.blockList.getEndPosition();
              }, c2.prototype.getBlocks = function() {
                return this.blockList.toArray();
              }, c2.prototype.getBlockCount = function() {
                return this.blockList.length;
              }, c2.prototype.getEditCount = function() {
                return this.editCount;
              }, c2.prototype.eachBlock = function(t4) {
                return this.blockList.eachObject(t4);
              }, c2.prototype.eachBlockAtRange = function(t4, e4) {
                var n3, o3, r3, s6, a5, u3, c3, l3, h5, p, d3, f;
                if (u3 = t4 = i3(t4), d3 = u3[0], r3 = u3[1], p = this.locationFromPosition(d3), o3 = this.locationFromPosition(r3), p.index === o3.index)
                  return n3 = this.getBlockAtIndex(p.index), f = [p.offset, o3.offset], e4(n3, f, p.index);
                for (h5 = [], a5 = s6 = c3 = p.index, l3 = o3.index; l3 >= c3 ? l3 >= s6 : s6 >= l3; a5 = l3 >= c3 ? ++s6 : --s6)
                  (n3 = this.getBlockAtIndex(a5)) ? (f = function() {
                    switch (a5) {
                      case p.index:
                        return [p.offset, n3.text.getLength()];
                      case o3.index:
                        return [0, o3.offset];
                      default:
                        return [0, n3.text.getLength()];
                    }
                  }(), h5.push(e4(n3, f, a5))) : h5.push(void 0);
                return h5;
              }, c2.prototype.getCommonAttributesAtRange = function(t4) {
                var n3, r3, s6;
                return r3 = (t4 = i3(t4))[0], o2(t4) ? this.getCommonAttributesAtPosition(r3) : (s6 = [], n3 = [], this.eachBlockAtRange(t4, function(t5, e4) {
                  return e4[0] !== e4[1] ? (s6.push(t5.text.getCommonAttributesAtRange(e4)), n3.push(l2(t5))) : void 0;
                }), e3.Hash.fromCommonAttributesOfObjects(s6).merge(e3.Hash.fromCommonAttributesOfObjects(n3)).toObject());
              }, c2.prototype.getCommonAttributesAtPosition = function(t4) {
                var n3, i4, o3, r3, s6, a5, c3, h5, p, d3;
                if (p = this.locationFromPosition(t4), s6 = p.index, h5 = p.offset, o3 = this.getBlockAtIndex(s6), !o3)
                  return {};
                r3 = l2(o3), n3 = o3.text.getAttributesAtPosition(h5), i4 = o3.text.getAttributesAtPosition(h5 - 1), a5 = function() {
                  var t5, n4;
                  t5 = e3.config.textAttributes, n4 = [];
                  for (c3 in t5)
                    d3 = t5[c3], d3.inheritable && n4.push(c3);
                  return n4;
                }();
                for (c3 in i4)
                  d3 = i4[c3], (d3 === n3[c3] || u2.call(a5, c3) >= 0) && (r3[c3] = d3);
                return r3;
              }, c2.prototype.getRangeOfCommonAttributeAtPosition = function(t4, e4) {
                var n3, o3, r3, s6, a5, u3, c3, l3, h5;
                return a5 = this.locationFromPosition(e4), r3 = a5.index, s6 = a5.offset, h5 = this.getTextAtIndex(r3), u3 = h5.getExpandedRangeForAttributeAtOffset(t4, s6), l3 = u3[0], o3 = u3[1], c3 = this.positionFromLocation({ index: r3, offset: l3 }), n3 = this.positionFromLocation({ index: r3, offset: o3 }), i3([c3, n3]);
              }, c2.prototype.getBaseBlockAttributes = function() {
                var t4, e4, n3, i4, o3, r3, s6;
                for (t4 = this.getBlockAtIndex(0).getAttributes(), n3 = i4 = 1, s6 = this.getBlockCount(); s6 >= 1 ? s6 > i4 : i4 > s6; n3 = s6 >= 1 ? ++i4 : --i4)
                  e4 = this.getBlockAtIndex(n3).getAttributes(), r3 = Math.min(t4.length, e4.length), t4 = function() {
                    var n4, i5, s7;
                    for (s7 = [], o3 = n4 = 0, i5 = r3; (i5 >= 0 ? i5 > n4 : n4 > i5) && e4[o3] === t4[o3]; o3 = i5 >= 0 ? ++n4 : --n4)
                      s7.push(e4[o3]);
                    return s7;
                  }();
                return t4;
              }, l2 = function(t4) {
                var e4, n3;
                return n3 = {}, (e4 = t4.getLastAttribute()) && (n3[e4] = true), n3;
              }, c2.prototype.getAttachmentById = function(t4) {
                var e4, n3, i4, o3;
                for (o3 = this.getAttachments(), n3 = 0, i4 = o3.length; i4 > n3; n3++)
                  if (e4 = o3[n3], e4.id === t4)
                    return e4;
              }, c2.prototype.getAttachmentPieces = function() {
                var t4;
                return t4 = [], this.blockList.eachObject(function(e4) {
                  var n3;
                  return n3 = e4.text, t4 = t4.concat(n3.getAttachmentPieces());
                }), t4;
              }, c2.prototype.getAttachments = function() {
                var t4, e4, n3, i4, o3;
                for (i4 = this.getAttachmentPieces(), o3 = [], t4 = 0, e4 = i4.length; e4 > t4; t4++)
                  n3 = i4[t4], o3.push(n3.attachment);
                return o3;
              }, c2.prototype.getRangeOfAttachment = function(t4) {
                var e4, n3, o3, r3, s6, a5, u3;
                for (r3 = 0, s6 = this.blockList.toArray(), n3 = e4 = 0, o3 = s6.length; o3 > e4; n3 = ++e4) {
                  if (a5 = s6[n3].text, u3 = a5.getRangeOfAttachment(t4))
                    return i3([r3 + u3[0], r3 + u3[1]]);
                  r3 += a5.getLength();
                }
              }, c2.prototype.getLocationRangeOfAttachment = function(t4) {
                var e4;
                return e4 = this.getRangeOfAttachment(t4), this.locationRangeFromRange(e4);
              }, c2.prototype.getAttachmentPieceForAttachment = function(t4) {
                var e4, n3, i4, o3;
                for (o3 = this.getAttachmentPieces(), e4 = 0, n3 = o3.length; n3 > e4; e4++)
                  if (i4 = o3[e4], i4.attachment === t4)
                    return i4;
              }, c2.prototype.findRangesForBlockAttribute = function(t4) {
                var e4, n3, i4, o3, r3, s6, a5;
                for (r3 = 0, s6 = [], a5 = this.getBlocks(), n3 = 0, i4 = a5.length; i4 > n3; n3++)
                  e4 = a5[n3], o3 = e4.getLength(), e4.hasAttribute(t4) && s6.push([r3, r3 + o3]), r3 += o3;
                return s6;
              }, c2.prototype.findRangesForTextAttribute = function(t4, e4) {
                var n3, i4, o3, r3, s6, a5, u3, c3, l3, h5;
                for (h5 = (e4 != null ? e4 : {}).withValue, a5 = 0, u3 = [], c3 = [], r3 = function(e5) {
                  return h5 != null ? e5.getAttribute(t4) === h5 : e5.hasAttribute(t4);
                }, l3 = this.getPieces(), n3 = 0, i4 = l3.length; i4 > n3; n3++)
                  s6 = l3[n3], o3 = s6.getLength(), r3(s6) && (u3[1] === a5 ? u3[1] = a5 + o3 : c3.push(u3 = [a5, a5 + o3])), a5 += o3;
                return c3;
              }, c2.prototype.locationFromPosition = function(t4) {
                var e4, n3;
                return n3 = this.blockList.findIndexAndOffsetAtPosition(Math.max(0, t4)), n3.index != null ? n3 : (e4 = this.getBlocks(), { index: e4.length - 1, offset: e4[e4.length - 1].getLength() });
              }, c2.prototype.positionFromLocation = function(t4) {
                return this.blockList.findPositionAtIndexAndOffset(t4.index, t4.offset);
              }, c2.prototype.locationRangeFromPosition = function(t4) {
                return i3(this.locationFromPosition(t4));
              }, c2.prototype.locationRangeFromRange = function(t4) {
                var e4, n3, o3, r3;
                if (t4 = i3(t4))
                  return r3 = t4[0], n3 = t4[1], o3 = this.locationFromPosition(r3), e4 = this.locationFromPosition(n3), i3([o3, e4]);
              }, c2.prototype.rangeFromLocationRange = function(t4) {
                var e4, n3;
                return t4 = i3(t4), e4 = this.positionFromLocation(t4[0]), o2(t4) || (n3 = this.positionFromLocation(t4[1])), i3([e4, n3]);
              }, c2.prototype.isEqualTo = function(t4) {
                return this.blockList.isEqualTo(t4 != null ? t4.blockList : void 0);
              }, c2.prototype.getTexts = function() {
                var t4, e4, n3, i4, o3;
                for (i4 = this.getBlocks(), o3 = [], e4 = 0, n3 = i4.length; n3 > e4; e4++)
                  t4 = i4[e4], o3.push(t4.text);
                return o3;
              }, c2.prototype.getPieces = function() {
                var t4, e4, n3, i4, o3;
                for (n3 = [], i4 = this.getTexts(), t4 = 0, e4 = i4.length; e4 > t4; t4++)
                  o3 = i4[t4], n3.push.apply(n3, o3.getPieces());
                return n3;
              }, c2.prototype.getObjects = function() {
                return this.getBlocks().concat(this.getTexts()).concat(this.getPieces());
              }, c2.prototype.toSerializableDocument = function() {
                var t4;
                return t4 = [], this.blockList.eachObject(function(e4) {
                  return t4.push(e4.copyWithText(e4.text.toSerializableText()));
                }), new this.constructor(t4);
              }, c2.prototype.toString = function() {
                return this.blockList.toString();
              }, c2.prototype.toJSON = function() {
                return this.blockList.toJSON();
              }, c2.prototype.toConsole = function() {
                var t4;
                return JSON.stringify(function() {
                  var e4, n3, i4, o3;
                  for (i4 = this.blockList.toArray(), o3 = [], e4 = 0, n3 = i4.length; n3 > e4; e4++)
                    t4 = i4[e4], o3.push(JSON.parse(t4.text.toConsole()));
                  return o3;
                }.call(this));
              }, c2;
            }(e3.Object);
          }.call(this), function() {
            e3.LineBreakInsertion = function() {
              function t3(t4) {
                var e4;
                this.composition = t4, this.document = this.composition.document, e4 = this.composition.getSelectedRange(), this.startPosition = e4[0], this.endPosition = e4[1], this.startLocation = this.document.locationFromPosition(this.startPosition), this.endLocation = this.document.locationFromPosition(this.endPosition), this.block = this.document.getBlockAtIndex(this.endLocation.index), this.breaksOnReturn = this.block.breaksOnReturn(), this.previousCharacter = this.block.text.getStringAtPosition(this.endLocation.offset - 1), this.nextCharacter = this.block.text.getStringAtPosition(this.endLocation.offset);
              }
              return t3.prototype.shouldInsertBlockBreak = function() {
                return this.block.hasAttributes() && this.block.isListItem() && !this.block.isEmpty() ? this.startLocation.offset !== 0 : this.breaksOnReturn && this.nextCharacter !== "\n";
              }, t3.prototype.shouldBreakFormattedBlock = function() {
                return this.block.hasAttributes() && !this.block.isListItem() && (this.breaksOnReturn && this.nextCharacter === "\n" || this.previousCharacter === "\n");
              }, t3.prototype.shouldDecreaseListLevel = function() {
                return this.block.hasAttributes() && this.block.isListItem() && this.block.isEmpty();
              }, t3.prototype.shouldPrependListItem = function() {
                return this.block.isListItem() && this.startLocation.offset === 0 && !this.block.isEmpty();
              }, t3.prototype.shouldRemoveLastBlockAttribute = function() {
                return this.block.hasAttributes() && !this.block.isListItem() && this.block.isEmpty();
              }, t3;
            }();
          }.call(this), function() {
            var t3, n2, i3, o2, r2, s4, a4, u2, c2, l2, h5 = function(t4, e4) {
              function n3() {
                this.constructor = t4;
              }
              for (var i4 in e4)
                p.call(e4, i4) && (t4[i4] = e4[i4]);
              return n3.prototype = e4.prototype, t4.prototype = new n3(), t4.__super__ = e4.prototype, t4;
            }, p = {}.hasOwnProperty;
            s4 = e3.normalizeRange, c2 = e3.rangesAreEqual, u2 = e3.rangeIsCollapsed, a4 = e3.objectsAreEqual, t3 = e3.arrayStartsWith, l2 = e3.summarizeArrayChange, i3 = e3.getAllAttributeNames, o2 = e3.getBlockConfig, r2 = e3.getTextConfig, n2 = e3.extend, e3.Composition = function(p2) {
              function d3() {
                this.document = new e3.Document(), this.attachments = [], this.currentAttributes = {}, this.revision = 0;
              }
              var f;
              return h5(d3, p2), d3.prototype.setDocument = function(t4) {
                var e4;
                return t4.isEqualTo(this.document) ? void 0 : (this.document = t4, this.refreshAttachments(), this.revision++, (e4 = this.delegate) != null && typeof e4.compositionDidChangeDocument == "function" ? e4.compositionDidChangeDocument(t4) : void 0);
              }, d3.prototype.getSnapshot = function() {
                return { document: this.document, selectedRange: this.getSelectedRange() };
              }, d3.prototype.loadSnapshot = function(t4) {
                var n3, i4, o3, r3;
                return n3 = t4.document, r3 = t4.selectedRange, (i4 = this.delegate) != null && typeof i4.compositionWillLoadSnapshot == "function" && i4.compositionWillLoadSnapshot(), this.setDocument(n3 != null ? n3 : new e3.Document()), this.setSelection(r3 != null ? r3 : [0, 0]), (o3 = this.delegate) != null && typeof o3.compositionDidLoadSnapshot == "function" ? o3.compositionDidLoadSnapshot() : void 0;
              }, d3.prototype.insertText = function(t4, e4) {
                var n3, i4, o3, r3;
                return r3 = (e4 != null ? e4 : { updatePosition: true }).updatePosition, i4 = this.getSelectedRange(), this.setDocument(this.document.insertTextAtRange(t4, i4)), o3 = i4[0], n3 = o3 + t4.getLength(), r3 && this.setSelection(n3), this.notifyDelegateOfInsertionAtRange([o3, n3]);
              }, d3.prototype.insertBlock = function(t4) {
                var n3;
                return t4 == null && (t4 = new e3.Block()), n3 = new e3.Document([t4]), this.insertDocument(n3);
              }, d3.prototype.insertDocument = function(t4) {
                var n3, i4, o3;
                return t4 == null && (t4 = new e3.Document()), i4 = this.getSelectedRange(), this.setDocument(this.document.insertDocumentAtRange(t4, i4)), o3 = i4[0], n3 = o3 + t4.getLength(), this.setSelection(n3), this.notifyDelegateOfInsertionAtRange([o3, n3]);
              }, d3.prototype.insertString = function(t4, n3) {
                var i4, o3;
                return i4 = this.getCurrentTextAttributes(), o3 = e3.Text.textForStringWithAttributes(t4, i4), this.insertText(o3, n3);
              }, d3.prototype.insertBlockBreak = function() {
                var t4, e4, n3;
                return e4 = this.getSelectedRange(), this.setDocument(this.document.insertBlockBreakAtRange(e4)), n3 = e4[0], t4 = n3 + 1, this.setSelection(t4), this.notifyDelegateOfInsertionAtRange([n3, t4]);
              }, d3.prototype.insertLineBreak = function() {
                var t4, n3;
                return n3 = new e3.LineBreakInsertion(this), n3.shouldDecreaseListLevel() ? (this.decreaseListLevel(), this.setSelection(n3.startPosition)) : n3.shouldPrependListItem() ? (t4 = new e3.Document([n3.block.copyWithoutText()]), this.insertDocument(t4)) : n3.shouldInsertBlockBreak() ? this.insertBlockBreak() : n3.shouldRemoveLastBlockAttribute() ? this.removeLastBlockAttribute() : n3.shouldBreakFormattedBlock() ? this.breakFormattedBlock(n3) : this.insertString("\n");
              }, d3.prototype.insertHTML = function(t4) {
                var n3, i4, o3, r3;
                return n3 = e3.Document.fromHTML(t4), o3 = this.getSelectedRange(), this.setDocument(this.document.mergeDocumentAtRange(n3, o3)), r3 = o3[0], i4 = r3 + n3.getLength() - 1, this.setSelection(i4), this.notifyDelegateOfInsertionAtRange([r3, i4]);
              }, d3.prototype.replaceHTML = function(t4) {
                var n3, i4, o3;
                return n3 = e3.Document.fromHTML(t4).copyUsingObjectsFromDocument(this.document), i4 = this.getLocationRange({ strict: false }), o3 = this.document.rangeFromLocationRange(i4), this.setDocument(n3), this.setSelection(o3);
              }, d3.prototype.insertFile = function(t4) {
                return this.insertFiles([t4]);
              }, d3.prototype.insertFiles = function(t4) {
                var n3, i4, o3, r3, s5, a5;
                for (i4 = [], r3 = 0, s5 = t4.length; s5 > r3; r3++)
                  o3 = t4[r3], ((a5 = this.delegate) != null ? a5.compositionShouldAcceptFile(o3) : void 0) && (n3 = e3.Attachment.attachmentForFile(o3), i4.push(n3));
                return this.insertAttachments(i4);
              }, d3.prototype.insertAttachment = function(t4) {
                return this.insertAttachments([t4]);
              }, d3.prototype.insertAttachments = function(t4) {
                var n3, i4, o3, r3, s5, a5, u3, c3, l3;
                for (c3 = new e3.Text(), r3 = 0, s5 = t4.length; s5 > r3; r3++)
                  n3 = t4[r3], l3 = n3.getType(), a5 = (u3 = e3.config.attachments[l3]) != null ? u3.presentation : void 0, o3 = this.getCurrentTextAttributes(), a5 && (o3.presentation = a5), i4 = e3.Text.textForAttachmentWithAttributes(n3, o3), c3 = c3.appendText(i4);
                return this.insertText(c3);
              }, d3.prototype.shouldManageDeletingInDirection = function(t4) {
                var e4;
                if (e4 = this.getLocationRange(), u2(e4)) {
                  if (t4 === "backward" && e4[0].offset === 0)
                    return true;
                  if (this.shouldManageMovingCursorInDirection(t4))
                    return true;
                } else if (e4[0].index !== e4[1].index)
                  return true;
                return false;
              }, d3.prototype.deleteInDirection = function(t4, e4) {
                var n3, i4, o3, r3, s5, a5, c3, l3;
                return r3 = (e4 != null ? e4 : {}).length, s5 = this.getLocationRange(), a5 = this.getSelectedRange(), c3 = u2(a5), c3 ? o3 = t4 === "backward" && s5[0].offset === 0 : l3 = s5[0].index !== s5[1].index, o3 && this.canDecreaseBlockAttributeLevel() && (i4 = this.getBlock(), i4.isListItem() ? this.decreaseListLevel() : this.decreaseBlockAttributeLevel(), this.setSelection(a5[0]), i4.isEmpty()) ? false : (c3 && (a5 = this.getExpandedRangeInDirection(t4, { length: r3 }), t4 === "backward" && (n3 = this.getAttachmentAtRange(a5))), n3 ? (this.editAttachment(n3), false) : (this.setDocument(this.document.removeTextAtRange(a5)), this.setSelection(a5[0]), o3 || l3 ? false : void 0));
              }, d3.prototype.moveTextFromRange = function(t4) {
                var e4;
                return e4 = this.getSelectedRange()[0], this.setDocument(this.document.moveTextFromRangeToPosition(t4, e4)), this.setSelection(e4);
              }, d3.prototype.removeAttachment = function(t4) {
                var e4;
                return (e4 = this.document.getRangeOfAttachment(t4)) ? (this.stopEditingAttachment(), this.setDocument(this.document.removeTextAtRange(e4)), this.setSelection(e4[0])) : void 0;
              }, d3.prototype.removeLastBlockAttribute = function() {
                var t4, e4, n3, i4;
                return n3 = this.getSelectedRange(), i4 = n3[0], e4 = n3[1], t4 = this.document.getBlockAtPosition(e4), this.removeCurrentAttribute(t4.getLastAttribute()), this.setSelection(i4);
              }, f = " ", d3.prototype.insertPlaceholder = function() {
                return this.placeholderPosition = this.getPosition(), this.insertString(f);
              }, d3.prototype.selectPlaceholder = function() {
                return this.placeholderPosition != null ? (this.setSelectedRange([this.placeholderPosition, this.placeholderPosition + f.length]), this.getSelectedRange()) : void 0;
              }, d3.prototype.forgetPlaceholder = function() {
                return this.placeholderPosition = null;
              }, d3.prototype.hasCurrentAttribute = function(t4) {
                var e4;
                return e4 = this.currentAttributes[t4], e4 != null && e4 !== false;
              }, d3.prototype.toggleCurrentAttribute = function(t4) {
                var e4;
                return (e4 = !this.currentAttributes[t4]) ? this.setCurrentAttribute(t4, e4) : this.removeCurrentAttribute(t4);
              }, d3.prototype.canSetCurrentAttribute = function(t4) {
                return o2(t4) ? this.canSetCurrentBlockAttribute(t4) : this.canSetCurrentTextAttribute(t4);
              }, d3.prototype.canSetCurrentTextAttribute = function() {
                var t4, e4, n3, i4, o3;
                if (e4 = this.getSelectedDocument()) {
                  for (o3 = e4.getAttachments(), n3 = 0, i4 = o3.length; i4 > n3; n3++)
                    if (t4 = o3[n3], !t4.hasContent())
                      return false;
                  return true;
                }
              }, d3.prototype.canSetCurrentBlockAttribute = function() {
                var t4;
                if (t4 = this.getBlock())
                  return !t4.isTerminalBlock();
              }, d3.prototype.setCurrentAttribute = function(t4, e4) {
                return o2(t4) ? this.setBlockAttribute(t4, e4) : (this.setTextAttribute(t4, e4), this.currentAttributes[t4] = e4, this.notifyDelegateOfCurrentAttributesChange());
              }, d3.prototype.setTextAttribute = function(t4, n3) {
                var i4, o3, r3, s5;
                if (o3 = this.getSelectedRange())
                  return r3 = o3[0], i4 = o3[1], r3 !== i4 ? this.setDocument(this.document.addAttributeAtRange(t4, n3, o3)) : t4 === "href" ? (s5 = e3.Text.textForStringWithAttributes(n3, { href: n3 }), this.insertText(s5)) : void 0;
              }, d3.prototype.setBlockAttribute = function(t4, e4) {
                var n3, i4;
                if (i4 = this.getSelectedRange())
                  return this.canSetCurrentAttribute(t4) ? (n3 = this.getBlock(), this.setDocument(this.document.applyBlockAttributeAtRange(t4, e4, i4)), this.setSelection(i4)) : void 0;
              }, d3.prototype.removeCurrentAttribute = function(t4) {
                return o2(t4) ? (this.removeBlockAttribute(t4), this.updateCurrentAttributes()) : (this.removeTextAttribute(t4), delete this.currentAttributes[t4], this.notifyDelegateOfCurrentAttributesChange());
              }, d3.prototype.removeTextAttribute = function(t4) {
                var e4;
                if (e4 = this.getSelectedRange())
                  return this.setDocument(this.document.removeAttributeAtRange(t4, e4));
              }, d3.prototype.removeBlockAttribute = function(t4) {
                var e4;
                if (e4 = this.getSelectedRange())
                  return this.setDocument(this.document.removeAttributeAtRange(t4, e4));
              }, d3.prototype.canDecreaseNestingLevel = function() {
                var t4;
                return ((t4 = this.getBlock()) != null ? t4.getNestingLevel() : void 0) > 0;
              }, d3.prototype.canIncreaseNestingLevel = function() {
                var e4, n3, i4;
                if (e4 = this.getBlock())
                  return ((i4 = o2(e4.getLastNestableAttribute())) != null ? i4.listAttribute : 0) ? (n3 = this.getPreviousBlock()) ? t3(n3.getListItemAttributes(), e4.getListItemAttributes()) : void 0 : e4.getNestingLevel() > 0;
              }, d3.prototype.decreaseNestingLevel = function() {
                var t4;
                if (t4 = this.getBlock())
                  return this.setDocument(this.document.replaceBlock(t4, t4.decreaseNestingLevel()));
              }, d3.prototype.increaseNestingLevel = function() {
                var t4;
                if (t4 = this.getBlock())
                  return this.setDocument(this.document.replaceBlock(t4, t4.increaseNestingLevel()));
              }, d3.prototype.canDecreaseBlockAttributeLevel = function() {
                var t4;
                return ((t4 = this.getBlock()) != null ? t4.getAttributeLevel() : void 0) > 0;
              }, d3.prototype.decreaseBlockAttributeLevel = function() {
                var t4, e4;
                return (t4 = (e4 = this.getBlock()) != null ? e4.getLastAttribute() : void 0) ? this.removeCurrentAttribute(t4) : void 0;
              }, d3.prototype.decreaseListLevel = function() {
                var t4, e4, n3, i4, o3, r3;
                for (r3 = this.getSelectedRange()[0], o3 = this.document.locationFromPosition(r3).index, n3 = o3, t4 = this.getBlock().getAttributeLevel(); (e4 = this.document.getBlockAtIndex(n3 + 1)) && e4.isListItem() && e4.getAttributeLevel() > t4; )
                  n3++;
                return r3 = this.document.positionFromLocation({ index: o3, offset: 0 }), i4 = this.document.positionFromLocation({ index: n3, offset: 0 }), this.setDocument(this.document.removeLastListAttributeAtRange([r3, i4]));
              }, d3.prototype.updateCurrentAttributes = function() {
                var t4, e4, n3, o3, r3, s5;
                if (s5 = this.getSelectedRange({ ignoreLock: true })) {
                  for (e4 = this.document.getCommonAttributesAtRange(s5), r3 = i3(), n3 = 0, o3 = r3.length; o3 > n3; n3++)
                    t4 = r3[n3], e4[t4] || this.canSetCurrentAttribute(t4) || (e4[t4] = false);
                  if (!a4(e4, this.currentAttributes))
                    return this.currentAttributes = e4, this.notifyDelegateOfCurrentAttributesChange();
                }
              }, d3.prototype.getCurrentAttributes = function() {
                return n2.call({}, this.currentAttributes);
              }, d3.prototype.getCurrentTextAttributes = function() {
                var t4, e4, n3, i4;
                t4 = {}, n3 = this.currentAttributes;
                for (e4 in n3)
                  i4 = n3[e4], i4 !== false && r2(e4) && (t4[e4] = i4);
                return t4;
              }, d3.prototype.freezeSelection = function() {
                return this.setCurrentAttribute("frozen", true);
              }, d3.prototype.thawSelection = function() {
                return this.removeCurrentAttribute("frozen");
              }, d3.prototype.hasFrozenSelection = function() {
                return this.hasCurrentAttribute("frozen");
              }, d3.proxyMethod("getSelectionManager().getPointRange"), d3.proxyMethod("getSelectionManager().setLocationRangeFromPointRange"), d3.proxyMethod("getSelectionManager().createLocationRangeFromDOMRange"), d3.proxyMethod("getSelectionManager().locationIsCursorTarget"), d3.proxyMethod("getSelectionManager().selectionIsExpanded"), d3.proxyMethod("delegate?.getSelectionManager"), d3.prototype.setSelection = function(t4) {
                var e4, n3;
                return e4 = this.document.locationRangeFromRange(t4), (n3 = this.delegate) != null ? n3.compositionDidRequestChangingSelectionToLocationRange(e4) : void 0;
              }, d3.prototype.getSelectedRange = function() {
                var t4;
                return (t4 = this.getLocationRange()) ? this.document.rangeFromLocationRange(t4) : void 0;
              }, d3.prototype.setSelectedRange = function(t4) {
                var e4;
                return e4 = this.document.locationRangeFromRange(t4), this.getSelectionManager().setLocationRange(e4);
              }, d3.prototype.getPosition = function() {
                var t4;
                return (t4 = this.getLocationRange()) ? this.document.positionFromLocation(t4[0]) : void 0;
              }, d3.prototype.getLocationRange = function(t4) {
                var e4, n3;
                return (e4 = (n3 = this.targetLocationRange) != null ? n3 : this.getSelectionManager().getLocationRange(t4)) != null ? e4 : s4({ index: 0, offset: 0 });
              }, d3.prototype.withTargetLocationRange = function(t4, e4) {
                var n3;
                this.targetLocationRange = t4;
                try {
                  n3 = e4();
                } finally {
                  this.targetLocationRange = null;
                }
                return n3;
              }, d3.prototype.withTargetRange = function(t4, e4) {
                var n3;
                return n3 = this.document.locationRangeFromRange(t4), this.withTargetLocationRange(n3, e4);
              }, d3.prototype.withTargetDOMRange = function(t4, e4) {
                var n3;
                return n3 = this.createLocationRangeFromDOMRange(t4, { strict: false }), this.withTargetLocationRange(n3, e4);
              }, d3.prototype.getExpandedRangeInDirection = function(t4, e4) {
                var n3, i4, o3, r3;
                return i4 = (e4 != null ? e4 : {}).length, o3 = this.getSelectedRange(), r3 = o3[0], n3 = o3[1], t4 === "backward" ? i4 ? r3 -= i4 : r3 = this.translateUTF16PositionFromOffset(r3, -1) : i4 ? n3 += i4 : n3 = this.translateUTF16PositionFromOffset(n3, 1), s4([r3, n3]);
              }, d3.prototype.shouldManageMovingCursorInDirection = function(t4) {
                var e4;
                return this.editingAttachment ? true : (e4 = this.getExpandedRangeInDirection(t4), this.getAttachmentAtRange(e4) != null);
              }, d3.prototype.moveCursorInDirection = function(t4) {
                var e4, n3, i4, o3;
                return this.editingAttachment ? i4 = this.document.getRangeOfAttachment(this.editingAttachment) : (o3 = this.getSelectedRange(), i4 = this.getExpandedRangeInDirection(t4), n3 = !c2(o3, i4)), this.setSelectedRange(t4 === "backward" ? i4[0] : i4[1]), n3 && (e4 = this.getAttachmentAtRange(i4)) ? this.editAttachment(e4) : void 0;
              }, d3.prototype.expandSelectionInDirection = function(t4, e4) {
                var n3, i4;
                return n3 = (e4 != null ? e4 : {}).length, i4 = this.getExpandedRangeInDirection(t4, { length: n3 }), this.setSelectedRange(i4);
              }, d3.prototype.expandSelectionForEditing = function() {
                return this.hasCurrentAttribute("href") ? this.expandSelectionAroundCommonAttribute("href") : void 0;
              }, d3.prototype.expandSelectionAroundCommonAttribute = function(t4) {
                var e4, n3;
                return e4 = this.getPosition(), n3 = this.document.getRangeOfCommonAttributeAtPosition(t4, e4), this.setSelectedRange(n3);
              }, d3.prototype.selectionContainsAttachments = function() {
                var t4;
                return ((t4 = this.getSelectedAttachments()) != null ? t4.length : void 0) > 0;
              }, d3.prototype.selectionIsInCursorTarget = function() {
                return this.editingAttachment || this.positionIsCursorTarget(this.getPosition());
              }, d3.prototype.positionIsCursorTarget = function(t4) {
                var e4;
                return (e4 = this.document.locationFromPosition(t4)) ? this.locationIsCursorTarget(e4) : void 0;
              }, d3.prototype.positionIsBlockBreak = function(t4) {
                var e4;
                return (e4 = this.document.getPieceAtPosition(t4)) != null ? e4.isBlockBreak() : void 0;
              }, d3.prototype.getSelectedDocument = function() {
                var t4;
                return (t4 = this.getSelectedRange()) ? this.document.getDocumentAtRange(t4) : void 0;
              }, d3.prototype.getSelectedAttachments = function() {
                var t4;
                return (t4 = this.getSelectedDocument()) != null ? t4.getAttachments() : void 0;
              }, d3.prototype.getAttachments = function() {
                return this.attachments.slice(0);
              }, d3.prototype.refreshAttachments = function() {
                var t4, e4, n3, i4, o3, r3, s5, a5, u3, c3, h6, p3;
                for (n3 = this.document.getAttachments(), a5 = l2(this.attachments, n3), t4 = a5.added, h6 = a5.removed, this.attachments = n3, i4 = 0, r3 = h6.length; r3 > i4; i4++)
                  e4 = h6[i4], e4.delegate = null, (u3 = this.delegate) != null && typeof u3.compositionDidRemoveAttachment == "function" && u3.compositionDidRemoveAttachment(e4);
                for (p3 = [], o3 = 0, s5 = t4.length; s5 > o3; o3++)
                  e4 = t4[o3], e4.delegate = this, p3.push((c3 = this.delegate) != null && typeof c3.compositionDidAddAttachment == "function" ? c3.compositionDidAddAttachment(e4) : void 0);
                return p3;
              }, d3.prototype.attachmentDidChangeAttributes = function(t4) {
                var e4;
                return this.revision++, (e4 = this.delegate) != null && typeof e4.compositionDidEditAttachment == "function" ? e4.compositionDidEditAttachment(t4) : void 0;
              }, d3.prototype.attachmentDidChangePreviewURL = function(t4) {
                var e4;
                return this.revision++, (e4 = this.delegate) != null && typeof e4.compositionDidChangeAttachmentPreviewURL == "function" ? e4.compositionDidChangeAttachmentPreviewURL(t4) : void 0;
              }, d3.prototype.editAttachment = function(t4, e4) {
                var n3;
                if (t4 !== this.editingAttachment)
                  return this.stopEditingAttachment(), this.editingAttachment = t4, (n3 = this.delegate) != null && typeof n3.compositionDidStartEditingAttachment == "function" ? n3.compositionDidStartEditingAttachment(this.editingAttachment, e4) : void 0;
              }, d3.prototype.stopEditingAttachment = function() {
                var t4;
                if (this.editingAttachment)
                  return (t4 = this.delegate) != null && typeof t4.compositionDidStopEditingAttachment == "function" && t4.compositionDidStopEditingAttachment(this.editingAttachment), this.editingAttachment = null;
              }, d3.prototype.updateAttributesForAttachment = function(t4, e4) {
                return this.setDocument(this.document.updateAttributesForAttachment(t4, e4));
              }, d3.prototype.removeAttributeForAttachment = function(t4, e4) {
                return this.setDocument(this.document.removeAttributeForAttachment(t4, e4));
              }, d3.prototype.breakFormattedBlock = function(t4) {
                var n3, i4, o3, r3, s5;
                return i4 = t4.document, n3 = t4.block, r3 = t4.startPosition, s5 = [r3 - 1, r3], n3.getBlockBreakPosition() === t4.startLocation.offset ? (n3.breaksOnReturn() && t4.nextCharacter === "\n" ? r3 += 1 : i4 = i4.removeTextAtRange(s5), s5 = [r3, r3]) : t4.nextCharacter === "\n" ? t4.previousCharacter === "\n" ? s5 = [r3 - 1, r3 + 1] : (s5 = [r3, r3 + 1], r3 += 1) : t4.startLocation.offset - 1 !== 0 && (r3 += 1), o3 = new e3.Document([n3.removeLastAttribute().copyWithoutText()]), this.setDocument(i4.insertDocumentAtRange(o3, s5)), this.setSelection(r3);
              }, d3.prototype.getPreviousBlock = function() {
                var t4, e4;
                return (e4 = this.getLocationRange()) && (t4 = e4[0].index, t4 > 0) ? this.document.getBlockAtIndex(t4 - 1) : void 0;
              }, d3.prototype.getBlock = function() {
                var t4;
                return (t4 = this.getLocationRange()) ? this.document.getBlockAtIndex(t4[0].index) : void 0;
              }, d3.prototype.getAttachmentAtRange = function(t4) {
                var n3;
                return n3 = this.document.getDocumentAtRange(t4), n3.toString() === e3.OBJECT_REPLACEMENT_CHARACTER + "\n" ? n3.getAttachments()[0] : void 0;
              }, d3.prototype.notifyDelegateOfCurrentAttributesChange = function() {
                var t4;
                return (t4 = this.delegate) != null && typeof t4.compositionDidChangeCurrentAttributes == "function" ? t4.compositionDidChangeCurrentAttributes(this.currentAttributes) : void 0;
              }, d3.prototype.notifyDelegateOfInsertionAtRange = function(t4) {
                var e4;
                return (e4 = this.delegate) != null && typeof e4.compositionDidPerformInsertionAtRange == "function" ? e4.compositionDidPerformInsertionAtRange(t4) : void 0;
              }, d3.prototype.translateUTF16PositionFromOffset = function(t4, e4) {
                var n3, i4;
                return i4 = this.document.toUTF16String(), n3 = i4.offsetFromUCS2Offset(t4), i4.offsetToUCS2Offset(n3 + e4);
              }, d3;
            }(e3.BasicObject);
          }.call(this), function() {
            var t3 = function(t4, e4) {
              function i3() {
                this.constructor = t4;
              }
              for (var o2 in e4)
                n2.call(e4, o2) && (t4[o2] = e4[o2]);
              return i3.prototype = e4.prototype, t4.prototype = new i3(), t4.__super__ = e4.prototype, t4;
            }, n2 = {}.hasOwnProperty;
            e3.UndoManager = function(e4) {
              function n3(t4) {
                this.composition = t4, this.undoEntries = [], this.redoEntries = [];
              }
              var i3;
              return t3(n3, e4), n3.prototype.recordUndoEntry = function(t4, e5) {
                var n4, o2, r2, s4, a4;
                return s4 = e5 != null ? e5 : {}, o2 = s4.context, n4 = s4.consolidatable, r2 = this.undoEntries.slice(-1)[0], n4 && i3(r2, t4, o2) ? void 0 : (a4 = this.createEntry({ description: t4, context: o2 }), this.undoEntries.push(a4), this.redoEntries = []);
              }, n3.prototype.undo = function() {
                var t4, e5;
                return (e5 = this.undoEntries.pop()) ? (t4 = this.createEntry(e5), this.redoEntries.push(t4), this.composition.loadSnapshot(e5.snapshot)) : void 0;
              }, n3.prototype.redo = function() {
                var t4, e5;
                return (t4 = this.redoEntries.pop()) ? (e5 = this.createEntry(t4), this.undoEntries.push(e5), this.composition.loadSnapshot(t4.snapshot)) : void 0;
              }, n3.prototype.canUndo = function() {
                return this.undoEntries.length > 0;
              }, n3.prototype.canRedo = function() {
                return this.redoEntries.length > 0;
              }, n3.prototype.createEntry = function(t4) {
                var e5, n4, i4;
                return i4 = t4 != null ? t4 : {}, n4 = i4.description, e5 = i4.context, { description: n4 != null ? n4.toString() : void 0, context: JSON.stringify(e5), snapshot: this.composition.getSnapshot() };
              }, i3 = function(t4, e5, n4) {
                return (t4 != null ? t4.description : void 0) === (e5 != null ? e5.toString() : void 0) && (t4 != null ? t4.context : void 0) === JSON.stringify(n4);
              }, n3;
            }(e3.BasicObject);
          }.call(this), function() {
            var t3;
            e3.attachmentGalleryFilter = function(e4) {
              var n2;
              return n2 = new t3(e4), n2.perform(), n2.getSnapshot();
            }, t3 = function() {
              function t4(t5) {
                this.document = t5.document, this.selectedRange = t5.selectedRange;
              }
              var e4, n2, i3;
              return e4 = "attachmentGallery", n2 = "presentation", i3 = "gallery", t4.prototype.perform = function() {
                return this.removeBlockAttribute(), this.applyBlockAttribute();
              }, t4.prototype.getSnapshot = function() {
                return { document: this.document, selectedRange: this.selectedRange };
              }, t4.prototype.removeBlockAttribute = function() {
                var t5, n3, i4, o2, r2;
                for (o2 = this.findRangesOfBlocks(), r2 = [], t5 = 0, n3 = o2.length; n3 > t5; t5++)
                  i4 = o2[t5], r2.push(this.document = this.document.removeAttributeAtRange(e4, i4));
                return r2;
              }, t4.prototype.applyBlockAttribute = function() {
                var t5, n3, i4, o2, r2, s4;
                for (i4 = 0, r2 = this.findRangesOfPieces(), s4 = [], t5 = 0, n3 = r2.length; n3 > t5; t5++)
                  o2 = r2[t5], o2[1] - o2[0] > 1 && (o2[0] += i4, o2[1] += i4, this.document.getCharacterAtPosition(o2[1]) !== "\n" && (this.document = this.document.insertBlockBreakAtRange(o2[1]), o2[1] < this.selectedRange[1] && this.moveSelectedRangeForward(), o2[1]++, i4++), o2[0] !== 0 && this.document.getCharacterAtPosition(o2[0] - 1) !== "\n" && (this.document = this.document.insertBlockBreakAtRange(o2[0]), o2[0] < this.selectedRange[0] && this.moveSelectedRangeForward(), o2[0]++, i4++), s4.push(this.document = this.document.applyBlockAttributeAtRange(e4, true, o2)));
                return s4;
              }, t4.prototype.findRangesOfBlocks = function() {
                return this.document.findRangesForBlockAttribute(e4);
              }, t4.prototype.findRangesOfPieces = function() {
                return this.document.findRangesForTextAttribute(n2, { withValue: i3 });
              }, t4.prototype.moveSelectedRangeForward = function() {
                return this.selectedRange[0] += 1, this.selectedRange[1] += 1;
              }, t4;
            }();
          }.call(this), function() {
            var t3 = function(t4, e4) {
              return function() {
                return t4.apply(e4, arguments);
              };
            };
            e3.Editor = function() {
              function n2(n3, o2, r2) {
                this.composition = n3, this.selectionManager = o2, this.element = r2, this.insertFiles = t3(this.insertFiles, this), this.undoManager = new e3.UndoManager(this.composition), this.filters = i3.slice(0);
              }
              var i3;
              return i3 = [e3.attachmentGalleryFilter], n2.prototype.loadDocument = function(t4) {
                return this.loadSnapshot({ document: t4, selectedRange: [0, 0] });
              }, n2.prototype.loadHTML = function(t4) {
                return t4 == null && (t4 = ""), this.loadDocument(e3.Document.fromHTML(t4, { referenceElement: this.element }));
              }, n2.prototype.loadJSON = function(t4) {
                var n3, i4;
                return n3 = t4.document, i4 = t4.selectedRange, n3 = e3.Document.fromJSON(n3), this.loadSnapshot({ document: n3, selectedRange: i4 });
              }, n2.prototype.loadSnapshot = function(t4) {
                return this.undoManager = new e3.UndoManager(this.composition), this.composition.loadSnapshot(t4);
              }, n2.prototype.getDocument = function() {
                return this.composition.document;
              }, n2.prototype.getSelectedDocument = function() {
                return this.composition.getSelectedDocument();
              }, n2.prototype.getSnapshot = function() {
                return this.composition.getSnapshot();
              }, n2.prototype.toJSON = function() {
                return this.getSnapshot();
              }, n2.prototype.deleteInDirection = function(t4) {
                return this.composition.deleteInDirection(t4);
              }, n2.prototype.insertAttachment = function(t4) {
                return this.composition.insertAttachment(t4);
              }, n2.prototype.insertAttachments = function(t4) {
                return this.composition.insertAttachments(t4);
              }, n2.prototype.insertDocument = function(t4) {
                return this.composition.insertDocument(t4);
              }, n2.prototype.insertFile = function(t4) {
                return this.composition.insertFile(t4);
              }, n2.prototype.insertFiles = function(t4) {
                return this.composition.insertFiles(t4);
              }, n2.prototype.insertHTML = function(t4) {
                return this.composition.insertHTML(t4);
              }, n2.prototype.insertString = function(t4) {
                return this.composition.insertString(t4);
              }, n2.prototype.insertText = function(t4) {
                return this.composition.insertText(t4);
              }, n2.prototype.insertLineBreak = function() {
                return this.composition.insertLineBreak();
              }, n2.prototype.getSelectedRange = function() {
                return this.composition.getSelectedRange();
              }, n2.prototype.getPosition = function() {
                return this.composition.getPosition();
              }, n2.prototype.getClientRectAtPosition = function(t4) {
                var e4;
                return e4 = this.getDocument().locationRangeFromRange([t4, t4 + 1]), this.selectionManager.getClientRectAtLocationRange(e4);
              }, n2.prototype.expandSelectionInDirection = function(t4) {
                return this.composition.expandSelectionInDirection(t4);
              }, n2.prototype.moveCursorInDirection = function(t4) {
                return this.composition.moveCursorInDirection(t4);
              }, n2.prototype.setSelectedRange = function(t4) {
                return this.composition.setSelectedRange(t4);
              }, n2.prototype.activateAttribute = function(t4, e4) {
                return e4 == null && (e4 = true), this.composition.setCurrentAttribute(t4, e4);
              }, n2.prototype.attributeIsActive = function(t4) {
                return this.composition.hasCurrentAttribute(t4);
              }, n2.prototype.canActivateAttribute = function(t4) {
                return this.composition.canSetCurrentAttribute(t4);
              }, n2.prototype.deactivateAttribute = function(t4) {
                return this.composition.removeCurrentAttribute(t4);
              }, n2.prototype.canDecreaseNestingLevel = function() {
                return this.composition.canDecreaseNestingLevel();
              }, n2.prototype.canIncreaseNestingLevel = function() {
                return this.composition.canIncreaseNestingLevel();
              }, n2.prototype.decreaseNestingLevel = function() {
                return this.canDecreaseNestingLevel() ? this.composition.decreaseNestingLevel() : void 0;
              }, n2.prototype.increaseNestingLevel = function() {
                return this.canIncreaseNestingLevel() ? this.composition.increaseNestingLevel() : void 0;
              }, n2.prototype.canRedo = function() {
                return this.undoManager.canRedo();
              }, n2.prototype.canUndo = function() {
                return this.undoManager.canUndo();
              }, n2.prototype.recordUndoEntry = function(t4, e4) {
                var n3, i4, o2;
                return o2 = e4 != null ? e4 : {}, i4 = o2.context, n3 = o2.consolidatable, this.undoManager.recordUndoEntry(t4, { context: i4, consolidatable: n3 });
              }, n2.prototype.redo = function() {
                return this.canRedo() ? this.undoManager.redo() : void 0;
              }, n2.prototype.undo = function() {
                return this.canUndo() ? this.undoManager.undo() : void 0;
              }, n2;
            }();
          }.call(this), function() {
            var t3 = function(t4, e4) {
              function i3() {
                this.constructor = t4;
              }
              for (var o2 in e4)
                n2.call(e4, o2) && (t4[o2] = e4[o2]);
              return i3.prototype = e4.prototype, t4.prototype = new i3(), t4.__super__ = e4.prototype, t4;
            }, n2 = {}.hasOwnProperty;
            e3.ManagedAttachment = function(e4) {
              function n3(t4, e5) {
                var n4;
                this.attachmentManager = t4, this.attachment = e5, n4 = this.attachment, this.id = n4.id, this.file = n4.file;
              }
              return t3(n3, e4), n3.prototype.remove = function() {
                return this.attachmentManager.requestRemovalOfAttachment(this.attachment);
              }, n3.proxyMethod("attachment.getAttribute"), n3.proxyMethod("attachment.hasAttribute"), n3.proxyMethod("attachment.setAttribute"), n3.proxyMethod("attachment.getAttributes"), n3.proxyMethod("attachment.setAttributes"), n3.proxyMethod("attachment.isPending"), n3.proxyMethod("attachment.isPreviewable"), n3.proxyMethod("attachment.getURL"), n3.proxyMethod("attachment.getHref"), n3.proxyMethod("attachment.getFilename"), n3.proxyMethod("attachment.getFilesize"), n3.proxyMethod("attachment.getFormattedFilesize"), n3.proxyMethod("attachment.getExtension"), n3.proxyMethod("attachment.getContentType"), n3.proxyMethod("attachment.getFile"), n3.proxyMethod("attachment.setFile"), n3.proxyMethod("attachment.releaseFile"), n3.proxyMethod("attachment.getUploadProgress"), n3.proxyMethod("attachment.setUploadProgress"), n3;
            }(e3.BasicObject);
          }.call(this), function() {
            var t3 = function(t4, e4) {
              function i3() {
                this.constructor = t4;
              }
              for (var o2 in e4)
                n2.call(e4, o2) && (t4[o2] = e4[o2]);
              return i3.prototype = e4.prototype, t4.prototype = new i3(), t4.__super__ = e4.prototype, t4;
            }, n2 = {}.hasOwnProperty;
            e3.AttachmentManager = function(n3) {
              function i3(t4) {
                var e4, n4, i4;
                for (t4 == null && (t4 = []), this.managedAttachments = {}, n4 = 0, i4 = t4.length; i4 > n4; n4++)
                  e4 = t4[n4], this.manageAttachment(e4);
              }
              return t3(i3, n3), i3.prototype.getAttachments = function() {
                var t4, e4, n4, i4;
                n4 = this.managedAttachments, i4 = [];
                for (e4 in n4)
                  t4 = n4[e4], i4.push(t4);
                return i4;
              }, i3.prototype.manageAttachment = function(t4) {
                var n4, i4;
                return (n4 = this.managedAttachments)[i4 = t4.id] != null ? n4[i4] : n4[i4] = new e3.ManagedAttachment(this, t4);
              }, i3.prototype.attachmentIsManaged = function(t4) {
                return t4.id in this.managedAttachments;
              }, i3.prototype.requestRemovalOfAttachment = function(t4) {
                var e4;
                return this.attachmentIsManaged(t4) && (e4 = this.delegate) != null && typeof e4.attachmentManagerDidRequestRemovalOfAttachment == "function" ? e4.attachmentManagerDidRequestRemovalOfAttachment(t4) : void 0;
              }, i3.prototype.unmanageAttachment = function(t4) {
                var e4;
                return e4 = this.managedAttachments[t4.id], delete this.managedAttachments[t4.id], e4;
              }, i3;
            }(e3.BasicObject);
          }.call(this), function() {
            var t3, n2, i3, o2, r2, s4, a4, u2, c2, l2, h5;
            t3 = e3.elementContainsNode, n2 = e3.findChildIndexOfNode, r2 = e3.nodeIsBlockStart, s4 = e3.nodeIsBlockStartComment, o2 = e3.nodeIsBlockContainer, a4 = e3.nodeIsCursorTarget, u2 = e3.nodeIsEmptyTextNode, c2 = e3.nodeIsTextNode, i3 = e3.nodeIsAttachmentElement, l2 = e3.tagName, h5 = e3.walkTree, e3.LocationMapper = function() {
              function e4(t4) {
                this.element = t4;
              }
              var p, d3, f, g;
              return e4.prototype.findLocationFromContainerAndOffset = function(e5, i4, o3) {
                var s5, u3, l3, p2, g2, m3, v;
                for (m3 = (o3 != null ? o3 : { strict: true }).strict, u3 = 0, l3 = false, p2 = { index: 0, offset: 0 }, (s5 = this.findAttachmentElementParentForNode(e5)) && (e5 = s5.parentNode, i4 = n2(s5)), v = h5(this.element, { usingFilter: f }); v.nextNode(); ) {
                  if (g2 = v.currentNode, g2 === e5 && c2(e5)) {
                    a4(g2) || (p2.offset += i4);
                    break;
                  }
                  if (g2.parentNode === e5) {
                    if (u3++ === i4)
                      break;
                  } else if (!t3(e5, g2) && u3 > 0)
                    break;
                  r2(g2, { strict: m3 }) ? (l3 && p2.index++, p2.offset = 0, l3 = true) : p2.offset += d3(g2);
                }
                return p2;
              }, e4.prototype.findContainerAndOffsetFromLocation = function(t4) {
                var e5, i4, s5, u3, l3;
                if (t4.index === 0 && t4.offset === 0) {
                  for (e5 = this.element, u3 = 0; e5.firstChild; )
                    if (e5 = e5.firstChild, o2(e5)) {
                      u3 = 1;
                      break;
                    }
                  return [e5, u3];
                }
                if (l3 = this.findNodeAndOffsetFromLocation(t4), i4 = l3[0], s5 = l3[1], i4) {
                  if (c2(i4))
                    d3(i4) === 0 ? (e5 = i4.parentNode.parentNode, u3 = n2(i4.parentNode), a4(i4, { name: "right" }) && u3++) : (e5 = i4, u3 = t4.offset - s5);
                  else {
                    if (e5 = i4.parentNode, !r2(i4.previousSibling) && !o2(e5))
                      for (; i4 === e5.lastChild && (i4 = e5, e5 = e5.parentNode, !o2(e5)); )
                        ;
                    u3 = n2(i4), t4.offset !== 0 && u3++;
                  }
                  return [e5, u3];
                }
              }, e4.prototype.findNodeAndOffsetFromLocation = function(t4) {
                var e5, n3, i4, o3, r3, s5, u3, l3;
                for (u3 = 0, l3 = this.getSignificantNodesForIndex(t4.index), n3 = 0, i4 = l3.length; i4 > n3; n3++) {
                  if (e5 = l3[n3], o3 = d3(e5), t4.offset <= u3 + o3)
                    if (c2(e5)) {
                      if (r3 = e5, s5 = u3, t4.offset === s5 && a4(r3))
                        break;
                    } else
                      r3 || (r3 = e5, s5 = u3);
                  if (u3 += o3, u3 > t4.offset)
                    break;
                }
                return [r3, s5];
              }, e4.prototype.findAttachmentElementParentForNode = function(t4) {
                for (; t4 && t4 !== this.element; ) {
                  if (i3(t4))
                    return t4;
                  t4 = t4.parentNode;
                }
              }, e4.prototype.getSignificantNodesForIndex = function(t4) {
                var e5, n3, i4, o3, r3;
                for (i4 = [], r3 = h5(this.element, { usingFilter: p }), o3 = false; r3.nextNode(); )
                  if (n3 = r3.currentNode, s4(n3)) {
                    if (typeof e5 != "undefined" && e5 !== null ? e5++ : e5 = 0, e5 === t4)
                      o3 = true;
                    else if (o3)
                      break;
                  } else
                    o3 && i4.push(n3);
                return i4;
              }, d3 = function(t4) {
                var e5;
                return t4.nodeType === Node.TEXT_NODE ? a4(t4) ? 0 : (e5 = t4.textContent, e5.length) : l2(t4) === "br" || i3(t4) ? 1 : 0;
              }, p = function(t4) {
                return g(t4) === NodeFilter.FILTER_ACCEPT ? f(t4) : NodeFilter.FILTER_REJECT;
              }, g = function(t4) {
                return u2(t4) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;
              }, f = function(t4) {
                return i3(t4.parentNode) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;
              }, e4;
            }();
          }.call(this), function() {
            var t3, n2, i3 = [].slice;
            t3 = e3.getDOMRange, n2 = e3.setDOMRange, e3.PointMapper = function() {
              function e4() {
              }
              return e4.prototype.createDOMRangeFromPoint = function(e5) {
                var i4, o2, r2, s4, a4, u2, c2, l2;
                if (c2 = e5.x, l2 = e5.y, document.caretPositionFromPoint)
                  return a4 = document.caretPositionFromPoint(c2, l2), r2 = a4.offsetNode, o2 = a4.offset, i4 = document.createRange(), i4.setStart(r2, o2), i4;
                if (document.caretRangeFromPoint)
                  return document.caretRangeFromPoint(c2, l2);
                if (document.body.createTextRange) {
                  s4 = t3();
                  try {
                    u2 = document.body.createTextRange(), u2.moveToPoint(c2, l2), u2.select();
                  } catch (h5) {
                  }
                  return i4 = t3(), n2(s4), i4;
                }
              }, e4.prototype.getClientRectsForDOMRange = function(t4) {
                var e5, n3, o2;
                return n3 = i3.call(t4.getClientRects()), o2 = n3[0], e5 = n3[n3.length - 1], [o2, e5];
              }, e4;
            }();
          }.call(this), function() {
            var t3, n2 = function(t4, e4) {
              return function() {
                return t4.apply(e4, arguments);
              };
            }, i3 = function(t4, e4) {
              function n3() {
                this.constructor = t4;
              }
              for (var i4 in e4)
                o2.call(e4, i4) && (t4[i4] = e4[i4]);
              return n3.prototype = e4.prototype, t4.prototype = new n3(), t4.__super__ = e4.prototype, t4;
            }, o2 = {}.hasOwnProperty, r2 = [].indexOf || function(t4) {
              for (var e4 = 0, n3 = this.length; n3 > e4; e4++)
                if (e4 in this && this[e4] === t4)
                  return e4;
              return -1;
            };
            t3 = e3.getDOMRange, e3.SelectionChangeObserver = function(e4) {
              function o3() {
                this.run = n2(this.run, this), this.update = n2(this.update, this), this.selectionManagers = [];
              }
              var s4;
              return i3(o3, e4), o3.prototype.start = function() {
                return this.started ? void 0 : (this.started = true, "onselectionchange" in document ? document.addEventListener("selectionchange", this.update, true) : this.run());
              }, o3.prototype.stop = function() {
                return this.started ? (this.started = false, document.removeEventListener("selectionchange", this.update, true)) : void 0;
              }, o3.prototype.registerSelectionManager = function(t4) {
                return r2.call(this.selectionManagers, t4) < 0 ? (this.selectionManagers.push(t4), this.start()) : void 0;
              }, o3.prototype.unregisterSelectionManager = function(t4) {
                var e5;
                return this.selectionManagers = function() {
                  var n3, i4, o4, r3;
                  for (o4 = this.selectionManagers, r3 = [], n3 = 0, i4 = o4.length; i4 > n3; n3++)
                    e5 = o4[n3], e5 !== t4 && r3.push(e5);
                  return r3;
                }.call(this), this.selectionManagers.length === 0 ? this.stop() : void 0;
              }, o3.prototype.notifySelectionManagersOfSelectionChange = function() {
                var t4, e5, n3, i4, o4;
                for (n3 = this.selectionManagers, i4 = [], t4 = 0, e5 = n3.length; e5 > t4; t4++)
                  o4 = n3[t4], i4.push(o4.selectionDidChange());
                return i4;
              }, o3.prototype.update = function() {
                var e5;
                return e5 = t3(), s4(e5, this.domRange) ? void 0 : (this.domRange = e5, this.notifySelectionManagersOfSelectionChange());
              }, o3.prototype.reset = function() {
                return this.domRange = null, this.update();
              }, o3.prototype.run = function() {
                return this.started ? (this.update(), requestAnimationFrame(this.run)) : void 0;
              }, s4 = function(t4, e5) {
                return (t4 != null ? t4.startContainer : void 0) === (e5 != null ? e5.startContainer : void 0) && (t4 != null ? t4.startOffset : void 0) === (e5 != null ? e5.startOffset : void 0) && (t4 != null ? t4.endContainer : void 0) === (e5 != null ? e5.endContainer : void 0) && (t4 != null ? t4.endOffset : void 0) === (e5 != null ? e5.endOffset : void 0);
              }, o3;
            }(e3.BasicObject), e3.selectionChangeObserver == null && (e3.selectionChangeObserver = new e3.SelectionChangeObserver());
          }.call(this), function() {
            var t3, n2, i3, o2, r2, s4, a4, u2, c2, l2, h5 = function(t4, e4) {
              return function() {
                return t4.apply(e4, arguments);
              };
            }, p = function(t4, e4) {
              function n3() {
                this.constructor = t4;
              }
              for (var i4 in e4)
                d3.call(e4, i4) && (t4[i4] = e4[i4]);
              return n3.prototype = e4.prototype, t4.prototype = new n3(), t4.__super__ = e4.prototype, t4;
            }, d3 = {}.hasOwnProperty;
            i3 = e3.getDOMSelection, n2 = e3.getDOMRange, l2 = e3.setDOMRange, t3 = e3.elementContainsNode, s4 = e3.nodeIsCursorTarget, r2 = e3.innerElementIsActive, o2 = e3.handleEvent, a4 = e3.normalizeRange, u2 = e3.rangeIsCollapsed, c2 = e3.rangesAreEqual, e3.SelectionManager = function(d4) {
              function f(t4) {
                this.element = t4, this.selectionDidChange = h5(this.selectionDidChange, this), this.didMouseDown = h5(this.didMouseDown, this), this.locationMapper = new e3.LocationMapper(this.element), this.pointMapper = new e3.PointMapper(), this.lockCount = 0, o2("mousedown", { onElement: this.element, withCallback: this.didMouseDown });
              }
              return p(f, d4), f.prototype.getLocationRange = function(t4) {
                var e4, i4;
                return t4 == null && (t4 = {}), e4 = t4.strict === false ? this.createLocationRangeFromDOMRange(n2(), { strict: false }) : t4.ignoreLock ? this.currentLocationRange : (i4 = this.lockedLocationRange) != null ? i4 : this.currentLocationRange;
              }, f.prototype.setLocationRange = function(t4) {
                var e4;
                if (!this.lockedLocationRange)
                  return t4 = a4(t4), (e4 = this.createDOMRangeFromLocationRange(t4)) ? (l2(e4), this.updateCurrentLocationRange(t4)) : void 0;
              }, f.prototype.setLocationRangeFromPointRange = function(t4) {
                var e4, n3;
                return t4 = a4(t4), n3 = this.getLocationAtPoint(t4[0]), e4 = this.getLocationAtPoint(t4[1]), this.setLocationRange([n3, e4]);
              }, f.prototype.getClientRectAtLocationRange = function(t4) {
                var e4;
                return (e4 = this.createDOMRangeFromLocationRange(t4)) ? this.getClientRectsForDOMRange(e4)[1] : void 0;
              }, f.prototype.locationIsCursorTarget = function(t4) {
                var e4, n3, i4;
                return i4 = this.findNodeAndOffsetFromLocation(t4), e4 = i4[0], n3 = i4[1], s4(e4);
              }, f.prototype.lock = function() {
                return this.lockCount++ === 0 ? (this.updateCurrentLocationRange(), this.lockedLocationRange = this.getLocationRange()) : void 0;
              }, f.prototype.unlock = function() {
                var t4;
                return --this.lockCount === 0 && (t4 = this.lockedLocationRange, this.lockedLocationRange = null, t4 != null) ? this.setLocationRange(t4) : void 0;
              }, f.prototype.clearSelection = function() {
                var t4;
                return (t4 = i3()) != null ? t4.removeAllRanges() : void 0;
              }, f.prototype.selectionIsCollapsed = function() {
                var t4;
                return ((t4 = n2()) != null ? t4.collapsed : void 0) === true;
              }, f.prototype.selectionIsExpanded = function() {
                return !this.selectionIsCollapsed();
              }, f.prototype.createLocationRangeFromDOMRange = function(t4, e4) {
                var n3, i4;
                if (t4 != null && this.domRangeWithinElement(t4) && (i4 = this.findLocationFromContainerAndOffset(t4.startContainer, t4.startOffset, e4)))
                  return t4.collapsed || (n3 = this.findLocationFromContainerAndOffset(t4.endContainer, t4.endOffset, e4)), a4([i4, n3]);
              }, f.proxyMethod("locationMapper.findLocationFromContainerAndOffset"), f.proxyMethod("locationMapper.findContainerAndOffsetFromLocation"), f.proxyMethod("locationMapper.findNodeAndOffsetFromLocation"), f.proxyMethod("pointMapper.createDOMRangeFromPoint"), f.proxyMethod("pointMapper.getClientRectsForDOMRange"), f.prototype.didMouseDown = function() {
                return this.pauseTemporarily();
              }, f.prototype.pauseTemporarily = function() {
                var e4, n3, i4, r3;
                return this.paused = true, n3 = function(e5) {
                  return function() {
                    var n4, o3, s5;
                    for (e5.paused = false, clearTimeout(r3), o3 = 0, s5 = i4.length; s5 > o3; o3++)
                      n4 = i4[o3], n4.destroy();
                    return t3(document, e5.element) ? e5.selectionDidChange() : void 0;
                  };
                }(this), r3 = setTimeout(n3, 200), i4 = function() {
                  var t4, i5, r4, s5;
                  for (r4 = ["mousemove", "keydown"], s5 = [], t4 = 0, i5 = r4.length; i5 > t4; t4++)
                    e4 = r4[t4], s5.push(o2(e4, { onElement: document, withCallback: n3 }));
                  return s5;
                }();
              }, f.prototype.selectionDidChange = function() {
                return this.paused || r2(this.element) ? void 0 : this.updateCurrentLocationRange();
              }, f.prototype.updateCurrentLocationRange = function(t4) {
                var e4;
                return (t4 != null ? t4 : t4 = this.createLocationRangeFromDOMRange(n2())) && !c2(t4, this.currentLocationRange) ? (this.currentLocationRange = t4, (e4 = this.delegate) != null && typeof e4.locationRangeDidChange == "function" ? e4.locationRangeDidChange(this.currentLocationRange.slice(0)) : void 0) : void 0;
              }, f.prototype.createDOMRangeFromLocationRange = function(t4) {
                var e4, n3, i4, o3;
                return i4 = this.findContainerAndOffsetFromLocation(t4[0]), n3 = u2(t4) ? i4 : (o3 = this.findContainerAndOffsetFromLocation(t4[1])) != null ? o3 : i4, i4 != null && n3 != null ? (e4 = document.createRange(), e4.setStart.apply(e4, i4), e4.setEnd.apply(e4, n3), e4) : void 0;
              }, f.prototype.getLocationAtPoint = function(t4) {
                var e4, n3;
                return (e4 = this.createDOMRangeFromPoint(t4)) && (n3 = this.createLocationRangeFromDOMRange(e4)) != null ? n3[0] : void 0;
              }, f.prototype.domRangeWithinElement = function(e4) {
                return e4.collapsed ? t3(this.element, e4.startContainer) : t3(this.element, e4.startContainer) && t3(this.element, e4.endContainer);
              }, f;
            }(e3.BasicObject);
          }.call(this), function() {
            var t3, n2, i3, o2, r2 = function(t4, e4) {
              function n3() {
                this.constructor = t4;
              }
              for (var i4 in e4)
                s4.call(e4, i4) && (t4[i4] = e4[i4]);
              return n3.prototype = e4.prototype, t4.prototype = new n3(), t4.__super__ = e4.prototype, t4;
            }, s4 = {}.hasOwnProperty, a4 = [].slice;
            i3 = e3.rangeIsCollapsed, o2 = e3.rangesAreEqual, n2 = e3.objectsAreEqual, t3 = e3.getBlockConfig, e3.EditorController = function(s5) {
              function u2(t4) {
                var n3, i4;
                this.editorElement = t4.editorElement, n3 = t4.document, i4 = t4.html, this.selectionManager = new e3.SelectionManager(this.editorElement), this.selectionManager.delegate = this, this.composition = new e3.Composition(), this.composition.delegate = this, this.attachmentManager = new e3.AttachmentManager(this.composition.getAttachments()), this.attachmentManager.delegate = this, this.inputController = new e3["Level" + e3.config.input.getLevel() + "InputController"](this.editorElement), this.inputController.delegate = this, this.inputController.responder = this.composition, this.compositionController = new e3.CompositionController(this.editorElement, this.composition), this.compositionController.delegate = this, this.toolbarController = new e3.ToolbarController(this.editorElement.toolbarElement), this.toolbarController.delegate = this, this.editor = new e3.Editor(this.composition, this.selectionManager, this.editorElement), n3 != null ? this.editor.loadDocument(n3) : this.editor.loadHTML(i4);
              }
              var c2;
              return r2(u2, s5), u2.prototype.registerSelectionManager = function() {
                return e3.selectionChangeObserver.registerSelectionManager(this.selectionManager);
              }, u2.prototype.unregisterSelectionManager = function() {
                return e3.selectionChangeObserver.unregisterSelectionManager(this.selectionManager);
              }, u2.prototype.render = function() {
                return this.compositionController.render();
              }, u2.prototype.reparse = function() {
                return this.composition.replaceHTML(this.editorElement.innerHTML);
              }, u2.prototype.compositionDidChangeDocument = function() {
                return this.notifyEditorElement("document-change"), this.handlingInput ? void 0 : this.render();
              }, u2.prototype.compositionDidChangeCurrentAttributes = function(t4) {
                return this.currentAttributes = t4, this.toolbarController.updateAttributes(this.currentAttributes), this.updateCurrentActions(), this.notifyEditorElement("attributes-change", { attributes: this.currentAttributes });
              }, u2.prototype.compositionDidPerformInsertionAtRange = function(t4) {
                return this.pasting ? this.pastedRange = t4 : void 0;
              }, u2.prototype.compositionShouldAcceptFile = function(t4) {
                return this.notifyEditorElement("file-accept", { file: t4 });
              }, u2.prototype.compositionDidAddAttachment = function(t4) {
                var e4;
                return e4 = this.attachmentManager.manageAttachment(t4), this.notifyEditorElement("attachment-add", { attachment: e4 });
              }, u2.prototype.compositionDidEditAttachment = function(t4) {
                var e4;
                return this.compositionController.rerenderViewForObject(t4), e4 = this.attachmentManager.manageAttachment(t4), this.notifyEditorElement("attachment-edit", { attachment: e4 }), this.notifyEditorElement("change");
              }, u2.prototype.compositionDidChangeAttachmentPreviewURL = function(t4) {
                return this.compositionController.invalidateViewForObject(t4), this.notifyEditorElement("change");
              }, u2.prototype.compositionDidRemoveAttachment = function(t4) {
                var e4;
                return e4 = this.attachmentManager.unmanageAttachment(t4), this.notifyEditorElement("attachment-remove", { attachment: e4 });
              }, u2.prototype.compositionDidStartEditingAttachment = function(t4, e4) {
                return this.attachmentLocationRange = this.composition.document.getLocationRangeOfAttachment(t4), this.compositionController.installAttachmentEditorForAttachment(t4, e4), this.selectionManager.setLocationRange(this.attachmentLocationRange);
              }, u2.prototype.compositionDidStopEditingAttachment = function() {
                return this.compositionController.uninstallAttachmentEditor(), this.attachmentLocationRange = null;
              }, u2.prototype.compositionDidRequestChangingSelectionToLocationRange = function(t4) {
                return !this.loadingSnapshot || this.isFocused() ? (this.requestedLocationRange = t4, this.compositionRevisionWhenLocationRangeRequested = this.composition.revision, this.handlingInput ? void 0 : this.render()) : void 0;
              }, u2.prototype.compositionWillLoadSnapshot = function() {
                return this.loadingSnapshot = true;
              }, u2.prototype.compositionDidLoadSnapshot = function() {
                return this.compositionController.refreshViewCache(), this.render(), this.loadingSnapshot = false;
              }, u2.prototype.getSelectionManager = function() {
                return this.selectionManager;
              }, u2.proxyMethod("getSelectionManager().setLocationRange"), u2.proxyMethod("getSelectionManager().getLocationRange"), u2.prototype.attachmentManagerDidRequestRemovalOfAttachment = function(t4) {
                return this.removeAttachment(t4);
              }, u2.prototype.compositionControllerWillSyncDocumentView = function() {
                return this.inputController.editorWillSyncDocumentView(), this.selectionManager.lock(), this.selectionManager.clearSelection();
              }, u2.prototype.compositionControllerDidSyncDocumentView = function() {
                return this.inputController.editorDidSyncDocumentView(), this.selectionManager.unlock(), this.updateCurrentActions(), this.notifyEditorElement("sync");
              }, u2.prototype.compositionControllerDidRender = function() {
                return this.requestedLocationRange != null && (this.compositionRevisionWhenLocationRangeRequested === this.composition.revision && this.selectionManager.setLocationRange(this.requestedLocationRange), this.requestedLocationRange = null, this.compositionRevisionWhenLocationRangeRequested = null), this.renderedCompositionRevision !== this.composition.revision && (this.runEditorFilters(), this.composition.updateCurrentAttributes(), this.notifyEditorElement("render")), this.renderedCompositionRevision = this.composition.revision;
              }, u2.prototype.compositionControllerDidFocus = function() {
                return this.isFocusedInvisibly() && this.setLocationRange({ index: 0, offset: 0 }), this.toolbarController.hideDialog(), this.notifyEditorElement("focus");
              }, u2.prototype.compositionControllerDidBlur = function() {
                return this.notifyEditorElement("blur");
              }, u2.prototype.compositionControllerDidSelectAttachment = function(t4, e4) {
                return this.toolbarController.hideDialog(), this.composition.editAttachment(t4, e4);
              }, u2.prototype.compositionControllerDidRequestDeselectingAttachment = function(t4) {
                var e4, n3;
                return e4 = (n3 = this.attachmentLocationRange) != null ? n3 : this.composition.document.getLocationRangeOfAttachment(t4), this.selectionManager.setLocationRange(e4[1]);
              }, u2.prototype.compositionControllerWillUpdateAttachment = function(t4) {
                return this.editor.recordUndoEntry("Edit Attachment", { context: t4.id, consolidatable: true });
              }, u2.prototype.compositionControllerDidRequestRemovalOfAttachment = function(t4) {
                return this.removeAttachment(t4);
              }, u2.prototype.inputControllerWillHandleInput = function() {
                return this.handlingInput = true, this.requestedRender = false;
              }, u2.prototype.inputControllerDidRequestRender = function() {
                return this.requestedRender = true;
              }, u2.prototype.inputControllerDidHandleInput = function() {
                return this.handlingInput = false, this.requestedRender ? (this.requestedRender = false, this.render()) : void 0;
              }, u2.prototype.inputControllerDidAllowUnhandledInput = function() {
                return this.notifyEditorElement("change");
              }, u2.prototype.inputControllerDidRequestReparse = function() {
                return this.reparse();
              }, u2.prototype.inputControllerWillPerformTyping = function() {
                return this.recordTypingUndoEntry();
              }, u2.prototype.inputControllerWillPerformFormatting = function(t4) {
                return this.recordFormattingUndoEntry(t4);
              }, u2.prototype.inputControllerWillCutText = function() {
                return this.editor.recordUndoEntry("Cut");
              }, u2.prototype.inputControllerWillPaste = function(t4) {
                return this.editor.recordUndoEntry("Paste"), this.pasting = true, this.notifyEditorElement("before-paste", { paste: t4 });
              }, u2.prototype.inputControllerDidPaste = function(t4) {
                return t4.range = this.pastedRange, this.pastedRange = null, this.pasting = null, this.notifyEditorElement("paste", { paste: t4 });
              }, u2.prototype.inputControllerWillMoveText = function() {
                return this.editor.recordUndoEntry("Move");
              }, u2.prototype.inputControllerWillAttachFiles = function() {
                return this.editor.recordUndoEntry("Drop Files");
              }, u2.prototype.inputControllerWillPerformUndo = function() {
                return this.editor.undo();
              }, u2.prototype.inputControllerWillPerformRedo = function() {
                return this.editor.redo();
              }, u2.prototype.inputControllerDidReceiveKeyboardCommand = function(t4) {
                return this.toolbarController.applyKeyboardCommand(t4);
              }, u2.prototype.inputControllerDidStartDrag = function() {
                return this.locationRangeBeforeDrag = this.selectionManager.getLocationRange();
              }, u2.prototype.inputControllerDidReceiveDragOverPoint = function(t4) {
                return this.selectionManager.setLocationRangeFromPointRange(t4);
              }, u2.prototype.inputControllerDidCancelDrag = function() {
                return this.selectionManager.setLocationRange(this.locationRangeBeforeDrag), this.locationRangeBeforeDrag = null;
              }, u2.prototype.locationRangeDidChange = function(t4) {
                return this.composition.updateCurrentAttributes(), this.updateCurrentActions(), this.attachmentLocationRange && !o2(this.attachmentLocationRange, t4) && this.composition.stopEditingAttachment(), this.notifyEditorElement("selection-change");
              }, u2.prototype.toolbarDidClickButton = function() {
                return this.getLocationRange() ? void 0 : this.setLocationRange({ index: 0, offset: 0 });
              }, u2.prototype.toolbarDidInvokeAction = function(t4) {
                return this.invokeAction(t4);
              }, u2.prototype.toolbarDidToggleAttribute = function(t4) {
                return this.recordFormattingUndoEntry(t4), this.composition.toggleCurrentAttribute(t4), this.render(), this.selectionFrozen ? void 0 : this.editorElement.focus();
              }, u2.prototype.toolbarDidUpdateAttribute = function(t4, e4) {
                return this.recordFormattingUndoEntry(t4), this.composition.setCurrentAttribute(t4, e4), this.render(), this.selectionFrozen ? void 0 : this.editorElement.focus();
              }, u2.prototype.toolbarDidRemoveAttribute = function(t4) {
                return this.recordFormattingUndoEntry(t4), this.composition.removeCurrentAttribute(t4), this.render(), this.selectionFrozen ? void 0 : this.editorElement.focus();
              }, u2.prototype.toolbarWillShowDialog = function() {
                return this.composition.expandSelectionForEditing(), this.freezeSelection();
              }, u2.prototype.toolbarDidShowDialog = function(t4) {
                return this.notifyEditorElement("toolbar-dialog-show", { dialogName: t4 });
              }, u2.prototype.toolbarDidHideDialog = function(t4) {
                return this.thawSelection(), this.editorElement.focus(), this.notifyEditorElement("toolbar-dialog-hide", { dialogName: t4 });
              }, u2.prototype.freezeSelection = function() {
                return this.selectionFrozen ? void 0 : (this.selectionManager.lock(), this.composition.freezeSelection(), this.selectionFrozen = true, this.render());
              }, u2.prototype.thawSelection = function() {
                return this.selectionFrozen ? (this.composition.thawSelection(), this.selectionManager.unlock(), this.selectionFrozen = false, this.render()) : void 0;
              }, u2.prototype.actions = { undo: { test: function() {
                return this.editor.canUndo();
              }, perform: function() {
                return this.editor.undo();
              } }, redo: { test: function() {
                return this.editor.canRedo();
              }, perform: function() {
                return this.editor.redo();
              } }, link: { test: function() {
                return this.editor.canActivateAttribute("href");
              } }, increaseNestingLevel: { test: function() {
                return this.editor.canIncreaseNestingLevel();
              }, perform: function() {
                return this.editor.increaseNestingLevel() && this.render();
              } }, decreaseNestingLevel: { test: function() {
                return this.editor.canDecreaseNestingLevel();
              }, perform: function() {
                return this.editor.decreaseNestingLevel() && this.render();
              } }, attachFiles: { test: function() {
                return true;
              }, perform: function() {
                return e3.config.input.pickFiles(this.editor.insertFiles);
              } } }, u2.prototype.canInvokeAction = function(t4) {
                var e4, n3;
                return this.actionIsExternal(t4) ? true : !!((e4 = this.actions[t4]) != null && (n3 = e4.test) != null ? n3.call(this) : void 0);
              }, u2.prototype.invokeAction = function(t4) {
                var e4, n3;
                return this.actionIsExternal(t4) ? this.notifyEditorElement("action-invoke", { actionName: t4 }) : (e4 = this.actions[t4]) != null && (n3 = e4.perform) != null ? n3.call(this) : void 0;
              }, u2.prototype.actionIsExternal = function(t4) {
                return /^x-./.test(t4);
              }, u2.prototype.getCurrentActions = function() {
                var t4, e4;
                e4 = {};
                for (t4 in this.actions)
                  e4[t4] = this.canInvokeAction(t4);
                return e4;
              }, u2.prototype.updateCurrentActions = function() {
                var t4;
                return t4 = this.getCurrentActions(), n2(t4, this.currentActions) ? void 0 : (this.currentActions = t4, this.toolbarController.updateActions(this.currentActions), this.notifyEditorElement("actions-change", { actions: this.currentActions }));
              }, u2.prototype.runEditorFilters = function() {
                var t4, e4, n3, i4, o3, r3, s6, a5;
                for (a5 = this.composition.getSnapshot(), o3 = this.editor.filters, n3 = 0, i4 = o3.length; i4 > n3; n3++)
                  e4 = o3[n3], t4 = a5.document, s6 = a5.selectedRange, a5 = (r3 = e4.call(this.editor, a5)) != null ? r3 : {}, a5.document == null && (a5.document = t4), a5.selectedRange == null && (a5.selectedRange = s6);
                return c2(a5, this.composition.getSnapshot()) ? void 0 : this.composition.loadSnapshot(a5);
              }, c2 = function(t4, e4) {
                return o2(t4.selectedRange, e4.selectedRange) && t4.document.isEqualTo(e4.document);
              }, u2.prototype.updateInputElement = function() {
                var t4, n3;
                return t4 = this.compositionController.getSerializableElement(), n3 = e3.serializeToContentType(t4, "text/html"), this.editorElement.setInputElementValue(n3);
              }, u2.prototype.notifyEditorElement = function(t4, e4) {
                switch (t4) {
                  case "document-change":
                    this.documentChangedSinceLastRender = true;
                    break;
                  case "render":
                    this.documentChangedSinceLastRender && (this.documentChangedSinceLastRender = false, this.notifyEditorElement("change"));
                    break;
                  case "change":
                  case "attachment-add":
                  case "attachment-edit":
                  case "attachment-remove":
                    this.updateInputElement();
                }
                return this.editorElement.notify(t4, e4);
              }, u2.prototype.removeAttachment = function(t4) {
                return this.editor.recordUndoEntry("Delete Attachment"), this.composition.removeAttachment(t4), this.render();
              }, u2.prototype.recordFormattingUndoEntry = function(e4) {
                var n3, o3;
                return n3 = t3(e4), o3 = this.selectionManager.getLocationRange(), n3 || !i3(o3) ? this.editor.recordUndoEntry("Formatting", { context: this.getUndoContext(), consolidatable: true }) : void 0;
              }, u2.prototype.recordTypingUndoEntry = function() {
                return this.editor.recordUndoEntry("Typing", { context: this.getUndoContext(this.currentAttributes), consolidatable: true });
              }, u2.prototype.getUndoContext = function() {
                var t4;
                return t4 = 1 <= arguments.length ? a4.call(arguments, 0) : [], [this.getLocationContext(), this.getTimeContext()].concat(a4.call(t4));
              }, u2.prototype.getLocationContext = function() {
                var t4;
                return t4 = this.selectionManager.getLocationRange(), i3(t4) ? t4[0].index : t4;
              }, u2.prototype.getTimeContext = function() {
                return e3.config.undoInterval > 0 ? Math.floor(new Date().getTime() / e3.config.undoInterval) : 0;
              }, u2.prototype.isFocused = function() {
                var t4;
                return this.editorElement === ((t4 = this.editorElement.ownerDocument) != null ? t4.activeElement : void 0);
              }, u2.prototype.isFocusedInvisibly = function() {
                return this.isFocused() && !this.getLocationRange();
              }, u2;
            }(e3.Controller);
          }.call(this), function() {
            var t3, n2, i3, o2, r2, s4, a4, u2 = [].indexOf || function(t4) {
              for (var e4 = 0, n3 = this.length; n3 > e4; e4++)
                if (e4 in this && this[e4] === t4)
                  return e4;
              return -1;
            };
            n2 = e3.browser, s4 = e3.makeElement, a4 = e3.triggerEvent, o2 = e3.handleEvent, r2 = e3.handleEventOnce, i3 = e3.findClosestElementFromNode, t3 = e3.AttachmentView.attachmentSelector, e3.registerElement("trix-editor", function() {
              var c2, l2, h5, p, d3, f, g, m3, v;
              return g = 0, l2 = function(t4) {
                return !document.querySelector(":focus") && t4.hasAttribute("autofocus") && document.querySelector("[autofocus]") === t4 ? t4.focus() : void 0;
              }, m3 = function(t4) {
                return t4.hasAttribute("contenteditable") ? void 0 : (t4.setAttribute("contenteditable", ""), r2("focus", { onElement: t4, withCallback: function() {
                  return h5(t4);
                } }));
              }, h5 = function(t4) {
                return d3(t4), v(t4);
              }, d3 = function(t4) {
                return (typeof document.queryCommandSupported == "function" ? document.queryCommandSupported("enableObjectResizing") : void 0) ? (document.execCommand("enableObjectResizing", false, false), o2("mscontrolselect", { onElement: t4, preventDefault: true })) : void 0;
              }, v = function() {
                var t4;
                return (typeof document.queryCommandSupported == "function" ? document.queryCommandSupported("DefaultParagraphSeparator") : void 0) && (t4 = e3.config.blockAttributes["default"].tagName, t4 === "div" || t4 === "p") ? document.execCommand("DefaultParagraphSeparator", false, t4) : void 0;
              }, c2 = function(t4) {
                return t4.hasAttribute("role") ? void 0 : t4.setAttribute("role", "textbox");
              }, f = function(t4) {
                var e4;
                if (!t4.hasAttribute("aria-label") && !t4.hasAttribute("aria-labelledby"))
                  return (e4 = function() {
                    var e5, n3, i4;
                    return i4 = function() {
                      var n4, i5, o3, r3;
                      for (o3 = t4.labels, r3 = [], n4 = 0, i5 = o3.length; i5 > n4; n4++)
                        e5 = o3[n4], e5.contains(t4) || r3.push(e5.textContent);
                      return r3;
                    }(), (n3 = i4.join(" ")) ? t4.setAttribute("aria-label", n3) : t4.removeAttribute("aria-label");
                  })(), o2("focus", { onElement: t4, withCallback: e4 });
              }, p = function() {
                return n2.forcesObjectResizing ? { display: "inline", width: "auto" } : { display: "inline-block", width: "1px" };
              }(), { defaultCSS: "%t {\n  display: block;\n}\n\n%t:empty:not(:focus)::before {\n  content: attr(placeholder);\n  color: graytext;\n  cursor: text;\n  pointer-events: none;\n}\n\n%t a[contenteditable=false] {\n  cursor: text;\n}\n\n%t img {\n  max-width: 100%;\n  height: auto;\n}\n\n%t " + t3 + " figcaption textarea {\n  resize: none;\n}\n\n%t " + t3 + " figcaption textarea.trix-autoresize-clone {\n  position: absolute;\n  left: -9999px;\n  max-height: 0px;\n}\n\n%t " + t3 + " figcaption[data-trix-placeholder]:empty::before {\n  content: attr(data-trix-placeholder);\n  color: graytext;\n}\n\n%t [data-trix-cursor-target] {\n  display: " + p.display + " !important;\n  width: " + p.width + " !important;\n  padding: 0 !important;\n  margin: 0 !important;\n  border: none !important;\n}\n\n%t [data-trix-cursor-target=left] {\n  vertical-align: top !important;\n  margin-left: -1px !important;\n}\n\n%t [data-trix-cursor-target=right] {\n  vertical-align: bottom !important;\n  margin-right: -1px !important;\n}", trixId: { get: function() {
                return this.hasAttribute("trix-id") ? this.getAttribute("trix-id") : (this.setAttribute("trix-id", ++g), this.trixId);
              } }, labels: { get: function() {
                var t4, e4, n3;
                return e4 = [], this.id && this.ownerDocument && e4.push.apply(e4, this.ownerDocument.querySelectorAll("label[for='" + this.id + "']")), (t4 = i3(this, { matchingSelector: "label" })) && ((n3 = t4.control) === this || n3 === null) && e4.push(t4), e4;
              } }, toolbarElement: { get: function() {
                var t4, e4, n3;
                return this.hasAttribute("toolbar") ? (e4 = this.ownerDocument) != null ? e4.getElementById(this.getAttribute("toolbar")) : void 0 : this.parentNode ? (n3 = "trix-toolbar-" + this.trixId, this.setAttribute("toolbar", n3), t4 = s4("trix-toolbar", { id: n3 }), this.parentNode.insertBefore(t4, this), t4) : void 0;
              } }, inputElement: { get: function() {
                var t4, e4, n3;
                return this.hasAttribute("input") ? (n3 = this.ownerDocument) != null ? n3.getElementById(this.getAttribute("input")) : void 0 : this.parentNode ? (e4 = "trix-input-" + this.trixId, this.setAttribute("input", e4), t4 = s4("input", { type: "hidden", id: e4 }), this.parentNode.insertBefore(t4, this.nextElementSibling), t4) : void 0;
              } }, editor: { get: function() {
                var t4;
                return (t4 = this.editorController) != null ? t4.editor : void 0;
              } }, name: { get: function() {
                var t4;
                return (t4 = this.inputElement) != null ? t4.name : void 0;
              } }, value: { get: function() {
                var t4;
                return (t4 = this.inputElement) != null ? t4.value : void 0;
              }, set: function(t4) {
                var e4;
                return this.defaultValue = t4, (e4 = this.editor) != null ? e4.loadHTML(this.defaultValue) : void 0;
              } }, notify: function(t4, e4) {
                return this.editorController ? a4("trix-" + t4, { onElement: this, attributes: e4 }) : void 0;
              }, setInputElementValue: function(t4) {
                var e4;
                return (e4 = this.inputElement) != null ? e4.value = t4 : void 0;
              }, initialize: function() {
                return this.hasAttribute("data-trix-internal") ? void 0 : (m3(this), c2(this), f(this));
              }, connect: function() {
                return this.hasAttribute("data-trix-internal") ? void 0 : (this.editorController || (a4("trix-before-initialize", { onElement: this }), this.editorController = new e3.EditorController({ editorElement: this, html: this.defaultValue = this.value }), requestAnimationFrame(function(t4) {
                  return function() {
                    return a4("trix-initialize", { onElement: t4 });
                  };
                }(this))), this.editorController.registerSelectionManager(), this.registerResetListener(), this.registerClickListener(), l2(this));
              }, disconnect: function() {
                var t4;
                return (t4 = this.editorController) != null && t4.unregisterSelectionManager(), this.unregisterResetListener(), this.unregisterClickListener();
              }, registerResetListener: function() {
                return this.resetListener = this.resetBubbled.bind(this), window.addEventListener("reset", this.resetListener, false);
              }, unregisterResetListener: function() {
                return window.removeEventListener("reset", this.resetListener, false);
              }, registerClickListener: function() {
                return this.clickListener = this.clickBubbled.bind(this), window.addEventListener("click", this.clickListener, false);
              }, unregisterClickListener: function() {
                return window.removeEventListener("click", this.clickListener, false);
              }, resetBubbled: function(t4) {
                var e4;
                if (!t4.defaultPrevented && t4.target === ((e4 = this.inputElement) != null ? e4.form : void 0))
                  return this.reset();
              }, clickBubbled: function(t4) {
                var e4;
                if (!(t4.defaultPrevented || this.contains(t4.target) || !(e4 = i3(t4.target, { matchingSelector: "label" })) || u2.call(this.labels, e4) < 0))
                  return this.focus();
              }, reset: function() {
                return this.value = this.defaultValue;
              } };
            }());
          }.call(this), function() {
          }.call(this);
        }).call(this), typeof module4 == "object" && module4.exports ? module4.exports = e3 : typeof define == "function" && define.amd && define(e3);
      }.call(exports2);
    }
  });

  // src/confirm.js
  var require_confirm = __commonJS({
    "src/confirm.js"() {
      var Rails3 = require_rails_ujs();
      var old_confirm = Rails3.confirm;
      var elements3 = ["a[data-confirm]", "button[data-confirm]", "input[type=submit][data-confirm]"];
      var createConfirmModal = (element) => {
        var id = "confirm-modal-" + String(Math.random()).slice(2, -1);
        var confirm2 = element.dataset.confirm;
        var content = `
    <div id="${id}" class="z-50 animated fadeIn fixed top-0 left-0 w-full h-full table" style="background-color: rgba(0, 0, 0, 0.8);">
      <div class="table-cell align-middle">

        <div class="bg-white mx-auto rounded shadow p-8 max-w-sm">
          <h4>${confirm2}</h4>

          <div class="flex justify-end items-center flex-wrap mt-6">
            <button data-behavior="cancel" class="btn btn-light-gray mr-2">Cancel</button>
            <button data-behavior="commit" class="btn btn-danger focus:outline-none">Confirm</button>
          </div>
        </div>
      </div>
    </div>
  `;
        element.insertAdjacentHTML("afterend", content);
        var modal = element.nextElementSibling;
        element.dataset.confirmModal = `#${id}`;
        modal.addEventListener("keyup", (event) => {
          if (event.key === "Escape") {
            event.preventDefault();
            element.removeAttribute("data-confirm-modal");
            modal.remove();
          }
        });
        modal.querySelector("[data-behavior='cancel']").addEventListener("click", (event) => {
          event.preventDefault();
          element.removeAttribute("data-confirm-modal");
          modal.remove();
        });
        modal.querySelector("[data-behavior='commit']").addEventListener("click", (event) => {
          event.preventDefault();
          Rails3.confirm = () => {
            return true;
          };
          element.click();
          element.removeAttribute("data-confirm-modal");
          Rails3.confirm = old_confirm;
          modal.remove();
        });
        modal.querySelector("[data-behavior='commit']").focus();
        return modal;
      };
      var confirmModalOpen = (element) => {
        return !!element.dataset.confirmModal;
      };
      var handleConfirm = (event) => {
        if (confirmModalOpen(event.target)) {
          return true;
        } else {
          createConfirmModal(event.target);
          return false;
        }
      };
      Rails3.delegate(document, elements3.join(", "), "confirm", handleConfirm);
    }
  });

  // src/direct_uploads.js
  var require_direct_uploads = __commonJS({
    "src/direct_uploads.js"() {
      addEventListener("direct-upload:initialize", (event) => {
        const { target, detail } = event;
        const { id, file } = detail;
        target.insertAdjacentHTML("beforebegin", `
    <div id="direct-upload-${id}" class="direct-upload direct-upload--pending">
      <div id="direct-upload-progress-${id}" class="direct-upload__progress" style="width: 0%"></div>
      <span class="direct-upload__filename">${file.name}</span>
    </div>
  `);
      });
      addEventListener("direct-upload:start", (event) => {
        const { id } = event.detail;
        const element = document.getElementById(`direct-upload-${id}`);
        element.classList.remove("direct-upload--pending");
      });
      addEventListener("direct-upload:progress", (event) => {
        const { id, progress } = event.detail;
        const progressElement = document.getElementById(`direct-upload-progress-${id}`);
        progressElement.style.width = `${progress}%`;
      });
      addEventListener("direct-upload:error", (event) => {
        event.preventDefault();
        const { id, error: error2 } = event.detail;
        const element = document.getElementById(`direct-upload-${id}`);
        element.classList.add("direct-upload--error");
        element.setAttribute("title", error2);
      });
      addEventListener("direct-upload:end", (event) => {
        const { id } = event.detail;
        const element = document.getElementById(`direct-upload-${id}`);
        element.classList.add("direct-upload--complete");
      });
    }
  });

  // src/lazysrc.js
  var require_lazysrc = __commonJS({
    "src/lazysrc.js"() {
      document.addEventListener("turbo:load", () => {
        document.querySelectorAll("[data-src]").forEach((element) => {
          element.setAttribute("src", element.getAttribute("data-src"));
        });
      });
    }
  });

  // ../../node_modules/jstz/dist/jstz.js
  var require_jstz = __commonJS({
    "../../node_modules/jstz/dist/jstz.js"(exports2, module4) {
      (function(root) {
        var jstz2 = function() {
          "use strict";
          var HEMISPHERE_SOUTH = "s", consts = {
            DAY: 864e5,
            HOUR: 36e5,
            MINUTE: 6e4,
            SECOND: 1e3,
            BASELINE_YEAR: 2014,
            MAX_SCORE: 864e6,
            AMBIGUITIES: {
              "America/Denver": ["America/Mazatlan"],
              "Europe/London": ["Africa/Casablanca"],
              "America/Chicago": ["America/Mexico_City"],
              "America/Asuncion": ["America/Campo_Grande", "America/Santiago"],
              "America/Montevideo": ["America/Sao_Paulo", "America/Santiago"],
              "Asia/Beirut": ["Asia/Amman", "Asia/Jerusalem", "Europe/Helsinki", "Asia/Damascus", "Africa/Cairo", "Asia/Gaza", "Europe/Minsk"],
              "Pacific/Auckland": ["Pacific/Fiji"],
              "America/Los_Angeles": ["America/Santa_Isabel"],
              "America/New_York": ["America/Havana"],
              "America/Halifax": ["America/Goose_Bay"],
              "America/Godthab": ["America/Miquelon"],
              "Asia/Dubai": ["Asia/Yerevan"],
              "Asia/Jakarta": ["Asia/Krasnoyarsk"],
              "Asia/Shanghai": ["Asia/Irkutsk", "Australia/Perth"],
              "Australia/Sydney": ["Australia/Lord_Howe"],
              "Asia/Tokyo": ["Asia/Yakutsk"],
              "Asia/Dhaka": ["Asia/Omsk"],
              "Asia/Baku": ["Asia/Yerevan"],
              "Australia/Brisbane": ["Asia/Vladivostok"],
              "Pacific/Noumea": ["Asia/Vladivostok"],
              "Pacific/Majuro": ["Asia/Kamchatka", "Pacific/Fiji"],
              "Pacific/Tongatapu": ["Pacific/Apia"],
              "Asia/Baghdad": ["Europe/Minsk", "Europe/Moscow"],
              "Asia/Karachi": ["Asia/Yekaterinburg"],
              "Africa/Johannesburg": ["Asia/Gaza", "Africa/Cairo"]
            }
          }, get_date_offset = function get_date_offset2(date) {
            var offset2 = -date.getTimezoneOffset();
            return offset2 !== null ? offset2 : 0;
          }, lookup_key = function lookup_key2() {
            var january_offset = get_date_offset(new Date(consts.BASELINE_YEAR, 0, 2)), june_offset = get_date_offset(new Date(consts.BASELINE_YEAR, 5, 2)), diff = january_offset - june_offset;
            if (diff < 0) {
              return january_offset + ",1";
            } else if (diff > 0) {
              return june_offset + ",1," + HEMISPHERE_SOUTH;
            }
            return january_offset + ",0";
          }, get_from_internationalization_api = function get_from_internationalization_api2() {
            var format3, timezone;
            if (typeof Intl === "undefined" || typeof Intl.DateTimeFormat === "undefined") {
              return;
            }
            format3 = Intl.DateTimeFormat();
            if (typeof format3 === "undefined" || typeof format3.resolvedOptions === "undefined") {
              return;
            }
            timezone = format3.resolvedOptions().timeZone;
            if (timezone && (timezone.indexOf("/") > -1 || timezone === "UTC") && timezone.indexOf("Etc") != 0) {
              return timezone;
            }
          }, dst_dates = function dst_dates2(year) {
            var yearstart = new Date(year, 0, 1, 0, 0, 1, 0).getTime();
            var yearend = new Date(year, 12, 31, 23, 59, 59).getTime();
            var current = yearstart;
            var offset2 = new Date(current).getTimezoneOffset();
            var dst_start = null;
            var dst_end = null;
            while (current < yearend - 864e5) {
              var dateToCheck = new Date(current);
              var dateToCheckOffset = dateToCheck.getTimezoneOffset();
              if (dateToCheckOffset !== offset2) {
                if (dateToCheckOffset < offset2) {
                  dst_start = dateToCheck;
                }
                if (dateToCheckOffset > offset2) {
                  dst_end = dateToCheck;
                }
                offset2 = dateToCheckOffset;
              }
              current += 864e5;
            }
            if (dst_start && dst_end) {
              return {
                s: find_dst_fold(dst_start).getTime(),
                e: find_dst_fold(dst_end).getTime()
              };
            }
            return false;
          }, find_dst_fold = function find_dst_fold2(a_date, padding, iterator) {
            if (typeof padding === "undefined") {
              padding = consts.DAY;
              iterator = consts.HOUR;
            }
            var date_start = new Date(a_date.getTime() - padding).getTime();
            var date_end = a_date.getTime() + padding;
            var offset2 = new Date(date_start).getTimezoneOffset();
            var current = date_start;
            var dst_change = null;
            while (current < date_end - iterator) {
              var dateToCheck = new Date(current);
              var dateToCheckOffset = dateToCheck.getTimezoneOffset();
              if (dateToCheckOffset !== offset2) {
                dst_change = dateToCheck;
                break;
              }
              current += iterator;
            }
            if (padding === consts.DAY) {
              return find_dst_fold2(dst_change, consts.HOUR, consts.MINUTE);
            }
            if (padding === consts.HOUR) {
              return find_dst_fold2(dst_change, consts.MINUTE, consts.SECOND);
            }
            return dst_change;
          }, windows7_adaptations = function windows7_adaptions(rule_list, preliminary_timezone, score, sample2) {
            if (score !== "N/A") {
              return score;
            }
            if (preliminary_timezone === "Asia/Beirut") {
              if (sample2.name === "Africa/Cairo") {
                if (rule_list[6].s === 13983768e5 && rule_list[6].e === 14116788e5) {
                  return 0;
                }
              }
              if (sample2.name === "Asia/Jerusalem") {
                if (rule_list[6].s === 13959648e5 && rule_list[6].e === 14118588e5) {
                  return 0;
                }
              }
            } else if (preliminary_timezone === "America/Santiago") {
              if (sample2.name === "America/Asuncion") {
                if (rule_list[6].s === 14124816e5 && rule_list[6].e === 1397358e6) {
                  return 0;
                }
              }
              if (sample2.name === "America/Campo_Grande") {
                if (rule_list[6].s === 14136912e5 && rule_list[6].e === 13925196e5) {
                  return 0;
                }
              }
            } else if (preliminary_timezone === "America/Montevideo") {
              if (sample2.name === "America/Sao_Paulo") {
                if (rule_list[6].s === 14136876e5 && rule_list[6].e === 1392516e6) {
                  return 0;
                }
              }
            } else if (preliminary_timezone === "Pacific/Auckland") {
              if (sample2.name === "Pacific/Fiji") {
                if (rule_list[6].s === 14142456e5 && rule_list[6].e === 13961016e5) {
                  return 0;
                }
              }
            }
            return score;
          }, best_dst_match = function best_dst_match2(rule_list, preliminary_timezone) {
            var score_sample = function score_sample2(sample3) {
              var score2 = 0;
              for (var j2 = 0; j2 < rule_list.length; j2++) {
                if (!!sample3.rules[j2] && !!rule_list[j2]) {
                  if (rule_list[j2].s >= sample3.rules[j2].s && rule_list[j2].e <= sample3.rules[j2].e) {
                    score2 = 0;
                    score2 += Math.abs(rule_list[j2].s - sample3.rules[j2].s);
                    score2 += Math.abs(sample3.rules[j2].e - rule_list[j2].e);
                  } else {
                    score2 = "N/A";
                    break;
                  }
                  if (score2 > consts.MAX_SCORE) {
                    score2 = "N/A";
                    break;
                  }
                }
              }
              score2 = windows7_adaptations(rule_list, preliminary_timezone, score2, sample3);
              return score2;
            };
            var scoreboard = {};
            var dst_zones = jstz2.olson.dst_rules.zones;
            var dst_zones_length = dst_zones.length;
            var ambiguities = consts.AMBIGUITIES[preliminary_timezone];
            for (var i3 = 0; i3 < dst_zones_length; i3++) {
              var sample2 = dst_zones[i3];
              var score = score_sample(dst_zones[i3]);
              if (score !== "N/A") {
                scoreboard[sample2.name] = score;
              }
            }
            for (var tz in scoreboard) {
              if (scoreboard.hasOwnProperty(tz)) {
                for (var j = 0; j < ambiguities.length; j++) {
                  if (ambiguities[j] === tz) {
                    return tz;
                  }
                }
              }
            }
            return preliminary_timezone;
          }, get_by_dst = function get_by_dst2(preliminary_timezone) {
            var get_rules = function get_rules2() {
              var rule_list = [];
              for (var i3 = 0; i3 < jstz2.olson.dst_rules.years.length; i3++) {
                var year_rules = dst_dates(jstz2.olson.dst_rules.years[i3]);
                rule_list.push(year_rules);
              }
              return rule_list;
            };
            var check_has_dst = function check_has_dst2(rules2) {
              for (var i3 = 0; i3 < rules2.length; i3++) {
                if (rules2[i3] !== false) {
                  return true;
                }
              }
              return false;
            };
            var rules = get_rules();
            var has_dst = check_has_dst(rules);
            if (has_dst) {
              return best_dst_match(rules, preliminary_timezone);
            }
            return preliminary_timezone;
          }, determine = function determine2() {
            var preliminary_tz = get_from_internationalization_api();
            if (!preliminary_tz) {
              preliminary_tz = jstz2.olson.timezones[lookup_key()];
              if (typeof consts.AMBIGUITIES[preliminary_tz] !== "undefined") {
                preliminary_tz = get_by_dst(preliminary_tz);
              }
            }
            return {
              name: function() {
                return preliminary_tz;
              },
              stdTimezoneOffset: function() {
                return -lookup_key().split(",")[0];
              },
              timezoneOffset: function() {
                return -get_date_offset(new Date());
              }
            };
          };
          return {
            determine
          };
        }();
        jstz2.olson = jstz2.olson || {};
        jstz2.olson.timezones = {
          "-720,0": "Etc/GMT+12",
          "-660,0": "Pacific/Pago_Pago",
          "-660,1,s": "Pacific/Apia",
          "-600,1": "America/Adak",
          "-600,0": "Pacific/Honolulu",
          "-570,0": "Pacific/Marquesas",
          "-540,0": "Pacific/Gambier",
          "-540,1": "America/Anchorage",
          "-480,1": "America/Los_Angeles",
          "-480,0": "Pacific/Pitcairn",
          "-420,0": "America/Phoenix",
          "-420,1": "America/Denver",
          "-360,0": "America/Guatemala",
          "-360,1": "America/Chicago",
          "-360,1,s": "Pacific/Easter",
          "-300,0": "America/Bogota",
          "-300,1": "America/New_York",
          "-270,0": "America/Caracas",
          "-240,1": "America/Halifax",
          "-240,0": "America/Santo_Domingo",
          "-240,1,s": "America/Asuncion",
          "-210,1": "America/St_Johns",
          "-180,1": "America/Godthab",
          "-180,0": "America/Argentina/Buenos_Aires",
          "-180,1,s": "America/Montevideo",
          "-120,0": "America/Noronha",
          "-120,1": "America/Noronha",
          "-60,1": "Atlantic/Azores",
          "-60,0": "Atlantic/Cape_Verde",
          "0,0": "UTC",
          "0,1": "Europe/London",
          "60,1": "Europe/Berlin",
          "60,0": "Africa/Lagos",
          "60,1,s": "Africa/Windhoek",
          "120,1": "Asia/Beirut",
          "120,0": "Africa/Johannesburg",
          "180,0": "Asia/Baghdad",
          "180,1": "Europe/Moscow",
          "210,1": "Asia/Tehran",
          "240,0": "Asia/Dubai",
          "240,1": "Asia/Baku",
          "270,0": "Asia/Kabul",
          "300,1": "Asia/Yekaterinburg",
          "300,0": "Asia/Karachi",
          "330,0": "Asia/Kolkata",
          "345,0": "Asia/Kathmandu",
          "360,0": "Asia/Dhaka",
          "360,1": "Asia/Omsk",
          "390,0": "Asia/Rangoon",
          "420,1": "Asia/Krasnoyarsk",
          "420,0": "Asia/Jakarta",
          "480,0": "Asia/Shanghai",
          "480,1": "Asia/Irkutsk",
          "525,0": "Australia/Eucla",
          "525,1,s": "Australia/Eucla",
          "540,1": "Asia/Yakutsk",
          "540,0": "Asia/Tokyo",
          "570,0": "Australia/Darwin",
          "570,1,s": "Australia/Adelaide",
          "600,0": "Australia/Brisbane",
          "600,1": "Asia/Vladivostok",
          "600,1,s": "Australia/Sydney",
          "630,1,s": "Australia/Lord_Howe",
          "660,1": "Asia/Kamchatka",
          "660,0": "Pacific/Noumea",
          "690,0": "Pacific/Norfolk",
          "720,1,s": "Pacific/Auckland",
          "720,0": "Pacific/Majuro",
          "765,1,s": "Pacific/Chatham",
          "780,0": "Pacific/Tongatapu",
          "780,1,s": "Pacific/Apia",
          "840,0": "Pacific/Kiritimati"
        };
        jstz2.olson.dst_rules = {
          "years": [
            2008,
            2009,
            2010,
            2011,
            2012,
            2013,
            2014
          ],
          "zones": [
            {
              "name": "Africa/Cairo",
              "rules": [
                {
                  "e": 12199572e5,
                  "s": 12090744e5
                },
                {
                  "e": 1250802e6,
                  "s": 1240524e6
                },
                {
                  "e": 12858804e5,
                  "s": 12840696e5
                },
                false,
                false,
                false,
                {
                  "e": 14116788e5,
                  "s": 1406844e6
                }
              ]
            },
            {
              "name": "Africa/Casablanca",
              "rules": [
                {
                  "e": 12202236e5,
                  "s": 12122784e5
                },
                {
                  "e": 12508092e5,
                  "s": 12438144e5
                },
                {
                  "e": 1281222e6,
                  "s": 12727584e5
                },
                {
                  "e": 13120668e5,
                  "s": 13017888e5
                },
                {
                  "e": 13489704e5,
                  "s": 1345428e6
                },
                {
                  "e": 13828392e5,
                  "s": 13761e8
                },
                {
                  "e": 14142888e5,
                  "s": 14069448e5
                }
              ]
            },
            {
              "name": "America/Asuncion",
              "rules": [
                {
                  "e": 12050316e5,
                  "s": 12243888e5
                },
                {
                  "e": 12364812e5,
                  "s": 12558384e5
                },
                {
                  "e": 12709548e5,
                  "s": 12860784e5
                },
                {
                  "e": 13024044e5,
                  "s": 1317528e6
                },
                {
                  "e": 1333854e6,
                  "s": 13495824e5
                },
                {
                  "e": 1364094e6,
                  "s": 1381032e6
                },
                {
                  "e": 13955436e5,
                  "s": 14124816e5
                }
              ]
            },
            {
              "name": "America/Campo_Grande",
              "rules": [
                {
                  "e": 12032172e5,
                  "s": 12243888e5
                },
                {
                  "e": 12346668e5,
                  "s": 12558384e5
                },
                {
                  "e": 12667212e5,
                  "s": 1287288e6
                },
                {
                  "e": 12981708e5,
                  "s": 13187376e5
                },
                {
                  "e": 13302252e5,
                  "s": 1350792e6
                },
                {
                  "e": 136107e7,
                  "s": 13822416e5
                },
                {
                  "e": 13925196e5,
                  "s": 14136912e5
                }
              ]
            },
            {
              "name": "America/Goose_Bay",
              "rules": [
                {
                  "e": 122559486e4,
                  "s": 120503526e4
                },
                {
                  "e": 125704446e4,
                  "s": 123648486e4
                },
                {
                  "e": 128909886e4,
                  "s": 126853926e4
                },
                {
                  "e": 13205556e5,
                  "s": 129998886e4
                },
                {
                  "e": 13520052e5,
                  "s": 13314456e5
                },
                {
                  "e": 13834548e5,
                  "s": 13628952e5
                },
                {
                  "e": 14149044e5,
                  "s": 13943448e5
                }
              ]
            },
            {
              "name": "America/Havana",
              "rules": [
                {
                  "e": 12249972e5,
                  "s": 12056436e5
                },
                {
                  "e": 12564468e5,
                  "s": 12364884e5
                },
                {
                  "e": 12885012e5,
                  "s": 12685428e5
                },
                {
                  "e": 13211604e5,
                  "s": 13005972e5
                },
                {
                  "e": 13520052e5,
                  "s": 13332564e5
                },
                {
                  "e": 13834548e5,
                  "s": 13628916e5
                },
                {
                  "e": 14149044e5,
                  "s": 13943412e5
                }
              ]
            },
            {
              "name": "America/Mazatlan",
              "rules": [
                {
                  "e": 1225008e6,
                  "s": 12074724e5
                },
                {
                  "e": 12564576e5,
                  "s": 1238922e6
                },
                {
                  "e": 1288512e6,
                  "s": 12703716e5
                },
                {
                  "e": 13199616e5,
                  "s": 13018212e5
                },
                {
                  "e": 13514112e5,
                  "s": 13332708e5
                },
                {
                  "e": 13828608e5,
                  "s": 13653252e5
                },
                {
                  "e": 14143104e5,
                  "s": 13967748e5
                }
              ]
            },
            {
              "name": "America/Mexico_City",
              "rules": [
                {
                  "e": 12250044e5,
                  "s": 12074688e5
                },
                {
                  "e": 1256454e6,
                  "s": 12389184e5
                },
                {
                  "e": 12885084e5,
                  "s": 1270368e6
                },
                {
                  "e": 1319958e6,
                  "s": 13018176e5
                },
                {
                  "e": 13514076e5,
                  "s": 13332672e5
                },
                {
                  "e": 13828572e5,
                  "s": 13653216e5
                },
                {
                  "e": 14143068e5,
                  "s": 13967712e5
                }
              ]
            },
            {
              "name": "America/Miquelon",
              "rules": [
                {
                  "e": 12255984e5,
                  "s": 12050388e5
                },
                {
                  "e": 1257048e6,
                  "s": 12364884e5
                },
                {
                  "e": 12891024e5,
                  "s": 12685428e5
                },
                {
                  "e": 1320552e6,
                  "s": 12999924e5
                },
                {
                  "e": 13520016e5,
                  "s": 1331442e6
                },
                {
                  "e": 13834512e5,
                  "s": 13628916e5
                },
                {
                  "e": 14149008e5,
                  "s": 13943412e5
                }
              ]
            },
            {
              "name": "America/Santa_Isabel",
              "rules": [
                {
                  "e": 12250116e5,
                  "s": 1207476e6
                },
                {
                  "e": 12564612e5,
                  "s": 12389256e5
                },
                {
                  "e": 12885156e5,
                  "s": 12703752e5
                },
                {
                  "e": 13199652e5,
                  "s": 13018248e5
                },
                {
                  "e": 13514148e5,
                  "s": 13332744e5
                },
                {
                  "e": 13828644e5,
                  "s": 13653288e5
                },
                {
                  "e": 1414314e6,
                  "s": 13967784e5
                }
              ]
            },
            {
              "name": "America/Santiago",
              "rules": [
                {
                  "e": 1206846e6,
                  "s": 1223784e6
                },
                {
                  "e": 1237086e6,
                  "s": 12552336e5
                },
                {
                  "e": 127035e7,
                  "s": 12866832e5
                },
                {
                  "e": 13048236e5,
                  "s": 13138992e5
                },
                {
                  "e": 13356684e5,
                  "s": 13465584e5
                },
                {
                  "e": 1367118e6,
                  "s": 13786128e5
                },
                {
                  "e": 13985676e5,
                  "s": 14100624e5
                }
              ]
            },
            {
              "name": "America/Sao_Paulo",
              "rules": [
                {
                  "e": 12032136e5,
                  "s": 12243852e5
                },
                {
                  "e": 12346632e5,
                  "s": 12558348e5
                },
                {
                  "e": 12667176e5,
                  "s": 12872844e5
                },
                {
                  "e": 12981672e5,
                  "s": 1318734e6
                },
                {
                  "e": 13302216e5,
                  "s": 13507884e5
                },
                {
                  "e": 13610664e5,
                  "s": 1382238e6
                },
                {
                  "e": 1392516e6,
                  "s": 14136876e5
                }
              ]
            },
            {
              "name": "Asia/Amman",
              "rules": [
                {
                  "e": 1225404e6,
                  "s": 12066552e5
                },
                {
                  "e": 12568536e5,
                  "s": 12381048e5
                },
                {
                  "e": 12883032e5,
                  "s": 12695544e5
                },
                {
                  "e": 13197528e5,
                  "s": 13016088e5
                },
                false,
                false,
                {
                  "e": 14147064e5,
                  "s": 13959576e5
                }
              ]
            },
            {
              "name": "Asia/Damascus",
              "rules": [
                {
                  "e": 12254868e5,
                  "s": 120726e7
                },
                {
                  "e": 125685e7,
                  "s": 12381048e5
                },
                {
                  "e": 12882996e5,
                  "s": 12701592e5
                },
                {
                  "e": 13197492e5,
                  "s": 13016088e5
                },
                {
                  "e": 13511988e5,
                  "s": 13330584e5
                },
                {
                  "e": 13826484e5,
                  "s": 1364508e6
                },
                {
                  "e": 14147028e5,
                  "s": 13959576e5
                }
              ]
            },
            {
              "name": "Asia/Dubai",
              "rules": [
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "name": "Asia/Gaza",
              "rules": [
                {
                  "e": 12199572e5,
                  "s": 12066552e5
                },
                {
                  "e": 12520152e5,
                  "s": 12381048e5
                },
                {
                  "e": 1281474e6,
                  "s": 126964086e4
                },
                {
                  "e": 1312146e6,
                  "s": 130160886e4
                },
                {
                  "e": 13481784e5,
                  "s": 13330584e5
                },
                {
                  "e": 13802292e5,
                  "s": 1364508e6
                },
                {
                  "e": 1414098e6,
                  "s": 13959576e5
                }
              ]
            },
            {
              "name": "Asia/Irkutsk",
              "rules": [
                {
                  "e": 12249576e5,
                  "s": 12068136e5
                },
                {
                  "e": 12564072e5,
                  "s": 12382632e5
                },
                {
                  "e": 12884616e5,
                  "s": 12697128e5
                },
                false,
                false,
                false,
                false
              ]
            },
            {
              "name": "Asia/Jerusalem",
              "rules": [
                {
                  "e": 12231612e5,
                  "s": 12066624e5
                },
                {
                  "e": 1254006e6,
                  "s": 1238112e6
                },
                {
                  "e": 1284246e6,
                  "s": 12695616e5
                },
                {
                  "e": 131751e7,
                  "s": 1301616e6
                },
                {
                  "e": 13483548e5,
                  "s": 13330656e5
                },
                {
                  "e": 13828284e5,
                  "s": 13645152e5
                },
                {
                  "e": 1414278e6,
                  "s": 13959648e5
                }
              ]
            },
            {
              "name": "Asia/Kamchatka",
              "rules": [
                {
                  "e": 12249432e5,
                  "s": 12067992e5
                },
                {
                  "e": 12563928e5,
                  "s": 12382488e5
                },
                {
                  "e": 12884508e5,
                  "s": 12696984e5
                },
                false,
                false,
                false,
                false
              ]
            },
            {
              "name": "Asia/Krasnoyarsk",
              "rules": [
                {
                  "e": 12249612e5,
                  "s": 12068172e5
                },
                {
                  "e": 12564108e5,
                  "s": 12382668e5
                },
                {
                  "e": 12884652e5,
                  "s": 12697164e5
                },
                false,
                false,
                false,
                false
              ]
            },
            {
              "name": "Asia/Omsk",
              "rules": [
                {
                  "e": 12249648e5,
                  "s": 12068208e5
                },
                {
                  "e": 12564144e5,
                  "s": 12382704e5
                },
                {
                  "e": 12884688e5,
                  "s": 126972e7
                },
                false,
                false,
                false,
                false
              ]
            },
            {
              "name": "Asia/Vladivostok",
              "rules": [
                {
                  "e": 12249504e5,
                  "s": 12068064e5
                },
                {
                  "e": 12564e8,
                  "s": 1238256e6
                },
                {
                  "e": 12884544e5,
                  "s": 12697056e5
                },
                false,
                false,
                false,
                false
              ]
            },
            {
              "name": "Asia/Yakutsk",
              "rules": [
                {
                  "e": 1224954e6,
                  "s": 120681e7
                },
                {
                  "e": 12564036e5,
                  "s": 12382596e5
                },
                {
                  "e": 1288458e6,
                  "s": 12697092e5
                },
                false,
                false,
                false,
                false
              ]
            },
            {
              "name": "Asia/Yekaterinburg",
              "rules": [
                {
                  "e": 12249684e5,
                  "s": 12068244e5
                },
                {
                  "e": 1256418e6,
                  "s": 1238274e6
                },
                {
                  "e": 12884724e5,
                  "s": 12697236e5
                },
                false,
                false,
                false,
                false
              ]
            },
            {
              "name": "Asia/Yerevan",
              "rules": [
                {
                  "e": 1224972e6,
                  "s": 1206828e6
                },
                {
                  "e": 12564216e5,
                  "s": 12382776e5
                },
                {
                  "e": 1288476e6,
                  "s": 12697272e5
                },
                {
                  "e": 13199256e5,
                  "s": 13011768e5
                },
                false,
                false,
                false
              ]
            },
            {
              "name": "Australia/Lord_Howe",
              "rules": [
                {
                  "e": 12074076e5,
                  "s": 12231342e5
                },
                {
                  "e": 12388572e5,
                  "s": 12545838e5
                },
                {
                  "e": 12703068e5,
                  "s": 12860334e5
                },
                {
                  "e": 13017564e5,
                  "s": 1317483e6
                },
                {
                  "e": 1333206e6,
                  "s": 13495374e5
                },
                {
                  "e": 13652604e5,
                  "s": 1380987e6
                },
                {
                  "e": 139671e7,
                  "s": 14124366e5
                }
              ]
            },
            {
              "name": "Australia/Perth",
              "rules": [
                {
                  "e": 12068136e5,
                  "s": 12249576e5
                },
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "name": "Europe/Helsinki",
              "rules": [
                {
                  "e": 12249828e5,
                  "s": 12068388e5
                },
                {
                  "e": 12564324e5,
                  "s": 12382884e5
                },
                {
                  "e": 12884868e5,
                  "s": 1269738e6
                },
                {
                  "e": 13199364e5,
                  "s": 13011876e5
                },
                {
                  "e": 1351386e6,
                  "s": 13326372e5
                },
                {
                  "e": 13828356e5,
                  "s": 13646916e5
                },
                {
                  "e": 14142852e5,
                  "s": 13961412e5
                }
              ]
            },
            {
              "name": "Europe/Minsk",
              "rules": [
                {
                  "e": 12249792e5,
                  "s": 12068352e5
                },
                {
                  "e": 12564288e5,
                  "s": 12382848e5
                },
                {
                  "e": 12884832e5,
                  "s": 12697344e5
                },
                false,
                false,
                false,
                false
              ]
            },
            {
              "name": "Europe/Moscow",
              "rules": [
                {
                  "e": 12249756e5,
                  "s": 12068316e5
                },
                {
                  "e": 12564252e5,
                  "s": 12382812e5
                },
                {
                  "e": 12884796e5,
                  "s": 12697308e5
                },
                false,
                false,
                false,
                false
              ]
            },
            {
              "name": "Pacific/Apia",
              "rules": [
                false,
                false,
                false,
                {
                  "e": 13017528e5,
                  "s": 13168728e5
                },
                {
                  "e": 13332024e5,
                  "s": 13489272e5
                },
                {
                  "e": 13652568e5,
                  "s": 13803768e5
                },
                {
                  "e": 13967064e5,
                  "s": 14118264e5
                }
              ]
            },
            {
              "name": "Pacific/Fiji",
              "rules": [
                false,
                false,
                {
                  "e": 12696984e5,
                  "s": 12878424e5
                },
                {
                  "e": 13271544e5,
                  "s": 1319292e6
                },
                {
                  "e": 1358604e6,
                  "s": 13507416e5
                },
                {
                  "e": 139005e7,
                  "s": 1382796e6
                },
                {
                  "e": 14215032e5,
                  "s": 14148504e5
                }
              ]
            },
            {
              "name": "Europe/London",
              "rules": [
                {
                  "e": 12249828e5,
                  "s": 12068388e5
                },
                {
                  "e": 12564324e5,
                  "s": 12382884e5
                },
                {
                  "e": 12884868e5,
                  "s": 1269738e6
                },
                {
                  "e": 13199364e5,
                  "s": 13011876e5
                },
                {
                  "e": 1351386e6,
                  "s": 13326372e5
                },
                {
                  "e": 13828356e5,
                  "s": 13646916e5
                },
                {
                  "e": 14142852e5,
                  "s": 13961412e5
                }
              ]
            }
          ]
        };
        if (typeof module4 !== "undefined" && typeof module4.exports !== "undefined") {
          module4.exports = jstz2;
        } else if (typeof define !== "undefined" && define !== null && define.amd != null) {
          define([], function() {
            return jstz2;
          });
        } else {
          if (typeof root === "undefined") {
            window.jstz = jstz2;
          } else {
            root.jstz = jstz2;
          }
        }
      })();
    }
  });

  // ../../node_modules/jstz/index.js
  var require_jstz2 = __commonJS({
    "../../node_modules/jstz/index.js"(exports2, module4) {
      module4.exports = require_jstz();
    }
  });

  // ../../node_modules/local-time/app/assets/javascripts/local-time.js
  var require_local_time = __commonJS({
    "../../node_modules/local-time/app/assets/javascripts/local-time.js"(exports2, module4) {
      (function() {
        var t2 = this;
        (function() {
          (function() {
            var t3 = [].slice;
            this.LocalTime = { config: {}, run: function() {
              return this.getController().processElements();
            }, process: function() {
              var e4, n2, r2, a4;
              for (n2 = 1 <= arguments.length ? t3.call(arguments, 0) : [], r2 = 0, a4 = n2.length; r2 < a4; r2++)
                e4 = n2[r2], this.getController().processElement(e4);
              return n2.length;
            }, getController: function() {
              return this.controller != null ? this.controller : this.controller = new e3.Controller();
            } };
          }).call(this);
        }).call(t2);
        var e3 = t2.LocalTime;
        (function() {
          (function() {
            e3.config.i18n = { en: { date: { dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], abbrDayNames: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], abbrMonthNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], yesterday: "yesterday", today: "today", tomorrow: "tomorrow", on: "on {date}", formats: { "default": "%b %e, %Y", thisYear: "%b %e" } }, time: { am: "am", pm: "pm", singular: "a {time}", singularAn: "an {time}", elapsed: "{time} ago", second: "second", seconds: "seconds", minute: "minute", minutes: "minutes", hour: "hour", hours: "hours", formats: { "default": "%l:%M%P" } }, datetime: { at: "{date} at {time}", formats: { "default": "%B %e, %Y at %l:%M%P %Z" } } } };
          }).call(this), function() {
            e3.config.locale = "en", e3.config.defaultLocale = "en";
          }.call(this), function() {
            e3.config.timerInterval = 6e4;
          }.call(this), function() {
            var t3, n2, r2;
            r2 = !isNaN(Date.parse("2011-01-01T12:00:00-05:00")), e3.parseDate = function(t4) {
              return t4 = t4.toString(), r2 || (t4 = n2(t4)), new Date(Date.parse(t4));
            }, t3 = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})(Z|[-+]?[\d:]+)$/, n2 = function(e4) {
              var n3, r3, a4, i3, o2, s4, u2, c2, l2;
              if (a4 = e4.match(t3))
                return a4[0], c2 = a4[1], o2 = a4[2], n3 = a4[3], r3 = a4[4], i3 = a4[5], u2 = a4[6], l2 = a4[7], l2 !== "Z" && (s4 = l2.replace(":", "")), c2 + "/" + o2 + "/" + n3 + " " + r3 + ":" + i3 + ":" + u2 + " GMT" + [s4];
            };
          }.call(this), function() {
            e3.elementMatchesSelector = function() {
              var t3, e4, n2, r2, a4, i3;
              return t3 = document.documentElement, e4 = (n2 = (r2 = (a4 = (i3 = t3.matches) != null ? i3 : t3.matchesSelector) != null ? a4 : t3.webkitMatchesSelector) != null ? r2 : t3.mozMatchesSelector) != null ? n2 : t3.msMatchesSelector, function(t4, n3) {
                if ((t4 != null ? t4.nodeType : void 0) === Node.ELEMENT_NODE)
                  return e4.call(t4, n3);
              };
            }();
          }.call(this), function() {
            var t3, n2, r2;
            t3 = e3.config, r2 = t3.i18n, e3.getI18nValue = function(a4, i3) {
              var o2, s4;
              return a4 == null && (a4 = ""), o2 = (i3 != null ? i3 : { locale: t3.locale }).locale, s4 = n2(r2[o2], a4), s4 != null ? s4 : o2 !== t3.defaultLocale ? e3.getI18nValue(a4, { locale: t3.defaultLocale }) : void 0;
            }, e3.translate = function(t4, n3, r3) {
              var a4, i3, o2;
              n3 == null && (n3 = {}), o2 = e3.getI18nValue(t4, r3);
              for (a4 in n3)
                i3 = n3[a4], o2 = o2.replace("{" + a4 + "}", i3);
              return o2;
            }, n2 = function(t4, e4) {
              var n3, r3, a4, i3, o2;
              for (o2 = t4, i3 = e4.split("."), n3 = 0, a4 = i3.length; n3 < a4; n3++) {
                if (r3 = i3[n3], o2[r3] == null)
                  return null;
                o2 = o2[r3];
              }
              return o2;
            };
          }.call(this), function() {
            var t3, n2, r2, a4, i3;
            t3 = e3.getI18nValue, i3 = e3.translate, e3.strftime = a4 = function(e4, o2) {
              var s4, u2, c2, l2, d3, h5, f;
              return u2 = e4.getDay(), s4 = e4.getDate(), d3 = e4.getMonth(), f = e4.getFullYear(), c2 = e4.getHours(), l2 = e4.getMinutes(), h5 = e4.getSeconds(), o2.replace(/%(-?)([%aAbBcdeHIlmMpPSwyYZ])/g, function(o3, m3, p) {
                switch (p) {
                  case "%":
                    return "%";
                  case "a":
                    return t3("date.abbrDayNames")[u2];
                  case "A":
                    return t3("date.dayNames")[u2];
                  case "b":
                    return t3("date.abbrMonthNames")[d3];
                  case "B":
                    return t3("date.monthNames")[d3];
                  case "c":
                    return e4.toString();
                  case "d":
                    return n2(s4, m3);
                  case "e":
                    return s4;
                  case "H":
                    return n2(c2, m3);
                  case "I":
                    return n2(a4(e4, "%l"), m3);
                  case "l":
                    return c2 === 0 || c2 === 12 ? 12 : (c2 + 12) % 12;
                  case "m":
                    return n2(d3 + 1, m3);
                  case "M":
                    return n2(l2, m3);
                  case "p":
                    return i3("time." + (c2 > 11 ? "pm" : "am")).toUpperCase();
                  case "P":
                    return i3("time." + (c2 > 11 ? "pm" : "am"));
                  case "S":
                    return n2(h5, m3);
                  case "w":
                    return u2;
                  case "y":
                    return n2(f % 100, m3);
                  case "Y":
                    return f;
                  case "Z":
                    return r2(e4);
                }
              });
            }, n2 = function(t4, e4) {
              switch (e4) {
                case "-":
                  return t4;
                default:
                  return ("0" + t4).slice(-2);
              }
            }, r2 = function(t4) {
              var e4, n3, r3, a5, i4;
              return i4 = t4.toString(), (e4 = (n3 = i4.match(/\(([\w\s]+)\)$/)) != null ? n3[1] : void 0) ? /\s/.test(e4) ? e4.match(/\b(\w)/g).join("") : e4 : (e4 = (r3 = i4.match(/(\w{3,4})\s\d{4}$/)) != null ? r3[1] : void 0) ? e4 : (e4 = (a5 = i4.match(/(UTC[\+\-]\d+)/)) != null ? a5[1] : void 0) ? e4 : "";
            };
          }.call(this), function() {
            e3.CalendarDate = function() {
              function t3(t4, e4, n2) {
                this.date = new Date(Date.UTC(t4, e4 - 1)), this.date.setUTCDate(n2), this.year = this.date.getUTCFullYear(), this.month = this.date.getUTCMonth() + 1, this.day = this.date.getUTCDate(), this.value = this.date.getTime();
              }
              return t3.fromDate = function(t4) {
                return new this(t4.getFullYear(), t4.getMonth() + 1, t4.getDate());
              }, t3.today = function() {
                return this.fromDate(new Date());
              }, t3.prototype.equals = function(t4) {
                return (t4 != null ? t4.value : void 0) === this.value;
              }, t3.prototype.is = function(t4) {
                return this.equals(t4);
              }, t3.prototype.isToday = function() {
                return this.is(this.constructor.today());
              }, t3.prototype.occursOnSameYearAs = function(t4) {
                return this.year === (t4 != null ? t4.year : void 0);
              }, t3.prototype.occursThisYear = function() {
                return this.occursOnSameYearAs(this.constructor.today());
              }, t3.prototype.daysSince = function(t4) {
                if (t4)
                  return (this.date - t4.date) / 864e5;
              }, t3.prototype.daysPassed = function() {
                return this.constructor.today().daysSince(this);
              }, t3;
            }();
          }.call(this), function() {
            var t3, n2, r2;
            n2 = e3.strftime, r2 = e3.translate, t3 = e3.getI18nValue, e3.RelativeTime = function() {
              function a4(t4) {
                this.date = t4, this.calendarDate = e3.CalendarDate.fromDate(this.date);
              }
              return a4.prototype.toString = function() {
                var t4, e4;
                return (e4 = this.toTimeElapsedString()) ? r2("time.elapsed", { time: e4 }) : (t4 = this.toWeekdayString()) ? (e4 = this.toTimeString(), r2("datetime.at", { date: t4, time: e4 })) : r2("date.on", { date: this.toDateString() });
              }, a4.prototype.toTimeOrDateString = function() {
                return this.calendarDate.isToday() ? this.toTimeString() : this.toDateString();
              }, a4.prototype.toTimeElapsedString = function() {
                var t4, e4, n3, a5, i3;
                return n3 = new Date().getTime() - this.date.getTime(), a5 = Math.round(n3 / 1e3), e4 = Math.round(a5 / 60), t4 = Math.round(e4 / 60), n3 < 0 ? null : a5 < 10 ? (i3 = r2("time.second"), r2("time.singular", { time: i3 })) : a5 < 45 ? a5 + " " + r2("time.seconds") : a5 < 90 ? (i3 = r2("time.minute"), r2("time.singular", { time: i3 })) : e4 < 45 ? e4 + " " + r2("time.minutes") : e4 < 90 ? (i3 = r2("time.hour"), r2("time.singularAn", { time: i3 })) : t4 < 24 ? t4 + " " + r2("time.hours") : "";
              }, a4.prototype.toWeekdayString = function() {
                switch (this.calendarDate.daysPassed()) {
                  case 0:
                    return r2("date.today");
                  case 1:
                    return r2("date.yesterday");
                  case -1:
                    return r2("date.tomorrow");
                  case 2:
                  case 3:
                  case 4:
                  case 5:
                  case 6:
                    return n2(this.date, "%A");
                  default:
                    return "";
                }
              }, a4.prototype.toDateString = function() {
                var e4;
                return e4 = t3(this.calendarDate.occursThisYear() ? "date.formats.thisYear" : "date.formats.default"), n2(this.date, e4);
              }, a4.prototype.toTimeString = function() {
                return n2(this.date, t3("time.formats.default"));
              }, a4;
            }();
          }.call(this), function() {
            var t3, n2 = function(t4, e4) {
              return function() {
                return t4.apply(e4, arguments);
              };
            };
            t3 = e3.elementMatchesSelector, e3.PageObserver = function() {
              function e4(t4, e5) {
                this.selector = t4, this.callback = e5, this.processInsertion = n2(this.processInsertion, this), this.processMutations = n2(this.processMutations, this);
              }
              return e4.prototype.start = function() {
                if (!this.started)
                  return this.observeWithMutationObserver() || this.observeWithMutationEvent(), this.started = true;
              }, e4.prototype.observeWithMutationObserver = function() {
                var t4;
                if (typeof MutationObserver != "undefined" && MutationObserver !== null)
                  return t4 = new MutationObserver(this.processMutations), t4.observe(document.documentElement, { childList: true, subtree: true }), true;
              }, e4.prototype.observeWithMutationEvent = function() {
                return addEventListener("DOMNodeInserted", this.processInsertion, false), true;
              }, e4.prototype.findSignificantElements = function(e5) {
                var n3;
                return n3 = [], (e5 != null ? e5.nodeType : void 0) === Node.ELEMENT_NODE && (t3(e5, this.selector) && n3.push(e5), n3.push.apply(n3, e5.querySelectorAll(this.selector))), n3;
              }, e4.prototype.processMutations = function(t4) {
                var e5, n3, r2, a4, i3, o2, s4, u2;
                for (e5 = [], n3 = 0, a4 = t4.length; n3 < a4; n3++)
                  switch (o2 = t4[n3], o2.type) {
                    case "childList":
                      for (u2 = o2.addedNodes, r2 = 0, i3 = u2.length; r2 < i3; r2++)
                        s4 = u2[r2], e5.push.apply(e5, this.findSignificantElements(s4));
                  }
                return this.notify(e5);
              }, e4.prototype.processInsertion = function(t4) {
                var e5;
                return e5 = this.findSignificantElements(t4.target), this.notify(e5);
              }, e4.prototype.notify = function(t4) {
                if (t4 != null ? t4.length : void 0)
                  return typeof this.callback == "function" ? this.callback(t4) : void 0;
              }, e4;
            }();
          }.call(this), function() {
            var t3, n2, r2, a4, i3 = function(t4, e4) {
              return function() {
                return t4.apply(e4, arguments);
              };
            };
            r2 = e3.parseDate, a4 = e3.strftime, n2 = e3.getI18nValue, t3 = e3.config, e3.Controller = function() {
              function o2() {
                this.processElements = i3(this.processElements, this), this.pageObserver = new e3.PageObserver(s4, this.processElements);
              }
              var s4, u2, c2;
              return s4 = "time[data-local]:not([data-localized])", o2.prototype.start = function() {
                if (!this.started)
                  return this.processElements(), this.startTimer(), this.pageObserver.start(), this.started = true;
              }, o2.prototype.startTimer = function() {
                var e4;
                if (e4 = t3.timerInterval)
                  return this.timer != null ? this.timer : this.timer = setInterval(this.processElements, e4);
              }, o2.prototype.processElements = function(t4) {
                var e4, n3, r3;
                for (t4 == null && (t4 = document.querySelectorAll(s4)), n3 = 0, r3 = t4.length; n3 < r3; n3++)
                  e4 = t4[n3], this.processElement(e4);
                return t4.length;
              }, o2.prototype.processElement = function(t4) {
                var e4, i4, o3, s5, l2, d3;
                if (i4 = t4.getAttribute("datetime"), o3 = t4.getAttribute("data-format"), s5 = t4.getAttribute("data-local"), l2 = r2(i4), !isNaN(l2))
                  return t4.hasAttribute("title") || (d3 = a4(l2, n2("datetime.formats.default")), t4.setAttribute("title", d3)), t4.textContent = e4 = function() {
                    switch (s5) {
                      case "time":
                        return u2(t4), a4(l2, o3);
                      case "date":
                        return u2(t4), c2(l2).toDateString();
                      case "time-ago":
                        return c2(l2).toString();
                      case "time-or-date":
                        return c2(l2).toTimeOrDateString();
                      case "weekday":
                        return c2(l2).toWeekdayString();
                      case "weekday-or-date":
                        return c2(l2).toWeekdayString() || c2(l2).toDateString();
                    }
                  }(), t4.hasAttribute("aria-label") ? void 0 : t4.setAttribute("aria-label", e4);
              }, u2 = function(t4) {
                return t4.setAttribute("data-localized", "");
              }, c2 = function(t4) {
                return new e3.RelativeTime(t4);
              }, o2;
            }();
          }.call(this), function() {
            var t3, n2, r2, a4;
            a4 = false, t3 = function() {
              return document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading";
            }, n2 = function(t4) {
              var e4;
              return (e4 = typeof requestAnimationFrame == "function" ? requestAnimationFrame(t4) : void 0) != null ? e4 : setTimeout(t4, 17);
            }, r2 = function() {
              var t4;
              return t4 = e3.getController(), t4.start();
            }, e3.start = function() {
              if (!a4)
                return a4 = true, typeof MutationObserver != "undefined" && MutationObserver !== null || t3() ? r2() : n2(r2);
            }, window.LocalTime === e3 && e3.start();
          }.call(this);
        }).call(this), typeof module4 == "object" && module4.exports ? module4.exports = e3 : typeof define == "function" && define.amd && define(e3);
      }).call(exports2);
    }
  });

  // application.js
  var import_ujs = __toESM(require_rails_ujs());

  // ../../node_modules/@hotwired/turbo/dist/turbo.es2017-esm.js
  var turbo_es2017_esm_exports = {};
  __export(turbo_es2017_esm_exports, {
    PageRenderer: () => PageRenderer,
    PageSnapshot: () => PageSnapshot,
    clearCache: () => clearCache,
    connectStreamSource: () => connectStreamSource,
    disconnectStreamSource: () => disconnectStreamSource,
    navigator: () => navigator$1,
    registerAdapter: () => registerAdapter,
    renderStreamMessage: () => renderStreamMessage,
    session: () => session,
    setConfirmMethod: () => setConfirmMethod,
    setProgressBarDelay: () => setProgressBarDelay,
    start: () => start,
    visit: () => visit
  });
  (function() {
    if (window.Reflect === void 0 || window.customElements === void 0 || window.customElements.polyfillWrapFlushCallback) {
      return;
    }
    const BuiltInHTMLElement = HTMLElement;
    const wrapperForTheName = {
      "HTMLElement": function HTMLElement2() {
        return Reflect.construct(BuiltInHTMLElement, [], this.constructor);
      }
    };
    window.HTMLElement = wrapperForTheName["HTMLElement"];
    HTMLElement.prototype = BuiltInHTMLElement.prototype;
    HTMLElement.prototype.constructor = HTMLElement;
    Object.setPrototypeOf(HTMLElement, BuiltInHTMLElement);
  })();
  (function(prototype) {
    if (typeof prototype.requestSubmit == "function")
      return;
    prototype.requestSubmit = function(submitter) {
      if (submitter) {
        validateSubmitter(submitter, this);
        submitter.click();
      } else {
        submitter = document.createElement("input");
        submitter.type = "submit";
        submitter.hidden = true;
        this.appendChild(submitter);
        submitter.click();
        this.removeChild(submitter);
      }
    };
    function validateSubmitter(submitter, form) {
      submitter instanceof HTMLElement || raise(TypeError, "parameter 1 is not of type 'HTMLElement'");
      submitter.type == "submit" || raise(TypeError, "The specified element is not a submit button");
      submitter.form == form || raise(DOMException, "The specified element is not owned by this form element", "NotFoundError");
    }
    function raise(errorConstructor, message, name2) {
      throw new errorConstructor("Failed to execute 'requestSubmit' on 'HTMLFormElement': " + message + ".", name2);
    }
  })(HTMLFormElement.prototype);
  var submittersByForm = /* @__PURE__ */ new WeakMap();
  function findSubmitterFromClickTarget(target) {
    const element = target instanceof Element ? target : target instanceof Node ? target.parentElement : null;
    const candidate = element ? element.closest("input, button") : null;
    return (candidate === null || candidate === void 0 ? void 0 : candidate.type) == "submit" ? candidate : null;
  }
  function clickCaptured(event) {
    const submitter = findSubmitterFromClickTarget(event.target);
    if (submitter && submitter.form) {
      submittersByForm.set(submitter.form, submitter);
    }
  }
  (function() {
    if ("submitter" in Event.prototype)
      return;
    let prototype;
    if ("SubmitEvent" in window && /Apple Computer/.test(navigator.vendor)) {
      prototype = window.SubmitEvent.prototype;
    } else if ("SubmitEvent" in window) {
      return;
    } else {
      prototype = window.Event.prototype;
    }
    addEventListener("click", clickCaptured, true);
    Object.defineProperty(prototype, "submitter", {
      get() {
        if (this.type == "submit" && this.target instanceof HTMLFormElement) {
          return submittersByForm.get(this.target);
        }
      }
    });
  })();
  var FrameLoadingStyle;
  (function(FrameLoadingStyle2) {
    FrameLoadingStyle2["eager"] = "eager";
    FrameLoadingStyle2["lazy"] = "lazy";
  })(FrameLoadingStyle || (FrameLoadingStyle = {}));
  var FrameElement = class extends HTMLElement {
    constructor() {
      super();
      this.loaded = Promise.resolve();
      this.delegate = new FrameElement.delegateConstructor(this);
    }
    static get observedAttributes() {
      return ["disabled", "loading", "src"];
    }
    connectedCallback() {
      this.delegate.connect();
    }
    disconnectedCallback() {
      this.delegate.disconnect();
    }
    reload() {
      const { src } = this;
      this.src = null;
      this.src = src;
    }
    attributeChangedCallback(name2) {
      if (name2 == "loading") {
        this.delegate.loadingStyleChanged();
      } else if (name2 == "src") {
        this.delegate.sourceURLChanged();
      } else {
        this.delegate.disabledChanged();
      }
    }
    get src() {
      return this.getAttribute("src");
    }
    set src(value) {
      if (value) {
        this.setAttribute("src", value);
      } else {
        this.removeAttribute("src");
      }
    }
    get loading() {
      return frameLoadingStyleFromString(this.getAttribute("loading") || "");
    }
    set loading(value) {
      if (value) {
        this.setAttribute("loading", value);
      } else {
        this.removeAttribute("loading");
      }
    }
    get disabled() {
      return this.hasAttribute("disabled");
    }
    set disabled(value) {
      if (value) {
        this.setAttribute("disabled", "");
      } else {
        this.removeAttribute("disabled");
      }
    }
    get autoscroll() {
      return this.hasAttribute("autoscroll");
    }
    set autoscroll(value) {
      if (value) {
        this.setAttribute("autoscroll", "");
      } else {
        this.removeAttribute("autoscroll");
      }
    }
    get complete() {
      return !this.delegate.isLoading;
    }
    get isActive() {
      return this.ownerDocument === document && !this.isPreview;
    }
    get isPreview() {
      var _a, _b;
      return (_b = (_a = this.ownerDocument) === null || _a === void 0 ? void 0 : _a.documentElement) === null || _b === void 0 ? void 0 : _b.hasAttribute("data-turbo-preview");
    }
  };
  function frameLoadingStyleFromString(style) {
    switch (style.toLowerCase()) {
      case "lazy":
        return FrameLoadingStyle.lazy;
      default:
        return FrameLoadingStyle.eager;
    }
  }
  function expandURL(locatable) {
    return new URL(locatable.toString(), document.baseURI);
  }
  function getAnchor(url) {
    let anchorMatch;
    if (url.hash) {
      return url.hash.slice(1);
    } else if (anchorMatch = url.href.match(/#(.*)$/)) {
      return anchorMatch[1];
    }
  }
  function getAction(form, submitter) {
    const action = (submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute("formaction")) || form.getAttribute("action") || form.action;
    return expandURL(action);
  }
  function getExtension(url) {
    return (getLastPathComponent(url).match(/\.[^.]*$/) || [])[0] || "";
  }
  function isHTML(url) {
    return !!getExtension(url).match(/^(?:|\.(?:htm|html|xhtml))$/);
  }
  function isPrefixedBy(baseURL, url) {
    const prefix = getPrefix(url);
    return baseURL.href === expandURL(prefix).href || baseURL.href.startsWith(prefix);
  }
  function locationIsVisitable(location2, rootLocation) {
    return isPrefixedBy(location2, rootLocation) && isHTML(location2);
  }
  function getRequestURL(url) {
    const anchor = getAnchor(url);
    return anchor != null ? url.href.slice(0, -(anchor.length + 1)) : url.href;
  }
  function toCacheKey(url) {
    return getRequestURL(url);
  }
  function urlsAreEqual(left2, right2) {
    return expandURL(left2).href == expandURL(right2).href;
  }
  function getPathComponents(url) {
    return url.pathname.split("/").slice(1);
  }
  function getLastPathComponent(url) {
    return getPathComponents(url).slice(-1)[0];
  }
  function getPrefix(url) {
    return addTrailingSlash(url.origin + url.pathname);
  }
  function addTrailingSlash(value) {
    return value.endsWith("/") ? value : value + "/";
  }
  var FetchResponse = class {
    constructor(response) {
      this.response = response;
    }
    get succeeded() {
      return this.response.ok;
    }
    get failed() {
      return !this.succeeded;
    }
    get clientError() {
      return this.statusCode >= 400 && this.statusCode <= 499;
    }
    get serverError() {
      return this.statusCode >= 500 && this.statusCode <= 599;
    }
    get redirected() {
      return this.response.redirected;
    }
    get location() {
      return expandURL(this.response.url);
    }
    get isHTML() {
      return this.contentType && this.contentType.match(/^(?:text\/([^\s;,]+\b)?html|application\/xhtml\+xml)\b/);
    }
    get statusCode() {
      return this.response.status;
    }
    get contentType() {
      return this.header("Content-Type");
    }
    get responseText() {
      return this.response.clone().text();
    }
    get responseHTML() {
      if (this.isHTML) {
        return this.response.clone().text();
      } else {
        return Promise.resolve(void 0);
      }
    }
    header(name2) {
      return this.response.headers.get(name2);
    }
  };
  function dispatch(eventName, { target, cancelable, detail } = {}) {
    const event = new CustomEvent(eventName, { cancelable, bubbles: true, detail });
    if (target && target.isConnected) {
      target.dispatchEvent(event);
    } else {
      document.documentElement.dispatchEvent(event);
    }
    return event;
  }
  function nextAnimationFrame() {
    return new Promise((resolve2) => requestAnimationFrame(() => resolve2()));
  }
  function nextEventLoopTick() {
    return new Promise((resolve2) => setTimeout(() => resolve2(), 0));
  }
  function nextMicrotask() {
    return Promise.resolve();
  }
  function parseHTMLDocument(html = "") {
    return new DOMParser().parseFromString(html, "text/html");
  }
  function unindent(strings, ...values) {
    const lines = interpolate(strings, values).replace(/^\n/, "").split("\n");
    const match2 = lines[0].match(/^\s+/);
    const indent = match2 ? match2[0].length : 0;
    return lines.map((line) => line.slice(indent)).join("\n");
  }
  function interpolate(strings, values) {
    return strings.reduce((result, string, i3) => {
      const value = values[i3] == void 0 ? "" : values[i3];
      return result + string + value;
    }, "");
  }
  function uuid() {
    return Array.apply(null, { length: 36 }).map((_, i3) => {
      if (i3 == 8 || i3 == 13 || i3 == 18 || i3 == 23) {
        return "-";
      } else if (i3 == 14) {
        return "4";
      } else if (i3 == 19) {
        return (Math.floor(Math.random() * 4) + 8).toString(16);
      } else {
        return Math.floor(Math.random() * 15).toString(16);
      }
    }).join("");
  }
  function getAttribute(attributeName, ...elements3) {
    for (const value of elements3.map((element) => element === null || element === void 0 ? void 0 : element.getAttribute(attributeName))) {
      if (typeof value == "string")
        return value;
    }
    return null;
  }
  function markAsBusy(...elements3) {
    for (const element of elements3) {
      if (element.localName == "turbo-frame") {
        element.setAttribute("busy", "");
      }
      element.setAttribute("aria-busy", "true");
    }
  }
  function clearBusyState(...elements3) {
    for (const element of elements3) {
      if (element.localName == "turbo-frame") {
        element.removeAttribute("busy");
      }
      element.removeAttribute("aria-busy");
    }
  }
  var FetchMethod;
  (function(FetchMethod2) {
    FetchMethod2[FetchMethod2["get"] = 0] = "get";
    FetchMethod2[FetchMethod2["post"] = 1] = "post";
    FetchMethod2[FetchMethod2["put"] = 2] = "put";
    FetchMethod2[FetchMethod2["patch"] = 3] = "patch";
    FetchMethod2[FetchMethod2["delete"] = 4] = "delete";
  })(FetchMethod || (FetchMethod = {}));
  function fetchMethodFromString(method) {
    switch (method.toLowerCase()) {
      case "get":
        return FetchMethod.get;
      case "post":
        return FetchMethod.post;
      case "put":
        return FetchMethod.put;
      case "patch":
        return FetchMethod.patch;
      case "delete":
        return FetchMethod.delete;
    }
  }
  var FetchRequest = class {
    constructor(delegate, method, location2, body = new URLSearchParams(), target = null) {
      this.abortController = new AbortController();
      this.resolveRequestPromise = (value) => {
      };
      this.delegate = delegate;
      this.method = method;
      this.headers = this.defaultHeaders;
      this.body = body;
      this.url = location2;
      this.target = target;
    }
    get location() {
      return this.url;
    }
    get params() {
      return this.url.searchParams;
    }
    get entries() {
      return this.body ? Array.from(this.body.entries()) : [];
    }
    cancel() {
      this.abortController.abort();
    }
    async perform() {
      var _a, _b;
      const { fetchOptions } = this;
      (_b = (_a = this.delegate).prepareHeadersForRequest) === null || _b === void 0 ? void 0 : _b.call(_a, this.headers, this);
      await this.allowRequestToBeIntercepted(fetchOptions);
      try {
        this.delegate.requestStarted(this);
        const response = await fetch(this.url.href, fetchOptions);
        return await this.receive(response);
      } catch (error2) {
        if (error2.name !== "AbortError") {
          this.delegate.requestErrored(this, error2);
          throw error2;
        }
      } finally {
        this.delegate.requestFinished(this);
      }
    }
    async receive(response) {
      const fetchResponse = new FetchResponse(response);
      const event = dispatch("turbo:before-fetch-response", { cancelable: true, detail: { fetchResponse }, target: this.target });
      if (event.defaultPrevented) {
        this.delegate.requestPreventedHandlingResponse(this, fetchResponse);
      } else if (fetchResponse.succeeded) {
        this.delegate.requestSucceededWithResponse(this, fetchResponse);
      } else {
        this.delegate.requestFailedWithResponse(this, fetchResponse);
      }
      return fetchResponse;
    }
    get fetchOptions() {
      var _a;
      return {
        method: FetchMethod[this.method].toUpperCase(),
        credentials: "same-origin",
        headers: this.headers,
        redirect: "follow",
        body: this.isIdempotent ? null : this.body,
        signal: this.abortSignal,
        referrer: (_a = this.delegate.referrer) === null || _a === void 0 ? void 0 : _a.href
      };
    }
    get defaultHeaders() {
      return {
        "Accept": "text/html, application/xhtml+xml"
      };
    }
    get isIdempotent() {
      return this.method == FetchMethod.get;
    }
    get abortSignal() {
      return this.abortController.signal;
    }
    async allowRequestToBeIntercepted(fetchOptions) {
      const requestInterception = new Promise((resolve2) => this.resolveRequestPromise = resolve2);
      const event = dispatch("turbo:before-fetch-request", {
        cancelable: true,
        detail: {
          fetchOptions,
          url: this.url,
          resume: this.resolveRequestPromise
        },
        target: this.target
      });
      if (event.defaultPrevented)
        await requestInterception;
    }
  };
  var AppearanceObserver = class {
    constructor(delegate, element) {
      this.started = false;
      this.intersect = (entries) => {
        const lastEntry = entries.slice(-1)[0];
        if (lastEntry === null || lastEntry === void 0 ? void 0 : lastEntry.isIntersecting) {
          this.delegate.elementAppearedInViewport(this.element);
        }
      };
      this.delegate = delegate;
      this.element = element;
      this.intersectionObserver = new IntersectionObserver(this.intersect);
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.intersectionObserver.observe(this.element);
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        this.intersectionObserver.unobserve(this.element);
      }
    }
  };
  var StreamMessage = class {
    constructor(html) {
      this.templateElement = document.createElement("template");
      this.templateElement.innerHTML = html;
    }
    static wrap(message) {
      if (typeof message == "string") {
        return new this(message);
      } else {
        return message;
      }
    }
    get fragment() {
      const fragment = document.createDocumentFragment();
      for (const element of this.foreignElements) {
        fragment.appendChild(document.importNode(element, true));
      }
      return fragment;
    }
    get foreignElements() {
      return this.templateChildren.reduce((streamElements, child) => {
        if (child.tagName.toLowerCase() == "turbo-stream") {
          return [...streamElements, child];
        } else {
          return streamElements;
        }
      }, []);
    }
    get templateChildren() {
      return Array.from(this.templateElement.content.children);
    }
  };
  StreamMessage.contentType = "text/vnd.turbo-stream.html";
  var FormSubmissionState;
  (function(FormSubmissionState2) {
    FormSubmissionState2[FormSubmissionState2["initialized"] = 0] = "initialized";
    FormSubmissionState2[FormSubmissionState2["requesting"] = 1] = "requesting";
    FormSubmissionState2[FormSubmissionState2["waiting"] = 2] = "waiting";
    FormSubmissionState2[FormSubmissionState2["receiving"] = 3] = "receiving";
    FormSubmissionState2[FormSubmissionState2["stopping"] = 4] = "stopping";
    FormSubmissionState2[FormSubmissionState2["stopped"] = 5] = "stopped";
  })(FormSubmissionState || (FormSubmissionState = {}));
  var FormEnctype;
  (function(FormEnctype2) {
    FormEnctype2["urlEncoded"] = "application/x-www-form-urlencoded";
    FormEnctype2["multipart"] = "multipart/form-data";
    FormEnctype2["plain"] = "text/plain";
  })(FormEnctype || (FormEnctype = {}));
  function formEnctypeFromString(encoding) {
    switch (encoding.toLowerCase()) {
      case FormEnctype.multipart:
        return FormEnctype.multipart;
      case FormEnctype.plain:
        return FormEnctype.plain;
      default:
        return FormEnctype.urlEncoded;
    }
  }
  var FormSubmission = class {
    constructor(delegate, formElement, submitter, mustRedirect = false) {
      this.state = FormSubmissionState.initialized;
      this.delegate = delegate;
      this.formElement = formElement;
      this.submitter = submitter;
      this.formData = buildFormData(formElement, submitter);
      this.location = expandURL(this.action);
      if (this.method == FetchMethod.get) {
        mergeFormDataEntries(this.location, [...this.body.entries()]);
      }
      this.fetchRequest = new FetchRequest(this, this.method, this.location, this.body, this.formElement);
      this.mustRedirect = mustRedirect;
    }
    static confirmMethod(message, element) {
      return confirm(message);
    }
    get method() {
      var _a;
      const method = ((_a = this.submitter) === null || _a === void 0 ? void 0 : _a.getAttribute("formmethod")) || this.formElement.getAttribute("method") || "";
      return fetchMethodFromString(method.toLowerCase()) || FetchMethod.get;
    }
    get action() {
      var _a;
      const formElementAction = typeof this.formElement.action === "string" ? this.formElement.action : null;
      return ((_a = this.submitter) === null || _a === void 0 ? void 0 : _a.getAttribute("formaction")) || this.formElement.getAttribute("action") || formElementAction || "";
    }
    get body() {
      if (this.enctype == FormEnctype.urlEncoded || this.method == FetchMethod.get) {
        return new URLSearchParams(this.stringFormData);
      } else {
        return this.formData;
      }
    }
    get enctype() {
      var _a;
      return formEnctypeFromString(((_a = this.submitter) === null || _a === void 0 ? void 0 : _a.getAttribute("formenctype")) || this.formElement.enctype);
    }
    get isIdempotent() {
      return this.fetchRequest.isIdempotent;
    }
    get stringFormData() {
      return [...this.formData].reduce((entries, [name2, value]) => {
        return entries.concat(typeof value == "string" ? [[name2, value]] : []);
      }, []);
    }
    get confirmationMessage() {
      return this.formElement.getAttribute("data-turbo-confirm");
    }
    get needsConfirmation() {
      return this.confirmationMessage !== null;
    }
    async start() {
      const { initialized, requesting } = FormSubmissionState;
      if (this.needsConfirmation) {
        const answer = FormSubmission.confirmMethod(this.confirmationMessage, this.formElement);
        if (!answer) {
          return;
        }
      }
      if (this.state == initialized) {
        this.state = requesting;
        return this.fetchRequest.perform();
      }
    }
    stop() {
      const { stopping, stopped } = FormSubmissionState;
      if (this.state != stopping && this.state != stopped) {
        this.state = stopping;
        this.fetchRequest.cancel();
        return true;
      }
    }
    prepareHeadersForRequest(headers, request) {
      if (!request.isIdempotent) {
        const token = getCookieValue(getMetaContent("csrf-param")) || getMetaContent("csrf-token");
        if (token) {
          headers["X-CSRF-Token"] = token;
        }
        headers["Accept"] = [StreamMessage.contentType, headers["Accept"]].join(", ");
      }
    }
    requestStarted(request) {
      var _a;
      this.state = FormSubmissionState.waiting;
      (_a = this.submitter) === null || _a === void 0 ? void 0 : _a.setAttribute("disabled", "");
      dispatch("turbo:submit-start", { target: this.formElement, detail: { formSubmission: this } });
      this.delegate.formSubmissionStarted(this);
    }
    requestPreventedHandlingResponse(request, response) {
      this.result = { success: response.succeeded, fetchResponse: response };
    }
    requestSucceededWithResponse(request, response) {
      if (response.clientError || response.serverError) {
        this.delegate.formSubmissionFailedWithResponse(this, response);
      } else if (this.requestMustRedirect(request) && responseSucceededWithoutRedirect(response)) {
        const error2 = new Error("Form responses must redirect to another location");
        this.delegate.formSubmissionErrored(this, error2);
      } else {
        this.state = FormSubmissionState.receiving;
        this.result = { success: true, fetchResponse: response };
        this.delegate.formSubmissionSucceededWithResponse(this, response);
      }
    }
    requestFailedWithResponse(request, response) {
      this.result = { success: false, fetchResponse: response };
      this.delegate.formSubmissionFailedWithResponse(this, response);
    }
    requestErrored(request, error2) {
      this.result = { success: false, error: error2 };
      this.delegate.formSubmissionErrored(this, error2);
    }
    requestFinished(request) {
      var _a;
      this.state = FormSubmissionState.stopped;
      (_a = this.submitter) === null || _a === void 0 ? void 0 : _a.removeAttribute("disabled");
      dispatch("turbo:submit-end", { target: this.formElement, detail: Object.assign({ formSubmission: this }, this.result) });
      this.delegate.formSubmissionFinished(this);
    }
    requestMustRedirect(request) {
      return !request.isIdempotent && this.mustRedirect;
    }
  };
  function buildFormData(formElement, submitter) {
    const formData = new FormData(formElement);
    const name2 = submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute("name");
    const value = submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute("value");
    if (name2 && value != null && formData.get(name2) != value) {
      formData.append(name2, value);
    }
    return formData;
  }
  function getCookieValue(cookieName) {
    if (cookieName != null) {
      const cookies = document.cookie ? document.cookie.split("; ") : [];
      const cookie = cookies.find((cookie2) => cookie2.startsWith(cookieName));
      if (cookie) {
        const value = cookie.split("=").slice(1).join("=");
        return value ? decodeURIComponent(value) : void 0;
      }
    }
  }
  function getMetaContent(name2) {
    const element = document.querySelector(`meta[name="${name2}"]`);
    return element && element.content;
  }
  function responseSucceededWithoutRedirect(response) {
    return response.statusCode == 200 && !response.redirected;
  }
  function mergeFormDataEntries(url, entries) {
    const searchParams = new URLSearchParams();
    for (const [name2, value] of entries) {
      if (value instanceof File)
        continue;
      searchParams.append(name2, value);
    }
    url.search = searchParams.toString();
    return url;
  }
  var Snapshot = class {
    constructor(element) {
      this.element = element;
    }
    get children() {
      return [...this.element.children];
    }
    hasAnchor(anchor) {
      return this.getElementForAnchor(anchor) != null;
    }
    getElementForAnchor(anchor) {
      return anchor ? this.element.querySelector(`[id='${anchor}'], a[name='${anchor}']`) : null;
    }
    get isConnected() {
      return this.element.isConnected;
    }
    get firstAutofocusableElement() {
      return this.element.querySelector("[autofocus]");
    }
    get permanentElements() {
      return [...this.element.querySelectorAll("[id][data-turbo-permanent]")];
    }
    getPermanentElementById(id) {
      return this.element.querySelector(`#${id}[data-turbo-permanent]`);
    }
    getPermanentElementMapForSnapshot(snapshot) {
      const permanentElementMap = {};
      for (const currentPermanentElement of this.permanentElements) {
        const { id } = currentPermanentElement;
        const newPermanentElement = snapshot.getPermanentElementById(id);
        if (newPermanentElement) {
          permanentElementMap[id] = [currentPermanentElement, newPermanentElement];
        }
      }
      return permanentElementMap;
    }
  };
  var FormInterceptor = class {
    constructor(delegate, element) {
      this.submitBubbled = (event) => {
        const form = event.target;
        if (!event.defaultPrevented && form instanceof HTMLFormElement && form.closest("turbo-frame, html") == this.element) {
          const submitter = event.submitter || void 0;
          const method = (submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute("formmethod")) || form.method;
          if (method != "dialog" && this.delegate.shouldInterceptFormSubmission(form, submitter)) {
            event.preventDefault();
            event.stopImmediatePropagation();
            this.delegate.formSubmissionIntercepted(form, submitter);
          }
        }
      };
      this.delegate = delegate;
      this.element = element;
    }
    start() {
      this.element.addEventListener("submit", this.submitBubbled);
    }
    stop() {
      this.element.removeEventListener("submit", this.submitBubbled);
    }
  };
  var View = class {
    constructor(delegate, element) {
      this.resolveRenderPromise = (value) => {
      };
      this.resolveInterceptionPromise = (value) => {
      };
      this.delegate = delegate;
      this.element = element;
    }
    scrollToAnchor(anchor) {
      const element = this.snapshot.getElementForAnchor(anchor);
      if (element) {
        this.scrollToElement(element);
        this.focusElement(element);
      } else {
        this.scrollToPosition({ x: 0, y: 0 });
      }
    }
    scrollToAnchorFromLocation(location2) {
      this.scrollToAnchor(getAnchor(location2));
    }
    scrollToElement(element) {
      element.scrollIntoView();
    }
    focusElement(element) {
      if (element instanceof HTMLElement) {
        if (element.hasAttribute("tabindex")) {
          element.focus();
        } else {
          element.setAttribute("tabindex", "-1");
          element.focus();
          element.removeAttribute("tabindex");
        }
      }
    }
    scrollToPosition({ x: x2, y: y3 }) {
      this.scrollRoot.scrollTo(x2, y3);
    }
    scrollToTop() {
      this.scrollToPosition({ x: 0, y: 0 });
    }
    get scrollRoot() {
      return window;
    }
    async render(renderer) {
      const { isPreview, shouldRender, newSnapshot: snapshot } = renderer;
      if (shouldRender) {
        try {
          this.renderPromise = new Promise((resolve2) => this.resolveRenderPromise = resolve2);
          this.renderer = renderer;
          this.prepareToRenderSnapshot(renderer);
          const renderInterception = new Promise((resolve2) => this.resolveInterceptionPromise = resolve2);
          const immediateRender = this.delegate.allowsImmediateRender(snapshot, this.resolveInterceptionPromise);
          if (!immediateRender)
            await renderInterception;
          await this.renderSnapshot(renderer);
          this.delegate.viewRenderedSnapshot(snapshot, isPreview);
          this.finishRenderingSnapshot(renderer);
        } finally {
          delete this.renderer;
          this.resolveRenderPromise(void 0);
          delete this.renderPromise;
        }
      } else {
        this.invalidate();
      }
    }
    invalidate() {
      this.delegate.viewInvalidated();
    }
    prepareToRenderSnapshot(renderer) {
      this.markAsPreview(renderer.isPreview);
      renderer.prepareToRender();
    }
    markAsPreview(isPreview) {
      if (isPreview) {
        this.element.setAttribute("data-turbo-preview", "");
      } else {
        this.element.removeAttribute("data-turbo-preview");
      }
    }
    async renderSnapshot(renderer) {
      await renderer.render();
    }
    finishRenderingSnapshot(renderer) {
      renderer.finishRendering();
    }
  };
  var FrameView = class extends View {
    invalidate() {
      this.element.innerHTML = "";
    }
    get snapshot() {
      return new Snapshot(this.element);
    }
  };
  var LinkInterceptor = class {
    constructor(delegate, element) {
      this.clickBubbled = (event) => {
        if (this.respondsToEventTarget(event.target)) {
          this.clickEvent = event;
        } else {
          delete this.clickEvent;
        }
      };
      this.linkClicked = (event) => {
        if (this.clickEvent && this.respondsToEventTarget(event.target) && event.target instanceof Element) {
          if (this.delegate.shouldInterceptLinkClick(event.target, event.detail.url)) {
            this.clickEvent.preventDefault();
            event.preventDefault();
            this.delegate.linkClickIntercepted(event.target, event.detail.url);
          }
        }
        delete this.clickEvent;
      };
      this.willVisit = () => {
        delete this.clickEvent;
      };
      this.delegate = delegate;
      this.element = element;
    }
    start() {
      this.element.addEventListener("click", this.clickBubbled);
      document.addEventListener("turbo:click", this.linkClicked);
      document.addEventListener("turbo:before-visit", this.willVisit);
    }
    stop() {
      this.element.removeEventListener("click", this.clickBubbled);
      document.removeEventListener("turbo:click", this.linkClicked);
      document.removeEventListener("turbo:before-visit", this.willVisit);
    }
    respondsToEventTarget(target) {
      const element = target instanceof Element ? target : target instanceof Node ? target.parentElement : null;
      return element && element.closest("turbo-frame, html") == this.element;
    }
  };
  var Bardo = class {
    constructor(permanentElementMap) {
      this.permanentElementMap = permanentElementMap;
    }
    static preservingPermanentElements(permanentElementMap, callback2) {
      const bardo = new this(permanentElementMap);
      bardo.enter();
      callback2();
      bardo.leave();
    }
    enter() {
      for (const id in this.permanentElementMap) {
        const [, newPermanentElement] = this.permanentElementMap[id];
        this.replaceNewPermanentElementWithPlaceholder(newPermanentElement);
      }
    }
    leave() {
      for (const id in this.permanentElementMap) {
        const [currentPermanentElement] = this.permanentElementMap[id];
        this.replaceCurrentPermanentElementWithClone(currentPermanentElement);
        this.replacePlaceholderWithPermanentElement(currentPermanentElement);
      }
    }
    replaceNewPermanentElementWithPlaceholder(permanentElement) {
      const placeholder = createPlaceholderForPermanentElement(permanentElement);
      permanentElement.replaceWith(placeholder);
    }
    replaceCurrentPermanentElementWithClone(permanentElement) {
      const clone3 = permanentElement.cloneNode(true);
      permanentElement.replaceWith(clone3);
    }
    replacePlaceholderWithPermanentElement(permanentElement) {
      const placeholder = this.getPlaceholderById(permanentElement.id);
      placeholder === null || placeholder === void 0 ? void 0 : placeholder.replaceWith(permanentElement);
    }
    getPlaceholderById(id) {
      return this.placeholders.find((element) => element.content == id);
    }
    get placeholders() {
      return [...document.querySelectorAll("meta[name=turbo-permanent-placeholder][content]")];
    }
  };
  function createPlaceholderForPermanentElement(permanentElement) {
    const element = document.createElement("meta");
    element.setAttribute("name", "turbo-permanent-placeholder");
    element.setAttribute("content", permanentElement.id);
    return element;
  }
  var Renderer = class {
    constructor(currentSnapshot, newSnapshot, isPreview, willRender = true) {
      this.currentSnapshot = currentSnapshot;
      this.newSnapshot = newSnapshot;
      this.isPreview = isPreview;
      this.willRender = willRender;
      this.promise = new Promise((resolve2, reject) => this.resolvingFunctions = { resolve: resolve2, reject });
    }
    get shouldRender() {
      return true;
    }
    prepareToRender() {
      return;
    }
    finishRendering() {
      if (this.resolvingFunctions) {
        this.resolvingFunctions.resolve();
        delete this.resolvingFunctions;
      }
    }
    createScriptElement(element) {
      if (element.getAttribute("data-turbo-eval") == "false") {
        return element;
      } else {
        const createdScriptElement = document.createElement("script");
        if (this.cspNonce) {
          createdScriptElement.nonce = this.cspNonce;
        }
        createdScriptElement.textContent = element.textContent;
        createdScriptElement.async = false;
        copyElementAttributes(createdScriptElement, element);
        return createdScriptElement;
      }
    }
    preservingPermanentElements(callback2) {
      Bardo.preservingPermanentElements(this.permanentElementMap, callback2);
    }
    focusFirstAutofocusableElement() {
      const element = this.connectedSnapshot.firstAutofocusableElement;
      if (elementIsFocusable(element)) {
        element.focus();
      }
    }
    get connectedSnapshot() {
      return this.newSnapshot.isConnected ? this.newSnapshot : this.currentSnapshot;
    }
    get currentElement() {
      return this.currentSnapshot.element;
    }
    get newElement() {
      return this.newSnapshot.element;
    }
    get permanentElementMap() {
      return this.currentSnapshot.getPermanentElementMapForSnapshot(this.newSnapshot);
    }
    get cspNonce() {
      var _a;
      return (_a = document.head.querySelector('meta[name="csp-nonce"]')) === null || _a === void 0 ? void 0 : _a.getAttribute("content");
    }
  };
  function copyElementAttributes(destinationElement, sourceElement) {
    for (const { name: name2, value } of [...sourceElement.attributes]) {
      destinationElement.setAttribute(name2, value);
    }
  }
  function elementIsFocusable(element) {
    return element && typeof element.focus == "function";
  }
  var FrameRenderer = class extends Renderer {
    get shouldRender() {
      return true;
    }
    async render() {
      await nextAnimationFrame();
      this.preservingPermanentElements(() => {
        this.loadFrameElement();
      });
      this.scrollFrameIntoView();
      await nextAnimationFrame();
      this.focusFirstAutofocusableElement();
      await nextAnimationFrame();
      this.activateScriptElements();
    }
    loadFrameElement() {
      var _a;
      const destinationRange = document.createRange();
      destinationRange.selectNodeContents(this.currentElement);
      destinationRange.deleteContents();
      const frameElement = this.newElement;
      const sourceRange = (_a = frameElement.ownerDocument) === null || _a === void 0 ? void 0 : _a.createRange();
      if (sourceRange) {
        sourceRange.selectNodeContents(frameElement);
        this.currentElement.appendChild(sourceRange.extractContents());
      }
    }
    scrollFrameIntoView() {
      if (this.currentElement.autoscroll || this.newElement.autoscroll) {
        const element = this.currentElement.firstElementChild;
        const block = readScrollLogicalPosition(this.currentElement.getAttribute("data-autoscroll-block"), "end");
        if (element) {
          element.scrollIntoView({ block });
          return true;
        }
      }
      return false;
    }
    activateScriptElements() {
      for (const inertScriptElement of this.newScriptElements) {
        const activatedScriptElement = this.createScriptElement(inertScriptElement);
        inertScriptElement.replaceWith(activatedScriptElement);
      }
    }
    get newScriptElements() {
      return this.currentElement.querySelectorAll("script");
    }
  };
  function readScrollLogicalPosition(value, defaultValue) {
    if (value == "end" || value == "start" || value == "center" || value == "nearest") {
      return value;
    } else {
      return defaultValue;
    }
  }
  var ProgressBar = class {
    constructor() {
      this.hiding = false;
      this.value = 0;
      this.visible = false;
      this.trickle = () => {
        this.setValue(this.value + Math.random() / 100);
      };
      this.stylesheetElement = this.createStylesheetElement();
      this.progressElement = this.createProgressElement();
      this.installStylesheetElement();
      this.setValue(0);
    }
    static get defaultCSS() {
      return unindent`
      .turbo-progress-bar {
        position: fixed;
        display: block;
        top: 0;
        left: 0;
        height: 3px;
        background: #0076ff;
        z-index: 9999;
        transition:
          width ${ProgressBar.animationDuration}ms ease-out,
          opacity ${ProgressBar.animationDuration / 2}ms ${ProgressBar.animationDuration / 2}ms ease-in;
        transform: translate3d(0, 0, 0);
      }
    `;
    }
    show() {
      if (!this.visible) {
        this.visible = true;
        this.installProgressElement();
        this.startTrickling();
      }
    }
    hide() {
      if (this.visible && !this.hiding) {
        this.hiding = true;
        this.fadeProgressElement(() => {
          this.uninstallProgressElement();
          this.stopTrickling();
          this.visible = false;
          this.hiding = false;
        });
      }
    }
    setValue(value) {
      this.value = value;
      this.refresh();
    }
    installStylesheetElement() {
      document.head.insertBefore(this.stylesheetElement, document.head.firstChild);
    }
    installProgressElement() {
      this.progressElement.style.width = "0";
      this.progressElement.style.opacity = "1";
      document.documentElement.insertBefore(this.progressElement, document.body);
      this.refresh();
    }
    fadeProgressElement(callback2) {
      this.progressElement.style.opacity = "0";
      setTimeout(callback2, ProgressBar.animationDuration * 1.5);
    }
    uninstallProgressElement() {
      if (this.progressElement.parentNode) {
        document.documentElement.removeChild(this.progressElement);
      }
    }
    startTrickling() {
      if (!this.trickleInterval) {
        this.trickleInterval = window.setInterval(this.trickle, ProgressBar.animationDuration);
      }
    }
    stopTrickling() {
      window.clearInterval(this.trickleInterval);
      delete this.trickleInterval;
    }
    refresh() {
      requestAnimationFrame(() => {
        this.progressElement.style.width = `${10 + this.value * 90}%`;
      });
    }
    createStylesheetElement() {
      const element = document.createElement("style");
      element.type = "text/css";
      element.textContent = ProgressBar.defaultCSS;
      return element;
    }
    createProgressElement() {
      const element = document.createElement("div");
      element.className = "turbo-progress-bar";
      return element;
    }
  };
  ProgressBar.animationDuration = 300;
  var HeadSnapshot = class extends Snapshot {
    constructor() {
      super(...arguments);
      this.detailsByOuterHTML = this.children.filter((element) => !elementIsNoscript(element)).map((element) => elementWithoutNonce(element)).reduce((result, element) => {
        const { outerHTML } = element;
        const details = outerHTML in result ? result[outerHTML] : {
          type: elementType(element),
          tracked: elementIsTracked(element),
          elements: []
        };
        return Object.assign(Object.assign({}, result), { [outerHTML]: Object.assign(Object.assign({}, details), { elements: [...details.elements, element] }) });
      }, {});
    }
    get trackedElementSignature() {
      return Object.keys(this.detailsByOuterHTML).filter((outerHTML) => this.detailsByOuterHTML[outerHTML].tracked).join("");
    }
    getScriptElementsNotInSnapshot(snapshot) {
      return this.getElementsMatchingTypeNotInSnapshot("script", snapshot);
    }
    getStylesheetElementsNotInSnapshot(snapshot) {
      return this.getElementsMatchingTypeNotInSnapshot("stylesheet", snapshot);
    }
    getElementsMatchingTypeNotInSnapshot(matchedType, snapshot) {
      return Object.keys(this.detailsByOuterHTML).filter((outerHTML) => !(outerHTML in snapshot.detailsByOuterHTML)).map((outerHTML) => this.detailsByOuterHTML[outerHTML]).filter(({ type }) => type == matchedType).map(({ elements: [element] }) => element);
    }
    get provisionalElements() {
      return Object.keys(this.detailsByOuterHTML).reduce((result, outerHTML) => {
        const { type, tracked, elements: elements3 } = this.detailsByOuterHTML[outerHTML];
        if (type == null && !tracked) {
          return [...result, ...elements3];
        } else if (elements3.length > 1) {
          return [...result, ...elements3.slice(1)];
        } else {
          return result;
        }
      }, []);
    }
    getMetaValue(name2) {
      const element = this.findMetaElementByName(name2);
      return element ? element.getAttribute("content") : null;
    }
    findMetaElementByName(name2) {
      return Object.keys(this.detailsByOuterHTML).reduce((result, outerHTML) => {
        const { elements: [element] } = this.detailsByOuterHTML[outerHTML];
        return elementIsMetaElementWithName(element, name2) ? element : result;
      }, void 0);
    }
  };
  function elementType(element) {
    if (elementIsScript(element)) {
      return "script";
    } else if (elementIsStylesheet(element)) {
      return "stylesheet";
    }
  }
  function elementIsTracked(element) {
    return element.getAttribute("data-turbo-track") == "reload";
  }
  function elementIsScript(element) {
    const tagName = element.tagName.toLowerCase();
    return tagName == "script";
  }
  function elementIsNoscript(element) {
    const tagName = element.tagName.toLowerCase();
    return tagName == "noscript";
  }
  function elementIsStylesheet(element) {
    const tagName = element.tagName.toLowerCase();
    return tagName == "style" || tagName == "link" && element.getAttribute("rel") == "stylesheet";
  }
  function elementIsMetaElementWithName(element, name2) {
    const tagName = element.tagName.toLowerCase();
    return tagName == "meta" && element.getAttribute("name") == name2;
  }
  function elementWithoutNonce(element) {
    if (element.hasAttribute("nonce")) {
      element.setAttribute("nonce", "");
    }
    return element;
  }
  var PageSnapshot = class extends Snapshot {
    constructor(element, headSnapshot) {
      super(element);
      this.headSnapshot = headSnapshot;
    }
    static fromHTMLString(html = "") {
      return this.fromDocument(parseHTMLDocument(html));
    }
    static fromElement(element) {
      return this.fromDocument(element.ownerDocument);
    }
    static fromDocument({ head, body }) {
      return new this(body, new HeadSnapshot(head));
    }
    clone() {
      return new PageSnapshot(this.element.cloneNode(true), this.headSnapshot);
    }
    get headElement() {
      return this.headSnapshot.element;
    }
    get rootLocation() {
      var _a;
      const root = (_a = this.getSetting("root")) !== null && _a !== void 0 ? _a : "/";
      return expandURL(root);
    }
    get cacheControlValue() {
      return this.getSetting("cache-control");
    }
    get isPreviewable() {
      return this.cacheControlValue != "no-preview";
    }
    get isCacheable() {
      return this.cacheControlValue != "no-cache";
    }
    get isVisitable() {
      return this.getSetting("visit-control") != "reload";
    }
    getSetting(name2) {
      return this.headSnapshot.getMetaValue(`turbo-${name2}`);
    }
  };
  var TimingMetric;
  (function(TimingMetric2) {
    TimingMetric2["visitStart"] = "visitStart";
    TimingMetric2["requestStart"] = "requestStart";
    TimingMetric2["requestEnd"] = "requestEnd";
    TimingMetric2["visitEnd"] = "visitEnd";
  })(TimingMetric || (TimingMetric = {}));
  var VisitState;
  (function(VisitState2) {
    VisitState2["initialized"] = "initialized";
    VisitState2["started"] = "started";
    VisitState2["canceled"] = "canceled";
    VisitState2["failed"] = "failed";
    VisitState2["completed"] = "completed";
  })(VisitState || (VisitState = {}));
  var defaultOptions = {
    action: "advance",
    historyChanged: false,
    visitCachedSnapshot: () => {
    },
    willRender: true
  };
  var SystemStatusCode;
  (function(SystemStatusCode2) {
    SystemStatusCode2[SystemStatusCode2["networkFailure"] = 0] = "networkFailure";
    SystemStatusCode2[SystemStatusCode2["timeoutFailure"] = -1] = "timeoutFailure";
    SystemStatusCode2[SystemStatusCode2["contentTypeMismatch"] = -2] = "contentTypeMismatch";
  })(SystemStatusCode || (SystemStatusCode = {}));
  var Visit = class {
    constructor(delegate, location2, restorationIdentifier, options2 = {}) {
      this.identifier = uuid();
      this.timingMetrics = {};
      this.followedRedirect = false;
      this.historyChanged = false;
      this.scrolled = false;
      this.snapshotCached = false;
      this.state = VisitState.initialized;
      this.delegate = delegate;
      this.location = location2;
      this.restorationIdentifier = restorationIdentifier || uuid();
      const { action, historyChanged, referrer, snapshotHTML, response, visitCachedSnapshot, willRender } = Object.assign(Object.assign({}, defaultOptions), options2);
      this.action = action;
      this.historyChanged = historyChanged;
      this.referrer = referrer;
      this.snapshotHTML = snapshotHTML;
      this.response = response;
      this.isSamePage = this.delegate.locationWithActionIsSamePage(this.location, this.action);
      this.visitCachedSnapshot = visitCachedSnapshot;
      this.willRender = willRender;
      this.scrolled = !willRender;
    }
    get adapter() {
      return this.delegate.adapter;
    }
    get view() {
      return this.delegate.view;
    }
    get history() {
      return this.delegate.history;
    }
    get restorationData() {
      return this.history.getRestorationDataForIdentifier(this.restorationIdentifier);
    }
    get silent() {
      return this.isSamePage;
    }
    start() {
      if (this.state == VisitState.initialized) {
        this.recordTimingMetric(TimingMetric.visitStart);
        this.state = VisitState.started;
        this.adapter.visitStarted(this);
        this.delegate.visitStarted(this);
      }
    }
    cancel() {
      if (this.state == VisitState.started) {
        if (this.request) {
          this.request.cancel();
        }
        this.cancelRender();
        this.state = VisitState.canceled;
      }
    }
    complete() {
      if (this.state == VisitState.started) {
        this.recordTimingMetric(TimingMetric.visitEnd);
        this.state = VisitState.completed;
        this.adapter.visitCompleted(this);
        this.delegate.visitCompleted(this);
        this.followRedirect();
      }
    }
    fail() {
      if (this.state == VisitState.started) {
        this.state = VisitState.failed;
        this.adapter.visitFailed(this);
      }
    }
    changeHistory() {
      var _a;
      if (!this.historyChanged) {
        const actionForHistory = this.location.href === ((_a = this.referrer) === null || _a === void 0 ? void 0 : _a.href) ? "replace" : this.action;
        const method = this.getHistoryMethodForAction(actionForHistory);
        this.history.update(method, this.location, this.restorationIdentifier);
        this.historyChanged = true;
      }
    }
    issueRequest() {
      if (this.hasPreloadedResponse()) {
        this.simulateRequest();
      } else if (this.shouldIssueRequest() && !this.request) {
        this.request = new FetchRequest(this, FetchMethod.get, this.location);
        this.request.perform();
      }
    }
    simulateRequest() {
      if (this.response) {
        this.startRequest();
        this.recordResponse();
        this.finishRequest();
      }
    }
    startRequest() {
      this.recordTimingMetric(TimingMetric.requestStart);
      this.adapter.visitRequestStarted(this);
    }
    recordResponse(response = this.response) {
      this.response = response;
      if (response) {
        const { statusCode } = response;
        if (isSuccessful(statusCode)) {
          this.adapter.visitRequestCompleted(this);
        } else {
          this.adapter.visitRequestFailedWithStatusCode(this, statusCode);
        }
      }
    }
    finishRequest() {
      this.recordTimingMetric(TimingMetric.requestEnd);
      this.adapter.visitRequestFinished(this);
    }
    loadResponse() {
      if (this.response) {
        const { statusCode, responseHTML } = this.response;
        this.render(async () => {
          this.cacheSnapshot();
          if (this.view.renderPromise)
            await this.view.renderPromise;
          if (isSuccessful(statusCode) && responseHTML != null) {
            await this.view.renderPage(PageSnapshot.fromHTMLString(responseHTML), false, this.willRender);
            this.adapter.visitRendered(this);
            this.complete();
          } else {
            await this.view.renderError(PageSnapshot.fromHTMLString(responseHTML));
            this.adapter.visitRendered(this);
            this.fail();
          }
        });
      }
    }
    getCachedSnapshot() {
      const snapshot = this.view.getCachedSnapshotForLocation(this.location) || this.getPreloadedSnapshot();
      if (snapshot && (!getAnchor(this.location) || snapshot.hasAnchor(getAnchor(this.location)))) {
        if (this.action == "restore" || snapshot.isPreviewable) {
          return snapshot;
        }
      }
    }
    getPreloadedSnapshot() {
      if (this.snapshotHTML) {
        return PageSnapshot.fromHTMLString(this.snapshotHTML);
      }
    }
    hasCachedSnapshot() {
      return this.getCachedSnapshot() != null;
    }
    loadCachedSnapshot() {
      const snapshot = this.getCachedSnapshot();
      if (snapshot) {
        const isPreview = this.shouldIssueRequest();
        this.render(async () => {
          this.cacheSnapshot();
          if (this.isSamePage) {
            this.adapter.visitRendered(this);
          } else {
            if (this.view.renderPromise)
              await this.view.renderPromise;
            await this.view.renderPage(snapshot, isPreview, this.willRender);
            this.adapter.visitRendered(this);
            if (!isPreview) {
              this.complete();
            }
          }
        });
      }
    }
    followRedirect() {
      var _a;
      if (this.redirectedToLocation && !this.followedRedirect && ((_a = this.response) === null || _a === void 0 ? void 0 : _a.redirected)) {
        this.adapter.visitProposedToLocation(this.redirectedToLocation, {
          action: "replace",
          response: this.response
        });
        this.followedRedirect = true;
      }
    }
    goToSamePageAnchor() {
      if (this.isSamePage) {
        this.render(async () => {
          this.cacheSnapshot();
          this.adapter.visitRendered(this);
        });
      }
    }
    requestStarted() {
      this.startRequest();
    }
    requestPreventedHandlingResponse(request, response) {
    }
    async requestSucceededWithResponse(request, response) {
      const responseHTML = await response.responseHTML;
      const { redirected, statusCode } = response;
      if (responseHTML == void 0) {
        this.recordResponse({ statusCode: SystemStatusCode.contentTypeMismatch, redirected });
      } else {
        this.redirectedToLocation = response.redirected ? response.location : void 0;
        this.recordResponse({ statusCode, responseHTML, redirected });
      }
    }
    async requestFailedWithResponse(request, response) {
      const responseHTML = await response.responseHTML;
      const { redirected, statusCode } = response;
      if (responseHTML == void 0) {
        this.recordResponse({ statusCode: SystemStatusCode.contentTypeMismatch, redirected });
      } else {
        this.recordResponse({ statusCode, responseHTML, redirected });
      }
    }
    requestErrored(request, error2) {
      this.recordResponse({ statusCode: SystemStatusCode.networkFailure, redirected: false });
    }
    requestFinished() {
      this.finishRequest();
    }
    performScroll() {
      if (!this.scrolled) {
        if (this.action == "restore") {
          this.scrollToRestoredPosition() || this.scrollToAnchor() || this.view.scrollToTop();
        } else {
          this.scrollToAnchor() || this.view.scrollToTop();
        }
        if (this.isSamePage) {
          this.delegate.visitScrolledToSamePageLocation(this.view.lastRenderedLocation, this.location);
        }
        this.scrolled = true;
      }
    }
    scrollToRestoredPosition() {
      const { scrollPosition } = this.restorationData;
      if (scrollPosition) {
        this.view.scrollToPosition(scrollPosition);
        return true;
      }
    }
    scrollToAnchor() {
      const anchor = getAnchor(this.location);
      if (anchor != null) {
        this.view.scrollToAnchor(anchor);
        return true;
      }
    }
    recordTimingMetric(metric) {
      this.timingMetrics[metric] = new Date().getTime();
    }
    getTimingMetrics() {
      return Object.assign({}, this.timingMetrics);
    }
    getHistoryMethodForAction(action) {
      switch (action) {
        case "replace":
          return history.replaceState;
        case "advance":
        case "restore":
          return history.pushState;
      }
    }
    hasPreloadedResponse() {
      return typeof this.response == "object";
    }
    shouldIssueRequest() {
      if (this.isSamePage) {
        return false;
      } else if (this.action == "restore") {
        return !this.hasCachedSnapshot();
      } else {
        return this.willRender;
      }
    }
    cacheSnapshot() {
      if (!this.snapshotCached) {
        this.view.cacheSnapshot().then((snapshot) => snapshot && this.visitCachedSnapshot(snapshot));
        this.snapshotCached = true;
      }
    }
    async render(callback2) {
      this.cancelRender();
      await new Promise((resolve2) => {
        this.frame = requestAnimationFrame(() => resolve2());
      });
      await callback2();
      delete this.frame;
      this.performScroll();
    }
    cancelRender() {
      if (this.frame) {
        cancelAnimationFrame(this.frame);
        delete this.frame;
      }
    }
  };
  function isSuccessful(statusCode) {
    return statusCode >= 200 && statusCode < 300;
  }
  var BrowserAdapter = class {
    constructor(session2) {
      this.progressBar = new ProgressBar();
      this.showProgressBar = () => {
        this.progressBar.show();
      };
      this.session = session2;
    }
    visitProposedToLocation(location2, options2) {
      this.navigator.startVisit(location2, uuid(), options2);
    }
    visitStarted(visit2) {
      visit2.loadCachedSnapshot();
      visit2.issueRequest();
      visit2.changeHistory();
      visit2.goToSamePageAnchor();
    }
    visitRequestStarted(visit2) {
      this.progressBar.setValue(0);
      if (visit2.hasCachedSnapshot() || visit2.action != "restore") {
        this.showVisitProgressBarAfterDelay();
      } else {
        this.showProgressBar();
      }
    }
    visitRequestCompleted(visit2) {
      visit2.loadResponse();
    }
    visitRequestFailedWithStatusCode(visit2, statusCode) {
      switch (statusCode) {
        case SystemStatusCode.networkFailure:
        case SystemStatusCode.timeoutFailure:
        case SystemStatusCode.contentTypeMismatch:
          return this.reload();
        default:
          return visit2.loadResponse();
      }
    }
    visitRequestFinished(visit2) {
      this.progressBar.setValue(1);
      this.hideVisitProgressBar();
    }
    visitCompleted(visit2) {
    }
    pageInvalidated() {
      this.reload();
    }
    visitFailed(visit2) {
    }
    visitRendered(visit2) {
    }
    formSubmissionStarted(formSubmission) {
      this.progressBar.setValue(0);
      this.showFormProgressBarAfterDelay();
    }
    formSubmissionFinished(formSubmission) {
      this.progressBar.setValue(1);
      this.hideFormProgressBar();
    }
    showVisitProgressBarAfterDelay() {
      this.visitProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);
    }
    hideVisitProgressBar() {
      this.progressBar.hide();
      if (this.visitProgressBarTimeout != null) {
        window.clearTimeout(this.visitProgressBarTimeout);
        delete this.visitProgressBarTimeout;
      }
    }
    showFormProgressBarAfterDelay() {
      if (this.formProgressBarTimeout == null) {
        this.formProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);
      }
    }
    hideFormProgressBar() {
      this.progressBar.hide();
      if (this.formProgressBarTimeout != null) {
        window.clearTimeout(this.formProgressBarTimeout);
        delete this.formProgressBarTimeout;
      }
    }
    reload() {
      window.location.reload();
    }
    get navigator() {
      return this.session.navigator;
    }
  };
  var CacheObserver = class {
    constructor() {
      this.started = false;
    }
    start() {
      if (!this.started) {
        this.started = true;
        addEventListener("turbo:before-cache", this.removeStaleElements, false);
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        removeEventListener("turbo:before-cache", this.removeStaleElements, false);
      }
    }
    removeStaleElements() {
      const staleElements = [...document.querySelectorAll('[data-turbo-cache="false"]')];
      for (const element of staleElements) {
        element.remove();
      }
    }
  };
  var FormSubmitObserver = class {
    constructor(delegate) {
      this.started = false;
      this.submitCaptured = () => {
        removeEventListener("submit", this.submitBubbled, false);
        addEventListener("submit", this.submitBubbled, false);
      };
      this.submitBubbled = (event) => {
        if (!event.defaultPrevented) {
          const form = event.target instanceof HTMLFormElement ? event.target : void 0;
          const submitter = event.submitter || void 0;
          if (form) {
            const method = (submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute("formmethod")) || form.getAttribute("method");
            if (method != "dialog" && this.delegate.willSubmitForm(form, submitter)) {
              event.preventDefault();
              this.delegate.formSubmitted(form, submitter);
            }
          }
        }
      };
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        addEventListener("submit", this.submitCaptured, true);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        removeEventListener("submit", this.submitCaptured, true);
        this.started = false;
      }
    }
  };
  var FrameRedirector = class {
    constructor(element) {
      this.element = element;
      this.linkInterceptor = new LinkInterceptor(this, element);
      this.formInterceptor = new FormInterceptor(this, element);
    }
    start() {
      this.linkInterceptor.start();
      this.formInterceptor.start();
    }
    stop() {
      this.linkInterceptor.stop();
      this.formInterceptor.stop();
    }
    shouldInterceptLinkClick(element, url) {
      return this.shouldRedirect(element);
    }
    linkClickIntercepted(element, url) {
      const frame = this.findFrameElement(element);
      if (frame) {
        frame.delegate.linkClickIntercepted(element, url);
      }
    }
    shouldInterceptFormSubmission(element, submitter) {
      return this.shouldSubmit(element, submitter);
    }
    formSubmissionIntercepted(element, submitter) {
      const frame = this.findFrameElement(element, submitter);
      if (frame) {
        frame.removeAttribute("reloadable");
        frame.delegate.formSubmissionIntercepted(element, submitter);
      }
    }
    shouldSubmit(form, submitter) {
      var _a;
      const action = getAction(form, submitter);
      const meta = this.element.ownerDocument.querySelector(`meta[name="turbo-root"]`);
      const rootLocation = expandURL((_a = meta === null || meta === void 0 ? void 0 : meta.content) !== null && _a !== void 0 ? _a : "/");
      return this.shouldRedirect(form, submitter) && locationIsVisitable(action, rootLocation);
    }
    shouldRedirect(element, submitter) {
      const frame = this.findFrameElement(element, submitter);
      return frame ? frame != element.closest("turbo-frame") : false;
    }
    findFrameElement(element, submitter) {
      const id = (submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute("data-turbo-frame")) || element.getAttribute("data-turbo-frame");
      if (id && id != "_top") {
        const frame = this.element.querySelector(`#${id}:not([disabled])`);
        if (frame instanceof FrameElement) {
          return frame;
        }
      }
    }
  };
  var History = class {
    constructor(delegate) {
      this.restorationIdentifier = uuid();
      this.restorationData = {};
      this.started = false;
      this.pageLoaded = false;
      this.onPopState = (event) => {
        if (this.shouldHandlePopState()) {
          const { turbo } = event.state || {};
          if (turbo) {
            this.location = new URL(window.location.href);
            const { restorationIdentifier } = turbo;
            this.restorationIdentifier = restorationIdentifier;
            this.delegate.historyPoppedToLocationWithRestorationIdentifier(this.location, restorationIdentifier);
          }
        }
      };
      this.onPageLoad = async (event) => {
        await nextMicrotask();
        this.pageLoaded = true;
      };
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        addEventListener("popstate", this.onPopState, false);
        addEventListener("load", this.onPageLoad, false);
        this.started = true;
        this.replace(new URL(window.location.href));
      }
    }
    stop() {
      if (this.started) {
        removeEventListener("popstate", this.onPopState, false);
        removeEventListener("load", this.onPageLoad, false);
        this.started = false;
      }
    }
    push(location2, restorationIdentifier) {
      this.update(history.pushState, location2, restorationIdentifier);
    }
    replace(location2, restorationIdentifier) {
      this.update(history.replaceState, location2, restorationIdentifier);
    }
    update(method, location2, restorationIdentifier = uuid()) {
      const state = { turbo: { restorationIdentifier } };
      method.call(history, state, "", location2.href);
      this.location = location2;
      this.restorationIdentifier = restorationIdentifier;
    }
    getRestorationDataForIdentifier(restorationIdentifier) {
      return this.restorationData[restorationIdentifier] || {};
    }
    updateRestorationData(additionalData) {
      const { restorationIdentifier } = this;
      const restorationData = this.restorationData[restorationIdentifier];
      this.restorationData[restorationIdentifier] = Object.assign(Object.assign({}, restorationData), additionalData);
    }
    assumeControlOfScrollRestoration() {
      var _a;
      if (!this.previousScrollRestoration) {
        this.previousScrollRestoration = (_a = history.scrollRestoration) !== null && _a !== void 0 ? _a : "auto";
        history.scrollRestoration = "manual";
      }
    }
    relinquishControlOfScrollRestoration() {
      if (this.previousScrollRestoration) {
        history.scrollRestoration = this.previousScrollRestoration;
        delete this.previousScrollRestoration;
      }
    }
    shouldHandlePopState() {
      return this.pageIsLoaded();
    }
    pageIsLoaded() {
      return this.pageLoaded || document.readyState == "complete";
    }
  };
  var LinkClickObserver = class {
    constructor(delegate) {
      this.started = false;
      this.clickCaptured = () => {
        removeEventListener("click", this.clickBubbled, false);
        addEventListener("click", this.clickBubbled, false);
      };
      this.clickBubbled = (event) => {
        if (this.clickEventIsSignificant(event)) {
          const target = event.composedPath && event.composedPath()[0] || event.target;
          const link = this.findLinkFromClickTarget(target);
          if (link) {
            const location2 = this.getLocationForLink(link);
            if (this.delegate.willFollowLinkToLocation(link, location2)) {
              event.preventDefault();
              this.delegate.followedLinkToLocation(link, location2);
            }
          }
        }
      };
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        addEventListener("click", this.clickCaptured, true);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        removeEventListener("click", this.clickCaptured, true);
        this.started = false;
      }
    }
    clickEventIsSignificant(event) {
      return !(event.target && event.target.isContentEditable || event.defaultPrevented || event.which > 1 || event.altKey || event.ctrlKey || event.metaKey || event.shiftKey);
    }
    findLinkFromClickTarget(target) {
      if (target instanceof Element) {
        return target.closest("a[href]:not([target^=_]):not([download])");
      }
    }
    getLocationForLink(link) {
      return expandURL(link.getAttribute("href") || "");
    }
  };
  function isAction(action) {
    return action == "advance" || action == "replace" || action == "restore";
  }
  var Navigator = class {
    constructor(delegate) {
      this.delegate = delegate;
    }
    proposeVisit(location2, options2 = {}) {
      if (this.delegate.allowsVisitingLocationWithAction(location2, options2.action)) {
        if (locationIsVisitable(location2, this.view.snapshot.rootLocation)) {
          this.delegate.visitProposedToLocation(location2, options2);
        } else {
          window.location.href = location2.toString();
        }
      }
    }
    startVisit(locatable, restorationIdentifier, options2 = {}) {
      this.stop();
      this.currentVisit = new Visit(this, expandURL(locatable), restorationIdentifier, Object.assign({ referrer: this.location }, options2));
      this.currentVisit.start();
    }
    submitForm(form, submitter) {
      this.stop();
      this.formSubmission = new FormSubmission(this, form, submitter, true);
      this.formSubmission.start();
    }
    stop() {
      if (this.formSubmission) {
        this.formSubmission.stop();
        delete this.formSubmission;
      }
      if (this.currentVisit) {
        this.currentVisit.cancel();
        delete this.currentVisit;
      }
    }
    get adapter() {
      return this.delegate.adapter;
    }
    get view() {
      return this.delegate.view;
    }
    get history() {
      return this.delegate.history;
    }
    formSubmissionStarted(formSubmission) {
      if (typeof this.adapter.formSubmissionStarted === "function") {
        this.adapter.formSubmissionStarted(formSubmission);
      }
    }
    async formSubmissionSucceededWithResponse(formSubmission, fetchResponse) {
      if (formSubmission == this.formSubmission) {
        const responseHTML = await fetchResponse.responseHTML;
        if (responseHTML) {
          if (formSubmission.method != FetchMethod.get) {
            this.view.clearSnapshotCache();
          }
          const { statusCode, redirected } = fetchResponse;
          const action = this.getActionForFormSubmission(formSubmission);
          const visitOptions = { action, response: { statusCode, responseHTML, redirected } };
          this.proposeVisit(fetchResponse.location, visitOptions);
        }
      }
    }
    async formSubmissionFailedWithResponse(formSubmission, fetchResponse) {
      const responseHTML = await fetchResponse.responseHTML;
      if (responseHTML) {
        const snapshot = PageSnapshot.fromHTMLString(responseHTML);
        if (fetchResponse.serverError) {
          await this.view.renderError(snapshot);
        } else {
          await this.view.renderPage(snapshot);
        }
        this.view.scrollToTop();
        this.view.clearSnapshotCache();
      }
    }
    formSubmissionErrored(formSubmission, error2) {
      console.error(error2);
    }
    formSubmissionFinished(formSubmission) {
      if (typeof this.adapter.formSubmissionFinished === "function") {
        this.adapter.formSubmissionFinished(formSubmission);
      }
    }
    visitStarted(visit2) {
      this.delegate.visitStarted(visit2);
    }
    visitCompleted(visit2) {
      this.delegate.visitCompleted(visit2);
    }
    locationWithActionIsSamePage(location2, action) {
      const anchor = getAnchor(location2);
      const currentAnchor = getAnchor(this.view.lastRenderedLocation);
      const isRestorationToTop = action === "restore" && typeof anchor === "undefined";
      return action !== "replace" && getRequestURL(location2) === getRequestURL(this.view.lastRenderedLocation) && (isRestorationToTop || anchor != null && anchor !== currentAnchor);
    }
    visitScrolledToSamePageLocation(oldURL, newURL) {
      this.delegate.visitScrolledToSamePageLocation(oldURL, newURL);
    }
    get location() {
      return this.history.location;
    }
    get restorationIdentifier() {
      return this.history.restorationIdentifier;
    }
    getActionForFormSubmission(formSubmission) {
      const { formElement, submitter } = formSubmission;
      const action = getAttribute("data-turbo-action", submitter, formElement);
      return isAction(action) ? action : "advance";
    }
  };
  var PageStage;
  (function(PageStage2) {
    PageStage2[PageStage2["initial"] = 0] = "initial";
    PageStage2[PageStage2["loading"] = 1] = "loading";
    PageStage2[PageStage2["interactive"] = 2] = "interactive";
    PageStage2[PageStage2["complete"] = 3] = "complete";
  })(PageStage || (PageStage = {}));
  var PageObserver = class {
    constructor(delegate) {
      this.stage = PageStage.initial;
      this.started = false;
      this.interpretReadyState = () => {
        const { readyState } = this;
        if (readyState == "interactive") {
          this.pageIsInteractive();
        } else if (readyState == "complete") {
          this.pageIsComplete();
        }
      };
      this.pageWillUnload = () => {
        this.delegate.pageWillUnload();
      };
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        if (this.stage == PageStage.initial) {
          this.stage = PageStage.loading;
        }
        document.addEventListener("readystatechange", this.interpretReadyState, false);
        addEventListener("pagehide", this.pageWillUnload, false);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        document.removeEventListener("readystatechange", this.interpretReadyState, false);
        removeEventListener("pagehide", this.pageWillUnload, false);
        this.started = false;
      }
    }
    pageIsInteractive() {
      if (this.stage == PageStage.loading) {
        this.stage = PageStage.interactive;
        this.delegate.pageBecameInteractive();
      }
    }
    pageIsComplete() {
      this.pageIsInteractive();
      if (this.stage == PageStage.interactive) {
        this.stage = PageStage.complete;
        this.delegate.pageLoaded();
      }
    }
    get readyState() {
      return document.readyState;
    }
  };
  var ScrollObserver = class {
    constructor(delegate) {
      this.started = false;
      this.onScroll = () => {
        this.updatePosition({ x: window.pageXOffset, y: window.pageYOffset });
      };
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        addEventListener("scroll", this.onScroll, false);
        this.onScroll();
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        removeEventListener("scroll", this.onScroll, false);
        this.started = false;
      }
    }
    updatePosition(position) {
      this.delegate.scrollPositionChanged(position);
    }
  };
  var StreamObserver = class {
    constructor(delegate) {
      this.sources = /* @__PURE__ */ new Set();
      this.started = false;
      this.inspectFetchResponse = (event) => {
        const response = fetchResponseFromEvent(event);
        if (response && fetchResponseIsStream(response)) {
          event.preventDefault();
          this.receiveMessageResponse(response);
        }
      };
      this.receiveMessageEvent = (event) => {
        if (this.started && typeof event.data == "string") {
          this.receiveMessageHTML(event.data);
        }
      };
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        this.started = true;
        addEventListener("turbo:before-fetch-response", this.inspectFetchResponse, false);
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        removeEventListener("turbo:before-fetch-response", this.inspectFetchResponse, false);
      }
    }
    connectStreamSource(source) {
      if (!this.streamSourceIsConnected(source)) {
        this.sources.add(source);
        source.addEventListener("message", this.receiveMessageEvent, false);
      }
    }
    disconnectStreamSource(source) {
      if (this.streamSourceIsConnected(source)) {
        this.sources.delete(source);
        source.removeEventListener("message", this.receiveMessageEvent, false);
      }
    }
    streamSourceIsConnected(source) {
      return this.sources.has(source);
    }
    async receiveMessageResponse(response) {
      const html = await response.responseHTML;
      if (html) {
        this.receiveMessageHTML(html);
      }
    }
    receiveMessageHTML(html) {
      this.delegate.receivedMessageFromStream(new StreamMessage(html));
    }
  };
  function fetchResponseFromEvent(event) {
    var _a;
    const fetchResponse = (_a = event.detail) === null || _a === void 0 ? void 0 : _a.fetchResponse;
    if (fetchResponse instanceof FetchResponse) {
      return fetchResponse;
    }
  }
  function fetchResponseIsStream(response) {
    var _a;
    const contentType = (_a = response.contentType) !== null && _a !== void 0 ? _a : "";
    return contentType.startsWith(StreamMessage.contentType);
  }
  var ErrorRenderer = class extends Renderer {
    async render() {
      this.replaceHeadAndBody();
      this.activateScriptElements();
    }
    replaceHeadAndBody() {
      const { documentElement, head, body } = document;
      documentElement.replaceChild(this.newHead, head);
      documentElement.replaceChild(this.newElement, body);
    }
    activateScriptElements() {
      for (const replaceableElement of this.scriptElements) {
        const parentNode = replaceableElement.parentNode;
        if (parentNode) {
          const element = this.createScriptElement(replaceableElement);
          parentNode.replaceChild(element, replaceableElement);
        }
      }
    }
    get newHead() {
      return this.newSnapshot.headSnapshot.element;
    }
    get scriptElements() {
      return [...document.documentElement.querySelectorAll("script")];
    }
  };
  var PageRenderer = class extends Renderer {
    get shouldRender() {
      return this.newSnapshot.isVisitable && this.trackedElementsAreIdentical;
    }
    prepareToRender() {
      this.mergeHead();
    }
    async render() {
      if (this.willRender) {
        this.replaceBody();
      }
    }
    finishRendering() {
      super.finishRendering();
      if (!this.isPreview) {
        this.focusFirstAutofocusableElement();
      }
    }
    get currentHeadSnapshot() {
      return this.currentSnapshot.headSnapshot;
    }
    get newHeadSnapshot() {
      return this.newSnapshot.headSnapshot;
    }
    get newElement() {
      return this.newSnapshot.element;
    }
    mergeHead() {
      this.copyNewHeadStylesheetElements();
      this.copyNewHeadScriptElements();
      this.removeCurrentHeadProvisionalElements();
      this.copyNewHeadProvisionalElements();
    }
    replaceBody() {
      this.preservingPermanentElements(() => {
        this.activateNewBody();
        this.assignNewBody();
      });
    }
    get trackedElementsAreIdentical() {
      return this.currentHeadSnapshot.trackedElementSignature == this.newHeadSnapshot.trackedElementSignature;
    }
    copyNewHeadStylesheetElements() {
      for (const element of this.newHeadStylesheetElements) {
        document.head.appendChild(element);
      }
    }
    copyNewHeadScriptElements() {
      for (const element of this.newHeadScriptElements) {
        document.head.appendChild(this.createScriptElement(element));
      }
    }
    removeCurrentHeadProvisionalElements() {
      for (const element of this.currentHeadProvisionalElements) {
        document.head.removeChild(element);
      }
    }
    copyNewHeadProvisionalElements() {
      for (const element of this.newHeadProvisionalElements) {
        document.head.appendChild(element);
      }
    }
    activateNewBody() {
      document.adoptNode(this.newElement);
      this.activateNewBodyScriptElements();
    }
    activateNewBodyScriptElements() {
      for (const inertScriptElement of this.newBodyScriptElements) {
        const activatedScriptElement = this.createScriptElement(inertScriptElement);
        inertScriptElement.replaceWith(activatedScriptElement);
      }
    }
    assignNewBody() {
      if (document.body && this.newElement instanceof HTMLBodyElement) {
        document.body.replaceWith(this.newElement);
      } else {
        document.documentElement.appendChild(this.newElement);
      }
    }
    get newHeadStylesheetElements() {
      return this.newHeadSnapshot.getStylesheetElementsNotInSnapshot(this.currentHeadSnapshot);
    }
    get newHeadScriptElements() {
      return this.newHeadSnapshot.getScriptElementsNotInSnapshot(this.currentHeadSnapshot);
    }
    get currentHeadProvisionalElements() {
      return this.currentHeadSnapshot.provisionalElements;
    }
    get newHeadProvisionalElements() {
      return this.newHeadSnapshot.provisionalElements;
    }
    get newBodyScriptElements() {
      return this.newElement.querySelectorAll("script");
    }
  };
  var SnapshotCache = class {
    constructor(size) {
      this.keys = [];
      this.snapshots = {};
      this.size = size;
    }
    has(location2) {
      return toCacheKey(location2) in this.snapshots;
    }
    get(location2) {
      if (this.has(location2)) {
        const snapshot = this.read(location2);
        this.touch(location2);
        return snapshot;
      }
    }
    put(location2, snapshot) {
      this.write(location2, snapshot);
      this.touch(location2);
      return snapshot;
    }
    clear() {
      this.snapshots = {};
    }
    read(location2) {
      return this.snapshots[toCacheKey(location2)];
    }
    write(location2, snapshot) {
      this.snapshots[toCacheKey(location2)] = snapshot;
    }
    touch(location2) {
      const key = toCacheKey(location2);
      const index2 = this.keys.indexOf(key);
      if (index2 > -1)
        this.keys.splice(index2, 1);
      this.keys.unshift(key);
      this.trim();
    }
    trim() {
      for (const key of this.keys.splice(this.size)) {
        delete this.snapshots[key];
      }
    }
  };
  var PageView = class extends View {
    constructor() {
      super(...arguments);
      this.snapshotCache = new SnapshotCache(10);
      this.lastRenderedLocation = new URL(location.href);
    }
    renderPage(snapshot, isPreview = false, willRender = true) {
      const renderer = new PageRenderer(this.snapshot, snapshot, isPreview, willRender);
      return this.render(renderer);
    }
    renderError(snapshot) {
      const renderer = new ErrorRenderer(this.snapshot, snapshot, false);
      return this.render(renderer);
    }
    clearSnapshotCache() {
      this.snapshotCache.clear();
    }
    async cacheSnapshot() {
      if (this.shouldCacheSnapshot) {
        this.delegate.viewWillCacheSnapshot();
        const { snapshot, lastRenderedLocation: location2 } = this;
        await nextEventLoopTick();
        const cachedSnapshot = snapshot.clone();
        this.snapshotCache.put(location2, cachedSnapshot);
        return cachedSnapshot;
      }
    }
    getCachedSnapshotForLocation(location2) {
      return this.snapshotCache.get(location2);
    }
    get snapshot() {
      return PageSnapshot.fromElement(this.element);
    }
    get shouldCacheSnapshot() {
      return this.snapshot.isCacheable;
    }
  };
  var Session = class {
    constructor() {
      this.navigator = new Navigator(this);
      this.history = new History(this);
      this.view = new PageView(this, document.documentElement);
      this.adapter = new BrowserAdapter(this);
      this.pageObserver = new PageObserver(this);
      this.cacheObserver = new CacheObserver();
      this.linkClickObserver = new LinkClickObserver(this);
      this.formSubmitObserver = new FormSubmitObserver(this);
      this.scrollObserver = new ScrollObserver(this);
      this.streamObserver = new StreamObserver(this);
      this.frameRedirector = new FrameRedirector(document.documentElement);
      this.drive = true;
      this.enabled = true;
      this.progressBarDelay = 500;
      this.started = false;
    }
    start() {
      if (!this.started) {
        this.pageObserver.start();
        this.cacheObserver.start();
        this.linkClickObserver.start();
        this.formSubmitObserver.start();
        this.scrollObserver.start();
        this.streamObserver.start();
        this.frameRedirector.start();
        this.history.start();
        this.started = true;
        this.enabled = true;
      }
    }
    disable() {
      this.enabled = false;
    }
    stop() {
      if (this.started) {
        this.pageObserver.stop();
        this.cacheObserver.stop();
        this.linkClickObserver.stop();
        this.formSubmitObserver.stop();
        this.scrollObserver.stop();
        this.streamObserver.stop();
        this.frameRedirector.stop();
        this.history.stop();
        this.started = false;
      }
    }
    registerAdapter(adapter) {
      this.adapter = adapter;
    }
    visit(location2, options2 = {}) {
      this.navigator.proposeVisit(expandURL(location2), options2);
    }
    connectStreamSource(source) {
      this.streamObserver.connectStreamSource(source);
    }
    disconnectStreamSource(source) {
      this.streamObserver.disconnectStreamSource(source);
    }
    renderStreamMessage(message) {
      document.documentElement.appendChild(StreamMessage.wrap(message).fragment);
    }
    clearCache() {
      this.view.clearSnapshotCache();
    }
    setProgressBarDelay(delay) {
      this.progressBarDelay = delay;
    }
    get location() {
      return this.history.location;
    }
    get restorationIdentifier() {
      return this.history.restorationIdentifier;
    }
    historyPoppedToLocationWithRestorationIdentifier(location2, restorationIdentifier) {
      if (this.enabled) {
        this.navigator.startVisit(location2, restorationIdentifier, { action: "restore", historyChanged: true });
      } else {
        this.adapter.pageInvalidated();
      }
    }
    scrollPositionChanged(position) {
      this.history.updateRestorationData({ scrollPosition: position });
    }
    willFollowLinkToLocation(link, location2) {
      return this.elementDriveEnabled(link) && locationIsVisitable(location2, this.snapshot.rootLocation) && this.applicationAllowsFollowingLinkToLocation(link, location2);
    }
    followedLinkToLocation(link, location2) {
      const action = this.getActionForLink(link);
      this.convertLinkWithMethodClickToFormSubmission(link) || this.visit(location2.href, { action });
    }
    convertLinkWithMethodClickToFormSubmission(link) {
      const linkMethod = link.getAttribute("data-turbo-method");
      if (linkMethod) {
        const form = document.createElement("form");
        form.method = linkMethod;
        form.action = link.getAttribute("href") || "undefined";
        form.hidden = true;
        if (link.hasAttribute("data-turbo-confirm")) {
          form.setAttribute("data-turbo-confirm", link.getAttribute("data-turbo-confirm"));
        }
        const frame = this.getTargetFrameForLink(link);
        if (frame) {
          form.setAttribute("data-turbo-frame", frame);
          form.addEventListener("turbo:submit-start", () => form.remove());
        } else {
          form.addEventListener("submit", () => form.remove());
        }
        document.body.appendChild(form);
        return dispatch("submit", { cancelable: true, target: form });
      } else {
        return false;
      }
    }
    allowsVisitingLocationWithAction(location2, action) {
      return this.locationWithActionIsSamePage(location2, action) || this.applicationAllowsVisitingLocation(location2);
    }
    visitProposedToLocation(location2, options2) {
      extendURLWithDeprecatedProperties(location2);
      this.adapter.visitProposedToLocation(location2, options2);
    }
    visitStarted(visit2) {
      extendURLWithDeprecatedProperties(visit2.location);
      if (!visit2.silent) {
        this.notifyApplicationAfterVisitingLocation(visit2.location, visit2.action);
      }
    }
    visitCompleted(visit2) {
      this.notifyApplicationAfterPageLoad(visit2.getTimingMetrics());
    }
    locationWithActionIsSamePage(location2, action) {
      return this.navigator.locationWithActionIsSamePage(location2, action);
    }
    visitScrolledToSamePageLocation(oldURL, newURL) {
      this.notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL);
    }
    willSubmitForm(form, submitter) {
      const action = getAction(form, submitter);
      return this.elementDriveEnabled(form) && (!submitter || this.elementDriveEnabled(submitter)) && locationIsVisitable(expandURL(action), this.snapshot.rootLocation);
    }
    formSubmitted(form, submitter) {
      this.navigator.submitForm(form, submitter);
    }
    pageBecameInteractive() {
      this.view.lastRenderedLocation = this.location;
      this.notifyApplicationAfterPageLoad();
    }
    pageLoaded() {
      this.history.assumeControlOfScrollRestoration();
    }
    pageWillUnload() {
      this.history.relinquishControlOfScrollRestoration();
    }
    receivedMessageFromStream(message) {
      this.renderStreamMessage(message);
    }
    viewWillCacheSnapshot() {
      var _a;
      if (!((_a = this.navigator.currentVisit) === null || _a === void 0 ? void 0 : _a.silent)) {
        this.notifyApplicationBeforeCachingSnapshot();
      }
    }
    allowsImmediateRender({ element }, resume) {
      const event = this.notifyApplicationBeforeRender(element, resume);
      return !event.defaultPrevented;
    }
    viewRenderedSnapshot(snapshot, isPreview) {
      this.view.lastRenderedLocation = this.history.location;
      this.notifyApplicationAfterRender();
    }
    viewInvalidated() {
      this.adapter.pageInvalidated();
    }
    frameLoaded(frame) {
      this.notifyApplicationAfterFrameLoad(frame);
    }
    frameRendered(fetchResponse, frame) {
      this.notifyApplicationAfterFrameRender(fetchResponse, frame);
    }
    applicationAllowsFollowingLinkToLocation(link, location2) {
      const event = this.notifyApplicationAfterClickingLinkToLocation(link, location2);
      return !event.defaultPrevented;
    }
    applicationAllowsVisitingLocation(location2) {
      const event = this.notifyApplicationBeforeVisitingLocation(location2);
      return !event.defaultPrevented;
    }
    notifyApplicationAfterClickingLinkToLocation(link, location2) {
      return dispatch("turbo:click", { target: link, detail: { url: location2.href }, cancelable: true });
    }
    notifyApplicationBeforeVisitingLocation(location2) {
      return dispatch("turbo:before-visit", { detail: { url: location2.href }, cancelable: true });
    }
    notifyApplicationAfterVisitingLocation(location2, action) {
      markAsBusy(document.documentElement);
      return dispatch("turbo:visit", { detail: { url: location2.href, action } });
    }
    notifyApplicationBeforeCachingSnapshot() {
      return dispatch("turbo:before-cache");
    }
    notifyApplicationBeforeRender(newBody, resume) {
      return dispatch("turbo:before-render", { detail: { newBody, resume }, cancelable: true });
    }
    notifyApplicationAfterRender() {
      return dispatch("turbo:render");
    }
    notifyApplicationAfterPageLoad(timing = {}) {
      clearBusyState(document.documentElement);
      return dispatch("turbo:load", { detail: { url: this.location.href, timing } });
    }
    notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL) {
      dispatchEvent(new HashChangeEvent("hashchange", { oldURL: oldURL.toString(), newURL: newURL.toString() }));
    }
    notifyApplicationAfterFrameLoad(frame) {
      return dispatch("turbo:frame-load", { target: frame });
    }
    notifyApplicationAfterFrameRender(fetchResponse, frame) {
      return dispatch("turbo:frame-render", { detail: { fetchResponse }, target: frame, cancelable: true });
    }
    elementDriveEnabled(element) {
      const container = element === null || element === void 0 ? void 0 : element.closest("[data-turbo]");
      if (this.drive) {
        if (container) {
          return container.getAttribute("data-turbo") != "false";
        } else {
          return true;
        }
      } else {
        if (container) {
          return container.getAttribute("data-turbo") == "true";
        } else {
          return false;
        }
      }
    }
    getActionForLink(link) {
      const action = link.getAttribute("data-turbo-action");
      return isAction(action) ? action : "advance";
    }
    getTargetFrameForLink(link) {
      const frame = link.getAttribute("data-turbo-frame");
      if (frame) {
        return frame;
      } else {
        const container = link.closest("turbo-frame");
        if (container) {
          return container.id;
        }
      }
    }
    get snapshot() {
      return this.view.snapshot;
    }
  };
  function extendURLWithDeprecatedProperties(url) {
    Object.defineProperties(url, deprecatedLocationPropertyDescriptors);
  }
  var deprecatedLocationPropertyDescriptors = {
    absoluteURL: {
      get() {
        return this.toString();
      }
    }
  };
  var session = new Session();
  var { navigator: navigator$1 } = session;
  function start() {
    session.start();
  }
  function registerAdapter(adapter) {
    session.registerAdapter(adapter);
  }
  function visit(location2, options2) {
    session.visit(location2, options2);
  }
  function connectStreamSource(source) {
    session.connectStreamSource(source);
  }
  function disconnectStreamSource(source) {
    session.disconnectStreamSource(source);
  }
  function renderStreamMessage(message) {
    session.renderStreamMessage(message);
  }
  function clearCache() {
    session.clearCache();
  }
  function setProgressBarDelay(delay) {
    session.setProgressBarDelay(delay);
  }
  function setConfirmMethod(confirmMethod) {
    FormSubmission.confirmMethod = confirmMethod;
  }
  var Turbo = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    navigator: navigator$1,
    session,
    PageRenderer,
    PageSnapshot,
    start,
    registerAdapter,
    visit,
    connectStreamSource,
    disconnectStreamSource,
    renderStreamMessage,
    clearCache,
    setProgressBarDelay,
    setConfirmMethod
  });
  var FrameController = class {
    constructor(element) {
      this.fetchResponseLoaded = (fetchResponse) => {
      };
      this.currentFetchRequest = null;
      this.resolveVisitPromise = () => {
      };
      this.connected = false;
      this.hasBeenLoaded = false;
      this.settingSourceURL = false;
      this.element = element;
      this.view = new FrameView(this, this.element);
      this.appearanceObserver = new AppearanceObserver(this, this.element);
      this.linkInterceptor = new LinkInterceptor(this, this.element);
      this.formInterceptor = new FormInterceptor(this, this.element);
    }
    connect() {
      if (!this.connected) {
        this.connected = true;
        this.reloadable = false;
        if (this.loadingStyle == FrameLoadingStyle.lazy) {
          this.appearanceObserver.start();
        }
        this.linkInterceptor.start();
        this.formInterceptor.start();
        this.sourceURLChanged();
      }
    }
    disconnect() {
      if (this.connected) {
        this.connected = false;
        this.appearanceObserver.stop();
        this.linkInterceptor.stop();
        this.formInterceptor.stop();
      }
    }
    disabledChanged() {
      if (this.loadingStyle == FrameLoadingStyle.eager) {
        this.loadSourceURL();
      }
    }
    sourceURLChanged() {
      if (this.loadingStyle == FrameLoadingStyle.eager || this.hasBeenLoaded) {
        this.loadSourceURL();
      }
    }
    loadingStyleChanged() {
      if (this.loadingStyle == FrameLoadingStyle.lazy) {
        this.appearanceObserver.start();
      } else {
        this.appearanceObserver.stop();
        this.loadSourceURL();
      }
    }
    async loadSourceURL() {
      if (!this.settingSourceURL && this.enabled && this.isActive && (this.reloadable || this.sourceURL != this.currentURL)) {
        const previousURL = this.currentURL;
        this.currentURL = this.sourceURL;
        if (this.sourceURL) {
          try {
            this.element.loaded = this.visit(expandURL(this.sourceURL));
            this.appearanceObserver.stop();
            await this.element.loaded;
            this.hasBeenLoaded = true;
          } catch (error2) {
            this.currentURL = previousURL;
            throw error2;
          }
        }
      }
    }
    async loadResponse(fetchResponse) {
      if (fetchResponse.redirected || fetchResponse.succeeded && fetchResponse.isHTML) {
        this.sourceURL = fetchResponse.response.url;
      }
      try {
        const html = await fetchResponse.responseHTML;
        if (html) {
          const { body } = parseHTMLDocument(html);
          const snapshot = new Snapshot(await this.extractForeignFrameElement(body));
          const renderer = new FrameRenderer(this.view.snapshot, snapshot, false, false);
          if (this.view.renderPromise)
            await this.view.renderPromise;
          await this.view.render(renderer);
          session.frameRendered(fetchResponse, this.element);
          session.frameLoaded(this.element);
          this.fetchResponseLoaded(fetchResponse);
        }
      } catch (error2) {
        console.error(error2);
        this.view.invalidate();
      } finally {
        this.fetchResponseLoaded = () => {
        };
      }
    }
    elementAppearedInViewport(element) {
      this.loadSourceURL();
    }
    shouldInterceptLinkClick(element, url) {
      if (element.hasAttribute("data-turbo-method")) {
        return false;
      } else {
        return this.shouldInterceptNavigation(element);
      }
    }
    linkClickIntercepted(element, url) {
      this.reloadable = true;
      this.navigateFrame(element, url);
    }
    shouldInterceptFormSubmission(element, submitter) {
      return this.shouldInterceptNavigation(element, submitter);
    }
    formSubmissionIntercepted(element, submitter) {
      if (this.formSubmission) {
        this.formSubmission.stop();
      }
      this.reloadable = false;
      this.formSubmission = new FormSubmission(this, element, submitter);
      const { fetchRequest } = this.formSubmission;
      this.prepareHeadersForRequest(fetchRequest.headers, fetchRequest);
      this.formSubmission.start();
    }
    prepareHeadersForRequest(headers, request) {
      headers["Turbo-Frame"] = this.id;
    }
    requestStarted(request) {
      markAsBusy(this.element);
    }
    requestPreventedHandlingResponse(request, response) {
      this.resolveVisitPromise();
    }
    async requestSucceededWithResponse(request, response) {
      await this.loadResponse(response);
      this.resolveVisitPromise();
    }
    requestFailedWithResponse(request, response) {
      console.error(response);
      this.resolveVisitPromise();
    }
    requestErrored(request, error2) {
      console.error(error2);
      this.resolveVisitPromise();
    }
    requestFinished(request) {
      clearBusyState(this.element);
    }
    formSubmissionStarted({ formElement }) {
      markAsBusy(formElement, this.findFrameElement(formElement));
    }
    formSubmissionSucceededWithResponse(formSubmission, response) {
      const frame = this.findFrameElement(formSubmission.formElement, formSubmission.submitter);
      this.proposeVisitIfNavigatedWithAction(frame, formSubmission.formElement, formSubmission.submitter);
      frame.delegate.loadResponse(response);
    }
    formSubmissionFailedWithResponse(formSubmission, fetchResponse) {
      this.element.delegate.loadResponse(fetchResponse);
    }
    formSubmissionErrored(formSubmission, error2) {
      console.error(error2);
    }
    formSubmissionFinished({ formElement }) {
      clearBusyState(formElement, this.findFrameElement(formElement));
    }
    allowsImmediateRender(snapshot, resume) {
      return true;
    }
    viewRenderedSnapshot(snapshot, isPreview) {
    }
    viewInvalidated() {
    }
    async visit(url) {
      var _a;
      const request = new FetchRequest(this, FetchMethod.get, url, new URLSearchParams(), this.element);
      (_a = this.currentFetchRequest) === null || _a === void 0 ? void 0 : _a.cancel();
      this.currentFetchRequest = request;
      return new Promise((resolve2) => {
        this.resolveVisitPromise = () => {
          this.resolveVisitPromise = () => {
          };
          this.currentFetchRequest = null;
          resolve2();
        };
        request.perform();
      });
    }
    navigateFrame(element, url, submitter) {
      const frame = this.findFrameElement(element, submitter);
      this.proposeVisitIfNavigatedWithAction(frame, element, submitter);
      frame.setAttribute("reloadable", "");
      frame.src = url;
    }
    proposeVisitIfNavigatedWithAction(frame, element, submitter) {
      const action = getAttribute("data-turbo-action", submitter, element, frame);
      if (isAction(action)) {
        const { visitCachedSnapshot } = new SnapshotSubstitution(frame);
        frame.delegate.fetchResponseLoaded = (fetchResponse) => {
          if (frame.src) {
            const { statusCode, redirected } = fetchResponse;
            const responseHTML = frame.ownerDocument.documentElement.outerHTML;
            const response = { statusCode, redirected, responseHTML };
            session.visit(frame.src, { action, response, visitCachedSnapshot, willRender: false });
          }
        };
      }
    }
    findFrameElement(element, submitter) {
      var _a;
      const id = getAttribute("data-turbo-frame", submitter, element) || this.element.getAttribute("target");
      return (_a = getFrameElementById(id)) !== null && _a !== void 0 ? _a : this.element;
    }
    async extractForeignFrameElement(container) {
      let element;
      const id = CSS.escape(this.id);
      try {
        if (element = activateElement(container.querySelector(`turbo-frame#${id}`), this.currentURL)) {
          return element;
        }
        if (element = activateElement(container.querySelector(`turbo-frame[src][recurse~=${id}]`), this.currentURL)) {
          await element.loaded;
          return await this.extractForeignFrameElement(element);
        }
        console.error(`Response has no matching <turbo-frame id="${id}"> element`);
      } catch (error2) {
        console.error(error2);
      }
      return new FrameElement();
    }
    formActionIsVisitable(form, submitter) {
      const action = getAction(form, submitter);
      return locationIsVisitable(expandURL(action), this.rootLocation);
    }
    shouldInterceptNavigation(element, submitter) {
      const id = getAttribute("data-turbo-frame", submitter, element) || this.element.getAttribute("target");
      if (element instanceof HTMLFormElement && !this.formActionIsVisitable(element, submitter)) {
        return false;
      }
      if (!this.enabled || id == "_top") {
        return false;
      }
      if (id) {
        const frameElement = getFrameElementById(id);
        if (frameElement) {
          return !frameElement.disabled;
        }
      }
      if (!session.elementDriveEnabled(element)) {
        return false;
      }
      if (submitter && !session.elementDriveEnabled(submitter)) {
        return false;
      }
      return true;
    }
    get id() {
      return this.element.id;
    }
    get enabled() {
      return !this.element.disabled;
    }
    get sourceURL() {
      if (this.element.src) {
        return this.element.src;
      }
    }
    get reloadable() {
      const frame = this.findFrameElement(this.element);
      return frame.hasAttribute("reloadable");
    }
    set reloadable(value) {
      const frame = this.findFrameElement(this.element);
      if (value) {
        frame.setAttribute("reloadable", "");
      } else {
        frame.removeAttribute("reloadable");
      }
    }
    set sourceURL(sourceURL) {
      this.settingSourceURL = true;
      this.element.src = sourceURL !== null && sourceURL !== void 0 ? sourceURL : null;
      this.currentURL = this.element.src;
      this.settingSourceURL = false;
    }
    get loadingStyle() {
      return this.element.loading;
    }
    get isLoading() {
      return this.formSubmission !== void 0 || this.resolveVisitPromise() !== void 0;
    }
    get isActive() {
      return this.element.isActive && this.connected;
    }
    get rootLocation() {
      var _a;
      const meta = this.element.ownerDocument.querySelector(`meta[name="turbo-root"]`);
      const root = (_a = meta === null || meta === void 0 ? void 0 : meta.content) !== null && _a !== void 0 ? _a : "/";
      return expandURL(root);
    }
  };
  var SnapshotSubstitution = class {
    constructor(element) {
      this.visitCachedSnapshot = ({ element: element2 }) => {
        var _a;
        const { id, clone: clone3 } = this;
        (_a = element2.querySelector("#" + id)) === null || _a === void 0 ? void 0 : _a.replaceWith(clone3);
      };
      this.clone = element.cloneNode(true);
      this.id = element.id;
    }
  };
  function getFrameElementById(id) {
    if (id != null) {
      const element = document.getElementById(id);
      if (element instanceof FrameElement) {
        return element;
      }
    }
  }
  function activateElement(element, currentURL) {
    if (element) {
      const src = element.getAttribute("src");
      if (src != null && currentURL != null && urlsAreEqual(src, currentURL)) {
        throw new Error(`Matching <turbo-frame id="${element.id}"> element has a source URL which references itself`);
      }
      if (element.ownerDocument !== document) {
        element = document.importNode(element, true);
      }
      if (element instanceof FrameElement) {
        element.connectedCallback();
        element.disconnectedCallback();
        return element;
      }
    }
  }
  var StreamActions = {
    after() {
      this.targetElements.forEach((e3) => {
        var _a;
        return (_a = e3.parentElement) === null || _a === void 0 ? void 0 : _a.insertBefore(this.templateContent, e3.nextSibling);
      });
    },
    append() {
      this.removeDuplicateTargetChildren();
      this.targetElements.forEach((e3) => e3.append(this.templateContent));
    },
    before() {
      this.targetElements.forEach((e3) => {
        var _a;
        return (_a = e3.parentElement) === null || _a === void 0 ? void 0 : _a.insertBefore(this.templateContent, e3);
      });
    },
    prepend() {
      this.removeDuplicateTargetChildren();
      this.targetElements.forEach((e3) => e3.prepend(this.templateContent));
    },
    remove() {
      this.targetElements.forEach((e3) => e3.remove());
    },
    replace() {
      this.targetElements.forEach((e3) => e3.replaceWith(this.templateContent));
    },
    update() {
      this.targetElements.forEach((e3) => {
        e3.innerHTML = "";
        e3.append(this.templateContent);
      });
    }
  };
  var StreamElement = class extends HTMLElement {
    async connectedCallback() {
      try {
        await this.render();
      } catch (error2) {
        console.error(error2);
      } finally {
        this.disconnect();
      }
    }
    async render() {
      var _a;
      return (_a = this.renderPromise) !== null && _a !== void 0 ? _a : this.renderPromise = (async () => {
        if (this.dispatchEvent(this.beforeRenderEvent)) {
          await nextAnimationFrame();
          this.performAction();
        }
      })();
    }
    disconnect() {
      try {
        this.remove();
      } catch (_a) {
      }
    }
    removeDuplicateTargetChildren() {
      this.duplicateChildren.forEach((c2) => c2.remove());
    }
    get duplicateChildren() {
      var _a;
      const existingChildren = this.targetElements.flatMap((e3) => [...e3.children]).filter((c2) => !!c2.id);
      const newChildrenIds = [...(_a = this.templateContent) === null || _a === void 0 ? void 0 : _a.children].filter((c2) => !!c2.id).map((c2) => c2.id);
      return existingChildren.filter((c2) => newChildrenIds.includes(c2.id));
    }
    get performAction() {
      if (this.action) {
        const actionFunction = StreamActions[this.action];
        if (actionFunction) {
          return actionFunction;
        }
        this.raise("unknown action");
      }
      this.raise("action attribute is missing");
    }
    get targetElements() {
      if (this.target) {
        return this.targetElementsById;
      } else if (this.targets) {
        return this.targetElementsByQuery;
      } else {
        this.raise("target or targets attribute is missing");
      }
    }
    get templateContent() {
      return this.templateElement.content.cloneNode(true);
    }
    get templateElement() {
      if (this.firstElementChild instanceof HTMLTemplateElement) {
        return this.firstElementChild;
      }
      this.raise("first child element must be a <template> element");
    }
    get action() {
      return this.getAttribute("action");
    }
    get target() {
      return this.getAttribute("target");
    }
    get targets() {
      return this.getAttribute("targets");
    }
    raise(message) {
      throw new Error(`${this.description}: ${message}`);
    }
    get description() {
      var _a, _b;
      return (_b = ((_a = this.outerHTML.match(/<[^>]+>/)) !== null && _a !== void 0 ? _a : [])[0]) !== null && _b !== void 0 ? _b : "<turbo-stream>";
    }
    get beforeRenderEvent() {
      return new CustomEvent("turbo:before-stream-render", { bubbles: true, cancelable: true });
    }
    get targetElementsById() {
      var _a;
      const element = (_a = this.ownerDocument) === null || _a === void 0 ? void 0 : _a.getElementById(this.target);
      if (element !== null) {
        return [element];
      } else {
        return [];
      }
    }
    get targetElementsByQuery() {
      var _a;
      const elements3 = (_a = this.ownerDocument) === null || _a === void 0 ? void 0 : _a.querySelectorAll(this.targets);
      if (elements3.length !== 0) {
        return Array.prototype.slice.call(elements3);
      } else {
        return [];
      }
    }
  };
  FrameElement.delegateConstructor = FrameController;
  customElements.define("turbo-frame", FrameElement);
  customElements.define("turbo-stream", StreamElement);
  (() => {
    let element = document.currentScript;
    if (!element)
      return;
    if (element.hasAttribute("data-turbo-suppress-warning"))
      return;
    while (element = element.parentElement) {
      if (element == document.body) {
        return console.warn(unindent`
        You are loading Turbo from a <script> element inside the <body> element. This is probably not what you meant to do!

        Load your applications JavaScript bundle inside the <head> element instead. <script> elements in <body> are evaluated with each page change.

        For more information, see: https://turbo.hotwired.dev/handbook/building#working-with-script-elements

        
        Suppress this warning by adding a "data-turbo-suppress-warning" attribute to: %s
      `, element.outerHTML);
      }
    }
  })();
  window.Turbo = Turbo;
  start();

  // ../../node_modules/@hotwired/turbo-rails/app/javascript/turbo/cable.js
  var consumer;
  async function getConsumer() {
    return consumer || setConsumer(createConsumer2().then(setConsumer));
  }
  function setConsumer(newConsumer) {
    return consumer = newConsumer;
  }
  async function createConsumer2() {
    const { createConsumer: createConsumer4 } = await Promise.resolve().then(() => (init_src(), src_exports));
    return createConsumer4();
  }
  async function subscribeTo(channel, mixin) {
    const { subscriptions } = await getConsumer();
    return subscriptions.create(channel, mixin);
  }

  // ../../node_modules/@hotwired/turbo-rails/app/javascript/turbo/cable_stream_source_element.js
  var TurboCableStreamSourceElement = class extends HTMLElement {
    async connectedCallback() {
      connectStreamSource(this);
      this.subscription = await subscribeTo(this.channel, { received: this.dispatchMessageEvent.bind(this) });
    }
    disconnectedCallback() {
      disconnectStreamSource(this);
      if (this.subscription)
        this.subscription.unsubscribe();
    }
    dispatchMessageEvent(data) {
      const event = new MessageEvent("message", { data });
      return this.dispatchEvent(event);
    }
    get channel() {
      const channel = this.getAttribute("channel");
      const signed_stream_name = this.getAttribute("signed-stream-name");
      return { channel, signed_stream_name };
    }
  };
  customElements.define("turbo-cable-stream-source", TurboCableStreamSourceElement);

  // ../../node_modules/chartkick/dist/chartkick.esm.js
  function isArray(variable) {
    return Object.prototype.toString.call(variable) === "[object Array]";
  }
  function isFunction(variable) {
    return variable instanceof Function;
  }
  function isPlainObject(variable) {
    return Object.prototype.toString.call(variable) === "[object Object]" && !isFunction(variable) && variable instanceof Object;
  }
  function extend2(target, source) {
    for (var key in source) {
      if (key === "__proto__") {
        continue;
      }
      if (isPlainObject(source[key]) || isArray(source[key])) {
        if (isPlainObject(source[key]) && !isPlainObject(target[key])) {
          target[key] = {};
        }
        if (isArray(source[key]) && !isArray(target[key])) {
          target[key] = [];
        }
        extend2(target[key], source[key]);
      } else if (source[key] !== void 0) {
        target[key] = source[key];
      }
    }
  }
  function merge(obj1, obj2) {
    var target = {};
    extend2(target, obj1);
    extend2(target, obj2);
    return target;
  }
  var DATE_PATTERN = /^(\d\d\d\d)(?:-)?(\d\d)(?:-)?(\d\d)$/i;
  function negativeValues(series) {
    for (var i3 = 0; i3 < series.length; i3++) {
      var data = series[i3].data;
      for (var j = 0; j < data.length; j++) {
        if (data[j][1] < 0) {
          return true;
        }
      }
    }
    return false;
  }
  function toStr(obj) {
    return "" + obj;
  }
  function toFloat(obj) {
    return parseFloat(obj);
  }
  function toDate(obj) {
    if (obj instanceof Date) {
      return obj;
    } else if (typeof obj === "number") {
      return new Date(obj * 1e3);
    } else {
      var s4 = toStr(obj);
      var matches = s4.match(DATE_PATTERN);
      if (matches) {
        var year = parseInt(matches[1], 10);
        var month = parseInt(matches[2], 10) - 1;
        var day = parseInt(matches[3], 10);
        return new Date(year, month, day);
      } else {
        var str = s4.replace(/ /, "T").replace(" ", "").replace("UTC", "Z");
        return new Date(Date.parse(str) || s4);
      }
    }
  }
  function toArr(obj) {
    if (isArray(obj)) {
      return obj;
    } else {
      var arr = [];
      for (var i3 in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, i3)) {
          arr.push([i3, obj[i3]]);
        }
      }
      return arr;
    }
  }
  function jsOptionsFunc(defaultOptions4, hideLegend2, setTitle2, setMin2, setMax2, setStacked2, setXtitle2, setYtitle2) {
    return function(chart, opts, chartOptions) {
      var series = chart.data;
      var options2 = merge({}, defaultOptions4);
      options2 = merge(options2, chartOptions || {});
      if (chart.singleSeriesFormat || "legend" in opts) {
        hideLegend2(options2, opts.legend, chart.singleSeriesFormat);
      }
      if (opts.title) {
        setTitle2(options2, opts.title);
      }
      if ("min" in opts) {
        setMin2(options2, opts.min);
      } else if (!negativeValues(series)) {
        setMin2(options2, 0);
      }
      if (opts.max) {
        setMax2(options2, opts.max);
      }
      if ("stacked" in opts) {
        setStacked2(options2, opts.stacked);
      }
      if (opts.colors) {
        options2.colors = opts.colors;
      }
      if (opts.xtitle) {
        setXtitle2(options2, opts.xtitle);
      }
      if (opts.ytitle) {
        setYtitle2(options2, opts.ytitle);
      }
      options2 = merge(options2, opts.library || {});
      return options2;
    };
  }
  function sortByTime(a4, b2) {
    return a4[0].getTime() - b2[0].getTime();
  }
  function sortByNumberSeries(a4, b2) {
    return a4[0] - b2[0];
  }
  function sortByNumber(a4, b2) {
    return a4 - b2;
  }
  function every(values, fn2) {
    for (var i3 = 0; i3 < values.length; i3++) {
      if (!fn2(values[i3])) {
        return false;
      }
    }
    return true;
  }
  function isDay(timeUnit) {
    return timeUnit === "day" || timeUnit === "week" || timeUnit === "month" || timeUnit === "year";
  }
  function calculateTimeUnit(values, maxDay) {
    if (maxDay === void 0)
      maxDay = false;
    if (values.length === 0) {
      return null;
    }
    var minute = every(values, function(d3) {
      return d3.getMilliseconds() === 0 && d3.getSeconds() === 0;
    });
    if (!minute) {
      return null;
    }
    var hour = every(values, function(d3) {
      return d3.getMinutes() === 0;
    });
    if (!hour) {
      return "minute";
    }
    var day = every(values, function(d3) {
      return d3.getHours() === 0;
    });
    if (!day) {
      return "hour";
    }
    if (maxDay) {
      return "day";
    }
    var month = every(values, function(d3) {
      return d3.getDate() === 1;
    });
    if (!month) {
      var dayOfWeek = values[0].getDay();
      var week = every(values, function(d3) {
        return d3.getDay() === dayOfWeek;
      });
      return week ? "week" : "day";
    }
    var year = every(values, function(d3) {
      return d3.getMonth() === 0;
    });
    if (!year) {
      return "month";
    }
    return "year";
  }
  function isDate(obj) {
    return !isNaN(toDate(obj)) && toStr(obj).length >= 6;
  }
  function isNumber(obj) {
    return typeof obj === "number";
  }
  var byteSuffixes = ["bytes", "KB", "MB", "GB", "TB", "PB", "EB"];
  function formatValue(pre, value, options2, axis) {
    pre = pre || "";
    if (options2.prefix) {
      if (value < 0) {
        value = value * -1;
        pre += "-";
      }
      pre += options2.prefix;
    }
    var suffix = options2.suffix || "";
    var precision = options2.precision;
    var round3 = options2.round;
    if (options2.byteScale) {
      var positive = value >= 0;
      if (!positive) {
        value *= -1;
      }
      var baseValue = axis ? options2.byteScale : value;
      var suffixIdx;
      if (baseValue >= 1152921504606847e3) {
        value /= 1152921504606847e3;
        suffixIdx = 6;
      } else if (baseValue >= 1125899906842624) {
        value /= 1125899906842624;
        suffixIdx = 5;
      } else if (baseValue >= 1099511627776) {
        value /= 1099511627776;
        suffixIdx = 4;
      } else if (baseValue >= 1073741824) {
        value /= 1073741824;
        suffixIdx = 3;
      } else if (baseValue >= 1048576) {
        value /= 1048576;
        suffixIdx = 2;
      } else if (baseValue >= 1024) {
        value /= 1024;
        suffixIdx = 1;
      } else {
        suffixIdx = 0;
      }
      if (precision === void 0 && round3 === void 0) {
        if (value >= 1023.5) {
          if (suffixIdx < byteSuffixes.length - 1) {
            value = 1;
            suffixIdx += 1;
          }
        }
        precision = value >= 1e3 ? 4 : 3;
      }
      suffix = " " + byteSuffixes[suffixIdx];
      if (!positive) {
        value *= -1;
      }
    }
    if (precision !== void 0 && round3 !== void 0) {
      throw Error("Use either round or precision, not both");
    }
    if (!axis) {
      if (precision !== void 0) {
        value = value.toPrecision(precision);
        if (!options2.zeros) {
          value = parseFloat(value);
        }
      }
      if (round3 !== void 0) {
        if (round3 < 0) {
          var num = Math.pow(10, -1 * round3);
          value = parseInt((1 * value / num).toFixed(0)) * num;
        } else {
          value = value.toFixed(round3);
          if (!options2.zeros) {
            value = parseFloat(value);
          }
        }
      }
    }
    if (options2.thousands || options2.decimal) {
      value = toStr(value);
      var parts = value.split(".");
      value = parts[0];
      if (options2.thousands) {
        value = value.replace(/\B(?=(\d{3})+(?!\d))/g, options2.thousands);
      }
      if (parts.length > 1) {
        value += (options2.decimal || ".") + parts[1];
      }
    }
    return pre + value + suffix;
  }
  function seriesOption(chart, series, option) {
    if (option in series) {
      return series[option];
    } else if (option in chart.options) {
      return chart.options[option];
    }
    return null;
  }
  var baseOptions = {
    maintainAspectRatio: false,
    animation: false,
    plugins: {
      legend: {},
      tooltip: {
        displayColors: false,
        callbacks: {}
      },
      title: {
        font: {
          size: 20
        },
        color: "#333"
      }
    },
    interaction: {}
  };
  var defaultOptions$2 = {
    scales: {
      y: {
        ticks: {
          maxTicksLimit: 4
        },
        title: {
          font: {
            size: 16
          },
          color: "#333"
        },
        grid: {}
      },
      x: {
        grid: {
          drawOnChartArea: false
        },
        title: {
          font: {
            size: 16
          },
          color: "#333"
        },
        time: {},
        ticks: {}
      }
    }
  };
  var defaultColors = [
    "#3366CC",
    "#DC3912",
    "#FF9900",
    "#109618",
    "#990099",
    "#3B3EAC",
    "#0099C6",
    "#DD4477",
    "#66AA00",
    "#B82E2E",
    "#316395",
    "#994499",
    "#22AA99",
    "#AAAA11",
    "#6633CC",
    "#E67300",
    "#8B0707",
    "#329262",
    "#5574A6",
    "#651067"
  ];
  function hideLegend$2(options2, legend, hideLegend2) {
    if (legend !== void 0) {
      options2.plugins.legend.display = !!legend;
      if (legend && legend !== true) {
        options2.plugins.legend.position = legend;
      }
    } else if (hideLegend2) {
      options2.plugins.legend.display = false;
    }
  }
  function setTitle$2(options2, title) {
    options2.plugins.title.display = true;
    options2.plugins.title.text = title;
  }
  function setMin$2(options2, min2) {
    if (min2 !== null) {
      options2.scales.y.min = toFloat(min2);
    }
  }
  function setMax$2(options2, max2) {
    options2.scales.y.max = toFloat(max2);
  }
  function setBarMin$1(options2, min2) {
    if (min2 !== null) {
      options2.scales.x.min = toFloat(min2);
    }
  }
  function setBarMax$1(options2, max2) {
    options2.scales.x.max = toFloat(max2);
  }
  function setStacked$2(options2, stacked) {
    options2.scales.x.stacked = !!stacked;
    options2.scales.y.stacked = !!stacked;
  }
  function setXtitle$2(options2, title) {
    options2.scales.x.title.display = true;
    options2.scales.x.title.text = title;
  }
  function setYtitle$2(options2, title) {
    options2.scales.y.title.display = true;
    options2.scales.y.title.text = title;
  }
  function addOpacity(hex2, opacity) {
    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex2);
    return result ? "rgba(" + parseInt(result[1], 16) + ", " + parseInt(result[2], 16) + ", " + parseInt(result[3], 16) + ", " + opacity + ")" : hex2;
  }
  function notnull(x2) {
    return x2 !== null && x2 !== void 0;
  }
  function setLabelSize(chart, data, options2) {
    var maxLabelSize = Math.ceil(chart.element.offsetWidth / 4 / data.labels.length);
    if (maxLabelSize > 25) {
      maxLabelSize = 25;
    } else if (maxLabelSize < 10) {
      maxLabelSize = 10;
    }
    if (!options2.scales.x.ticks.callback) {
      options2.scales.x.ticks.callback = function(value) {
        value = toStr(this.getLabelForValue(value));
        if (value.length > maxLabelSize) {
          return value.substring(0, maxLabelSize - 2) + "...";
        } else {
          return value;
        }
      };
    }
  }
  function calculateScale(series) {
    var scale = 1;
    var max2 = maxAbsY(series);
    while (max2 >= 1024) {
      scale *= 1024;
      max2 /= 1024;
    }
    return scale;
  }
  function setFormatOptions$1(chart, options2, chartType) {
    var numericOptions = {
      thousands: chart.options.thousands,
      decimal: chart.options.decimal
    };
    var formatOptions = merge({
      prefix: chart.options.prefix,
      suffix: chart.options.suffix,
      precision: chart.options.precision,
      round: chart.options.round,
      zeros: chart.options.zeros
    }, numericOptions);
    if (chart.options.bytes) {
      var series = chart.data;
      if (chartType === "pie") {
        series = [{ data: series }];
      }
      formatOptions.byteScale = calculateScale(series);
    }
    if (chartType !== "pie") {
      var axis = options2.scales.y;
      if (chartType === "bar") {
        axis = options2.scales.x;
      }
      if (formatOptions.byteScale) {
        if (!axis.ticks.stepSize) {
          axis.ticks.stepSize = formatOptions.byteScale / 2;
        }
        if (!axis.ticks.maxTicksLimit) {
          axis.ticks.maxTicksLimit = 4;
        }
      }
      if (!axis.ticks.callback) {
        axis.ticks.callback = function(value) {
          return formatValue("", value, formatOptions, true);
        };
      }
      if ((chartType === "scatter" || chartType === "bubble") && !options2.scales.x.ticks.callback) {
        options2.scales.x.ticks.callback = function(value) {
          return formatValue("", value, numericOptions, true);
        };
      }
    }
    if (!options2.plugins.tooltip.callbacks.label) {
      if (chartType === "scatter") {
        options2.plugins.tooltip.callbacks.label = function(context) {
          var label = context.dataset.label || "";
          if (label) {
            label += ": ";
          }
          var dataPoint = context.parsed;
          return label + "(" + formatValue("", dataPoint.x, numericOptions) + ", " + formatValue("", dataPoint.y, formatOptions) + ")";
        };
      } else if (chartType === "bubble") {
        options2.plugins.tooltip.callbacks.label = function(context) {
          var label = context.dataset.label || "";
          if (label) {
            label += ": ";
          }
          var dataPoint = context.raw;
          return label + "(" + formatValue("", dataPoint.x, numericOptions) + ", " + formatValue("", dataPoint.y, formatOptions) + ", " + formatValue("", dataPoint.v, numericOptions) + ")";
        };
      } else if (chartType === "pie") {
        options2.plugins.tooltip.callbacks.label = function(context) {
          return formatValue("", context.parsed, formatOptions);
        };
      } else {
        var valueLabel = chartType === "bar" ? "x" : "y";
        options2.plugins.tooltip.callbacks.label = function(context) {
          if (context.parsed[valueLabel] === null) {
            return;
          }
          var label = context.dataset.label || "";
          if (label) {
            label += ": ";
          }
          return formatValue(label, context.parsed[valueLabel], formatOptions);
        };
      }
    }
    if ((chartType === "line" || chartType === "area") && chart.xtype === "number") {
      if (!options2.scales.x.ticks.callback) {
        options2.scales.x.ticks.callback = function(value) {
          return toStr(value);
        };
      }
      if (!options2.plugins.tooltip.callbacks.title) {
        options2.plugins.tooltip.callbacks.title = function(context) {
          return toStr(context[0].parsed.x);
        };
      }
    }
  }
  function maxAbsY(series) {
    var max2 = 0;
    for (var i3 = 0; i3 < series.length; i3++) {
      var data = series[i3].data;
      for (var j = 0; j < data.length; j++) {
        var v = Math.abs(data[j][1]);
        if (v > max2) {
          max2 = v;
        }
      }
    }
    return max2;
  }
  function maxR(series) {
    var max2 = 0;
    for (var i3 = 0; i3 < series.length; i3++) {
      var data = series[i3].data;
      for (var j = 0; j < data.length; j++) {
        var v = data[j][2];
        if (v > max2) {
          max2 = v;
        }
      }
    }
    return max2;
  }
  var jsOptions$2 = jsOptionsFunc(merge(baseOptions, defaultOptions$2), hideLegend$2, setTitle$2, setMin$2, setMax$2, setStacked$2, setXtitle$2, setYtitle$2);
  function prepareDefaultData(chart) {
    var series = chart.data;
    var rows = {};
    var keys = [];
    var labels = [];
    var values = [];
    for (var i3 = 0; i3 < series.length; i3++) {
      var data = series[i3].data;
      for (var j = 0; j < data.length; j++) {
        var d3 = data[j];
        var key = chart.xtype === "datetime" ? d3[0].getTime() : d3[0];
        if (!rows[key]) {
          rows[key] = new Array(series.length);
          keys.push(key);
        }
        rows[key][i3] = d3[1];
      }
    }
    if (chart.xtype === "datetime" || chart.xtype === "number") {
      keys.sort(sortByNumber);
    }
    for (var i$1 = 0; i$1 < series.length; i$1++) {
      values.push([]);
    }
    for (var i$2 = 0; i$2 < keys.length; i$2++) {
      var key$1 = keys[i$2];
      var label = chart.xtype === "datetime" ? new Date(key$1) : key$1;
      labels.push(label);
      var row = rows[key$1];
      for (var j$1 = 0; j$1 < series.length; j$1++) {
        var v = row[j$1];
        values[j$1].push(v === void 0 ? null : v);
      }
    }
    return {
      labels,
      values
    };
  }
  function prepareBubbleData(chart) {
    var series = chart.data;
    var values = [];
    var max2 = maxR(series);
    for (var i3 = 0; i3 < series.length; i3++) {
      var data = series[i3].data;
      var points = [];
      for (var j = 0; j < data.length; j++) {
        var v = data[j];
        points.push({
          x: v[0],
          y: v[1],
          r: v[2] * 20 / max2,
          v: v[2]
        });
      }
      values.push(points);
    }
    return {
      labels: [],
      values
    };
  }
  function prepareNumberData(chart) {
    var series = chart.data;
    var values = [];
    for (var i3 = 0; i3 < series.length; i3++) {
      var data = series[i3].data;
      data.sort(sortByNumberSeries);
      var points = [];
      for (var j = 0; j < data.length; j++) {
        var v = data[j];
        points.push({
          x: v[0],
          y: v[1]
        });
      }
      values.push(points);
    }
    return {
      labels: [],
      values
    };
  }
  function prepareData(chart, chartType) {
    if (chartType === "bubble") {
      return prepareBubbleData(chart);
    } else if (chart.xtype === "number" && chartType !== "bar" && chartType !== "column") {
      return prepareNumberData(chart);
    } else {
      return prepareDefaultData(chart);
    }
  }
  function createDataTable(chart, options2, chartType) {
    var ref = prepareData(chart, chartType);
    var labels = ref.labels;
    var values = ref.values;
    var series = chart.data;
    var datasets = [];
    var colors2 = chart.options.colors || defaultColors;
    for (var i3 = 0; i3 < series.length; i3++) {
      var s4 = series[i3];
      var color2 = void 0;
      var backgroundColor = void 0;
      if (chart.options.colors && chart.singleSeriesFormat && (chartType === "bar" || chartType === "column") && !s4.color && isArray(chart.options.colors) && !isArray(chart.options.colors[0])) {
        color2 = colors2;
        backgroundColor = [];
        for (var j = 0; j < colors2.length; j++) {
          backgroundColor[j] = addOpacity(color2[j], 0.5);
        }
      } else {
        color2 = s4.color || colors2[i3];
        backgroundColor = chartType !== "line" ? addOpacity(color2, 0.5) : color2;
      }
      var dataset = {
        label: s4.name || "",
        data: values[i3],
        fill: chartType === "area",
        borderColor: color2,
        backgroundColor,
        borderWidth: 2
      };
      var pointChart = chartType === "line" || chartType === "area" || chartType === "scatter" || chartType === "bubble";
      if (pointChart) {
        dataset.pointBackgroundColor = color2;
        dataset.pointHoverBackgroundColor = color2;
        dataset.pointHitRadius = 50;
      }
      if (chartType === "bubble") {
        dataset.pointBackgroundColor = backgroundColor;
        dataset.pointHoverBackgroundColor = backgroundColor;
        dataset.pointHoverBorderWidth = 2;
      }
      if (s4.stack) {
        dataset.stack = s4.stack;
      }
      var curve = seriesOption(chart, s4, "curve");
      if (curve === false) {
        dataset.tension = 0;
      } else if (pointChart) {
        dataset.tension = 0.4;
      }
      var points = seriesOption(chart, s4, "points");
      if (points === false) {
        dataset.pointRadius = 0;
        dataset.pointHoverRadius = 0;
      }
      dataset = merge(dataset, chart.options.dataset || {});
      dataset = merge(dataset, s4.library || {});
      dataset = merge(dataset, s4.dataset || {});
      datasets.push(dataset);
    }
    var xmin = chart.options.xmin;
    var xmax = chart.options.xmax;
    if (chart.xtype === "datetime") {
      if (notnull(xmin)) {
        options2.scales.x.min = toDate(xmin).getTime();
      }
      if (notnull(xmax)) {
        options2.scales.x.max = toDate(xmax).getTime();
      }
    } else if (chart.xtype === "number") {
      if (notnull(xmin)) {
        options2.scales.x.min = xmin;
      }
      if (notnull(xmax)) {
        options2.scales.x.max = xmax;
      }
    }
    if (chart.xtype === "datetime") {
      var timeUnit = calculateTimeUnit(labels);
      if (labels.length === 0) {
        if (notnull(xmin)) {
          labels.push(toDate(xmin));
        }
        if (notnull(xmax)) {
          labels.push(toDate(xmax));
        }
      }
      if (labels.length > 0) {
        var minTime2 = (notnull(xmin) ? toDate(xmin) : labels[0]).getTime();
        var maxTime2 = (notnull(xmax) ? toDate(xmax) : labels[0]).getTime();
        for (var i$1 = 1; i$1 < labels.length; i$1++) {
          var value = labels[i$1].getTime();
          if (value < minTime2) {
            minTime2 = value;
          }
          if (value > maxTime2) {
            maxTime2 = value;
          }
        }
        var timeDiff = (maxTime2 - minTime2) / (86400 * 1e3);
        if (!options2.scales.x.time.unit) {
          var step;
          if (timeUnit === "year" || timeDiff > 365 * 10) {
            options2.scales.x.time.unit = "year";
            step = 365;
          } else if (timeUnit === "month" || timeDiff > 30 * 10) {
            options2.scales.x.time.unit = "month";
            step = 30;
          } else if (timeUnit === "week" || timeUnit === "day" || timeDiff > 10) {
            options2.scales.x.time.unit = "day";
            step = 1;
          } else if (timeUnit === "hour" || timeDiff > 0.5) {
            options2.scales.x.time.displayFormats = { hour: "MMM d, h a" };
            options2.scales.x.time.unit = "hour";
            step = 1 / 24;
          } else if (timeUnit === "minute") {
            options2.scales.x.time.displayFormats = { minute: "h:mm a" };
            options2.scales.x.time.unit = "minute";
            step = 1 / 24 / 60;
          }
          if (step && timeDiff > 0) {
            var width = chart.element.offsetWidth;
            if (width > 0) {
              var unitStepSize = Math.ceil(timeDiff / step / (width / 100));
              if (timeUnit === "week" && step === 1) {
                unitStepSize = Math.ceil(unitStepSize / 7) * 7;
              }
              options2.scales.x.ticks.stepSize = unitStepSize;
            }
          }
        }
        if (!options2.scales.x.time.tooltipFormat) {
          if (timeUnit === "year") {
            options2.scales.x.time.tooltipFormat = "yyyy";
          } else if (timeUnit === "month") {
            options2.scales.x.time.tooltipFormat = "MMM yyyy";
          } else if (timeUnit === "week" || timeUnit === "day") {
            options2.scales.x.time.tooltipFormat = "PP";
          } else if (timeUnit === "hour") {
            options2.scales.x.time.tooltipFormat = "MMM d, h a";
          } else if (timeUnit === "minute") {
            options2.scales.x.time.tooltipFormat = "h:mm a";
          }
        }
      }
    }
    return {
      labels,
      datasets
    };
  }
  var defaultExport$2 = function defaultExport(library) {
    this.name = "chartjs";
    this.library = library;
  };
  defaultExport$2.prototype.renderLineChart = function renderLineChart(chart, chartType) {
    if (!chartType) {
      chartType = "line";
    }
    var chartOptions = {};
    var options2 = jsOptions$2(chart, merge(chartOptions, chart.options));
    setFormatOptions$1(chart, options2, chartType);
    var data = createDataTable(chart, options2, chartType);
    if (chart.xtype === "number") {
      options2.scales.x.type = options2.scales.x.type || "linear";
      options2.scales.x.position = options2.scales.x.position || "bottom";
    } else {
      options2.scales.x.type = chart.xtype === "string" ? "category" : "time";
    }
    this.drawChart(chart, "line", data, options2);
  };
  defaultExport$2.prototype.renderPieChart = function renderPieChart(chart) {
    var options2 = merge({}, baseOptions);
    if (chart.options.donut) {
      options2.cutout = "50%";
    }
    if ("legend" in chart.options) {
      hideLegend$2(options2, chart.options.legend);
    }
    if (chart.options.title) {
      setTitle$2(options2, chart.options.title);
    }
    options2 = merge(options2, chart.options.library || {});
    setFormatOptions$1(chart, options2, "pie");
    var labels = [];
    var values = [];
    for (var i3 = 0; i3 < chart.data.length; i3++) {
      var point = chart.data[i3];
      labels.push(point[0]);
      values.push(point[1]);
    }
    var dataset = {
      data: values,
      backgroundColor: chart.options.colors || defaultColors
    };
    dataset = merge(dataset, chart.options.dataset || {});
    var data = {
      labels,
      datasets: [dataset]
    };
    this.drawChart(chart, "pie", data, options2);
  };
  defaultExport$2.prototype.renderColumnChart = function renderColumnChart(chart, chartType) {
    var options2;
    if (chartType === "bar") {
      var barOptions = merge(baseOptions, defaultOptions$2);
      barOptions.indexAxis = "y";
      barOptions.scales.x.grid.drawOnChartArea = true;
      barOptions.scales.y.grid.drawOnChartArea = false;
      delete barOptions.scales.y.ticks.maxTicksLimit;
      options2 = jsOptionsFunc(barOptions, hideLegend$2, setTitle$2, setBarMin$1, setBarMax$1, setStacked$2, setXtitle$2, setYtitle$2)(chart, chart.options);
    } else {
      options2 = jsOptions$2(chart, chart.options);
    }
    setFormatOptions$1(chart, options2, chartType);
    var data = createDataTable(chart, options2, "column");
    if (chartType !== "bar") {
      setLabelSize(chart, data, options2);
    }
    if (!("mode" in options2.interaction)) {
      options2.interaction.mode = "index";
    }
    this.drawChart(chart, "bar", data, options2);
  };
  defaultExport$2.prototype.renderAreaChart = function renderAreaChart(chart) {
    this.renderLineChart(chart, "area");
  };
  defaultExport$2.prototype.renderBarChart = function renderBarChart(chart) {
    this.renderColumnChart(chart, "bar");
  };
  defaultExport$2.prototype.renderScatterChart = function renderScatterChart(chart, chartType) {
    chartType = chartType || "scatter";
    var options2 = jsOptions$2(chart, chart.options);
    setFormatOptions$1(chart, options2, chartType);
    if (!("showLine" in options2)) {
      options2.showLine = false;
    }
    var data = createDataTable(chart, options2, chartType);
    options2.scales.x.type = options2.scales.x.type || "linear";
    options2.scales.x.position = options2.scales.x.position || "bottom";
    if (!("mode" in options2.interaction)) {
      options2.interaction.mode = "nearest";
    }
    this.drawChart(chart, chartType, data, options2);
  };
  defaultExport$2.prototype.renderBubbleChart = function renderBubbleChart(chart) {
    this.renderScatterChart(chart, "bubble");
  };
  defaultExport$2.prototype.destroy = function destroy(chart) {
    if (chart.chart) {
      chart.chart.destroy();
    }
  };
  defaultExport$2.prototype.drawChart = function drawChart(chart, type, data, options2) {
    this.destroy(chart);
    if (chart.destroyed) {
      return;
    }
    var chartOptions = {
      type,
      data,
      options: options2
    };
    if (chart.options.code) {
      window.console.log("new Chart(ctx, " + JSON.stringify(chartOptions) + ");");
    }
    chart.element.innerHTML = "<canvas></canvas>";
    var ctx = chart.element.getElementsByTagName("CANVAS")[0];
    chart.chart = new this.library(ctx, chartOptions);
  };
  var defaultOptions$1 = {
    chart: {},
    xAxis: {
      title: {
        text: null
      },
      labels: {
        style: {
          fontSize: "12px"
        }
      }
    },
    yAxis: {
      title: {
        text: null
      },
      labels: {
        style: {
          fontSize: "12px"
        }
      }
    },
    title: {
      text: null
    },
    credits: {
      enabled: false
    },
    legend: {
      borderWidth: 0
    },
    tooltip: {
      style: {
        fontSize: "12px"
      }
    },
    plotOptions: {
      areaspline: {},
      area: {},
      series: {
        marker: {}
      }
    },
    time: {
      useUTC: false
    }
  };
  function hideLegend$1(options2, legend, hideLegend2) {
    if (legend !== void 0) {
      options2.legend.enabled = !!legend;
      if (legend && legend !== true) {
        if (legend === "top" || legend === "bottom") {
          options2.legend.verticalAlign = legend;
        } else {
          options2.legend.layout = "vertical";
          options2.legend.verticalAlign = "middle";
          options2.legend.align = legend;
        }
      }
    } else if (hideLegend2) {
      options2.legend.enabled = false;
    }
  }
  function setTitle$1(options2, title) {
    options2.title.text = title;
  }
  function setMin$1(options2, min2) {
    options2.yAxis.min = min2;
  }
  function setMax$1(options2, max2) {
    options2.yAxis.max = max2;
  }
  function setStacked$1(options2, stacked) {
    var stackedValue = stacked ? stacked === true ? "normal" : stacked : null;
    options2.plotOptions.series.stacking = stackedValue;
    options2.plotOptions.area.stacking = stackedValue;
    options2.plotOptions.areaspline.stacking = stackedValue;
  }
  function setXtitle$1(options2, title) {
    options2.xAxis.title.text = title;
  }
  function setYtitle$1(options2, title) {
    options2.yAxis.title.text = title;
  }
  var jsOptions$1 = jsOptionsFunc(defaultOptions$1, hideLegend$1, setTitle$1, setMin$1, setMax$1, setStacked$1, setXtitle$1, setYtitle$1);
  function setFormatOptions(chart, options2, chartType) {
    var formatOptions = {
      prefix: chart.options.prefix,
      suffix: chart.options.suffix,
      thousands: chart.options.thousands,
      decimal: chart.options.decimal,
      precision: chart.options.precision,
      round: chart.options.round,
      zeros: chart.options.zeros
    };
    if (chartType !== "pie" && !isArray(options2.yAxis) && !options2.yAxis.labels.formatter) {
      options2.yAxis.labels.formatter = function() {
        return formatValue("", this.value, formatOptions);
      };
    }
    if (!options2.tooltip.pointFormatter && !options2.tooltip.pointFormat) {
      options2.tooltip.pointFormatter = function() {
        return '<span style="color:' + this.color + '">\u25CF</span> ' + formatValue(this.series.name + ": <b>", this.y, formatOptions) + "</b><br/>";
      };
    }
  }
  var defaultExport$1 = function defaultExport2(library) {
    this.name = "highcharts";
    this.library = library;
  };
  defaultExport$1.prototype.renderLineChart = function renderLineChart2(chart, chartType) {
    chartType = chartType || "spline";
    var chartOptions = {};
    if (chartType === "areaspline") {
      chartOptions = {
        plotOptions: {
          areaspline: {
            stacking: "normal"
          },
          area: {
            stacking: "normal"
          },
          series: {
            marker: {
              enabled: false
            }
          }
        }
      };
    }
    if (chart.options.curve === false) {
      if (chartType === "areaspline") {
        chartType = "area";
      } else if (chartType === "spline") {
        chartType = "line";
      }
    }
    var options2 = jsOptions$1(chart, chart.options, chartOptions);
    if (chart.xtype === "number") {
      options2.xAxis.type = options2.xAxis.type || "linear";
    } else {
      options2.xAxis.type = chart.xtype === "string" ? "category" : "datetime";
    }
    if (!options2.chart.type) {
      options2.chart.type = chartType;
    }
    setFormatOptions(chart, options2, chartType);
    var series = chart.data;
    for (var i3 = 0; i3 < series.length; i3++) {
      series[i3].name = series[i3].name || "Value";
      var data = series[i3].data;
      if (chart.xtype === "datetime") {
        for (var j = 0; j < data.length; j++) {
          data[j][0] = data[j][0].getTime();
        }
      } else if (chart.xtype === "number") {
        data.sort(sortByNumberSeries);
      }
      series[i3].marker = { symbol: "circle" };
      if (chart.options.points === false) {
        series[i3].marker.enabled = false;
      }
    }
    this.drawChart(chart, series, options2);
  };
  defaultExport$1.prototype.renderScatterChart = function renderScatterChart2(chart) {
    var options2 = jsOptions$1(chart, chart.options, {});
    options2.chart.type = "scatter";
    this.drawChart(chart, chart.data, options2);
  };
  defaultExport$1.prototype.renderPieChart = function renderPieChart2(chart) {
    var chartOptions = merge(defaultOptions$1, {});
    if (chart.options.colors) {
      chartOptions.colors = chart.options.colors;
    }
    if (chart.options.donut) {
      chartOptions.plotOptions = { pie: { innerSize: "50%" } };
    }
    if ("legend" in chart.options) {
      hideLegend$1(chartOptions, chart.options.legend);
    }
    if (chart.options.title) {
      setTitle$1(chartOptions, chart.options.title);
    }
    var options2 = merge(chartOptions, chart.options.library || {});
    setFormatOptions(chart, options2, "pie");
    var series = [{
      type: "pie",
      name: chart.options.label || "Value",
      data: chart.data
    }];
    this.drawChart(chart, series, options2);
  };
  defaultExport$1.prototype.renderColumnChart = function renderColumnChart2(chart, chartType) {
    chartType = chartType || "column";
    var series = chart.data;
    var options2 = jsOptions$1(chart, chart.options);
    var rows = [];
    var categories = [];
    options2.chart.type = chartType;
    setFormatOptions(chart, options2, chartType);
    for (var i3 = 0; i3 < series.length; i3++) {
      var s4 = series[i3];
      for (var j = 0; j < s4.data.length; j++) {
        var d3 = s4.data[j];
        if (!rows[d3[0]]) {
          rows[d3[0]] = new Array(series.length);
          categories.push(d3[0]);
        }
        rows[d3[0]][i3] = d3[1];
      }
    }
    if (chart.xtype === "number") {
      categories.sort(sortByNumber);
    }
    options2.xAxis.categories = categories;
    var newSeries = [];
    for (var i$1 = 0; i$1 < series.length; i$1++) {
      var d$1 = [];
      for (var j$1 = 0; j$1 < categories.length; j$1++) {
        d$1.push(rows[categories[j$1]][i$1] || 0);
      }
      var d22 = {
        name: series[i$1].name || "Value",
        data: d$1
      };
      if (series[i$1].stack) {
        d22.stack = series[i$1].stack;
      }
      newSeries.push(d22);
    }
    this.drawChart(chart, newSeries, options2);
  };
  defaultExport$1.prototype.renderBarChart = function renderBarChart2(chart) {
    this.renderColumnChart(chart, "bar");
  };
  defaultExport$1.prototype.renderAreaChart = function renderAreaChart2(chart) {
    this.renderLineChart(chart, "areaspline");
  };
  defaultExport$1.prototype.destroy = function destroy2(chart) {
    if (chart.chart) {
      chart.chart.destroy();
    }
  };
  defaultExport$1.prototype.drawChart = function drawChart2(chart, data, options2) {
    this.destroy(chart);
    if (chart.destroyed) {
      return;
    }
    options2.chart.renderTo = chart.element.id;
    options2.series = data;
    if (chart.options.code) {
      window.console.log("new Highcharts.Chart(" + JSON.stringify(options2) + ");");
    }
    chart.chart = new this.library.Chart(options2);
  };
  var loaded = {};
  var callbacks = [];
  var defaultOptions2 = {
    chartArea: {},
    fontName: "'Lucida Grande', 'Lucida Sans Unicode', Verdana, Arial, Helvetica, sans-serif",
    pointSize: 6,
    legend: {
      textStyle: {
        fontSize: 12,
        color: "#444"
      },
      alignment: "center",
      position: "right"
    },
    curveType: "function",
    hAxis: {
      textStyle: {
        color: "#666",
        fontSize: 12
      },
      titleTextStyle: {},
      gridlines: {
        color: "transparent"
      },
      baselineColor: "#ccc",
      viewWindow: {}
    },
    vAxis: {
      textStyle: {
        color: "#666",
        fontSize: 12
      },
      titleTextStyle: {},
      baselineColor: "#ccc",
      viewWindow: {}
    },
    tooltip: {
      textStyle: {
        color: "#666",
        fontSize: 12
      }
    }
  };
  function hideLegend(options2, legend, hideLegend2) {
    if (legend !== void 0) {
      var position;
      if (!legend) {
        position = "none";
      } else if (legend === true) {
        position = "right";
      } else {
        position = legend;
      }
      options2.legend.position = position;
    } else if (hideLegend2) {
      options2.legend.position = "none";
    }
  }
  function setTitle(options2, title) {
    options2.title = title;
    options2.titleTextStyle = { color: "#333", fontSize: "20px" };
  }
  function setMin(options2, min2) {
    options2.vAxis.viewWindow.min = min2;
  }
  function setMax(options2, max2) {
    options2.vAxis.viewWindow.max = max2;
  }
  function setBarMin(options2, min2) {
    options2.hAxis.viewWindow.min = min2;
  }
  function setBarMax(options2, max2) {
    options2.hAxis.viewWindow.max = max2;
  }
  function setStacked(options2, stacked) {
    options2.isStacked = stacked || false;
  }
  function setXtitle(options2, title) {
    options2.hAxis.title = title;
    options2.hAxis.titleTextStyle.italic = false;
  }
  function setYtitle(options2, title) {
    options2.vAxis.title = title;
    options2.vAxis.titleTextStyle.italic = false;
  }
  var jsOptions = jsOptionsFunc(defaultOptions2, hideLegend, setTitle, setMin, setMax, setStacked, setXtitle, setYtitle);
  function resize(callback2) {
    if (window.attachEvent) {
      window.attachEvent("onresize", callback2);
    } else if (window.addEventListener) {
      window.addEventListener("resize", callback2, true);
    }
    callback2();
  }
  var defaultExport3 = function defaultExport4(library) {
    this.name = "google";
    this.library = library;
  };
  defaultExport3.prototype.renderLineChart = function renderLineChart3(chart) {
    var this$1$1 = this;
    this.waitForLoaded(chart, function() {
      var chartOptions = {};
      if (chart.options.curve === false) {
        chartOptions.curveType = "none";
      }
      if (chart.options.points === false) {
        chartOptions.pointSize = 0;
      }
      var options2 = jsOptions(chart, chart.options, chartOptions);
      var data = this$1$1.createDataTable(chart.data, chart.xtype);
      this$1$1.drawChart(chart, "LineChart", data, options2);
    });
  };
  defaultExport3.prototype.renderPieChart = function renderPieChart3(chart) {
    var this$1$1 = this;
    this.waitForLoaded(chart, function() {
      var chartOptions = {
        chartArea: {
          top: "10%",
          height: "80%"
        },
        legend: {}
      };
      if (chart.options.colors) {
        chartOptions.colors = chart.options.colors;
      }
      if (chart.options.donut) {
        chartOptions.pieHole = 0.5;
      }
      if ("legend" in chart.options) {
        hideLegend(chartOptions, chart.options.legend);
      }
      if (chart.options.title) {
        setTitle(chartOptions, chart.options.title);
      }
      var options2 = merge(merge(defaultOptions2, chartOptions), chart.options.library || {});
      var data = new this$1$1.library.visualization.DataTable();
      data.addColumn("string", "");
      data.addColumn("number", "Value");
      data.addRows(chart.data);
      this$1$1.drawChart(chart, "PieChart", data, options2);
    });
  };
  defaultExport3.prototype.renderColumnChart = function renderColumnChart3(chart) {
    var this$1$1 = this;
    this.waitForLoaded(chart, function() {
      var options2 = jsOptions(chart, chart.options);
      var data = this$1$1.createDataTable(chart.data, chart.xtype);
      this$1$1.drawChart(chart, "ColumnChart", data, options2);
    });
  };
  defaultExport3.prototype.renderBarChart = function renderBarChart3(chart) {
    var this$1$1 = this;
    this.waitForLoaded(chart, function() {
      var chartOptions = {
        hAxis: {
          gridlines: {
            color: "#ccc"
          }
        }
      };
      var options2 = jsOptionsFunc(defaultOptions2, hideLegend, setTitle, setBarMin, setBarMax, setStacked, setXtitle, setYtitle)(chart, chart.options, chartOptions);
      var data = this$1$1.createDataTable(chart.data, chart.xtype);
      this$1$1.drawChart(chart, "BarChart", data, options2);
    });
  };
  defaultExport3.prototype.renderAreaChart = function renderAreaChart3(chart) {
    var this$1$1 = this;
    this.waitForLoaded(chart, function() {
      var chartOptions = {
        isStacked: true,
        pointSize: 0,
        areaOpacity: 0.5
      };
      var options2 = jsOptions(chart, chart.options, chartOptions);
      var data = this$1$1.createDataTable(chart.data, chart.xtype);
      this$1$1.drawChart(chart, "AreaChart", data, options2);
    });
  };
  defaultExport3.prototype.renderGeoChart = function renderGeoChart(chart) {
    var this$1$1 = this;
    this.waitForLoaded(chart, "geochart", function() {
      var chartOptions = {
        legend: "none",
        colorAxis: {
          colors: chart.options.colors || ["#f6c7b6", "#ce502d"]
        }
      };
      var options2 = merge(merge(defaultOptions2, chartOptions), chart.options.library || {});
      var data = new this$1$1.library.visualization.DataTable();
      data.addColumn("string", "");
      data.addColumn("number", chart.options.label || "Value");
      data.addRows(chart.data);
      this$1$1.drawChart(chart, "GeoChart", data, options2);
    });
  };
  defaultExport3.prototype.renderScatterChart = function renderScatterChart3(chart) {
    var this$1$1 = this;
    this.waitForLoaded(chart, function() {
      var chartOptions = {};
      var options2 = jsOptions(chart, chart.options, chartOptions);
      var series = chart.data;
      var rows2 = [];
      for (var i3 = 0; i3 < series.length; i3++) {
        series[i3].name = series[i3].name || "Value";
        var d3 = series[i3].data;
        for (var j = 0; j < d3.length; j++) {
          var row = new Array(series.length + 1);
          row[0] = d3[j][0];
          row[i3 + 1] = d3[j][1];
          rows2.push(row);
        }
      }
      var data = new this$1$1.library.visualization.DataTable();
      data.addColumn("number", "");
      for (var i$1 = 0; i$1 < series.length; i$1++) {
        data.addColumn("number", series[i$1].name);
      }
      data.addRows(rows2);
      this$1$1.drawChart(chart, "ScatterChart", data, options2);
    });
  };
  defaultExport3.prototype.renderTimeline = function renderTimeline(chart) {
    var this$1$1 = this;
    this.waitForLoaded(chart, "timeline", function() {
      var chartOptions = {
        legend: "none"
      };
      if (chart.options.colors) {
        chartOptions.colors = chart.options.colors;
      }
      var options2 = merge(merge(defaultOptions2, chartOptions), chart.options.library || {});
      var data = new this$1$1.library.visualization.DataTable();
      data.addColumn({ type: "string", id: "Name" });
      data.addColumn({ type: "date", id: "Start" });
      data.addColumn({ type: "date", id: "End" });
      data.addRows(chart.data);
      chart.element.style.lineHeight = "normal";
      this$1$1.drawChart(chart, "Timeline", data, options2);
    });
  };
  defaultExport3.prototype.destroy = function destroy3(chart) {
    if (chart.chart) {
      chart.chart.clearChart();
    }
  };
  defaultExport3.prototype.drawChart = function drawChart3(chart, type, data, options2) {
    this.destroy(chart);
    if (chart.destroyed) {
      return;
    }
    if (chart.options.code) {
      window.console.log("var data = new google.visualization.DataTable(" + data.toJSON() + ");\nvar chart = new google.visualization." + type + "(element);\nchart.draw(data, " + JSON.stringify(options2) + ");");
    }
    chart.chart = new this.library.visualization[type](chart.element);
    resize(function() {
      chart.chart.draw(data, options2);
    });
  };
  defaultExport3.prototype.waitForLoaded = function waitForLoaded(chart, pack, callback2) {
    var this$1$1 = this;
    if (!callback2) {
      callback2 = pack;
      pack = "corechart";
    }
    callbacks.push({ pack, callback: callback2 });
    if (loaded[pack]) {
      this.runCallbacks();
    } else {
      loaded[pack] = true;
      var loadOptions = {
        packages: [pack],
        callback: function() {
          this$1$1.runCallbacks();
        }
      };
      var config = chart.__config();
      if (config.language) {
        loadOptions.language = config.language;
      }
      if (pack === "geochart" && config.mapsApiKey) {
        loadOptions.mapsApiKey = config.mapsApiKey;
      }
      this.library.charts.load("current", loadOptions);
    }
  };
  defaultExport3.prototype.runCallbacks = function runCallbacks() {
    for (var i3 = 0; i3 < callbacks.length; i3++) {
      var cb = callbacks[i3];
      var call = this.library.visualization && (cb.pack === "corechart" && this.library.visualization.LineChart || cb.pack === "timeline" && this.library.visualization.Timeline || cb.pack === "geochart" && this.library.visualization.GeoChart);
      if (call) {
        cb.callback();
        callbacks.splice(i3, 1);
        i3--;
      }
    }
  };
  defaultExport3.prototype.createDataTable = function createDataTable2(series, columnType) {
    var rows = [];
    var sortedLabels = [];
    for (var i3 = 0; i3 < series.length; i3++) {
      var s4 = series[i3];
      series[i3].name = series[i3].name || "Value";
      for (var j = 0; j < s4.data.length; j++) {
        var d3 = s4.data[j];
        var key = columnType === "datetime" ? d3[0].getTime() : d3[0];
        if (!rows[key]) {
          rows[key] = new Array(series.length);
          sortedLabels.push(key);
        }
        rows[key][i3] = d3[1];
      }
    }
    var rows2 = [];
    var values = [];
    for (var j$1 = 0; j$1 < sortedLabels.length; j$1++) {
      var i$1 = sortedLabels[j$1];
      var value = void 0;
      if (columnType === "datetime") {
        value = new Date(i$1);
        values.push(value);
      } else {
        value = i$1;
      }
      rows2.push([value].concat(rows[i$1]));
    }
    var day = true;
    if (columnType === "datetime") {
      rows2.sort(sortByTime);
      var timeUnit = calculateTimeUnit(values, true);
      day = isDay(timeUnit);
    } else if (columnType === "number") {
      rows2.sort(sortByNumberSeries);
      for (var i$2 = 0; i$2 < rows2.length; i$2++) {
        rows2[i$2][0] = toStr(rows2[i$2][0]);
      }
      columnType = "string";
    }
    var data = new this.library.visualization.DataTable();
    columnType = columnType === "datetime" && day ? "date" : columnType;
    data.addColumn(columnType, "");
    for (var i$3 = 0; i$3 < series.length; i$3++) {
      data.addColumn("number", series[i$3].name);
    }
    data.addRows(rows2);
    return data;
  };
  var adapters = [];
  function getAdapterType(library) {
    if (library) {
      if (library.product === "Highcharts") {
        return defaultExport$1;
      } else if (library.charts) {
        return defaultExport3;
      } else if (isFunction(library)) {
        return defaultExport$2;
      }
    }
    throw new Error("Unknown adapter");
  }
  function addAdapter(library) {
    var adapterType = getAdapterType(library);
    for (var i3 = 0; i3 < adapters.length; i3++) {
      if (adapters[i3].library === library) {
        return;
      }
    }
    adapters.push(new adapterType(library));
  }
  function loadAdapters() {
    if ("Chart" in window) {
      addAdapter(window.Chart);
    }
    if ("Highcharts" in window) {
      addAdapter(window.Highcharts);
    }
    if (window.google && window.google.charts) {
      addAdapter(window.google);
    }
  }
  function callAdapter(chartType, chart) {
    var fnName = "render" + chartType;
    var adapterName = chart.options.adapter;
    loadAdapters();
    for (var i3 = 0; i3 < adapters.length; i3++) {
      var adapter = adapters[i3];
      if ((!adapterName || adapterName === adapter.name) && isFunction(adapter[fnName])) {
        chart.adapter = adapter.name;
        chart.__adapterObject = adapter;
        return adapter[fnName](chart);
      }
    }
    if (adapters.length > 0) {
      throw new Error("No charting library found for " + chartType);
    } else {
      throw new Error("No charting libraries found - be sure to include one before your charts");
    }
  }
  var Chartkick = {
    charts: {},
    configure: function(options2) {
      for (var key in options2) {
        if (Object.prototype.hasOwnProperty.call(options2, key)) {
          Chartkick.config[key] = options2[key];
        }
      }
    },
    setDefaultOptions: function(opts) {
      Chartkick.options = opts;
    },
    eachChart: function(callback2) {
      for (var chartId in Chartkick.charts) {
        if (Object.prototype.hasOwnProperty.call(Chartkick.charts, chartId)) {
          callback2(Chartkick.charts[chartId]);
        }
      }
    },
    destroyAll: function() {
      for (var chartId in Chartkick.charts) {
        if (Object.prototype.hasOwnProperty.call(Chartkick.charts, chartId)) {
          Chartkick.charts[chartId].destroy();
          delete Chartkick.charts[chartId];
        }
      }
    },
    config: {},
    options: {},
    adapters,
    addAdapter,
    use: function(adapter) {
      addAdapter(adapter);
      return Chartkick;
    }
  };
  function formatSeriesBubble(data) {
    var r2 = [];
    for (var i3 = 0; i3 < data.length; i3++) {
      r2.push([toFloat(data[i3][0]), toFloat(data[i3][1]), toFloat(data[i3][2])]);
    }
    return r2;
  }
  function formatSeriesData(data, keyType) {
    if (keyType === "bubble") {
      return formatSeriesBubble(data);
    }
    var keyFunc;
    if (keyType === "number") {
      keyFunc = toFloat;
    } else if (keyType === "datetime") {
      keyFunc = toDate;
    } else {
      keyFunc = toStr;
    }
    var r2 = [];
    for (var i3 = 0; i3 < data.length; i3++) {
      r2.push([keyFunc(data[i3][0]), toFloat(data[i3][1])]);
    }
    return r2;
  }
  function detectXType(series, noDatetime, options2) {
    if (dataEmpty(series)) {
      if ((options2.xmin || options2.xmax) && (!options2.xmin || isDate(options2.xmin)) && (!options2.xmax || isDate(options2.xmax))) {
        return "datetime";
      } else {
        return "number";
      }
    } else if (detectXTypeWithFunction(series, isNumber)) {
      return "number";
    } else if (!noDatetime && detectXTypeWithFunction(series, isDate)) {
      return "datetime";
    } else {
      return "string";
    }
  }
  function detectXTypeWithFunction(series, func) {
    for (var i3 = 0; i3 < series.length; i3++) {
      var data = toArr(series[i3].data);
      for (var j = 0; j < data.length; j++) {
        if (!func(data[j][0])) {
          return false;
        }
      }
    }
    return true;
  }
  function copySeries(series) {
    var newSeries = [];
    for (var i3 = 0; i3 < series.length; i3++) {
      var copy = {};
      for (var j in series[i3]) {
        if (Object.prototype.hasOwnProperty.call(series[i3], j)) {
          copy[j] = series[i3][j];
        }
      }
      newSeries.push(copy);
    }
    return newSeries;
  }
  function processSeries(chart, keyType, noDatetime) {
    var opts = chart.options;
    var series = chart.rawData;
    chart.singleSeriesFormat = !isArray(series) || !isPlainObject(series[0]);
    if (chart.singleSeriesFormat) {
      series = [{ name: opts.label, data: series }];
    }
    series = copySeries(series);
    for (var i3 = 0; i3 < series.length; i3++) {
      series[i3].data = toArr(series[i3].data);
    }
    chart.xtype = keyType || (opts.discrete ? "string" : detectXType(series, noDatetime, opts));
    for (var i$1 = 0; i$1 < series.length; i$1++) {
      series[i$1].data = formatSeriesData(series[i$1].data, chart.xtype);
    }
    return series;
  }
  function processSimple(chart) {
    var perfectData = toArr(chart.rawData);
    for (var i3 = 0; i3 < perfectData.length; i3++) {
      perfectData[i3] = [toStr(perfectData[i3][0]), toFloat(perfectData[i3][1])];
    }
    return perfectData;
  }
  function dataEmpty(data, chartType) {
    if (chartType === "PieChart" || chartType === "GeoChart" || chartType === "Timeline") {
      return data.length === 0;
    } else {
      for (var i3 = 0; i3 < data.length; i3++) {
        if (data[i3].data.length > 0) {
          return false;
        }
      }
      return true;
    }
  }
  function addDownloadButton(chart) {
    var download = chart.options.download;
    if (download === true) {
      download = {};
    } else if (typeof download === "string") {
      download = { filename: download };
    }
    var link = document.createElement("a");
    link.download = download.filename || "chart.png";
    link.style.position = "absolute";
    link.style.top = "20px";
    link.style.right = "20px";
    link.style.zIndex = 1e3;
    link.style.lineHeight = "20px";
    link.target = "_blank";
    var image = document.createElement("img");
    var svg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path fill="#CCCCCC" d="M344 240h-56L287.1 152c0-13.25-10.75-24-24-24h-16C234.7 128 223.1 138.8 223.1 152L224 240h-56c-9.531 0-18.16 5.656-22 14.38C142.2 263.1 143.9 273.3 150.4 280.3l88.75 96C243.7 381.2 250.1 384 256.8 384c7.781-.3125 13.25-2.875 17.75-7.844l87.25-96c6.406-7.031 8.031-17.19 4.188-25.88S353.5 240 344 240zM256 0C114.6 0 0 114.6 0 256s114.6 256 256 256s256-114.6 256-256S397.4 0 256 0zM256 464c-114.7 0-208-93.31-208-208S141.3 48 256 48s208 93.31 208 208S370.7 464 256 464z"/></svg>';
    image.src = "data:image/svg+xml;utf8," + encodeURIComponent(svg);
    image.alt = "Download";
    image.style.width = "20px";
    image.style.height = "20px";
    image.style.border = "none";
    link.appendChild(image);
    var element = chart.element;
    element.style.position = "relative";
    chart.__downloadAttached = true;
    chart.__enterEvent = element.addEventListener("mouseover", function(e3) {
      var related = e3.relatedTarget;
      if ((!related || related !== this && !this.contains(related)) && chart.options.download) {
        link.href = chart.toImage(download);
        element.appendChild(link);
      }
    });
    chart.__leaveEvent = element.addEventListener("mouseout", function(e3) {
      var related = e3.relatedTarget;
      if (!related || related !== this && !this.contains(related)) {
        if (link.parentNode) {
          link.parentNode.removeChild(link);
        }
      }
    });
  }
  var pendingRequests = [];
  var runningRequests = 0;
  var maxRequests = 4;
  function pushRequest(url, success, error2) {
    pendingRequests.push([url, success, error2]);
    runNext();
  }
  function runNext() {
    if (runningRequests < maxRequests) {
      var request = pendingRequests.shift();
      if (request) {
        runningRequests++;
        getJSON(request[0], request[1], request[2]);
        runNext();
      }
    }
  }
  function requestComplete() {
    runningRequests--;
    runNext();
  }
  function getJSON(url, success, error2) {
    var xhr = new XMLHttpRequest();
    xhr.open("GET", url, true);
    xhr.setRequestHeader("Content-Type", "application/json");
    xhr.onload = function() {
      requestComplete();
      if (xhr.status === 200) {
        success(JSON.parse(xhr.responseText));
      } else {
        error2(xhr.statusText);
      }
    };
    xhr.send();
  }
  function setText(element, text) {
    element.textContent = text;
  }
  function chartError(element, message, noPrefix) {
    if (!noPrefix) {
      message = "Error Loading Chart: " + message;
    }
    setText(element, message);
    element.style.color = "#ff0000";
  }
  function errorCatcher(chart) {
    try {
      chart.__render();
    } catch (err) {
      chartError(chart.element, err.message);
      throw err;
    }
  }
  function fetchDataSource(chart, dataSource, showLoading) {
    if (showLoading && chart.options.loading && (typeof dataSource === "string" || typeof dataSource === "function")) {
      setText(chart.element, chart.options.loading);
    }
    if (typeof dataSource === "string") {
      pushRequest(dataSource, function(data) {
        chart.rawData = data;
        errorCatcher(chart);
      }, function(message) {
        chartError(chart.element, message);
      });
    } else if (typeof dataSource === "function") {
      try {
        dataSource(function(data) {
          chart.rawData = data;
          errorCatcher(chart);
        }, function(message) {
          chartError(chart.element, message, true);
        });
      } catch (err) {
        chartError(chart.element, err, true);
      }
    } else {
      chart.rawData = dataSource;
      errorCatcher(chart);
    }
  }
  function renderChart(chartType, chart) {
    if (dataEmpty(chart.data, chartType)) {
      var message = chart.options.empty || chart.options.messages && chart.options.messages.empty || "No data";
      setText(chart.element, message);
    } else {
      callAdapter(chartType, chart);
      if (chart.options.download && !chart.__downloadAttached && chart.adapter === "chartjs") {
        addDownloadButton(chart);
      }
    }
  }
  function getElement(element) {
    if (typeof element === "string") {
      var elementId = element;
      element = document.getElementById(element);
      if (!element) {
        throw new Error("No element with id " + elementId);
      }
    }
    return element;
  }
  var Chart = function Chart2(element, dataSource, options2) {
    this.element = getElement(element);
    this.options = merge(Chartkick.options, options2 || {});
    this.dataSource = dataSource;
    if (this.element.id) {
      Chartkick.charts[this.element.id] = this;
    }
    fetchDataSource(this, dataSource, true);
    if (this.options.refresh) {
      this.startRefresh();
    }
  };
  Chart.prototype.getElement = function getElement2() {
    return this.element;
  };
  Chart.prototype.getDataSource = function getDataSource() {
    return this.dataSource;
  };
  Chart.prototype.getData = function getData() {
    return this.data;
  };
  Chart.prototype.getOptions = function getOptions() {
    return this.options;
  };
  Chart.prototype.getChartObject = function getChartObject() {
    return this.chart;
  };
  Chart.prototype.getAdapter = function getAdapter() {
    return this.adapter;
  };
  Chart.prototype.updateData = function updateData(dataSource, options2) {
    this.dataSource = dataSource;
    if (options2) {
      this.__updateOptions(options2);
    }
    fetchDataSource(this, dataSource, true);
  };
  Chart.prototype.setOptions = function setOptions(options2) {
    this.__updateOptions(options2);
    this.redraw();
  };
  Chart.prototype.redraw = function redraw() {
    fetchDataSource(this, this.rawData);
  };
  Chart.prototype.refreshData = function refreshData() {
    if (typeof this.dataSource === "string") {
      var sep = this.dataSource.indexOf("?") === -1 ? "?" : "&";
      var url = this.dataSource + sep + "_=" + new Date().getTime();
      fetchDataSource(this, url);
    } else if (typeof this.dataSource === "function") {
      fetchDataSource(this, this.dataSource);
    }
  };
  Chart.prototype.startRefresh = function startRefresh() {
    var this$1$1 = this;
    var refresh = this.options.refresh;
    if (refresh && typeof this.dataSource !== "string" && typeof this.dataSource !== "function") {
      throw new Error("Data source must be a URL or callback for refresh");
    }
    if (!this.intervalId) {
      if (refresh) {
        this.intervalId = setInterval(function() {
          this$1$1.refreshData();
        }, refresh * 1e3);
      } else {
        throw new Error("No refresh interval");
      }
    }
  };
  Chart.prototype.stopRefresh = function stopRefresh() {
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = null;
    }
  };
  Chart.prototype.toImage = function toImage(download) {
    if (this.adapter === "chartjs") {
      if (download && download.background && download.background !== "transparent") {
        var canvas = this.chart.canvas;
        var ctx = this.chart.ctx;
        var tmpCanvas = document.createElement("canvas");
        var tmpCtx = tmpCanvas.getContext("2d");
        tmpCanvas.width = ctx.canvas.width;
        tmpCanvas.height = ctx.canvas.height;
        tmpCtx.fillStyle = download.background;
        tmpCtx.fillRect(0, 0, tmpCanvas.width, tmpCanvas.height);
        tmpCtx.drawImage(canvas, 0, 0);
        return tmpCanvas.toDataURL("image/png");
      } else {
        return this.chart.toBase64Image();
      }
    } else {
      throw new Error("Feature only available for Chart.js");
    }
  };
  Chart.prototype.destroy = function destroy4() {
    this.destroyed = true;
    this.stopRefresh();
    if (this.__adapterObject) {
      this.__adapterObject.destroy(this);
    }
    if (this.__enterEvent) {
      this.element.removeEventListener("mouseover", this.__enterEvent);
    }
    if (this.__leaveEvent) {
      this.element.removeEventListener("mouseout", this.__leaveEvent);
    }
  };
  Chart.prototype.__updateOptions = function __updateOptions(options2) {
    var updateRefresh = options2.refresh && options2.refresh !== this.options.refresh;
    this.options = merge(Chartkick.options, options2);
    if (updateRefresh) {
      this.stopRefresh();
      this.startRefresh();
    }
  };
  Chart.prototype.__render = function __render() {
    this.data = this.__processData();
    renderChart(this.__chartName(), this);
  };
  Chart.prototype.__config = function __config() {
    return Chartkick.config;
  };
  var LineChart = /* @__PURE__ */ function(Chart4) {
    function LineChart2() {
      Chart4.apply(this, arguments);
    }
    if (Chart4)
      LineChart2.__proto__ = Chart4;
    LineChart2.prototype = Object.create(Chart4 && Chart4.prototype);
    LineChart2.prototype.constructor = LineChart2;
    LineChart2.prototype.__processData = function __processData() {
      return processSeries(this);
    };
    LineChart2.prototype.__chartName = function __chartName() {
      return "LineChart";
    };
    return LineChart2;
  }(Chart);
  var PieChart = /* @__PURE__ */ function(Chart4) {
    function PieChart2() {
      Chart4.apply(this, arguments);
    }
    if (Chart4)
      PieChart2.__proto__ = Chart4;
    PieChart2.prototype = Object.create(Chart4 && Chart4.prototype);
    PieChart2.prototype.constructor = PieChart2;
    PieChart2.prototype.__processData = function __processData() {
      return processSimple(this);
    };
    PieChart2.prototype.__chartName = function __chartName() {
      return "PieChart";
    };
    return PieChart2;
  }(Chart);
  var ColumnChart = /* @__PURE__ */ function(Chart4) {
    function ColumnChart2() {
      Chart4.apply(this, arguments);
    }
    if (Chart4)
      ColumnChart2.__proto__ = Chart4;
    ColumnChart2.prototype = Object.create(Chart4 && Chart4.prototype);
    ColumnChart2.prototype.constructor = ColumnChart2;
    ColumnChart2.prototype.__processData = function __processData() {
      return processSeries(this, null, true);
    };
    ColumnChart2.prototype.__chartName = function __chartName() {
      return "ColumnChart";
    };
    return ColumnChart2;
  }(Chart);
  var BarChart = /* @__PURE__ */ function(Chart4) {
    function BarChart2() {
      Chart4.apply(this, arguments);
    }
    if (Chart4)
      BarChart2.__proto__ = Chart4;
    BarChart2.prototype = Object.create(Chart4 && Chart4.prototype);
    BarChart2.prototype.constructor = BarChart2;
    BarChart2.prototype.__processData = function __processData() {
      return processSeries(this, null, true);
    };
    BarChart2.prototype.__chartName = function __chartName() {
      return "BarChart";
    };
    return BarChart2;
  }(Chart);
  var AreaChart = /* @__PURE__ */ function(Chart4) {
    function AreaChart2() {
      Chart4.apply(this, arguments);
    }
    if (Chart4)
      AreaChart2.__proto__ = Chart4;
    AreaChart2.prototype = Object.create(Chart4 && Chart4.prototype);
    AreaChart2.prototype.constructor = AreaChart2;
    AreaChart2.prototype.__processData = function __processData() {
      return processSeries(this);
    };
    AreaChart2.prototype.__chartName = function __chartName() {
      return "AreaChart";
    };
    return AreaChart2;
  }(Chart);
  var GeoChart = /* @__PURE__ */ function(Chart4) {
    function GeoChart2() {
      Chart4.apply(this, arguments);
    }
    if (Chart4)
      GeoChart2.__proto__ = Chart4;
    GeoChart2.prototype = Object.create(Chart4 && Chart4.prototype);
    GeoChart2.prototype.constructor = GeoChart2;
    GeoChart2.prototype.__processData = function __processData() {
      return processSimple(this);
    };
    GeoChart2.prototype.__chartName = function __chartName() {
      return "GeoChart";
    };
    return GeoChart2;
  }(Chart);
  var ScatterChart = /* @__PURE__ */ function(Chart4) {
    function ScatterChart2() {
      Chart4.apply(this, arguments);
    }
    if (Chart4)
      ScatterChart2.__proto__ = Chart4;
    ScatterChart2.prototype = Object.create(Chart4 && Chart4.prototype);
    ScatterChart2.prototype.constructor = ScatterChart2;
    ScatterChart2.prototype.__processData = function __processData() {
      return processSeries(this, "number");
    };
    ScatterChart2.prototype.__chartName = function __chartName() {
      return "ScatterChart";
    };
    return ScatterChart2;
  }(Chart);
  var BubbleChart = /* @__PURE__ */ function(Chart4) {
    function BubbleChart2() {
      Chart4.apply(this, arguments);
    }
    if (Chart4)
      BubbleChart2.__proto__ = Chart4;
    BubbleChart2.prototype = Object.create(Chart4 && Chart4.prototype);
    BubbleChart2.prototype.constructor = BubbleChart2;
    BubbleChart2.prototype.__processData = function __processData() {
      return processSeries(this, "bubble");
    };
    BubbleChart2.prototype.__chartName = function __chartName() {
      return "BubbleChart";
    };
    return BubbleChart2;
  }(Chart);
  var Timeline = /* @__PURE__ */ function(Chart4) {
    function Timeline2() {
      Chart4.apply(this, arguments);
    }
    if (Chart4)
      Timeline2.__proto__ = Chart4;
    Timeline2.prototype = Object.create(Chart4 && Chart4.prototype);
    Timeline2.prototype.constructor = Timeline2;
    Timeline2.prototype.__processData = function __processData() {
      var data = this.rawData;
      for (var i3 = 0; i3 < data.length; i3++) {
        data[i3][1] = toDate(data[i3][1]);
        data[i3][2] = toDate(data[i3][2]);
      }
      return data;
    };
    Timeline2.prototype.__chartName = function __chartName() {
      return "Timeline";
    };
    return Timeline2;
  }(Chart);
  Chartkick.LineChart = LineChart;
  Chartkick.PieChart = PieChart;
  Chartkick.ColumnChart = ColumnChart;
  Chartkick.BarChart = BarChart;
  Chartkick.AreaChart = AreaChart;
  Chartkick.GeoChart = GeoChart;
  Chartkick.ScatterChart = ScatterChart;
  Chartkick.BubbleChart = BubbleChart;
  Chartkick.Timeline = Timeline;
  if (typeof window !== "undefined" && !window.Chartkick) {
    window.Chartkick = Chartkick;
    document.addEventListener("turbolinks:before-render", function() {
      if (Chartkick.config.autoDestroy !== false) {
        Chartkick.destroyAll();
      }
    });
    document.addEventListener("turbo:before-render", function() {
      if (Chartkick.config.autoDestroy !== false) {
        Chartkick.destroyAll();
      }
    });
    setTimeout(function() {
      window.dispatchEvent(new Event("chartkick:load"));
    }, 0);
  }
  Chartkick.default = Chartkick;

  // ../../node_modules/@kurkle/color/dist/color.esm.js
  function round(v) {
    return v + 0.5 | 0;
  }
  var lim = (v, l2, h5) => Math.max(Math.min(v, h5), l2);
  function p2b(v) {
    return lim(round(v * 2.55), 0, 255);
  }
  function n2b(v) {
    return lim(round(v * 255), 0, 255);
  }
  function b2n(v) {
    return lim(round(v / 2.55) / 100, 0, 1);
  }
  function n2p(v) {
    return lim(round(v * 100), 0, 100);
  }
  var map$1 = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
  var hex = [..."0123456789ABCDEF"];
  var h1 = (b2) => hex[b2 & 15];
  var h2 = (b2) => hex[(b2 & 240) >> 4] + hex[b2 & 15];
  var eq = (b2) => (b2 & 240) >> 4 === (b2 & 15);
  var isShort = (v) => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
  function hexParse(str) {
    var len = str.length;
    var ret;
    if (str[0] === "#") {
      if (len === 4 || len === 5) {
        ret = {
          r: 255 & map$1[str[1]] * 17,
          g: 255 & map$1[str[2]] * 17,
          b: 255 & map$1[str[3]] * 17,
          a: len === 5 ? map$1[str[4]] * 17 : 255
        };
      } else if (len === 7 || len === 9) {
        ret = {
          r: map$1[str[1]] << 4 | map$1[str[2]],
          g: map$1[str[3]] << 4 | map$1[str[4]],
          b: map$1[str[5]] << 4 | map$1[str[6]],
          a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
        };
      }
    }
    return ret;
  }
  var alpha = (a4, f) => a4 < 255 ? f(a4) : "";
  function hexString(v) {
    var f = isShort(v) ? h1 : h2;
    return v ? "#" + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f) : void 0;
  }
  var HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
  function hsl2rgbn(h5, s4, l2) {
    const a4 = s4 * Math.min(l2, 1 - l2);
    const f = (n2, k2 = (n2 + h5 / 30) % 12) => l2 - a4 * Math.max(Math.min(k2 - 3, 9 - k2, 1), -1);
    return [f(0), f(8), f(4)];
  }
  function hsv2rgbn(h5, s4, v) {
    const f = (n2, k2 = (n2 + h5 / 60) % 6) => v - v * s4 * Math.max(Math.min(k2, 4 - k2, 1), 0);
    return [f(5), f(3), f(1)];
  }
  function hwb2rgbn(h5, w2, b2) {
    const rgb = hsl2rgbn(h5, 1, 0.5);
    let i3;
    if (w2 + b2 > 1) {
      i3 = 1 / (w2 + b2);
      w2 *= i3;
      b2 *= i3;
    }
    for (i3 = 0; i3 < 3; i3++) {
      rgb[i3] *= 1 - w2 - b2;
      rgb[i3] += w2;
    }
    return rgb;
  }
  function hueValue(r2, g, b2, d3, max2) {
    if (r2 === max2) {
      return (g - b2) / d3 + (g < b2 ? 6 : 0);
    }
    if (g === max2) {
      return (b2 - r2) / d3 + 2;
    }
    return (r2 - g) / d3 + 4;
  }
  function rgb2hsl(v) {
    const range = 255;
    const r2 = v.r / range;
    const g = v.g / range;
    const b2 = v.b / range;
    const max2 = Math.max(r2, g, b2);
    const min2 = Math.min(r2, g, b2);
    const l2 = (max2 + min2) / 2;
    let h5, s4, d3;
    if (max2 !== min2) {
      d3 = max2 - min2;
      s4 = l2 > 0.5 ? d3 / (2 - max2 - min2) : d3 / (max2 + min2);
      h5 = hueValue(r2, g, b2, d3, max2);
      h5 = h5 * 60 + 0.5;
    }
    return [h5 | 0, s4 || 0, l2];
  }
  function calln(f, a4, b2, c2) {
    return (Array.isArray(a4) ? f(a4[0], a4[1], a4[2]) : f(a4, b2, c2)).map(n2b);
  }
  function hsl2rgb(h5, s4, l2) {
    return calln(hsl2rgbn, h5, s4, l2);
  }
  function hwb2rgb(h5, w2, b2) {
    return calln(hwb2rgbn, h5, w2, b2);
  }
  function hsv2rgb(h5, s4, v) {
    return calln(hsv2rgbn, h5, s4, v);
  }
  function hue(h5) {
    return (h5 % 360 + 360) % 360;
  }
  function hueParse(str) {
    const m3 = HUE_RE.exec(str);
    let a4 = 255;
    let v;
    if (!m3) {
      return;
    }
    if (m3[5] !== v) {
      a4 = m3[6] ? p2b(+m3[5]) : n2b(+m3[5]);
    }
    const h5 = hue(+m3[2]);
    const p1 = +m3[3] / 100;
    const p2 = +m3[4] / 100;
    if (m3[1] === "hwb") {
      v = hwb2rgb(h5, p1, p2);
    } else if (m3[1] === "hsv") {
      v = hsv2rgb(h5, p1, p2);
    } else {
      v = hsl2rgb(h5, p1, p2);
    }
    return {
      r: v[0],
      g: v[1],
      b: v[2],
      a: a4
    };
  }
  function rotate(v, deg) {
    var h5 = rgb2hsl(v);
    h5[0] = hue(h5[0] + deg);
    h5 = hsl2rgb(h5);
    v.r = h5[0];
    v.g = h5[1];
    v.b = h5[2];
  }
  function hslString(v) {
    if (!v) {
      return;
    }
    const a4 = rgb2hsl(v);
    const h5 = a4[0];
    const s4 = n2p(a4[1]);
    const l2 = n2p(a4[2]);
    return v.a < 255 ? `hsla(${h5}, ${s4}%, ${l2}%, ${b2n(v.a)})` : `hsl(${h5}, ${s4}%, ${l2}%)`;
  }
  var map = {
    x: "dark",
    Z: "light",
    Y: "re",
    X: "blu",
    W: "gr",
    V: "medium",
    U: "slate",
    A: "ee",
    T: "ol",
    S: "or",
    B: "ra",
    C: "lateg",
    D: "ights",
    R: "in",
    Q: "turquois",
    E: "hi",
    P: "ro",
    O: "al",
    N: "le",
    M: "de",
    L: "yello",
    F: "en",
    K: "ch",
    G: "arks",
    H: "ea",
    I: "ightg",
    J: "wh"
  };
  var names$1 = {
    OiceXe: "f0f8ff",
    antiquewEte: "faebd7",
    aqua: "ffff",
    aquamarRe: "7fffd4",
    azuY: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "0",
    blanKedOmond: "ffebcd",
    Xe: "ff",
    XeviTet: "8a2be2",
    bPwn: "a52a2a",
    burlywood: "deb887",
    caMtXe: "5f9ea0",
    KartYuse: "7fff00",
    KocTate: "d2691e",
    cSO: "ff7f50",
    cSnflowerXe: "6495ed",
    cSnsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "ffff",
    xXe: "8b",
    xcyan: "8b8b",
    xgTMnPd: "b8860b",
    xWay: "a9a9a9",
    xgYF: "6400",
    xgYy: "a9a9a9",
    xkhaki: "bdb76b",
    xmagFta: "8b008b",
    xTivegYF: "556b2f",
    xSange: "ff8c00",
    xScEd: "9932cc",
    xYd: "8b0000",
    xsOmon: "e9967a",
    xsHgYF: "8fbc8f",
    xUXe: "483d8b",
    xUWay: "2f4f4f",
    xUgYy: "2f4f4f",
    xQe: "ced1",
    xviTet: "9400d3",
    dAppRk: "ff1493",
    dApskyXe: "bfff",
    dimWay: "696969",
    dimgYy: "696969",
    dodgerXe: "1e90ff",
    fiYbrick: "b22222",
    flSOwEte: "fffaf0",
    foYstWAn: "228b22",
    fuKsia: "ff00ff",
    gaRsbSo: "dcdcdc",
    ghostwEte: "f8f8ff",
    gTd: "ffd700",
    gTMnPd: "daa520",
    Way: "808080",
    gYF: "8000",
    gYFLw: "adff2f",
    gYy: "808080",
    honeyMw: "f0fff0",
    hotpRk: "ff69b4",
    RdianYd: "cd5c5c",
    Rdigo: "4b0082",
    ivSy: "fffff0",
    khaki: "f0e68c",
    lavFMr: "e6e6fa",
    lavFMrXsh: "fff0f5",
    lawngYF: "7cfc00",
    NmoncEffon: "fffacd",
    ZXe: "add8e6",
    ZcSO: "f08080",
    Zcyan: "e0ffff",
    ZgTMnPdLw: "fafad2",
    ZWay: "d3d3d3",
    ZgYF: "90ee90",
    ZgYy: "d3d3d3",
    ZpRk: "ffb6c1",
    ZsOmon: "ffa07a",
    ZsHgYF: "20b2aa",
    ZskyXe: "87cefa",
    ZUWay: "778899",
    ZUgYy: "778899",
    ZstAlXe: "b0c4de",
    ZLw: "ffffe0",
    lime: "ff00",
    limegYF: "32cd32",
    lRF: "faf0e6",
    magFta: "ff00ff",
    maPon: "800000",
    VaquamarRe: "66cdaa",
    VXe: "cd",
    VScEd: "ba55d3",
    VpurpN: "9370db",
    VsHgYF: "3cb371",
    VUXe: "7b68ee",
    VsprRggYF: "fa9a",
    VQe: "48d1cc",
    VviTetYd: "c71585",
    midnightXe: "191970",
    mRtcYam: "f5fffa",
    mistyPse: "ffe4e1",
    moccasR: "ffe4b5",
    navajowEte: "ffdead",
    navy: "80",
    Tdlace: "fdf5e6",
    Tive: "808000",
    TivedBb: "6b8e23",
    Sange: "ffa500",
    SangeYd: "ff4500",
    ScEd: "da70d6",
    pOegTMnPd: "eee8aa",
    pOegYF: "98fb98",
    pOeQe: "afeeee",
    pOeviTetYd: "db7093",
    papayawEp: "ffefd5",
    pHKpuff: "ffdab9",
    peru: "cd853f",
    pRk: "ffc0cb",
    plum: "dda0dd",
    powMrXe: "b0e0e6",
    purpN: "800080",
    YbeccapurpN: "663399",
    Yd: "ff0000",
    Psybrown: "bc8f8f",
    PyOXe: "4169e1",
    saddNbPwn: "8b4513",
    sOmon: "fa8072",
    sandybPwn: "f4a460",
    sHgYF: "2e8b57",
    sHshell: "fff5ee",
    siFna: "a0522d",
    silver: "c0c0c0",
    skyXe: "87ceeb",
    UXe: "6a5acd",
    UWay: "708090",
    UgYy: "708090",
    snow: "fffafa",
    sprRggYF: "ff7f",
    stAlXe: "4682b4",
    tan: "d2b48c",
    teO: "8080",
    tEstN: "d8bfd8",
    tomato: "ff6347",
    Qe: "40e0d0",
    viTet: "ee82ee",
    JHt: "f5deb3",
    wEte: "ffffff",
    wEtesmoke: "f5f5f5",
    Lw: "ffff00",
    LwgYF: "9acd32"
  };
  function unpack() {
    const unpacked = {};
    const keys = Object.keys(names$1);
    const tkeys = Object.keys(map);
    let i3, j, k2, ok, nk;
    for (i3 = 0; i3 < keys.length; i3++) {
      ok = nk = keys[i3];
      for (j = 0; j < tkeys.length; j++) {
        k2 = tkeys[j];
        nk = nk.replace(k2, map[k2]);
      }
      k2 = parseInt(names$1[ok], 16);
      unpacked[nk] = [k2 >> 16 & 255, k2 >> 8 & 255, k2 & 255];
    }
    return unpacked;
  }
  var names;
  function nameParse(str) {
    if (!names) {
      names = unpack();
      names.transparent = [0, 0, 0, 0];
    }
    const a4 = names[str.toLowerCase()];
    return a4 && {
      r: a4[0],
      g: a4[1],
      b: a4[2],
      a: a4.length === 4 ? a4[3] : 255
    };
  }
  var RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
  function rgbParse(str) {
    const m3 = RGB_RE.exec(str);
    let a4 = 255;
    let r2, g, b2;
    if (!m3) {
      return;
    }
    if (m3[7] !== r2) {
      const v = +m3[7];
      a4 = m3[8] ? p2b(v) : lim(v * 255, 0, 255);
    }
    r2 = +m3[1];
    g = +m3[3];
    b2 = +m3[5];
    r2 = 255 & (m3[2] ? p2b(r2) : lim(r2, 0, 255));
    g = 255 & (m3[4] ? p2b(g) : lim(g, 0, 255));
    b2 = 255 & (m3[6] ? p2b(b2) : lim(b2, 0, 255));
    return {
      r: r2,
      g,
      b: b2,
      a: a4
    };
  }
  function rgbString(v) {
    return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);
  }
  var to = (v) => v <= 31308e-7 ? v * 12.92 : Math.pow(v, 1 / 2.4) * 1.055 - 0.055;
  var from = (v) => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
  function interpolate2(rgb1, rgb2, t2) {
    const r2 = from(b2n(rgb1.r));
    const g = from(b2n(rgb1.g));
    const b2 = from(b2n(rgb1.b));
    return {
      r: n2b(to(r2 + t2 * (from(b2n(rgb2.r)) - r2))),
      g: n2b(to(g + t2 * (from(b2n(rgb2.g)) - g))),
      b: n2b(to(b2 + t2 * (from(b2n(rgb2.b)) - b2))),
      a: rgb1.a + t2 * (rgb2.a - rgb1.a)
    };
  }
  function modHSL(v, i3, ratio) {
    if (v) {
      let tmp = rgb2hsl(v);
      tmp[i3] = Math.max(0, Math.min(tmp[i3] + tmp[i3] * ratio, i3 === 0 ? 360 : 1));
      tmp = hsl2rgb(tmp);
      v.r = tmp[0];
      v.g = tmp[1];
      v.b = tmp[2];
    }
  }
  function clone(v, proto) {
    return v ? Object.assign(proto || {}, v) : v;
  }
  function fromObject(input) {
    var v = { r: 0, g: 0, b: 0, a: 255 };
    if (Array.isArray(input)) {
      if (input.length >= 3) {
        v = { r: input[0], g: input[1], b: input[2], a: 255 };
        if (input.length > 3) {
          v.a = n2b(input[3]);
        }
      }
    } else {
      v = clone(input, { r: 0, g: 0, b: 0, a: 1 });
      v.a = n2b(v.a);
    }
    return v;
  }
  function functionParse(str) {
    if (str.charAt(0) === "r") {
      return rgbParse(str);
    }
    return hueParse(str);
  }
  var Color = class {
    constructor(input) {
      if (input instanceof Color) {
        return input;
      }
      const type = typeof input;
      let v;
      if (type === "object") {
        v = fromObject(input);
      } else if (type === "string") {
        v = hexParse(input) || nameParse(input) || functionParse(input);
      }
      this._rgb = v;
      this._valid = !!v;
    }
    get valid() {
      return this._valid;
    }
    get rgb() {
      var v = clone(this._rgb);
      if (v) {
        v.a = b2n(v.a);
      }
      return v;
    }
    set rgb(obj) {
      this._rgb = fromObject(obj);
    }
    rgbString() {
      return this._valid ? rgbString(this._rgb) : void 0;
    }
    hexString() {
      return this._valid ? hexString(this._rgb) : void 0;
    }
    hslString() {
      return this._valid ? hslString(this._rgb) : void 0;
    }
    mix(color2, weight) {
      if (color2) {
        const c1 = this.rgb;
        const c2 = color2.rgb;
        let w2;
        const p = weight === w2 ? 0.5 : weight;
        const w3 = 2 * p - 1;
        const a4 = c1.a - c2.a;
        const w1 = ((w3 * a4 === -1 ? w3 : (w3 + a4) / (1 + w3 * a4)) + 1) / 2;
        w2 = 1 - w1;
        c1.r = 255 & w1 * c1.r + w2 * c2.r + 0.5;
        c1.g = 255 & w1 * c1.g + w2 * c2.g + 0.5;
        c1.b = 255 & w1 * c1.b + w2 * c2.b + 0.5;
        c1.a = p * c1.a + (1 - p) * c2.a;
        this.rgb = c1;
      }
      return this;
    }
    interpolate(color2, t2) {
      if (color2) {
        this._rgb = interpolate2(this._rgb, color2._rgb, t2);
      }
      return this;
    }
    clone() {
      return new Color(this.rgb);
    }
    alpha(a4) {
      this._rgb.a = n2b(a4);
      return this;
    }
    clearer(ratio) {
      const rgb = this._rgb;
      rgb.a *= 1 - ratio;
      return this;
    }
    greyscale() {
      const rgb = this._rgb;
      const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
      rgb.r = rgb.g = rgb.b = val;
      return this;
    }
    opaquer(ratio) {
      const rgb = this._rgb;
      rgb.a *= 1 + ratio;
      return this;
    }
    negate() {
      const v = this._rgb;
      v.r = 255 - v.r;
      v.g = 255 - v.g;
      v.b = 255 - v.b;
      return this;
    }
    lighten(ratio) {
      modHSL(this._rgb, 2, ratio);
      return this;
    }
    darken(ratio) {
      modHSL(this._rgb, 2, -ratio);
      return this;
    }
    saturate(ratio) {
      modHSL(this._rgb, 1, ratio);
      return this;
    }
    desaturate(ratio) {
      modHSL(this._rgb, 1, -ratio);
      return this;
    }
    rotate(deg) {
      rotate(this._rgb, deg);
      return this;
    }
  };

  // ../../node_modules/chart.js/dist/chunks/helpers.segment.js
  function noop() {
  }
  var uid = (() => {
    let id = 0;
    return () => id++;
  })();
  function isNullOrUndef(value) {
    return value === null || typeof value === "undefined";
  }
  function isArray2(value) {
    if (Array.isArray && Array.isArray(value)) {
      return true;
    }
    const type = Object.prototype.toString.call(value);
    if (type.slice(0, 7) === "[object" && type.slice(-6) === "Array]") {
      return true;
    }
    return false;
  }
  function isObject(value) {
    return value !== null && Object.prototype.toString.call(value) === "[object Object]";
  }
  function isNumberFinite(value) {
    return (typeof value === "number" || value instanceof Number) && isFinite(+value);
  }
  function finiteOrDefault(value, defaultValue) {
    return isNumberFinite(value) ? value : defaultValue;
  }
  function valueOrDefault(value, defaultValue) {
    return typeof value === "undefined" ? defaultValue : value;
  }
  var toPercentage = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 : +value / dimension;
  var toDimension = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
  function callback(fn2, args, thisArg) {
    if (fn2 && typeof fn2.call === "function") {
      return fn2.apply(thisArg, args);
    }
  }
  function each(loopable, fn2, thisArg, reverse) {
    let i3, len, keys;
    if (isArray2(loopable)) {
      len = loopable.length;
      if (reverse) {
        for (i3 = len - 1; i3 >= 0; i3--) {
          fn2.call(thisArg, loopable[i3], i3);
        }
      } else {
        for (i3 = 0; i3 < len; i3++) {
          fn2.call(thisArg, loopable[i3], i3);
        }
      }
    } else if (isObject(loopable)) {
      keys = Object.keys(loopable);
      len = keys.length;
      for (i3 = 0; i3 < len; i3++) {
        fn2.call(thisArg, loopable[keys[i3]], keys[i3]);
      }
    }
  }
  function _elementsEqual(a0, a1) {
    let i3, ilen, v0, v1;
    if (!a0 || !a1 || a0.length !== a1.length) {
      return false;
    }
    for (i3 = 0, ilen = a0.length; i3 < ilen; ++i3) {
      v0 = a0[i3];
      v1 = a1[i3];
      if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
        return false;
      }
    }
    return true;
  }
  function clone2(source) {
    if (isArray2(source)) {
      return source.map(clone2);
    }
    if (isObject(source)) {
      const target = Object.create(null);
      const keys = Object.keys(source);
      const klen = keys.length;
      let k2 = 0;
      for (; k2 < klen; ++k2) {
        target[keys[k2]] = clone2(source[keys[k2]]);
      }
      return target;
    }
    return source;
  }
  function isValidKey(key) {
    return [
      "__proto__",
      "prototype",
      "constructor"
    ].indexOf(key) === -1;
  }
  function _merger(key, target, source, options2) {
    if (!isValidKey(key)) {
      return;
    }
    const tval = target[key];
    const sval = source[key];
    if (isObject(tval) && isObject(sval)) {
      merge2(tval, sval, options2);
    } else {
      target[key] = clone2(sval);
    }
  }
  function merge2(target, source, options2) {
    const sources = isArray2(source) ? source : [
      source
    ];
    const ilen = sources.length;
    if (!isObject(target)) {
      return target;
    }
    options2 = options2 || {};
    const merger = options2.merger || _merger;
    let current;
    for (let i3 = 0; i3 < ilen; ++i3) {
      current = sources[i3];
      if (!isObject(current)) {
        continue;
      }
      const keys = Object.keys(current);
      for (let k2 = 0, klen = keys.length; k2 < klen; ++k2) {
        merger(keys[k2], target, current, options2);
      }
    }
    return target;
  }
  function mergeIf(target, source) {
    return merge2(target, source, {
      merger: _mergerIf
    });
  }
  function _mergerIf(key, target, source) {
    if (!isValidKey(key)) {
      return;
    }
    const tval = target[key];
    const sval = source[key];
    if (isObject(tval) && isObject(sval)) {
      mergeIf(tval, sval);
    } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
      target[key] = clone2(sval);
    }
  }
  var keyResolvers = {
    "": (v) => v,
    x: (o2) => o2.x,
    y: (o2) => o2.y
  };
  function _splitKey(key) {
    const parts = key.split(".");
    const keys = [];
    let tmp = "";
    for (const part of parts) {
      tmp += part;
      if (tmp.endsWith("\\")) {
        tmp = tmp.slice(0, -1) + ".";
      } else {
        keys.push(tmp);
        tmp = "";
      }
    }
    return keys;
  }
  function _getKeyResolver(key) {
    const keys = _splitKey(key);
    return (obj) => {
      for (const k2 of keys) {
        if (k2 === "") {
          break;
        }
        obj = obj && obj[k2];
      }
      return obj;
    };
  }
  function resolveObjectKey(obj, key) {
    const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
    return resolver(obj);
  }
  function _capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
  var defined = (value) => typeof value !== "undefined";
  var isFunction2 = (value) => typeof value === "function";
  var setsEqual = (a4, b2) => {
    if (a4.size !== b2.size) {
      return false;
    }
    for (const item of a4) {
      if (!b2.has(item)) {
        return false;
      }
    }
    return true;
  };
  function _isClickEvent(e3) {
    return e3.type === "mouseup" || e3.type === "click" || e3.type === "contextmenu";
  }
  var PI = Math.PI;
  var TAU = 2 * PI;
  var PITAU = TAU + PI;
  var INFINITY = Number.POSITIVE_INFINITY;
  var RAD_PER_DEG = PI / 180;
  var HALF_PI = PI / 2;
  var QUARTER_PI = PI / 4;
  var TWO_THIRDS_PI = PI * 2 / 3;
  var log10 = Math.log10;
  var sign = Math.sign;
  function almostEquals(x2, y3, epsilon) {
    return Math.abs(x2 - y3) < epsilon;
  }
  function niceNum(range) {
    const roundedRange = Math.round(range);
    range = almostEquals(range, roundedRange, range / 1e3) ? roundedRange : range;
    const niceRange = Math.pow(10, Math.floor(log10(range)));
    const fraction = range / niceRange;
    const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
    return niceFraction * niceRange;
  }
  function _factorize(value) {
    const result = [];
    const sqrt = Math.sqrt(value);
    let i3;
    for (i3 = 1; i3 < sqrt; i3++) {
      if (value % i3 === 0) {
        result.push(i3);
        result.push(value / i3);
      }
    }
    if (sqrt === (sqrt | 0)) {
      result.push(sqrt);
    }
    result.sort((a4, b2) => a4 - b2).pop();
    return result;
  }
  function isNumber2(n2) {
    return !isNaN(parseFloat(n2)) && isFinite(n2);
  }
  function almostWhole(x2, epsilon) {
    const rounded = Math.round(x2);
    return rounded - epsilon <= x2 && rounded + epsilon >= x2;
  }
  function _setMinAndMaxByKey(array, target, property) {
    let i3, ilen, value;
    for (i3 = 0, ilen = array.length; i3 < ilen; i3++) {
      value = array[i3][property];
      if (!isNaN(value)) {
        target.min = Math.min(target.min, value);
        target.max = Math.max(target.max, value);
      }
    }
  }
  function toRadians(degrees) {
    return degrees * (PI / 180);
  }
  function toDegrees(radians) {
    return radians * (180 / PI);
  }
  function _decimalPlaces(x2) {
    if (!isNumberFinite(x2)) {
      return;
    }
    let e3 = 1;
    let p = 0;
    while (Math.round(x2 * e3) / e3 !== x2) {
      e3 *= 10;
      p++;
    }
    return p;
  }
  function getAngleFromPoint(centrePoint, anglePoint) {
    const distanceFromXCenter = anglePoint.x - centrePoint.x;
    const distanceFromYCenter = anglePoint.y - centrePoint.y;
    const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
    let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
    if (angle < -0.5 * PI) {
      angle += TAU;
    }
    return {
      angle,
      distance: radialDistanceFromCenter
    };
  }
  function distanceBetweenPoints(pt1, pt2) {
    return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
  }
  function _angleDiff(a4, b2) {
    return (a4 - b2 + PITAU) % TAU - PI;
  }
  function _normalizeAngle(a4) {
    return (a4 % TAU + TAU) % TAU;
  }
  function _angleBetween(angle, start3, end2, sameAngleIsFullCircle) {
    const a4 = _normalizeAngle(angle);
    const s4 = _normalizeAngle(start3);
    const e3 = _normalizeAngle(end2);
    const angleToStart = _normalizeAngle(s4 - a4);
    const angleToEnd = _normalizeAngle(e3 - a4);
    const startToAngle = _normalizeAngle(a4 - s4);
    const endToAngle = _normalizeAngle(a4 - e3);
    return a4 === s4 || a4 === e3 || sameAngleIsFullCircle && s4 === e3 || angleToStart > angleToEnd && startToAngle < endToAngle;
  }
  function _limitValue(value, min2, max2) {
    return Math.max(min2, Math.min(max2, value));
  }
  function _int16Range(value) {
    return _limitValue(value, -32768, 32767);
  }
  function _isBetween(value, start3, end2, epsilon = 1e-6) {
    return value >= Math.min(start3, end2) - epsilon && value <= Math.max(start3, end2) + epsilon;
  }
  function _lookup(table, value, cmp) {
    cmp = cmp || ((index2) => table[index2] < value);
    let hi = table.length - 1;
    let lo = 0;
    let mid;
    while (hi - lo > 1) {
      mid = lo + hi >> 1;
      if (cmp(mid)) {
        lo = mid;
      } else {
        hi = mid;
      }
    }
    return {
      lo,
      hi
    };
  }
  var _lookupByKey = (table, key, value, last) => _lookup(table, value, last ? (index2) => {
    const ti = table[index2][key];
    return ti < value || ti === value && table[index2 + 1][key] === value;
  } : (index2) => table[index2][key] < value);
  var _rlookupByKey = (table, key, value) => _lookup(table, value, (index2) => table[index2][key] >= value);
  function _filterBetween(values, min2, max2) {
    let start3 = 0;
    let end2 = values.length;
    while (start3 < end2 && values[start3] < min2) {
      start3++;
    }
    while (end2 > start3 && values[end2 - 1] > max2) {
      end2--;
    }
    return start3 > 0 || end2 < values.length ? values.slice(start3, end2) : values;
  }
  var arrayEvents = [
    "push",
    "pop",
    "shift",
    "splice",
    "unshift"
  ];
  function listenArrayEvents(array, listener) {
    if (array._chartjs) {
      array._chartjs.listeners.push(listener);
      return;
    }
    Object.defineProperty(array, "_chartjs", {
      configurable: true,
      enumerable: false,
      value: {
        listeners: [
          listener
        ]
      }
    });
    arrayEvents.forEach((key) => {
      const method = "_onData" + _capitalize(key);
      const base = array[key];
      Object.defineProperty(array, key, {
        configurable: true,
        enumerable: false,
        value(...args) {
          const res = base.apply(this, args);
          array._chartjs.listeners.forEach((object) => {
            if (typeof object[method] === "function") {
              object[method](...args);
            }
          });
          return res;
        }
      });
    });
  }
  function unlistenArrayEvents(array, listener) {
    const stub = array._chartjs;
    if (!stub) {
      return;
    }
    const listeners = stub.listeners;
    const index2 = listeners.indexOf(listener);
    if (index2 !== -1) {
      listeners.splice(index2, 1);
    }
    if (listeners.length > 0) {
      return;
    }
    arrayEvents.forEach((key) => {
      delete array[key];
    });
    delete array._chartjs;
  }
  function _arrayUnique(items) {
    const set2 = /* @__PURE__ */ new Set();
    let i3, ilen;
    for (i3 = 0, ilen = items.length; i3 < ilen; ++i3) {
      set2.add(items[i3]);
    }
    if (set2.size === ilen) {
      return items;
    }
    return Array.from(set2);
  }
  var requestAnimFrame = function() {
    if (typeof window === "undefined") {
      return function(callback2) {
        return callback2();
      };
    }
    return window.requestAnimationFrame;
  }();
  function throttled(fn2, thisArg) {
    let argsToUse = [];
    let ticking = false;
    return function(...args) {
      argsToUse = args;
      if (!ticking) {
        ticking = true;
        requestAnimFrame.call(window, () => {
          ticking = false;
          fn2.apply(thisArg, argsToUse);
        });
      }
    };
  }
  function debounce(fn2, delay) {
    let timeout;
    return function(...args) {
      if (delay) {
        clearTimeout(timeout);
        timeout = setTimeout(fn2, delay, args);
      } else {
        fn2.apply(this, args);
      }
      return delay;
    };
  }
  var _toLeftRightCenter = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
  var _alignStartEnd = (align, start3, end2) => align === "start" ? start3 : align === "end" ? end2 : (start3 + end2) / 2;
  var _textX = (align, left2, right2, rtl) => {
    const check = rtl ? "left" : "right";
    return align === check ? right2 : align === "center" ? (left2 + right2) / 2 : left2;
  };
  function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
    const pointCount = points.length;
    let start3 = 0;
    let count = pointCount;
    if (meta._sorted) {
      const { iScale, _parsed } = meta;
      const axis = iScale.axis;
      const { min: min2, max: max2, minDefined, maxDefined } = iScale.getUserBounds();
      if (minDefined) {
        start3 = _limitValue(Math.min(_lookupByKey(_parsed, iScale.axis, min2).lo, animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min2)).lo), 0, pointCount - 1);
      }
      if (maxDefined) {
        count = _limitValue(Math.max(_lookupByKey(_parsed, iScale.axis, max2, true).hi + 1, animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max2), true).hi + 1), start3, pointCount) - start3;
      } else {
        count = pointCount - start3;
      }
    }
    return {
      start: start3,
      count
    };
  }
  function _scaleRangesChanged(meta) {
    const { xScale, yScale, _scaleRanges } = meta;
    const newRanges = {
      xmin: xScale.min,
      xmax: xScale.max,
      ymin: yScale.min,
      ymax: yScale.max
    };
    if (!_scaleRanges) {
      meta._scaleRanges = newRanges;
      return true;
    }
    const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
    Object.assign(_scaleRanges, newRanges);
    return changed;
  }
  var atEdge = (t2) => t2 === 0 || t2 === 1;
  var elasticIn = (t2, s4, p) => -(Math.pow(2, 10 * (t2 -= 1)) * Math.sin((t2 - s4) * TAU / p));
  var elasticOut = (t2, s4, p) => Math.pow(2, -10 * t2) * Math.sin((t2 - s4) * TAU / p) + 1;
  var effects = {
    linear: (t2) => t2,
    easeInQuad: (t2) => t2 * t2,
    easeOutQuad: (t2) => -t2 * (t2 - 2),
    easeInOutQuad: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 : -0.5 * (--t2 * (t2 - 2) - 1),
    easeInCubic: (t2) => t2 * t2 * t2,
    easeOutCubic: (t2) => (t2 -= 1) * t2 * t2 + 1,
    easeInOutCubic: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 : 0.5 * ((t2 -= 2) * t2 * t2 + 2),
    easeInQuart: (t2) => t2 * t2 * t2 * t2,
    easeOutQuart: (t2) => -((t2 -= 1) * t2 * t2 * t2 - 1),
    easeInOutQuart: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 * t2 : -0.5 * ((t2 -= 2) * t2 * t2 * t2 - 2),
    easeInQuint: (t2) => t2 * t2 * t2 * t2 * t2,
    easeOutQuint: (t2) => (t2 -= 1) * t2 * t2 * t2 * t2 + 1,
    easeInOutQuint: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 * t2 * t2 : 0.5 * ((t2 -= 2) * t2 * t2 * t2 * t2 + 2),
    easeInSine: (t2) => -Math.cos(t2 * HALF_PI) + 1,
    easeOutSine: (t2) => Math.sin(t2 * HALF_PI),
    easeInOutSine: (t2) => -0.5 * (Math.cos(PI * t2) - 1),
    easeInExpo: (t2) => t2 === 0 ? 0 : Math.pow(2, 10 * (t2 - 1)),
    easeOutExpo: (t2) => t2 === 1 ? 1 : -Math.pow(2, -10 * t2) + 1,
    easeInOutExpo: (t2) => atEdge(t2) ? t2 : t2 < 0.5 ? 0.5 * Math.pow(2, 10 * (t2 * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t2 * 2 - 1)) + 2),
    easeInCirc: (t2) => t2 >= 1 ? t2 : -(Math.sqrt(1 - t2 * t2) - 1),
    easeOutCirc: (t2) => Math.sqrt(1 - (t2 -= 1) * t2),
    easeInOutCirc: (t2) => (t2 /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t2 * t2) - 1) : 0.5 * (Math.sqrt(1 - (t2 -= 2) * t2) + 1),
    easeInElastic: (t2) => atEdge(t2) ? t2 : elasticIn(t2, 0.075, 0.3),
    easeOutElastic: (t2) => atEdge(t2) ? t2 : elasticOut(t2, 0.075, 0.3),
    easeInOutElastic(t2) {
      const s4 = 0.1125;
      const p = 0.45;
      return atEdge(t2) ? t2 : t2 < 0.5 ? 0.5 * elasticIn(t2 * 2, s4, p) : 0.5 + 0.5 * elasticOut(t2 * 2 - 1, s4, p);
    },
    easeInBack(t2) {
      const s4 = 1.70158;
      return t2 * t2 * ((s4 + 1) * t2 - s4);
    },
    easeOutBack(t2) {
      const s4 = 1.70158;
      return (t2 -= 1) * t2 * ((s4 + 1) * t2 + s4) + 1;
    },
    easeInOutBack(t2) {
      let s4 = 1.70158;
      if ((t2 /= 0.5) < 1) {
        return 0.5 * (t2 * t2 * (((s4 *= 1.525) + 1) * t2 - s4));
      }
      return 0.5 * ((t2 -= 2) * t2 * (((s4 *= 1.525) + 1) * t2 + s4) + 2);
    },
    easeInBounce: (t2) => 1 - effects.easeOutBounce(1 - t2),
    easeOutBounce(t2) {
      const m3 = 7.5625;
      const d3 = 2.75;
      if (t2 < 1 / d3) {
        return m3 * t2 * t2;
      }
      if (t2 < 2 / d3) {
        return m3 * (t2 -= 1.5 / d3) * t2 + 0.75;
      }
      if (t2 < 2.5 / d3) {
        return m3 * (t2 -= 2.25 / d3) * t2 + 0.9375;
      }
      return m3 * (t2 -= 2.625 / d3) * t2 + 0.984375;
    },
    easeInOutBounce: (t2) => t2 < 0.5 ? effects.easeInBounce(t2 * 2) * 0.5 : effects.easeOutBounce(t2 * 2 - 1) * 0.5 + 0.5
  };
  function isPatternOrGradient(value) {
    if (value && typeof value === "object") {
      const type = value.toString();
      return type === "[object CanvasPattern]" || type === "[object CanvasGradient]";
    }
    return false;
  }
  function color(value) {
    return isPatternOrGradient(value) ? value : new Color(value);
  }
  function getHoverColor(value) {
    return isPatternOrGradient(value) ? value : new Color(value).saturate(0.5).darken(0.1).hexString();
  }
  var numbers = [
    "x",
    "y",
    "borderWidth",
    "radius",
    "tension"
  ];
  var colors = [
    "color",
    "borderColor",
    "backgroundColor"
  ];
  function applyAnimationsDefaults(defaults3) {
    defaults3.set("animation", {
      delay: void 0,
      duration: 1e3,
      easing: "easeOutQuart",
      fn: void 0,
      from: void 0,
      loop: void 0,
      to: void 0,
      type: void 0
    });
    defaults3.describe("animation", {
      _fallback: false,
      _indexable: false,
      _scriptable: (name2) => name2 !== "onProgress" && name2 !== "onComplete" && name2 !== "fn"
    });
    defaults3.set("animations", {
      colors: {
        type: "color",
        properties: colors
      },
      numbers: {
        type: "number",
        properties: numbers
      }
    });
    defaults3.describe("animations", {
      _fallback: "animation"
    });
    defaults3.set("transitions", {
      active: {
        animation: {
          duration: 400
        }
      },
      resize: {
        animation: {
          duration: 0
        }
      },
      show: {
        animations: {
          colors: {
            from: "transparent"
          },
          visible: {
            type: "boolean",
            duration: 0
          }
        }
      },
      hide: {
        animations: {
          colors: {
            to: "transparent"
          },
          visible: {
            type: "boolean",
            easing: "linear",
            fn: (v) => v | 0
          }
        }
      }
    });
  }
  function applyLayoutsDefaults(defaults3) {
    defaults3.set("layout", {
      autoPadding: true,
      padding: {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      }
    });
  }
  var intlCache = /* @__PURE__ */ new Map();
  function getNumberFormat(locale2, options2) {
    options2 = options2 || {};
    const cacheKey = locale2 + JSON.stringify(options2);
    let formatter = intlCache.get(cacheKey);
    if (!formatter) {
      formatter = new Intl.NumberFormat(locale2, options2);
      intlCache.set(cacheKey, formatter);
    }
    return formatter;
  }
  function formatNumber(num, locale2, options2) {
    return getNumberFormat(locale2, options2).format(num);
  }
  var formatters = {
    values(value) {
      return isArray2(value) ? value : "" + value;
    },
    numeric(tickValue, index2, ticks) {
      if (tickValue === 0) {
        return "0";
      }
      const locale2 = this.chart.options.locale;
      let notation;
      let delta = tickValue;
      if (ticks.length > 1) {
        const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
        if (maxTick < 1e-4 || maxTick > 1e15) {
          notation = "scientific";
        }
        delta = calculateDelta(tickValue, ticks);
      }
      const logDelta = log10(Math.abs(delta));
      const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
      const options2 = {
        notation,
        minimumFractionDigits: numDecimal,
        maximumFractionDigits: numDecimal
      };
      Object.assign(options2, this.options.ticks.format);
      return formatNumber(tickValue, locale2, options2);
    },
    logarithmic(tickValue, index2, ticks) {
      if (tickValue === 0) {
        return "0";
      }
      const remain = ticks[index2].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));
      if ([
        1,
        2,
        3,
        5,
        10,
        15
      ].includes(remain) || index2 > 0.8 * ticks.length) {
        return formatters.numeric.call(this, tickValue, index2, ticks);
      }
      return "";
    }
  };
  function calculateDelta(tickValue, ticks) {
    let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
    if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
      delta = tickValue - Math.floor(tickValue);
    }
    return delta;
  }
  var Ticks = {
    formatters
  };
  function applyScaleDefaults(defaults3) {
    defaults3.set("scale", {
      display: true,
      offset: false,
      reverse: false,
      beginAtZero: false,
      bounds: "ticks",
      grace: 0,
      grid: {
        display: true,
        lineWidth: 1,
        drawOnChartArea: true,
        drawTicks: true,
        tickLength: 8,
        tickWidth: (_ctx, options2) => options2.lineWidth,
        tickColor: (_ctx, options2) => options2.color,
        offset: false
      },
      border: {
        display: true,
        dash: [],
        dashOffset: 0,
        width: 1
      },
      title: {
        display: false,
        text: "",
        padding: {
          top: 4,
          bottom: 4
        }
      },
      ticks: {
        minRotation: 0,
        maxRotation: 50,
        mirror: false,
        textStrokeWidth: 0,
        textStrokeColor: "",
        padding: 3,
        display: true,
        autoSkip: true,
        autoSkipPadding: 3,
        labelOffset: 0,
        callback: Ticks.formatters.values,
        minor: {},
        major: {},
        align: "center",
        crossAlign: "near",
        showLabelBackdrop: false,
        backdropColor: "rgba(255, 255, 255, 0.75)",
        backdropPadding: 2
      }
    });
    defaults3.route("scale.ticks", "color", "", "color");
    defaults3.route("scale.grid", "color", "", "borderColor");
    defaults3.route("scale.border", "color", "", "borderColor");
    defaults3.route("scale.title", "color", "", "color");
    defaults3.describe("scale", {
      _fallback: false,
      _scriptable: (name2) => !name2.startsWith("before") && !name2.startsWith("after") && name2 !== "callback" && name2 !== "parser",
      _indexable: (name2) => name2 !== "borderDash" && name2 !== "tickBorderDash" && name2 !== "dash"
    });
    defaults3.describe("scales", {
      _fallback: "scale"
    });
    defaults3.describe("scale.ticks", {
      _scriptable: (name2) => name2 !== "backdropPadding" && name2 !== "callback",
      _indexable: (name2) => name2 !== "backdropPadding"
    });
  }
  var overrides = Object.create(null);
  var descriptors = Object.create(null);
  function getScope$1(node, key) {
    if (!key) {
      return node;
    }
    const keys = key.split(".");
    for (let i3 = 0, n2 = keys.length; i3 < n2; ++i3) {
      const k2 = keys[i3];
      node = node[k2] || (node[k2] = Object.create(null));
    }
    return node;
  }
  function set(root, scope, values) {
    if (typeof scope === "string") {
      return merge2(getScope$1(root, scope), values);
    }
    return merge2(getScope$1(root, ""), scope);
  }
  var Defaults = class {
    constructor(_descriptors2, _appliers) {
      this.animation = void 0;
      this.backgroundColor = "rgba(0,0,0,0.1)";
      this.borderColor = "rgba(0,0,0,0.1)";
      this.color = "#666";
      this.datasets = {};
      this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
      this.elements = {};
      this.events = [
        "mousemove",
        "mouseout",
        "click",
        "touchstart",
        "touchmove"
      ];
      this.font = {
        family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
        size: 12,
        style: "normal",
        lineHeight: 1.2,
        weight: null
      };
      this.hover = {};
      this.hoverBackgroundColor = (ctx, options2) => getHoverColor(options2.backgroundColor);
      this.hoverBorderColor = (ctx, options2) => getHoverColor(options2.borderColor);
      this.hoverColor = (ctx, options2) => getHoverColor(options2.color);
      this.indexAxis = "x";
      this.interaction = {
        mode: "nearest",
        intersect: true,
        includeInvisible: false
      };
      this.maintainAspectRatio = true;
      this.onHover = null;
      this.onClick = null;
      this.parsing = true;
      this.plugins = {};
      this.responsive = true;
      this.scale = void 0;
      this.scales = {};
      this.showLine = true;
      this.drawActiveElementsOnTop = true;
      this.describe(_descriptors2);
      this.apply(_appliers);
    }
    set(scope, values) {
      return set(this, scope, values);
    }
    get(scope) {
      return getScope$1(this, scope);
    }
    describe(scope, values) {
      return set(descriptors, scope, values);
    }
    override(scope, values) {
      return set(overrides, scope, values);
    }
    route(scope, name2, targetScope, targetName) {
      const scopeObject = getScope$1(this, scope);
      const targetScopeObject = getScope$1(this, targetScope);
      const privateName = "_" + name2;
      Object.defineProperties(scopeObject, {
        [privateName]: {
          value: scopeObject[name2],
          writable: true
        },
        [name2]: {
          enumerable: true,
          get() {
            const local = this[privateName];
            const target = targetScopeObject[targetName];
            if (isObject(local)) {
              return Object.assign({}, target, local);
            }
            return valueOrDefault(local, target);
          },
          set(value) {
            this[privateName] = value;
          }
        }
      });
    }
    apply(appliers) {
      appliers.forEach((apply) => apply(this));
    }
  };
  var defaults = /* @__PURE__ */ new Defaults({
    _scriptable: (name2) => !name2.startsWith("on"),
    _indexable: (name2) => name2 !== "events",
    hover: {
      _fallback: "interaction"
    },
    interaction: {
      _scriptable: false,
      _indexable: false
    }
  }, [
    applyAnimationsDefaults,
    applyLayoutsDefaults,
    applyScaleDefaults
  ]);
  function toFontString(font) {
    if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
      return null;
    }
    return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
  }
  function _measureText(ctx, data, gc, longest, string) {
    let textWidth = data[string];
    if (!textWidth) {
      textWidth = data[string] = ctx.measureText(string).width;
      gc.push(string);
    }
    if (textWidth > longest) {
      longest = textWidth;
    }
    return longest;
  }
  function _longestText(ctx, font, arrayOfThings, cache) {
    cache = cache || {};
    let data = cache.data = cache.data || {};
    let gc = cache.garbageCollect = cache.garbageCollect || [];
    if (cache.font !== font) {
      data = cache.data = {};
      gc = cache.garbageCollect = [];
      cache.font = font;
    }
    ctx.save();
    ctx.font = font;
    let longest = 0;
    const ilen = arrayOfThings.length;
    let i3, j, jlen, thing, nestedThing;
    for (i3 = 0; i3 < ilen; i3++) {
      thing = arrayOfThings[i3];
      if (thing !== void 0 && thing !== null && isArray2(thing) !== true) {
        longest = _measureText(ctx, data, gc, longest, thing);
      } else if (isArray2(thing)) {
        for (j = 0, jlen = thing.length; j < jlen; j++) {
          nestedThing = thing[j];
          if (nestedThing !== void 0 && nestedThing !== null && !isArray2(nestedThing)) {
            longest = _measureText(ctx, data, gc, longest, nestedThing);
          }
        }
      }
    }
    ctx.restore();
    const gcLen = gc.length / 2;
    if (gcLen > arrayOfThings.length) {
      for (i3 = 0; i3 < gcLen; i3++) {
        delete data[gc[i3]];
      }
      gc.splice(0, gcLen);
    }
    return longest;
  }
  function _alignPixel(chart, pixel, width) {
    const devicePixelRatio = chart.currentDevicePixelRatio;
    const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
    return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
  }
  function clearCanvas(canvas, ctx) {
    ctx = ctx || canvas.getContext("2d");
    ctx.save();
    ctx.resetTransform();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.restore();
  }
  function drawPoint(ctx, options2, x2, y3) {
    drawPointLegend(ctx, options2, x2, y3, null);
  }
  function drawPointLegend(ctx, options2, x2, y3, w2) {
    let type, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;
    const style = options2.pointStyle;
    const rotation = options2.rotation;
    const radius = options2.radius;
    let rad = (rotation || 0) * RAD_PER_DEG;
    if (style && typeof style === "object") {
      type = style.toString();
      if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
        ctx.save();
        ctx.translate(x2, y3);
        ctx.rotate(rad);
        ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
        ctx.restore();
        return;
      }
    }
    if (isNaN(radius) || radius <= 0) {
      return;
    }
    ctx.beginPath();
    switch (style) {
      default:
        if (w2) {
          ctx.ellipse(x2, y3, w2 / 2, radius, 0, 0, TAU);
        } else {
          ctx.arc(x2, y3, radius, 0, TAU);
        }
        ctx.closePath();
        break;
      case "triangle":
        width = w2 ? w2 / 2 : radius;
        ctx.moveTo(x2 + Math.sin(rad) * width, y3 - Math.cos(rad) * radius);
        rad += TWO_THIRDS_PI;
        ctx.lineTo(x2 + Math.sin(rad) * width, y3 - Math.cos(rad) * radius);
        rad += TWO_THIRDS_PI;
        ctx.lineTo(x2 + Math.sin(rad) * width, y3 - Math.cos(rad) * radius);
        ctx.closePath();
        break;
      case "rectRounded":
        cornerRadius = radius * 0.516;
        size = radius - cornerRadius;
        xOffset = Math.cos(rad + QUARTER_PI) * size;
        xOffsetW = Math.cos(rad + QUARTER_PI) * (w2 ? w2 / 2 - cornerRadius : size);
        yOffset = Math.sin(rad + QUARTER_PI) * size;
        yOffsetW = Math.sin(rad + QUARTER_PI) * (w2 ? w2 / 2 - cornerRadius : size);
        ctx.arc(x2 - xOffsetW, y3 - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
        ctx.arc(x2 + yOffsetW, y3 - xOffset, cornerRadius, rad - HALF_PI, rad);
        ctx.arc(x2 + xOffsetW, y3 + yOffset, cornerRadius, rad, rad + HALF_PI);
        ctx.arc(x2 - yOffsetW, y3 + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
        ctx.closePath();
        break;
      case "rect":
        if (!rotation) {
          size = Math.SQRT1_2 * radius;
          width = w2 ? w2 / 2 : size;
          ctx.rect(x2 - width, y3 - size, 2 * width, 2 * size);
          break;
        }
        rad += QUARTER_PI;
      case "rectRot":
        xOffsetW = Math.cos(rad) * (w2 ? w2 / 2 : radius);
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        yOffsetW = Math.sin(rad) * (w2 ? w2 / 2 : radius);
        ctx.moveTo(x2 - xOffsetW, y3 - yOffset);
        ctx.lineTo(x2 + yOffsetW, y3 - xOffset);
        ctx.lineTo(x2 + xOffsetW, y3 + yOffset);
        ctx.lineTo(x2 - yOffsetW, y3 + xOffset);
        ctx.closePath();
        break;
      case "crossRot":
        rad += QUARTER_PI;
      case "cross":
        xOffsetW = Math.cos(rad) * (w2 ? w2 / 2 : radius);
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        yOffsetW = Math.sin(rad) * (w2 ? w2 / 2 : radius);
        ctx.moveTo(x2 - xOffsetW, y3 - yOffset);
        ctx.lineTo(x2 + xOffsetW, y3 + yOffset);
        ctx.moveTo(x2 + yOffsetW, y3 - xOffset);
        ctx.lineTo(x2 - yOffsetW, y3 + xOffset);
        break;
      case "star":
        xOffsetW = Math.cos(rad) * (w2 ? w2 / 2 : radius);
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        yOffsetW = Math.sin(rad) * (w2 ? w2 / 2 : radius);
        ctx.moveTo(x2 - xOffsetW, y3 - yOffset);
        ctx.lineTo(x2 + xOffsetW, y3 + yOffset);
        ctx.moveTo(x2 + yOffsetW, y3 - xOffset);
        ctx.lineTo(x2 - yOffsetW, y3 + xOffset);
        rad += QUARTER_PI;
        xOffsetW = Math.cos(rad) * (w2 ? w2 / 2 : radius);
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        yOffsetW = Math.sin(rad) * (w2 ? w2 / 2 : radius);
        ctx.moveTo(x2 - xOffsetW, y3 - yOffset);
        ctx.lineTo(x2 + xOffsetW, y3 + yOffset);
        ctx.moveTo(x2 + yOffsetW, y3 - xOffset);
        ctx.lineTo(x2 - yOffsetW, y3 + xOffset);
        break;
      case "line":
        xOffset = w2 ? w2 / 2 : Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        ctx.moveTo(x2 - xOffset, y3 - yOffset);
        ctx.lineTo(x2 + xOffset, y3 + yOffset);
        break;
      case "dash":
        ctx.moveTo(x2, y3);
        ctx.lineTo(x2 + Math.cos(rad) * (w2 ? w2 / 2 : radius), y3 + Math.sin(rad) * radius);
        break;
      case false:
        ctx.closePath();
        break;
    }
    ctx.fill();
    if (options2.borderWidth > 0) {
      ctx.stroke();
    }
  }
  function _isPointInArea(point, area, margin) {
    margin = margin || 0.5;
    return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
  }
  function clipArea(ctx, area) {
    ctx.save();
    ctx.beginPath();
    ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
    ctx.clip();
  }
  function unclipArea(ctx) {
    ctx.restore();
  }
  function _steppedLineTo(ctx, previous, target, flip2, mode) {
    if (!previous) {
      return ctx.lineTo(target.x, target.y);
    }
    if (mode === "middle") {
      const midpoint = (previous.x + target.x) / 2;
      ctx.lineTo(midpoint, previous.y);
      ctx.lineTo(midpoint, target.y);
    } else if (mode === "after" !== !!flip2) {
      ctx.lineTo(previous.x, target.y);
    } else {
      ctx.lineTo(target.x, previous.y);
    }
    ctx.lineTo(target.x, target.y);
  }
  function _bezierCurveTo(ctx, previous, target, flip2) {
    if (!previous) {
      return ctx.lineTo(target.x, target.y);
    }
    ctx.bezierCurveTo(flip2 ? previous.cp1x : previous.cp2x, flip2 ? previous.cp1y : previous.cp2y, flip2 ? target.cp2x : target.cp1x, flip2 ? target.cp2y : target.cp1y, target.x, target.y);
  }
  function renderText(ctx, text, x2, y3, font, opts = {}) {
    const lines = isArray2(text) ? text : [
      text
    ];
    const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
    let i3, line;
    ctx.save();
    ctx.font = font.string;
    setRenderOpts(ctx, opts);
    for (i3 = 0; i3 < lines.length; ++i3) {
      line = lines[i3];
      if (opts.backdrop) {
        drawBackdrop(ctx, opts.backdrop);
      }
      if (stroke) {
        if (opts.strokeColor) {
          ctx.strokeStyle = opts.strokeColor;
        }
        if (!isNullOrUndef(opts.strokeWidth)) {
          ctx.lineWidth = opts.strokeWidth;
        }
        ctx.strokeText(line, x2, y3, opts.maxWidth);
      }
      ctx.fillText(line, x2, y3, opts.maxWidth);
      decorateText(ctx, x2, y3, line, opts);
      y3 += font.lineHeight;
    }
    ctx.restore();
  }
  function setRenderOpts(ctx, opts) {
    if (opts.translation) {
      ctx.translate(opts.translation[0], opts.translation[1]);
    }
    if (!isNullOrUndef(opts.rotation)) {
      ctx.rotate(opts.rotation);
    }
    if (opts.color) {
      ctx.fillStyle = opts.color;
    }
    if (opts.textAlign) {
      ctx.textAlign = opts.textAlign;
    }
    if (opts.textBaseline) {
      ctx.textBaseline = opts.textBaseline;
    }
  }
  function decorateText(ctx, x2, y3, line, opts) {
    if (opts.strikethrough || opts.underline) {
      const metrics = ctx.measureText(line);
      const left2 = x2 - metrics.actualBoundingBoxLeft;
      const right2 = x2 + metrics.actualBoundingBoxRight;
      const top2 = y3 - metrics.actualBoundingBoxAscent;
      const bottom2 = y3 + metrics.actualBoundingBoxDescent;
      const yDecoration = opts.strikethrough ? (top2 + bottom2) / 2 : bottom2;
      ctx.strokeStyle = ctx.fillStyle;
      ctx.beginPath();
      ctx.lineWidth = opts.decorationWidth || 2;
      ctx.moveTo(left2, yDecoration);
      ctx.lineTo(right2, yDecoration);
      ctx.stroke();
    }
  }
  function drawBackdrop(ctx, opts) {
    const oldColor = ctx.fillStyle;
    ctx.fillStyle = opts.color;
    ctx.fillRect(opts.left, opts.top, opts.width, opts.height);
    ctx.fillStyle = oldColor;
  }
  function addRoundedRectPath(ctx, rect) {
    const { x: x2, y: y3, w: w2, h: h5, radius } = rect;
    ctx.arc(x2 + radius.topLeft, y3 + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);
    ctx.lineTo(x2, y3 + h5 - radius.bottomLeft);
    ctx.arc(x2 + radius.bottomLeft, y3 + h5 - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
    ctx.lineTo(x2 + w2 - radius.bottomRight, y3 + h5);
    ctx.arc(x2 + w2 - radius.bottomRight, y3 + h5 - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
    ctx.lineTo(x2 + w2, y3 + radius.topRight);
    ctx.arc(x2 + w2 - radius.topRight, y3 + radius.topRight, radius.topRight, 0, -HALF_PI, true);
    ctx.lineTo(x2 + radius.topLeft, y3);
  }
  var LINE_HEIGHT = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/;
  var FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
  function toLineHeight(value, size) {
    const matches = ("" + value).match(LINE_HEIGHT);
    if (!matches || matches[1] === "normal") {
      return size * 1.2;
    }
    value = +matches[2];
    switch (matches[3]) {
      case "px":
        return value;
      case "%":
        value /= 100;
        break;
    }
    return size * value;
  }
  var numberOrZero = (v) => +v || 0;
  function _readValueToProps(value, props) {
    const ret = {};
    const objProps = isObject(props);
    const keys = objProps ? Object.keys(props) : props;
    const read2 = isObject(value) ? objProps ? (prop) => valueOrDefault(value[prop], value[props[prop]]) : (prop) => value[prop] : () => value;
    for (const prop of keys) {
      ret[prop] = numberOrZero(read2(prop));
    }
    return ret;
  }
  function toTRBL(value) {
    return _readValueToProps(value, {
      top: "y",
      right: "x",
      bottom: "y",
      left: "x"
    });
  }
  function toTRBLCorners(value) {
    return _readValueToProps(value, [
      "topLeft",
      "topRight",
      "bottomLeft",
      "bottomRight"
    ]);
  }
  function toPadding(value) {
    const obj = toTRBL(value);
    obj.width = obj.left + obj.right;
    obj.height = obj.top + obj.bottom;
    return obj;
  }
  function toFont(options2, fallback) {
    options2 = options2 || {};
    fallback = fallback || defaults.font;
    let size = valueOrDefault(options2.size, fallback.size);
    if (typeof size === "string") {
      size = parseInt(size, 10);
    }
    let style = valueOrDefault(options2.style, fallback.style);
    if (style && !("" + style).match(FONT_STYLE)) {
      console.warn('Invalid font style specified: "' + style + '"');
      style = void 0;
    }
    const font = {
      family: valueOrDefault(options2.family, fallback.family),
      lineHeight: toLineHeight(valueOrDefault(options2.lineHeight, fallback.lineHeight), size),
      size,
      style,
      weight: valueOrDefault(options2.weight, fallback.weight),
      string: ""
    };
    font.string = toFontString(font);
    return font;
  }
  function resolve(inputs, context, index2, info) {
    let cacheable = true;
    let i3, ilen, value;
    for (i3 = 0, ilen = inputs.length; i3 < ilen; ++i3) {
      value = inputs[i3];
      if (value === void 0) {
        continue;
      }
      if (context !== void 0 && typeof value === "function") {
        value = value(context);
        cacheable = false;
      }
      if (index2 !== void 0 && isArray2(value)) {
        value = value[index2 % value.length];
        cacheable = false;
      }
      if (value !== void 0) {
        if (info && !cacheable) {
          info.cacheable = false;
        }
        return value;
      }
    }
  }
  function _addGrace(minmax, grace, beginAtZero) {
    const { min: min2, max: max2 } = minmax;
    const change = toDimension(grace, (max2 - min2) / 2);
    const keepZero = (value, add2) => beginAtZero && value === 0 ? 0 : value + add2;
    return {
      min: keepZero(min2, -Math.abs(change)),
      max: keepZero(max2, change)
    };
  }
  function createContext(parentContext, context) {
    return Object.assign(Object.create(parentContext), context);
  }
  function _createResolver(scopes, prefixes = [
    ""
  ], rootScopes = scopes, fallback, getTarget = () => scopes[0]) {
    if (!defined(fallback)) {
      fallback = _resolve("_fallback", scopes);
    }
    const cache = {
      [Symbol.toStringTag]: "Object",
      _cacheable: true,
      _scopes: scopes,
      _rootScopes: rootScopes,
      _fallback: fallback,
      _getTarget: getTarget,
      override: (scope) => _createResolver([
        scope,
        ...scopes
      ], prefixes, rootScopes, fallback)
    };
    return new Proxy(cache, {
      deleteProperty(target, prop) {
        delete target[prop];
        delete target._keys;
        delete scopes[0][prop];
        return true;
      },
      get(target, prop) {
        return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes, scopes, target));
      },
      getOwnPropertyDescriptor(target, prop) {
        return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
      },
      getPrototypeOf() {
        return Reflect.getPrototypeOf(scopes[0]);
      },
      has(target, prop) {
        return getKeysFromAllScopes(target).includes(prop);
      },
      ownKeys(target) {
        return getKeysFromAllScopes(target);
      },
      set(target, prop, value) {
        const storage = target._storage || (target._storage = getTarget());
        target[prop] = storage[prop] = value;
        delete target._keys;
        return true;
      }
    });
  }
  function _attachContext(proxy, context, subProxy, descriptorDefaults) {
    const cache = {
      _cacheable: false,
      _proxy: proxy,
      _context: context,
      _subProxy: subProxy,
      _stack: /* @__PURE__ */ new Set(),
      _descriptors: _descriptors(proxy, descriptorDefaults),
      setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
      override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
    };
    return new Proxy(cache, {
      deleteProperty(target, prop) {
        delete target[prop];
        delete proxy[prop];
        return true;
      },
      get(target, prop, receiver) {
        return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));
      },
      getOwnPropertyDescriptor(target, prop) {
        return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {
          enumerable: true,
          configurable: true
        } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
      },
      getPrototypeOf() {
        return Reflect.getPrototypeOf(proxy);
      },
      has(target, prop) {
        return Reflect.has(proxy, prop);
      },
      ownKeys() {
        return Reflect.ownKeys(proxy);
      },
      set(target, prop, value) {
        proxy[prop] = value;
        delete target[prop];
        return true;
      }
    });
  }
  function _descriptors(proxy, defaults3 = {
    scriptable: true,
    indexable: true
  }) {
    const { _scriptable = defaults3.scriptable, _indexable = defaults3.indexable, _allKeys = defaults3.allKeys } = proxy;
    return {
      allKeys: _allKeys,
      scriptable: _scriptable,
      indexable: _indexable,
      isScriptable: isFunction2(_scriptable) ? _scriptable : () => _scriptable,
      isIndexable: isFunction2(_indexable) ? _indexable : () => _indexable
    };
  }
  var readKey = (prefix, name2) => prefix ? prefix + _capitalize(name2) : name2;
  var needsSubResolver = (prop, value) => isObject(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object);
  function _cached(target, prop, resolve2) {
    if (Object.prototype.hasOwnProperty.call(target, prop)) {
      return target[prop];
    }
    const value = resolve2();
    target[prop] = value;
    return value;
  }
  function _resolveWithContext(target, prop, receiver) {
    const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
    let value = _proxy[prop];
    if (isFunction2(value) && descriptors2.isScriptable(prop)) {
      value = _resolveScriptable(prop, value, target, receiver);
    }
    if (isArray2(value) && value.length) {
      value = _resolveArray(prop, value, target, descriptors2.isIndexable);
    }
    if (needsSubResolver(prop, value)) {
      value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors2);
    }
    return value;
  }
  function _resolveScriptable(prop, value, target, receiver) {
    const { _proxy, _context, _subProxy, _stack } = target;
    if (_stack.has(prop)) {
      throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
    }
    _stack.add(prop);
    value = value(_context, _subProxy || receiver);
    _stack.delete(prop);
    if (needsSubResolver(prop, value)) {
      value = createSubResolver(_proxy._scopes, _proxy, prop, value);
    }
    return value;
  }
  function _resolveArray(prop, value, target, isIndexable) {
    const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
    if (defined(_context.index) && isIndexable(prop)) {
      value = value[_context.index % value.length];
    } else if (isObject(value[0])) {
      const arr = value;
      const scopes = _proxy._scopes.filter((s4) => s4 !== arr);
      value = [];
      for (const item of arr) {
        const resolver = createSubResolver(scopes, _proxy, prop, item);
        value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));
      }
    }
    return value;
  }
  function resolveFallback(fallback, prop, value) {
    return isFunction2(fallback) ? fallback(prop, value) : fallback;
  }
  var getScope = (key, parent) => key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : void 0;
  function addScopes(set2, parentScopes, key, parentFallback, value) {
    for (const parent of parentScopes) {
      const scope = getScope(key, parent);
      if (scope) {
        set2.add(scope);
        const fallback = resolveFallback(scope._fallback, key, value);
        if (defined(fallback) && fallback !== key && fallback !== parentFallback) {
          return fallback;
        }
      } else if (scope === false && defined(parentFallback) && key !== parentFallback) {
        return null;
      }
    }
    return false;
  }
  function createSubResolver(parentScopes, resolver, prop, value) {
    const rootScopes = resolver._rootScopes;
    const fallback = resolveFallback(resolver._fallback, prop, value);
    const allScopes = [
      ...parentScopes,
      ...rootScopes
    ];
    const set2 = /* @__PURE__ */ new Set();
    set2.add(value);
    let key = addScopesFromKey(set2, allScopes, prop, fallback || prop, value);
    if (key === null) {
      return false;
    }
    if (defined(fallback) && fallback !== prop) {
      key = addScopesFromKey(set2, allScopes, fallback, key, value);
      if (key === null) {
        return false;
      }
    }
    return _createResolver(Array.from(set2), [
      ""
    ], rootScopes, fallback, () => subGetTarget(resolver, prop, value));
  }
  function addScopesFromKey(set2, allScopes, key, fallback, item) {
    while (key) {
      key = addScopes(set2, allScopes, key, fallback, item);
    }
    return key;
  }
  function subGetTarget(resolver, prop, value) {
    const parent = resolver._getTarget();
    if (!(prop in parent)) {
      parent[prop] = {};
    }
    const target = parent[prop];
    if (isArray2(target) && isObject(value)) {
      return value;
    }
    return target || {};
  }
  function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
    let value;
    for (const prefix of prefixes) {
      value = _resolve(readKey(prefix, prop), scopes);
      if (defined(value)) {
        return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
      }
    }
  }
  function _resolve(key, scopes) {
    for (const scope of scopes) {
      if (!scope) {
        continue;
      }
      const value = scope[key];
      if (defined(value)) {
        return value;
      }
    }
  }
  function getKeysFromAllScopes(target) {
    let keys = target._keys;
    if (!keys) {
      keys = target._keys = resolveKeysFromAllScopes(target._scopes);
    }
    return keys;
  }
  function resolveKeysFromAllScopes(scopes) {
    const set2 = /* @__PURE__ */ new Set();
    for (const scope of scopes) {
      for (const key of Object.keys(scope).filter((k2) => !k2.startsWith("_"))) {
        set2.add(key);
      }
    }
    return Array.from(set2);
  }
  function _parseObjectDataRadialScale(meta, data, start3, count) {
    const { iScale } = meta;
    const { key = "r" } = this._parsing;
    const parsed = new Array(count);
    let i3, ilen, index2, item;
    for (i3 = 0, ilen = count; i3 < ilen; ++i3) {
      index2 = i3 + start3;
      item = data[index2];
      parsed[i3] = {
        r: iScale.parse(resolveObjectKey(item, key), index2)
      };
    }
    return parsed;
  }
  var EPSILON = Number.EPSILON || 1e-14;
  var getPoint = (points, i3) => i3 < points.length && !points[i3].skip && points[i3];
  var getValueAxis = (indexAxis) => indexAxis === "x" ? "y" : "x";
  function splineCurve(firstPoint, middlePoint, afterPoint, t2) {
    const previous = firstPoint.skip ? middlePoint : firstPoint;
    const current = middlePoint;
    const next = afterPoint.skip ? middlePoint : afterPoint;
    const d01 = distanceBetweenPoints(current, previous);
    const d12 = distanceBetweenPoints(next, current);
    let s01 = d01 / (d01 + d12);
    let s12 = d12 / (d01 + d12);
    s01 = isNaN(s01) ? 0 : s01;
    s12 = isNaN(s12) ? 0 : s12;
    const fa = t2 * s01;
    const fb = t2 * s12;
    return {
      previous: {
        x: current.x - fa * (next.x - previous.x),
        y: current.y - fa * (next.y - previous.y)
      },
      next: {
        x: current.x + fb * (next.x - previous.x),
        y: current.y + fb * (next.y - previous.y)
      }
    };
  }
  function monotoneAdjust(points, deltaK, mK) {
    const pointsLen = points.length;
    let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for (let i3 = 0; i3 < pointsLen - 1; ++i3) {
      pointCurrent = pointAfter;
      pointAfter = getPoint(points, i3 + 1);
      if (!pointCurrent || !pointAfter) {
        continue;
      }
      if (almostEquals(deltaK[i3], 0, EPSILON)) {
        mK[i3] = mK[i3 + 1] = 0;
        continue;
      }
      alphaK = mK[i3] / deltaK[i3];
      betaK = mK[i3 + 1] / deltaK[i3];
      squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
      if (squaredMagnitude <= 9) {
        continue;
      }
      tauK = 3 / Math.sqrt(squaredMagnitude);
      mK[i3] = alphaK * tauK * deltaK[i3];
      mK[i3 + 1] = betaK * tauK * deltaK[i3];
    }
  }
  function monotoneCompute(points, mK, indexAxis = "x") {
    const valueAxis = getValueAxis(indexAxis);
    const pointsLen = points.length;
    let delta, pointBefore, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for (let i3 = 0; i3 < pointsLen; ++i3) {
      pointBefore = pointCurrent;
      pointCurrent = pointAfter;
      pointAfter = getPoint(points, i3 + 1);
      if (!pointCurrent) {
        continue;
      }
      const iPixel = pointCurrent[indexAxis];
      const vPixel = pointCurrent[valueAxis];
      if (pointBefore) {
        delta = (iPixel - pointBefore[indexAxis]) / 3;
        pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
        pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i3];
      }
      if (pointAfter) {
        delta = (pointAfter[indexAxis] - iPixel) / 3;
        pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
        pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i3];
      }
    }
  }
  function splineCurveMonotone(points, indexAxis = "x") {
    const valueAxis = getValueAxis(indexAxis);
    const pointsLen = points.length;
    const deltaK = Array(pointsLen).fill(0);
    const mK = Array(pointsLen);
    let i3, pointBefore, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for (i3 = 0; i3 < pointsLen; ++i3) {
      pointBefore = pointCurrent;
      pointCurrent = pointAfter;
      pointAfter = getPoint(points, i3 + 1);
      if (!pointCurrent) {
        continue;
      }
      if (pointAfter) {
        const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
        deltaK[i3] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
      }
      mK[i3] = !pointBefore ? deltaK[i3] : !pointAfter ? deltaK[i3 - 1] : sign(deltaK[i3 - 1]) !== sign(deltaK[i3]) ? 0 : (deltaK[i3 - 1] + deltaK[i3]) / 2;
    }
    monotoneAdjust(points, deltaK, mK);
    monotoneCompute(points, mK, indexAxis);
  }
  function capControlPoint(pt, min2, max2) {
    return Math.max(Math.min(pt, max2), min2);
  }
  function capBezierPoints(points, area) {
    let i3, ilen, point, inArea, inAreaPrev;
    let inAreaNext = _isPointInArea(points[0], area);
    for (i3 = 0, ilen = points.length; i3 < ilen; ++i3) {
      inAreaPrev = inArea;
      inArea = inAreaNext;
      inAreaNext = i3 < ilen - 1 && _isPointInArea(points[i3 + 1], area);
      if (!inArea) {
        continue;
      }
      point = points[i3];
      if (inAreaPrev) {
        point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
        point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
      }
      if (inAreaNext) {
        point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
        point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
      }
    }
  }
  function _updateBezierControlPoints(points, options2, area, loop, indexAxis) {
    let i3, ilen, point, controlPoints;
    if (options2.spanGaps) {
      points = points.filter((pt) => !pt.skip);
    }
    if (options2.cubicInterpolationMode === "monotone") {
      splineCurveMonotone(points, indexAxis);
    } else {
      let prev = loop ? points[points.length - 1] : points[0];
      for (i3 = 0, ilen = points.length; i3 < ilen; ++i3) {
        point = points[i3];
        controlPoints = splineCurve(prev, point, points[Math.min(i3 + 1, ilen - (loop ? 0 : 1)) % ilen], options2.tension);
        point.cp1x = controlPoints.previous.x;
        point.cp1y = controlPoints.previous.y;
        point.cp2x = controlPoints.next.x;
        point.cp2y = controlPoints.next.y;
        prev = point;
      }
    }
    if (options2.capBezierPoints) {
      capBezierPoints(points, area);
    }
  }
  function _isDomSupported() {
    return typeof window !== "undefined" && typeof document !== "undefined";
  }
  function _getParentNode(domNode) {
    let parent = domNode.parentNode;
    if (parent && parent.toString() === "[object ShadowRoot]") {
      parent = parent.host;
    }
    return parent;
  }
  function parseMaxStyle(styleValue, node, parentProperty) {
    let valueInPixels;
    if (typeof styleValue === "string") {
      valueInPixels = parseInt(styleValue, 10);
      if (styleValue.indexOf("%") !== -1) {
        valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
      }
    } else {
      valueInPixels = styleValue;
    }
    return valueInPixels;
  }
  var getComputedStyle2 = (element) => element.ownerDocument.defaultView.getComputedStyle(element, null);
  function getStyle(el, property) {
    return getComputedStyle2(el).getPropertyValue(property);
  }
  var positions = [
    "top",
    "right",
    "bottom",
    "left"
  ];
  function getPositionedStyle(styles, style, suffix) {
    const result = {};
    suffix = suffix ? "-" + suffix : "";
    for (let i3 = 0; i3 < 4; i3++) {
      const pos = positions[i3];
      result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
    }
    result.width = result.left + result.right;
    result.height = result.top + result.bottom;
    return result;
  }
  var useOffsetPos = (x2, y3, target) => (x2 > 0 || y3 > 0) && (!target || !target.shadowRoot);
  function getCanvasPosition(e3, canvas) {
    const touches = e3.touches;
    const source = touches && touches.length ? touches[0] : e3;
    const { offsetX, offsetY } = source;
    let box = false;
    let x2, y3;
    if (useOffsetPos(offsetX, offsetY, e3.target)) {
      x2 = offsetX;
      y3 = offsetY;
    } else {
      const rect = canvas.getBoundingClientRect();
      x2 = source.clientX - rect.left;
      y3 = source.clientY - rect.top;
      box = true;
    }
    return {
      x: x2,
      y: y3,
      box
    };
  }
  function getRelativePosition(event, chart) {
    if ("native" in event) {
      return event;
    }
    const { canvas, currentDevicePixelRatio } = chart;
    const style = getComputedStyle2(canvas);
    const borderBox = style.boxSizing === "border-box";
    const paddings = getPositionedStyle(style, "padding");
    const borders = getPositionedStyle(style, "border", "width");
    const { x: x2, y: y3, box } = getCanvasPosition(event, canvas);
    const xOffset = paddings.left + (box && borders.left);
    const yOffset = paddings.top + (box && borders.top);
    let { width, height } = chart;
    if (borderBox) {
      width -= paddings.width + borders.width;
      height -= paddings.height + borders.height;
    }
    return {
      x: Math.round((x2 - xOffset) / width * canvas.width / currentDevicePixelRatio),
      y: Math.round((y3 - yOffset) / height * canvas.height / currentDevicePixelRatio)
    };
  }
  function getContainerSize(canvas, width, height) {
    let maxWidth, maxHeight;
    if (width === void 0 || height === void 0) {
      const container = _getParentNode(canvas);
      if (!container) {
        width = canvas.clientWidth;
        height = canvas.clientHeight;
      } else {
        const rect = container.getBoundingClientRect();
        const containerStyle = getComputedStyle2(container);
        const containerBorder = getPositionedStyle(containerStyle, "border", "width");
        const containerPadding = getPositionedStyle(containerStyle, "padding");
        width = rect.width - containerPadding.width - containerBorder.width;
        height = rect.height - containerPadding.height - containerBorder.height;
        maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
        maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
      }
    }
    return {
      width,
      height,
      maxWidth: maxWidth || INFINITY,
      maxHeight: maxHeight || INFINITY
    };
  }
  var round1 = (v) => Math.round(v * 10) / 10;
  function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
    const style = getComputedStyle2(canvas);
    const margins = getPositionedStyle(style, "margin");
    const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
    const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
    const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
    let { width, height } = containerSize;
    if (style.boxSizing === "content-box") {
      const borders = getPositionedStyle(style, "border", "width");
      const paddings = getPositionedStyle(style, "padding");
      width -= paddings.width + borders.width;
      height -= paddings.height + borders.height;
    }
    width = Math.max(0, width - margins.width);
    height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);
    width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
    height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
    if (width && !height) {
      height = round1(width / 2);
    }
    const maintainHeight = bbWidth !== void 0 || bbHeight !== void 0;
    if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {
      height = containerSize.height;
      width = round1(Math.floor(height * aspectRatio));
    }
    return {
      width,
      height
    };
  }
  function retinaScale(chart, forceRatio, forceStyle) {
    const pixelRatio = forceRatio || 1;
    const deviceHeight = Math.floor(chart.height * pixelRatio);
    const deviceWidth = Math.floor(chart.width * pixelRatio);
    chart.height = Math.floor(chart.height);
    chart.width = Math.floor(chart.width);
    const canvas = chart.canvas;
    if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
      canvas.style.height = `${chart.height}px`;
      canvas.style.width = `${chart.width}px`;
    }
    if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
      chart.currentDevicePixelRatio = pixelRatio;
      canvas.height = deviceHeight;
      canvas.width = deviceWidth;
      chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
      return true;
    }
    return false;
  }
  var supportsEventListenerOptions = function() {
    let passiveSupported = false;
    try {
      const options2 = {
        get passive() {
          passiveSupported = true;
          return false;
        }
      };
      window.addEventListener("test", null, options2);
      window.removeEventListener("test", null, options2);
    } catch (e3) {
    }
    return passiveSupported;
  }();
  function readUsedSize(element, property) {
    const value = getStyle(element, property);
    const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
    return matches ? +matches[1] : void 0;
  }
  function _pointInLine(p1, p2, t2, mode) {
    return {
      x: p1.x + t2 * (p2.x - p1.x),
      y: p1.y + t2 * (p2.y - p1.y)
    };
  }
  function _steppedInterpolation(p1, p2, t2, mode) {
    return {
      x: p1.x + t2 * (p2.x - p1.x),
      y: mode === "middle" ? t2 < 0.5 ? p1.y : p2.y : mode === "after" ? t2 < 1 ? p1.y : p2.y : t2 > 0 ? p2.y : p1.y
    };
  }
  function _bezierInterpolation(p1, p2, t2, mode) {
    const cp1 = {
      x: p1.cp2x,
      y: p1.cp2y
    };
    const cp2 = {
      x: p2.cp1x,
      y: p2.cp1y
    };
    const a4 = _pointInLine(p1, cp1, t2);
    const b2 = _pointInLine(cp1, cp2, t2);
    const c2 = _pointInLine(cp2, p2, t2);
    const d3 = _pointInLine(a4, b2, t2);
    const e3 = _pointInLine(b2, c2, t2);
    return _pointInLine(d3, e3, t2);
  }
  var getRightToLeftAdapter = function(rectX, width) {
    return {
      x(x2) {
        return rectX + rectX + width - x2;
      },
      setWidth(w2) {
        width = w2;
      },
      textAlign(align) {
        if (align === "center") {
          return align;
        }
        return align === "right" ? "left" : "right";
      },
      xPlus(x2, value) {
        return x2 - value;
      },
      leftForLtr(x2, itemWidth) {
        return x2 - itemWidth;
      }
    };
  };
  var getLeftToRightAdapter = function() {
    return {
      x(x2) {
        return x2;
      },
      setWidth(w2) {
      },
      textAlign(align) {
        return align;
      },
      xPlus(x2, value) {
        return x2 + value;
      },
      leftForLtr(x2, _itemWidth) {
        return x2;
      }
    };
  };
  function getRtlAdapter(rtl, rectX, width) {
    return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
  }
  function overrideTextDirection(ctx, direction) {
    let style, original;
    if (direction === "ltr" || direction === "rtl") {
      style = ctx.canvas.style;
      original = [
        style.getPropertyValue("direction"),
        style.getPropertyPriority("direction")
      ];
      style.setProperty("direction", direction, "important");
      ctx.prevTextDirection = original;
    }
  }
  function restoreTextDirection(ctx, original) {
    if (original !== void 0) {
      delete ctx.prevTextDirection;
      ctx.canvas.style.setProperty("direction", original[0], original[1]);
    }
  }
  function propertyFn(property) {
    if (property === "angle") {
      return {
        between: _angleBetween,
        compare: _angleDiff,
        normalize: _normalizeAngle
      };
    }
    return {
      between: _isBetween,
      compare: (a4, b2) => a4 - b2,
      normalize: (x2) => x2
    };
  }
  function normalizeSegment({ start: start3, end: end2, count, loop, style }) {
    return {
      start: start3 % count,
      end: end2 % count,
      loop: loop && (end2 - start3 + 1) % count === 0,
      style
    };
  }
  function getSegment(segment, points, bounds) {
    const { property, start: startBound, end: endBound } = bounds;
    const { between, normalize } = propertyFn(property);
    const count = points.length;
    let { start: start3, end: end2, loop } = segment;
    let i3, ilen;
    if (loop) {
      start3 += count;
      end2 += count;
      for (i3 = 0, ilen = count; i3 < ilen; ++i3) {
        if (!between(normalize(points[start3 % count][property]), startBound, endBound)) {
          break;
        }
        start3--;
        end2--;
      }
      start3 %= count;
      end2 %= count;
    }
    if (end2 < start3) {
      end2 += count;
    }
    return {
      start: start3,
      end: end2,
      loop,
      style: segment.style
    };
  }
  function _boundSegment(segment, points, bounds) {
    if (!bounds) {
      return [
        segment
      ];
    }
    const { property, start: startBound, end: endBound } = bounds;
    const count = points.length;
    const { compare, between, normalize } = propertyFn(property);
    const { start: start3, end: end2, loop, style } = getSegment(segment, points, bounds);
    const result = [];
    let inside = false;
    let subStart = null;
    let value, point, prevValue;
    const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
    const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);
    const shouldStart = () => inside || startIsBefore();
    const shouldStop = () => !inside || endIsBefore();
    for (let i3 = start3, prev = start3; i3 <= end2; ++i3) {
      point = points[i3 % count];
      if (point.skip) {
        continue;
      }
      value = normalize(point[property]);
      if (value === prevValue) {
        continue;
      }
      inside = between(value, startBound, endBound);
      if (subStart === null && shouldStart()) {
        subStart = compare(value, startBound) === 0 ? i3 : prev;
      }
      if (subStart !== null && shouldStop()) {
        result.push(normalizeSegment({
          start: subStart,
          end: i3,
          loop,
          count,
          style
        }));
        subStart = null;
      }
      prev = i3;
      prevValue = value;
    }
    if (subStart !== null) {
      result.push(normalizeSegment({
        start: subStart,
        end: end2,
        loop,
        count,
        style
      }));
    }
    return result;
  }
  function _boundSegments(line, bounds) {
    const result = [];
    const segments = line.segments;
    for (let i3 = 0; i3 < segments.length; i3++) {
      const sub = _boundSegment(segments[i3], line.points, bounds);
      if (sub.length) {
        result.push(...sub);
      }
    }
    return result;
  }
  function findStartAndEnd(points, count, loop, spanGaps) {
    let start3 = 0;
    let end2 = count - 1;
    if (loop && !spanGaps) {
      while (start3 < count && !points[start3].skip) {
        start3++;
      }
    }
    while (start3 < count && points[start3].skip) {
      start3++;
    }
    start3 %= count;
    if (loop) {
      end2 += start3;
    }
    while (end2 > start3 && points[end2 % count].skip) {
      end2--;
    }
    end2 %= count;
    return {
      start: start3,
      end: end2
    };
  }
  function solidSegments(points, start3, max2, loop) {
    const count = points.length;
    const result = [];
    let last = start3;
    let prev = points[start3];
    let end2;
    for (end2 = start3 + 1; end2 <= max2; ++end2) {
      const cur = points[end2 % count];
      if (cur.skip || cur.stop) {
        if (!prev.skip) {
          loop = false;
          result.push({
            start: start3 % count,
            end: (end2 - 1) % count,
            loop
          });
          start3 = last = cur.stop ? end2 : null;
        }
      } else {
        last = end2;
        if (prev.skip) {
          start3 = end2;
        }
      }
      prev = cur;
    }
    if (last !== null) {
      result.push({
        start: start3 % count,
        end: last % count,
        loop
      });
    }
    return result;
  }
  function _computeSegments(line, segmentOptions) {
    const points = line.points;
    const spanGaps = line.options.spanGaps;
    const count = points.length;
    if (!count) {
      return [];
    }
    const loop = !!line._loop;
    const { start: start3, end: end2 } = findStartAndEnd(points, count, loop, spanGaps);
    if (spanGaps === true) {
      return splitByStyles(line, [
        {
          start: start3,
          end: end2,
          loop
        }
      ], points, segmentOptions);
    }
    const max2 = end2 < start3 ? end2 + count : end2;
    const completeLoop = !!line._fullLoop && start3 === 0 && end2 === count - 1;
    return splitByStyles(line, solidSegments(points, start3, max2, completeLoop), points, segmentOptions);
  }
  function splitByStyles(line, segments, points, segmentOptions) {
    if (!segmentOptions || !segmentOptions.setContext || !points) {
      return segments;
    }
    return doSplitByStyles(line, segments, points, segmentOptions);
  }
  function doSplitByStyles(line, segments, points, segmentOptions) {
    const chartContext = line._chart.getContext();
    const baseStyle = readStyle(line.options);
    const { _datasetIndex: datasetIndex, options: { spanGaps } } = line;
    const count = points.length;
    const result = [];
    let prevStyle = baseStyle;
    let start3 = segments[0].start;
    let i3 = start3;
    function addStyle(s4, e3, l2, st) {
      const dir = spanGaps ? -1 : 1;
      if (s4 === e3) {
        return;
      }
      s4 += count;
      while (points[s4 % count].skip) {
        s4 -= dir;
      }
      while (points[e3 % count].skip) {
        e3 += dir;
      }
      if (s4 % count !== e3 % count) {
        result.push({
          start: s4 % count,
          end: e3 % count,
          loop: l2,
          style: st
        });
        prevStyle = st;
        start3 = e3 % count;
      }
    }
    for (const segment of segments) {
      start3 = spanGaps ? start3 : segment.start;
      let prev = points[start3 % count];
      let style;
      for (i3 = start3 + 1; i3 <= segment.end; i3++) {
        const pt = points[i3 % count];
        style = readStyle(segmentOptions.setContext(createContext(chartContext, {
          type: "segment",
          p0: prev,
          p1: pt,
          p0DataIndex: (i3 - 1) % count,
          p1DataIndex: i3 % count,
          datasetIndex
        })));
        if (styleChanged(style, prevStyle)) {
          addStyle(start3, i3 - 1, segment.loop, prevStyle);
        }
        prev = pt;
        prevStyle = style;
      }
      if (start3 < i3 - 1) {
        addStyle(start3, i3 - 1, segment.loop, prevStyle);
      }
    }
    return result;
  }
  function readStyle(options2) {
    return {
      backgroundColor: options2.backgroundColor,
      borderCapStyle: options2.borderCapStyle,
      borderDash: options2.borderDash,
      borderDashOffset: options2.borderDashOffset,
      borderJoinStyle: options2.borderJoinStyle,
      borderWidth: options2.borderWidth,
      borderColor: options2.borderColor
    };
  }
  function styleChanged(style, prevStyle) {
    return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);
  }

  // ../../node_modules/chart.js/dist/chart.js
  var Animator = class {
    constructor() {
      this._request = null;
      this._charts = /* @__PURE__ */ new Map();
      this._running = false;
      this._lastDate = void 0;
    }
    _notify(chart, anims, date, type) {
      const callbacks2 = anims.listeners[type];
      const numSteps = anims.duration;
      callbacks2.forEach((fn2) => fn2({
        chart,
        initial: anims.initial,
        numSteps,
        currentStep: Math.min(date - anims.start, numSteps)
      }));
    }
    _refresh() {
      if (this._request) {
        return;
      }
      this._running = true;
      this._request = requestAnimFrame.call(window, () => {
        this._update();
        this._request = null;
        if (this._running) {
          this._refresh();
        }
      });
    }
    _update(date = Date.now()) {
      let remaining = 0;
      this._charts.forEach((anims, chart) => {
        if (!anims.running || !anims.items.length) {
          return;
        }
        const items = anims.items;
        let i3 = items.length - 1;
        let draw2 = false;
        let item;
        for (; i3 >= 0; --i3) {
          item = items[i3];
          if (item._active) {
            if (item._total > anims.duration) {
              anims.duration = item._total;
            }
            item.tick(date);
            draw2 = true;
          } else {
            items[i3] = items[items.length - 1];
            items.pop();
          }
        }
        if (draw2) {
          chart.draw();
          this._notify(chart, anims, date, "progress");
        }
        if (!items.length) {
          anims.running = false;
          this._notify(chart, anims, date, "complete");
          anims.initial = false;
        }
        remaining += items.length;
      });
      this._lastDate = date;
      if (remaining === 0) {
        this._running = false;
      }
    }
    _getAnims(chart) {
      const charts = this._charts;
      let anims = charts.get(chart);
      if (!anims) {
        anims = {
          running: false,
          initial: true,
          items: [],
          listeners: {
            complete: [],
            progress: []
          }
        };
        charts.set(chart, anims);
      }
      return anims;
    }
    listen(chart, event, cb) {
      this._getAnims(chart).listeners[event].push(cb);
    }
    add(chart, items) {
      if (!items || !items.length) {
        return;
      }
      this._getAnims(chart).items.push(...items);
    }
    has(chart) {
      return this._getAnims(chart).items.length > 0;
    }
    start(chart) {
      const anims = this._charts.get(chart);
      if (!anims) {
        return;
      }
      anims.running = true;
      anims.start = Date.now();
      anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
      this._refresh();
    }
    running(chart) {
      if (!this._running) {
        return false;
      }
      const anims = this._charts.get(chart);
      if (!anims || !anims.running || !anims.items.length) {
        return false;
      }
      return true;
    }
    stop(chart) {
      const anims = this._charts.get(chart);
      if (!anims || !anims.items.length) {
        return;
      }
      const items = anims.items;
      let i3 = items.length - 1;
      for (; i3 >= 0; --i3) {
        items[i3].cancel();
      }
      anims.items = [];
      this._notify(chart, anims, Date.now(), "complete");
    }
    remove(chart) {
      return this._charts.delete(chart);
    }
  };
  var animator = /* @__PURE__ */ new Animator();
  var transparent = "transparent";
  var interpolators = {
    boolean(from2, to2, factor) {
      return factor > 0.5 ? to2 : from2;
    },
    color(from2, to2, factor) {
      const c0 = color(from2 || transparent);
      const c1 = c0.valid && color(to2 || transparent);
      return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to2;
    },
    number(from2, to2, factor) {
      return from2 + (to2 - from2) * factor;
    }
  };
  var Animation = class {
    constructor(cfg, target, prop, to2) {
      const currentValue = target[prop];
      to2 = resolve([
        cfg.to,
        to2,
        currentValue,
        cfg.from
      ]);
      const from2 = resolve([
        cfg.from,
        currentValue,
        to2
      ]);
      this._active = true;
      this._fn = cfg.fn || interpolators[cfg.type || typeof from2];
      this._easing = effects[cfg.easing] || effects.linear;
      this._start = Math.floor(Date.now() + (cfg.delay || 0));
      this._duration = this._total = Math.floor(cfg.duration);
      this._loop = !!cfg.loop;
      this._target = target;
      this._prop = prop;
      this._from = from2;
      this._to = to2;
      this._promises = void 0;
    }
    active() {
      return this._active;
    }
    update(cfg, to2, date) {
      if (this._active) {
        this._notify(false);
        const currentValue = this._target[this._prop];
        const elapsed = date - this._start;
        const remain = this._duration - elapsed;
        this._start = date;
        this._duration = Math.floor(Math.max(remain, cfg.duration));
        this._total += elapsed;
        this._loop = !!cfg.loop;
        this._to = resolve([
          cfg.to,
          to2,
          currentValue,
          cfg.from
        ]);
        this._from = resolve([
          cfg.from,
          currentValue,
          to2
        ]);
      }
    }
    cancel() {
      if (this._active) {
        this.tick(Date.now());
        this._active = false;
        this._notify(false);
      }
    }
    tick(date) {
      const elapsed = date - this._start;
      const duration2 = this._duration;
      const prop = this._prop;
      const from2 = this._from;
      const loop = this._loop;
      const to2 = this._to;
      let factor;
      this._active = from2 !== to2 && (loop || elapsed < duration2);
      if (!this._active) {
        this._target[prop] = to2;
        this._notify(true);
        return;
      }
      if (elapsed < 0) {
        this._target[prop] = from2;
        return;
      }
      factor = elapsed / duration2 % 2;
      factor = loop && factor > 1 ? 2 - factor : factor;
      factor = this._easing(Math.min(1, Math.max(0, factor)));
      this._target[prop] = this._fn(from2, to2, factor);
    }
    wait() {
      const promises = this._promises || (this._promises = []);
      return new Promise((res, rej) => {
        promises.push({
          res,
          rej
        });
      });
    }
    _notify(resolved) {
      const method = resolved ? "res" : "rej";
      const promises = this._promises || [];
      for (let i3 = 0; i3 < promises.length; i3++) {
        promises[i3][method]();
      }
    }
  };
  var Animations = class {
    constructor(chart, config) {
      this._chart = chart;
      this._properties = /* @__PURE__ */ new Map();
      this.configure(config);
    }
    configure(config) {
      if (!isObject(config)) {
        return;
      }
      const animationOptions = Object.keys(defaults.animation);
      const animatedProps = this._properties;
      Object.getOwnPropertyNames(config).forEach((key) => {
        const cfg = config[key];
        if (!isObject(cfg)) {
          return;
        }
        const resolved = {};
        for (const option of animationOptions) {
          resolved[option] = cfg[option];
        }
        (isArray2(cfg.properties) && cfg.properties || [
          key
        ]).forEach((prop) => {
          if (prop === key || !animatedProps.has(prop)) {
            animatedProps.set(prop, resolved);
          }
        });
      });
    }
    _animateOptions(target, values) {
      const newOptions = values.options;
      const options2 = resolveTargetOptions(target, newOptions);
      if (!options2) {
        return [];
      }
      const animations = this._createAnimations(options2, newOptions);
      if (newOptions.$shared) {
        awaitAll(target.options.$animations, newOptions).then(() => {
          target.options = newOptions;
        }, () => {
        });
      }
      return animations;
    }
    _createAnimations(target, values) {
      const animatedProps = this._properties;
      const animations = [];
      const running = target.$animations || (target.$animations = {});
      const props = Object.keys(values);
      const date = Date.now();
      let i3;
      for (i3 = props.length - 1; i3 >= 0; --i3) {
        const prop = props[i3];
        if (prop.charAt(0) === "$") {
          continue;
        }
        if (prop === "options") {
          animations.push(...this._animateOptions(target, values));
          continue;
        }
        const value = values[prop];
        let animation = running[prop];
        const cfg = animatedProps.get(prop);
        if (animation) {
          if (cfg && animation.active()) {
            animation.update(cfg, value, date);
            continue;
          } else {
            animation.cancel();
          }
        }
        if (!cfg || !cfg.duration) {
          target[prop] = value;
          continue;
        }
        running[prop] = animation = new Animation(cfg, target, prop, value);
        animations.push(animation);
      }
      return animations;
    }
    update(target, values) {
      if (this._properties.size === 0) {
        Object.assign(target, values);
        return;
      }
      const animations = this._createAnimations(target, values);
      if (animations.length) {
        animator.add(this._chart, animations);
        return true;
      }
    }
  };
  function awaitAll(animations, properties) {
    const running = [];
    const keys = Object.keys(properties);
    for (let i3 = 0; i3 < keys.length; i3++) {
      const anim = animations[keys[i3]];
      if (anim && anim.active()) {
        running.push(anim.wait());
      }
    }
    return Promise.all(running);
  }
  function resolveTargetOptions(target, newOptions) {
    if (!newOptions) {
      return;
    }
    let options2 = target.options;
    if (!options2) {
      target.options = newOptions;
      return;
    }
    if (options2.$shared) {
      target.options = options2 = Object.assign({}, options2, {
        $shared: false,
        $animations: {}
      });
    }
    return options2;
  }
  function scaleClip(scale, allowedOverflow) {
    const opts = scale && scale.options || {};
    const reverse = opts.reverse;
    const min2 = opts.min === void 0 ? allowedOverflow : 0;
    const max2 = opts.max === void 0 ? allowedOverflow : 0;
    return {
      start: reverse ? max2 : min2,
      end: reverse ? min2 : max2
    };
  }
  function defaultClip(xScale, yScale, allowedOverflow) {
    if (allowedOverflow === false) {
      return false;
    }
    const x2 = scaleClip(xScale, allowedOverflow);
    const y3 = scaleClip(yScale, allowedOverflow);
    return {
      top: y3.end,
      right: x2.end,
      bottom: y3.start,
      left: x2.start
    };
  }
  function toClip(value) {
    let t2, r2, b2, l2;
    if (isObject(value)) {
      t2 = value.top;
      r2 = value.right;
      b2 = value.bottom;
      l2 = value.left;
    } else {
      t2 = r2 = b2 = l2 = value;
    }
    return {
      top: t2,
      right: r2,
      bottom: b2,
      left: l2,
      disabled: value === false
    };
  }
  function getSortedDatasetIndices(chart, filterVisible) {
    const keys = [];
    const metasets = chart._getSortedDatasetMetas(filterVisible);
    let i3, ilen;
    for (i3 = 0, ilen = metasets.length; i3 < ilen; ++i3) {
      keys.push(metasets[i3].index);
    }
    return keys;
  }
  function applyStack(stack, value, dsIndex, options2 = {}) {
    const keys = stack.keys;
    const singleMode = options2.mode === "single";
    let i3, ilen, datasetIndex, otherValue;
    if (value === null) {
      return;
    }
    for (i3 = 0, ilen = keys.length; i3 < ilen; ++i3) {
      datasetIndex = +keys[i3];
      if (datasetIndex === dsIndex) {
        if (options2.all) {
          continue;
        }
        break;
      }
      otherValue = stack.values[datasetIndex];
      if (isNumberFinite(otherValue) && (singleMode || value === 0 || sign(value) === sign(otherValue))) {
        value += otherValue;
      }
    }
    return value;
  }
  function convertObjectDataToArray(data) {
    const keys = Object.keys(data);
    const adata = new Array(keys.length);
    let i3, ilen, key;
    for (i3 = 0, ilen = keys.length; i3 < ilen; ++i3) {
      key = keys[i3];
      adata[i3] = {
        x: key,
        y: data[key]
      };
    }
    return adata;
  }
  function isStacked(scale, meta) {
    const stacked = scale && scale.options.stacked;
    return stacked || stacked === void 0 && meta.stack !== void 0;
  }
  function getStackKey(indexScale, valueScale, meta) {
    return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
  }
  function getUserBounds(scale) {
    const { min: min2, max: max2, minDefined, maxDefined } = scale.getUserBounds();
    return {
      min: minDefined ? min2 : Number.NEGATIVE_INFINITY,
      max: maxDefined ? max2 : Number.POSITIVE_INFINITY
    };
  }
  function getOrCreateStack(stacks, stackKey, indexValue) {
    const subStack = stacks[stackKey] || (stacks[stackKey] = {});
    return subStack[indexValue] || (subStack[indexValue] = {});
  }
  function getLastIndexInStack(stack, vScale, positive, type) {
    for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
      const value = stack[meta.index];
      if (positive && value > 0 || !positive && value < 0) {
        return meta.index;
      }
    }
    return null;
  }
  function updateStacks(controller, parsed) {
    const { chart, _cachedMeta: meta } = controller;
    const stacks = chart._stacks || (chart._stacks = {});
    const { iScale, vScale, index: datasetIndex } = meta;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const key = getStackKey(iScale, vScale, meta);
    const ilen = parsed.length;
    let stack;
    for (let i3 = 0; i3 < ilen; ++i3) {
      const item = parsed[i3];
      const { [iAxis]: index2, [vAxis]: value } = item;
      const itemStacks = item._stacks || (item._stacks = {});
      stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index2);
      stack[datasetIndex] = value;
      stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
      stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
      const visualValues = stack._visualValues || (stack._visualValues = {});
      visualValues[datasetIndex] = value;
    }
  }
  function getFirstScaleId(chart, axis) {
    const scales2 = chart.scales;
    return Object.keys(scales2).filter((key) => scales2[key].axis === axis).shift();
  }
  function createDatasetContext(parent, index2) {
    return createContext(parent, {
      active: false,
      dataset: void 0,
      datasetIndex: index2,
      index: index2,
      mode: "default",
      type: "dataset"
    });
  }
  function createDataContext(parent, index2, element) {
    return createContext(parent, {
      active: false,
      dataIndex: index2,
      parsed: void 0,
      raw: void 0,
      element,
      index: index2,
      mode: "default",
      type: "data"
    });
  }
  function clearStacks(meta, items) {
    const datasetIndex = meta.controller.index;
    const axis = meta.vScale && meta.vScale.axis;
    if (!axis) {
      return;
    }
    items = items || meta._parsed;
    for (const parsed of items) {
      const stacks = parsed._stacks;
      if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {
        return;
      }
      delete stacks[axis][datasetIndex];
      if (stacks[axis]._visualValues !== void 0 && stacks[axis]._visualValues[datasetIndex] !== void 0) {
        delete stacks[axis]._visualValues[datasetIndex];
      }
    }
  }
  var isDirectUpdateMode = (mode) => mode === "reset" || mode === "none";
  var cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
  var createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked && {
    keys: getSortedDatasetIndices(chart, true),
    values: null
  };
  var DatasetController = class {
    constructor(chart, datasetIndex) {
      this.chart = chart;
      this._ctx = chart.ctx;
      this.index = datasetIndex;
      this._cachedDataOpts = {};
      this._cachedMeta = this.getMeta();
      this._type = this._cachedMeta.type;
      this.options = void 0;
      this._parsing = false;
      this._data = void 0;
      this._objectData = void 0;
      this._sharedOptions = void 0;
      this._drawStart = void 0;
      this._drawCount = void 0;
      this.enableOptionSharing = false;
      this.supportsDecimation = false;
      this.$context = void 0;
      this._syncList = [];
      this.datasetElementType = new.target.datasetElementType;
      this.dataElementType = new.target.dataElementType;
      this.initialize();
    }
    initialize() {
      const meta = this._cachedMeta;
      this.configure();
      this.linkScales();
      meta._stacked = isStacked(meta.vScale, meta);
      this.addElements();
      if (this.options.fill && !this.chart.isPluginEnabled("filler")) {
        console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
      }
    }
    updateIndex(datasetIndex) {
      if (this.index !== datasetIndex) {
        clearStacks(this._cachedMeta);
      }
      this.index = datasetIndex;
    }
    linkScales() {
      const chart = this.chart;
      const meta = this._cachedMeta;
      const dataset = this.getDataset();
      const chooseId = (axis, x2, y3, r2) => axis === "x" ? x2 : axis === "r" ? r2 : y3;
      const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x"));
      const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y"));
      const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r"));
      const indexAxis = meta.indexAxis;
      const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
      const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
      meta.xScale = this.getScaleForId(xid);
      meta.yScale = this.getScaleForId(yid);
      meta.rScale = this.getScaleForId(rid);
      meta.iScale = this.getScaleForId(iid);
      meta.vScale = this.getScaleForId(vid);
    }
    getDataset() {
      return this.chart.data.datasets[this.index];
    }
    getMeta() {
      return this.chart.getDatasetMeta(this.index);
    }
    getScaleForId(scaleID) {
      return this.chart.scales[scaleID];
    }
    _getOtherScale(scale) {
      const meta = this._cachedMeta;
      return scale === meta.iScale ? meta.vScale : meta.iScale;
    }
    reset() {
      this._update("reset");
    }
    _destroy() {
      const meta = this._cachedMeta;
      if (this._data) {
        unlistenArrayEvents(this._data, this);
      }
      if (meta._stacked) {
        clearStacks(meta);
      }
    }
    _dataCheck() {
      const dataset = this.getDataset();
      const data = dataset.data || (dataset.data = []);
      const _data = this._data;
      if (isObject(data)) {
        this._data = convertObjectDataToArray(data);
      } else if (_data !== data) {
        if (_data) {
          unlistenArrayEvents(_data, this);
          const meta = this._cachedMeta;
          clearStacks(meta);
          meta._parsed = [];
        }
        if (data && Object.isExtensible(data)) {
          listenArrayEvents(data, this);
        }
        this._syncList = [];
        this._data = data;
      }
    }
    addElements() {
      const meta = this._cachedMeta;
      this._dataCheck();
      if (this.datasetElementType) {
        meta.dataset = new this.datasetElementType();
      }
    }
    buildOrUpdateElements(resetNewElements) {
      const meta = this._cachedMeta;
      const dataset = this.getDataset();
      let stackChanged = false;
      this._dataCheck();
      const oldStacked = meta._stacked;
      meta._stacked = isStacked(meta.vScale, meta);
      if (meta.stack !== dataset.stack) {
        stackChanged = true;
        clearStacks(meta);
        meta.stack = dataset.stack;
      }
      this._resyncElements(resetNewElements);
      if (stackChanged || oldStacked !== meta._stacked) {
        updateStacks(this, meta._parsed);
      }
    }
    configure() {
      const config = this.chart.config;
      const scopeKeys = config.datasetScopeKeys(this._type);
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
      this.options = config.createResolver(scopes, this.getContext());
      this._parsing = this.options.parsing;
      this._cachedDataOpts = {};
    }
    parse(start3, count) {
      const { _cachedMeta: meta, _data: data } = this;
      const { iScale, _stacked } = meta;
      const iAxis = iScale.axis;
      let sorted = start3 === 0 && count === data.length ? true : meta._sorted;
      let prev = start3 > 0 && meta._parsed[start3 - 1];
      let i3, cur, parsed;
      if (this._parsing === false) {
        meta._parsed = data;
        meta._sorted = true;
        parsed = data;
      } else {
        if (isArray2(data[start3])) {
          parsed = this.parseArrayData(meta, data, start3, count);
        } else if (isObject(data[start3])) {
          parsed = this.parseObjectData(meta, data, start3, count);
        } else {
          parsed = this.parsePrimitiveData(meta, data, start3, count);
        }
        const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
        for (i3 = 0; i3 < count; ++i3) {
          meta._parsed[i3 + start3] = cur = parsed[i3];
          if (sorted) {
            if (isNotInOrderComparedToPrev()) {
              sorted = false;
            }
            prev = cur;
          }
        }
        meta._sorted = sorted;
      }
      if (_stacked) {
        updateStacks(this, parsed);
      }
    }
    parsePrimitiveData(meta, data, start3, count) {
      const { iScale, vScale } = meta;
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      const labels = iScale.getLabels();
      const singleScale = iScale === vScale;
      const parsed = new Array(count);
      let i3, ilen, index2;
      for (i3 = 0, ilen = count; i3 < ilen; ++i3) {
        index2 = i3 + start3;
        parsed[i3] = {
          [iAxis]: singleScale || iScale.parse(labels[index2], index2),
          [vAxis]: vScale.parse(data[index2], index2)
        };
      }
      return parsed;
    }
    parseArrayData(meta, data, start3, count) {
      const { xScale, yScale } = meta;
      const parsed = new Array(count);
      let i3, ilen, index2, item;
      for (i3 = 0, ilen = count; i3 < ilen; ++i3) {
        index2 = i3 + start3;
        item = data[index2];
        parsed[i3] = {
          x: xScale.parse(item[0], index2),
          y: yScale.parse(item[1], index2)
        };
      }
      return parsed;
    }
    parseObjectData(meta, data, start3, count) {
      const { xScale, yScale } = meta;
      const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
      const parsed = new Array(count);
      let i3, ilen, index2, item;
      for (i3 = 0, ilen = count; i3 < ilen; ++i3) {
        index2 = i3 + start3;
        item = data[index2];
        parsed[i3] = {
          x: xScale.parse(resolveObjectKey(item, xAxisKey), index2),
          y: yScale.parse(resolveObjectKey(item, yAxisKey), index2)
        };
      }
      return parsed;
    }
    getParsed(index2) {
      return this._cachedMeta._parsed[index2];
    }
    getDataElement(index2) {
      return this._cachedMeta.data[index2];
    }
    applyStack(scale, parsed, mode) {
      const chart = this.chart;
      const meta = this._cachedMeta;
      const value = parsed[scale.axis];
      const stack = {
        keys: getSortedDatasetIndices(chart, true),
        values: parsed._stacks[scale.axis]._visualValues
      };
      return applyStack(stack, value, meta.index, {
        mode
      });
    }
    updateRangeFromParsed(range, scale, parsed, stack) {
      const parsedValue = parsed[scale.axis];
      let value = parsedValue === null ? NaN : parsedValue;
      const values = stack && parsed._stacks[scale.axis];
      if (stack && values) {
        stack.values = values;
        value = applyStack(stack, parsedValue, this._cachedMeta.index);
      }
      range.min = Math.min(range.min, value);
      range.max = Math.max(range.max, value);
    }
    getMinMax(scale, canStack) {
      const meta = this._cachedMeta;
      const _parsed = meta._parsed;
      const sorted = meta._sorted && scale === meta.iScale;
      const ilen = _parsed.length;
      const otherScale = this._getOtherScale(scale);
      const stack = createStack(canStack, meta, this.chart);
      const range = {
        min: Number.POSITIVE_INFINITY,
        max: Number.NEGATIVE_INFINITY
      };
      const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
      let i3, parsed;
      function _skip() {
        parsed = _parsed[i3];
        const otherValue = parsed[otherScale.axis];
        return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
      }
      for (i3 = 0; i3 < ilen; ++i3) {
        if (_skip()) {
          continue;
        }
        this.updateRangeFromParsed(range, scale, parsed, stack);
        if (sorted) {
          break;
        }
      }
      if (sorted) {
        for (i3 = ilen - 1; i3 >= 0; --i3) {
          if (_skip()) {
            continue;
          }
          this.updateRangeFromParsed(range, scale, parsed, stack);
          break;
        }
      }
      return range;
    }
    getAllParsedValues(scale) {
      const parsed = this._cachedMeta._parsed;
      const values = [];
      let i3, ilen, value;
      for (i3 = 0, ilen = parsed.length; i3 < ilen; ++i3) {
        value = parsed[i3][scale.axis];
        if (isNumberFinite(value)) {
          values.push(value);
        }
      }
      return values;
    }
    getMaxOverflow() {
      return false;
    }
    getLabelAndValue(index2) {
      const meta = this._cachedMeta;
      const iScale = meta.iScale;
      const vScale = meta.vScale;
      const parsed = this.getParsed(index2);
      return {
        label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
        value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
      };
    }
    _update(mode) {
      const meta = this._cachedMeta;
      this.update(mode || "default");
      meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
    }
    update(mode) {
    }
    draw() {
      const ctx = this._ctx;
      const chart = this.chart;
      const meta = this._cachedMeta;
      const elements3 = meta.data || [];
      const area = chart.chartArea;
      const active = [];
      const start3 = this._drawStart || 0;
      const count = this._drawCount || elements3.length - start3;
      const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
      let i3;
      if (meta.dataset) {
        meta.dataset.draw(ctx, area, start3, count);
      }
      for (i3 = start3; i3 < start3 + count; ++i3) {
        const element = elements3[i3];
        if (element.hidden) {
          continue;
        }
        if (element.active && drawActiveElementsOnTop) {
          active.push(element);
        } else {
          element.draw(ctx, area);
        }
      }
      for (i3 = 0; i3 < active.length; ++i3) {
        active[i3].draw(ctx, area);
      }
    }
    getStyle(index2, active) {
      const mode = active ? "active" : "default";
      return index2 === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index2 || 0, mode);
    }
    getContext(index2, active, mode) {
      const dataset = this.getDataset();
      let context;
      if (index2 >= 0 && index2 < this._cachedMeta.data.length) {
        const element = this._cachedMeta.data[index2];
        context = element.$context || (element.$context = createDataContext(this.getContext(), index2, element));
        context.parsed = this.getParsed(index2);
        context.raw = dataset.data[index2];
        context.index = context.dataIndex = index2;
      } else {
        context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
        context.dataset = dataset;
        context.index = context.datasetIndex = this.index;
      }
      context.active = !!active;
      context.mode = mode;
      return context;
    }
    resolveDatasetElementOptions(mode) {
      return this._resolveElementOptions(this.datasetElementType.id, mode);
    }
    resolveDataElementOptions(index2, mode) {
      return this._resolveElementOptions(this.dataElementType.id, mode, index2);
    }
    _resolveElementOptions(elementType2, mode = "default", index2) {
      const active = mode === "active";
      const cache = this._cachedDataOpts;
      const cacheKey = elementType2 + "-" + mode;
      const cached = cache[cacheKey];
      const sharing = this.enableOptionSharing && defined(index2);
      if (cached) {
        return cloneIfNotShared(cached, sharing);
      }
      const config = this.chart.config;
      const scopeKeys = config.datasetElementScopeKeys(this._type, elementType2);
      const prefixes = active ? [
        `${elementType2}Hover`,
        "hover",
        elementType2,
        ""
      ] : [
        elementType2,
        ""
      ];
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
      const names2 = Object.keys(defaults.elements[elementType2]);
      const context = () => this.getContext(index2, active, mode);
      const values = config.resolveNamedOptions(scopes, names2, context, prefixes);
      if (values.$shared) {
        values.$shared = sharing;
        cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
      }
      return values;
    }
    _resolveAnimations(index2, transition, active) {
      const chart = this.chart;
      const cache = this._cachedDataOpts;
      const cacheKey = `animation-${transition}`;
      const cached = cache[cacheKey];
      if (cached) {
        return cached;
      }
      let options2;
      if (chart.options.animation !== false) {
        const config = this.chart.config;
        const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
        options2 = config.createResolver(scopes, this.getContext(index2, active, transition));
      }
      const animations = new Animations(chart, options2 && options2.animations);
      if (options2 && options2._cacheable) {
        cache[cacheKey] = Object.freeze(animations);
      }
      return animations;
    }
    getSharedOptions(options2) {
      if (!options2.$shared) {
        return;
      }
      return this._sharedOptions || (this._sharedOptions = Object.assign({}, options2));
    }
    includeOptions(mode, sharedOptions) {
      return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
    }
    _getSharedOptions(start3, mode) {
      const firstOpts = this.resolveDataElementOptions(start3, mode);
      const previouslySharedOptions = this._sharedOptions;
      const sharedOptions = this.getSharedOptions(firstOpts);
      const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
      this.updateSharedOptions(sharedOptions, mode, firstOpts);
      return {
        sharedOptions,
        includeOptions
      };
    }
    updateElement(element, index2, properties, mode) {
      if (isDirectUpdateMode(mode)) {
        Object.assign(element, properties);
      } else {
        this._resolveAnimations(index2, mode).update(element, properties);
      }
    }
    updateSharedOptions(sharedOptions, mode, newOptions) {
      if (sharedOptions && !isDirectUpdateMode(mode)) {
        this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
      }
    }
    _setStyle(element, index2, mode, active) {
      element.active = active;
      const options2 = this.getStyle(index2, active);
      this._resolveAnimations(index2, mode, active).update(element, {
        options: !active && this.getSharedOptions(options2) || options2
      });
    }
    removeHoverStyle(element, datasetIndex, index2) {
      this._setStyle(element, index2, "active", false);
    }
    setHoverStyle(element, datasetIndex, index2) {
      this._setStyle(element, index2, "active", true);
    }
    _removeDatasetHoverStyle() {
      const element = this._cachedMeta.dataset;
      if (element) {
        this._setStyle(element, void 0, "active", false);
      }
    }
    _setDatasetHoverStyle() {
      const element = this._cachedMeta.dataset;
      if (element) {
        this._setStyle(element, void 0, "active", true);
      }
    }
    _resyncElements(resetNewElements) {
      const data = this._data;
      const elements3 = this._cachedMeta.data;
      for (const [method, arg1, arg2] of this._syncList) {
        this[method](arg1, arg2);
      }
      this._syncList = [];
      const numMeta = elements3.length;
      const numData = data.length;
      const count = Math.min(numData, numMeta);
      if (count) {
        this.parse(0, count);
      }
      if (numData > numMeta) {
        this._insertElements(numMeta, numData - numMeta, resetNewElements);
      } else if (numData < numMeta) {
        this._removeElements(numData, numMeta - numData);
      }
    }
    _insertElements(start3, count, resetNewElements = true) {
      const meta = this._cachedMeta;
      const data = meta.data;
      const end2 = start3 + count;
      let i3;
      const move = (arr) => {
        arr.length += count;
        for (i3 = arr.length - 1; i3 >= end2; i3--) {
          arr[i3] = arr[i3 - count];
        }
      };
      move(data);
      for (i3 = start3; i3 < end2; ++i3) {
        data[i3] = new this.dataElementType();
      }
      if (this._parsing) {
        move(meta._parsed);
      }
      this.parse(start3, count);
      if (resetNewElements) {
        this.updateElements(data, start3, count, "reset");
      }
    }
    updateElements(element, start3, count, mode) {
    }
    _removeElements(start3, count) {
      const meta = this._cachedMeta;
      if (this._parsing) {
        const removed = meta._parsed.splice(start3, count);
        if (meta._stacked) {
          clearStacks(meta, removed);
        }
      }
      meta.data.splice(start3, count);
    }
    _sync(args) {
      if (this._parsing) {
        this._syncList.push(args);
      } else {
        const [method, arg1, arg2] = args;
        this[method](arg1, arg2);
      }
      this.chart._dataChanges.push([
        this.index,
        ...args
      ]);
    }
    _onDataPush() {
      const count = arguments.length;
      this._sync([
        "_insertElements",
        this.getDataset().data.length - count,
        count
      ]);
    }
    _onDataPop() {
      this._sync([
        "_removeElements",
        this._cachedMeta.data.length - 1,
        1
      ]);
    }
    _onDataShift() {
      this._sync([
        "_removeElements",
        0,
        1
      ]);
    }
    _onDataSplice(start3, count) {
      if (count) {
        this._sync([
          "_removeElements",
          start3,
          count
        ]);
      }
      const newCount = arguments.length - 2;
      if (newCount) {
        this._sync([
          "_insertElements",
          start3,
          newCount
        ]);
      }
    }
    _onDataUnshift() {
      this._sync([
        "_insertElements",
        0,
        arguments.length
      ]);
    }
  };
  __publicField(DatasetController, "defaults", {});
  __publicField(DatasetController, "datasetElementType", null);
  __publicField(DatasetController, "dataElementType", null);
  function getAllScaleValues(scale, type) {
    if (!scale._cache.$bar) {
      const visibleMetas = scale.getMatchingVisibleMetas(type);
      let values = [];
      for (let i3 = 0, ilen = visibleMetas.length; i3 < ilen; i3++) {
        values = values.concat(visibleMetas[i3].controller.getAllParsedValues(scale));
      }
      scale._cache.$bar = _arrayUnique(values.sort((a4, b2) => a4 - b2));
    }
    return scale._cache.$bar;
  }
  function computeMinSampleSize(meta) {
    const scale = meta.iScale;
    const values = getAllScaleValues(scale, meta.type);
    let min2 = scale._length;
    let i3, ilen, curr, prev;
    const updateMinAndPrev = () => {
      if (curr === 32767 || curr === -32768) {
        return;
      }
      if (defined(prev)) {
        min2 = Math.min(min2, Math.abs(curr - prev) || min2);
      }
      prev = curr;
    };
    for (i3 = 0, ilen = values.length; i3 < ilen; ++i3) {
      curr = scale.getPixelForValue(values[i3]);
      updateMinAndPrev();
    }
    prev = void 0;
    for (i3 = 0, ilen = scale.ticks.length; i3 < ilen; ++i3) {
      curr = scale.getPixelForTick(i3);
      updateMinAndPrev();
    }
    return min2;
  }
  function computeFitCategoryTraits(index2, ruler, options2, stackCount) {
    const thickness = options2.barThickness;
    let size, ratio;
    if (isNullOrUndef(thickness)) {
      size = ruler.min * options2.categoryPercentage;
      ratio = options2.barPercentage;
    } else {
      size = thickness * stackCount;
      ratio = 1;
    }
    return {
      chunk: size / stackCount,
      ratio,
      start: ruler.pixels[index2] - size / 2
    };
  }
  function computeFlexCategoryTraits(index2, ruler, options2, stackCount) {
    const pixels = ruler.pixels;
    const curr = pixels[index2];
    let prev = index2 > 0 ? pixels[index2 - 1] : null;
    let next = index2 < pixels.length - 1 ? pixels[index2 + 1] : null;
    const percent = options2.categoryPercentage;
    if (prev === null) {
      prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
    }
    if (next === null) {
      next = curr + curr - prev;
    }
    const start3 = curr - (curr - Math.min(prev, next)) / 2 * percent;
    const size = Math.abs(next - prev) / 2 * percent;
    return {
      chunk: size / stackCount,
      ratio: options2.barPercentage,
      start: start3
    };
  }
  function parseFloatBar(entry, item, vScale, i3) {
    const startValue = vScale.parse(entry[0], i3);
    const endValue = vScale.parse(entry[1], i3);
    const min2 = Math.min(startValue, endValue);
    const max2 = Math.max(startValue, endValue);
    let barStart = min2;
    let barEnd = max2;
    if (Math.abs(min2) > Math.abs(max2)) {
      barStart = max2;
      barEnd = min2;
    }
    item[vScale.axis] = barEnd;
    item._custom = {
      barStart,
      barEnd,
      start: startValue,
      end: endValue,
      min: min2,
      max: max2
    };
  }
  function parseValue(entry, item, vScale, i3) {
    if (isArray2(entry)) {
      parseFloatBar(entry, item, vScale, i3);
    } else {
      item[vScale.axis] = vScale.parse(entry, i3);
    }
    return item;
  }
  function parseArrayOrPrimitive(meta, data, start3, count) {
    const iScale = meta.iScale;
    const vScale = meta.vScale;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = [];
    let i3, ilen, item, entry;
    for (i3 = start3, ilen = start3 + count; i3 < ilen; ++i3) {
      entry = data[i3];
      item = {};
      item[iScale.axis] = singleScale || iScale.parse(labels[i3], i3);
      parsed.push(parseValue(entry, item, vScale, i3));
    }
    return parsed;
  }
  function isFloatBar(custom) {
    return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;
  }
  function barSign(size, vScale, actualBase) {
    if (size !== 0) {
      return sign(size);
    }
    return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
  }
  function borderProps(properties) {
    let reverse, start3, end2, top2, bottom2;
    if (properties.horizontal) {
      reverse = properties.base > properties.x;
      start3 = "left";
      end2 = "right";
    } else {
      reverse = properties.base < properties.y;
      start3 = "bottom";
      end2 = "top";
    }
    if (reverse) {
      top2 = "end";
      bottom2 = "start";
    } else {
      top2 = "start";
      bottom2 = "end";
    }
    return {
      start: start3,
      end: end2,
      reverse,
      top: top2,
      bottom: bottom2
    };
  }
  function setBorderSkipped(properties, options2, stack, index2) {
    let edge = options2.borderSkipped;
    const res = {};
    if (!edge) {
      properties.borderSkipped = res;
      return;
    }
    if (edge === true) {
      properties.borderSkipped = {
        top: true,
        right: true,
        bottom: true,
        left: true
      };
      return;
    }
    const { start: start3, end: end2, reverse, top: top2, bottom: bottom2 } = borderProps(properties);
    if (edge === "middle" && stack) {
      properties.enableBorderRadius = true;
      if ((stack._top || 0) === index2) {
        edge = top2;
      } else if ((stack._bottom || 0) === index2) {
        edge = bottom2;
      } else {
        res[parseEdge(bottom2, start3, end2, reverse)] = true;
        edge = top2;
      }
    }
    res[parseEdge(edge, start3, end2, reverse)] = true;
    properties.borderSkipped = res;
  }
  function parseEdge(edge, a4, b2, reverse) {
    if (reverse) {
      edge = swap(edge, a4, b2);
      edge = startEnd(edge, b2, a4);
    } else {
      edge = startEnd(edge, a4, b2);
    }
    return edge;
  }
  function swap(orig, v1, v2) {
    return orig === v1 ? v2 : orig === v2 ? v1 : orig;
  }
  function startEnd(v, start3, end2) {
    return v === "start" ? start3 : v === "end" ? end2 : v;
  }
  function setInflateAmount(properties, { inflateAmount }, ratio) {
    properties.inflateAmount = inflateAmount === "auto" ? ratio === 1 ? 0.33 : 0 : inflateAmount;
  }
  var BarController = class extends DatasetController {
    parsePrimitiveData(meta, data, start3, count) {
      return parseArrayOrPrimitive(meta, data, start3, count);
    }
    parseArrayData(meta, data, start3, count) {
      return parseArrayOrPrimitive(meta, data, start3, count);
    }
    parseObjectData(meta, data, start3, count) {
      const { iScale, vScale } = meta;
      const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
      const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
      const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
      const parsed = [];
      let i3, ilen, item, obj;
      for (i3 = start3, ilen = start3 + count; i3 < ilen; ++i3) {
        obj = data[i3];
        item = {};
        item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i3);
        parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i3));
      }
      return parsed;
    }
    updateRangeFromParsed(range, scale, parsed, stack) {
      super.updateRangeFromParsed(range, scale, parsed, stack);
      const custom = parsed._custom;
      if (custom && scale === this._cachedMeta.vScale) {
        range.min = Math.min(range.min, custom.min);
        range.max = Math.max(range.max, custom.max);
      }
    }
    getMaxOverflow() {
      return 0;
    }
    getLabelAndValue(index2) {
      const meta = this._cachedMeta;
      const { iScale, vScale } = meta;
      const parsed = this.getParsed(index2);
      const custom = parsed._custom;
      const value = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
      return {
        label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
        value
      };
    }
    initialize() {
      this.enableOptionSharing = true;
      super.initialize();
      const meta = this._cachedMeta;
      meta.stack = this.getDataset().stack;
    }
    update(mode) {
      const meta = this._cachedMeta;
      this.updateElements(meta.data, 0, meta.data.length, mode);
    }
    updateElements(bars, start3, count, mode) {
      const reset = mode === "reset";
      const { index: index2, _cachedMeta: { vScale } } = this;
      const base = vScale.getBasePixel();
      const horizontal = vScale.isHorizontal();
      const ruler = this._getRuler();
      const { sharedOptions, includeOptions } = this._getSharedOptions(start3, mode);
      for (let i3 = start3; i3 < start3 + count; i3++) {
        const parsed = this.getParsed(i3);
        const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {
          base,
          head: base
        } : this._calculateBarValuePixels(i3);
        const ipixels = this._calculateBarIndexPixels(i3, ruler);
        const stack = (parsed._stacks || {})[vScale.axis];
        const properties = {
          horizontal,
          base: vpixels.base,
          enableBorderRadius: !stack || isFloatBar(parsed._custom) || index2 === stack._top || index2 === stack._bottom,
          x: horizontal ? vpixels.head : ipixels.center,
          y: horizontal ? ipixels.center : vpixels.head,
          height: horizontal ? ipixels.size : Math.abs(vpixels.size),
          width: horizontal ? Math.abs(vpixels.size) : ipixels.size
        };
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i3, bars[i3].active ? "active" : mode);
        }
        const options2 = properties.options || bars[i3].options;
        setBorderSkipped(properties, options2, stack, index2);
        setInflateAmount(properties, options2, ruler.ratio);
        this.updateElement(bars[i3], i3, properties, mode);
      }
    }
    _getStacks(last, dataIndex) {
      const { iScale } = this._cachedMeta;
      const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta) => meta.controller.options.grouped);
      const stacked = iScale.options.stacked;
      const stacks = [];
      const skipNull = (meta) => {
        const parsed = meta.controller.getParsed(dataIndex);
        const val = parsed && parsed[meta.vScale.axis];
        if (isNullOrUndef(val) || isNaN(val)) {
          return true;
        }
      };
      for (const meta of metasets) {
        if (dataIndex !== void 0 && skipNull(meta)) {
          continue;
        }
        if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === void 0 && meta.stack === void 0) {
          stacks.push(meta.stack);
        }
        if (meta.index === last) {
          break;
        }
      }
      if (!stacks.length) {
        stacks.push(void 0);
      }
      return stacks;
    }
    _getStackCount(index2) {
      return this._getStacks(void 0, index2).length;
    }
    _getStackIndex(datasetIndex, name2, dataIndex) {
      const stacks = this._getStacks(datasetIndex, dataIndex);
      const index2 = name2 !== void 0 ? stacks.indexOf(name2) : -1;
      return index2 === -1 ? stacks.length - 1 : index2;
    }
    _getRuler() {
      const opts = this.options;
      const meta = this._cachedMeta;
      const iScale = meta.iScale;
      const pixels = [];
      let i3, ilen;
      for (i3 = 0, ilen = meta.data.length; i3 < ilen; ++i3) {
        pixels.push(iScale.getPixelForValue(this.getParsed(i3)[iScale.axis], i3));
      }
      const barThickness = opts.barThickness;
      const min2 = barThickness || computeMinSampleSize(meta);
      return {
        min: min2,
        pixels,
        start: iScale._startPixel,
        end: iScale._endPixel,
        stackCount: this._getStackCount(),
        scale: iScale,
        grouped: opts.grouped,
        ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
      };
    }
    _calculateBarValuePixels(index2) {
      const { _cachedMeta: { vScale, _stacked, index: datasetIndex }, options: { base: baseValue, minBarLength } } = this;
      const actualBase = baseValue || 0;
      const parsed = this.getParsed(index2);
      const custom = parsed._custom;
      const floating = isFloatBar(custom);
      let value = parsed[vScale.axis];
      let start3 = 0;
      let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
      let head, size;
      if (length !== value) {
        start3 = length - value;
        length = value;
      }
      if (floating) {
        value = custom.barStart;
        length = custom.barEnd - custom.barStart;
        if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
          start3 = 0;
        }
        start3 += value;
      }
      const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start3;
      let base = vScale.getPixelForValue(startValue);
      if (this.chart.getDataVisibility(index2)) {
        head = vScale.getPixelForValue(start3 + length);
      } else {
        head = base;
      }
      size = head - base;
      if (Math.abs(size) < minBarLength) {
        size = barSign(size, vScale, actualBase) * minBarLength;
        if (value === actualBase) {
          base -= size / 2;
        }
        const startPixel = vScale.getPixelForDecimal(0);
        const endPixel = vScale.getPixelForDecimal(1);
        const min2 = Math.min(startPixel, endPixel);
        const max2 = Math.max(startPixel, endPixel);
        base = Math.max(Math.min(base, max2), min2);
        head = base + size;
        if (_stacked && !floating) {
          parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);
        }
      }
      if (base === vScale.getPixelForValue(actualBase)) {
        const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
        base += halfGrid;
        size -= halfGrid;
      }
      return {
        size,
        base,
        head,
        center: head + size / 2
      };
    }
    _calculateBarIndexPixels(index2, ruler) {
      const scale = ruler.scale;
      const options2 = this.options;
      const skipNull = options2.skipNull;
      const maxBarThickness = valueOrDefault(options2.maxBarThickness, Infinity);
      let center, size;
      if (ruler.grouped) {
        const stackCount = skipNull ? this._getStackCount(index2) : ruler.stackCount;
        const range = options2.barThickness === "flex" ? computeFlexCategoryTraits(index2, ruler, options2, stackCount) : computeFitCategoryTraits(index2, ruler, options2, stackCount);
        const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index2 : void 0);
        center = range.start + range.chunk * stackIndex + range.chunk / 2;
        size = Math.min(maxBarThickness, range.chunk * range.ratio);
      } else {
        center = scale.getPixelForValue(this.getParsed(index2)[scale.axis], index2);
        size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
      }
      return {
        base: center - size / 2,
        head: center + size / 2,
        center,
        size
      };
    }
    draw() {
      const meta = this._cachedMeta;
      const vScale = meta.vScale;
      const rects = meta.data;
      const ilen = rects.length;
      let i3 = 0;
      for (; i3 < ilen; ++i3) {
        if (this.getParsed(i3)[vScale.axis] !== null) {
          rects[i3].draw(this._ctx);
        }
      }
    }
  };
  __publicField(BarController, "id", "bar");
  __publicField(BarController, "defaults", {
    datasetElementType: false,
    dataElementType: "bar",
    categoryPercentage: 0.8,
    barPercentage: 0.9,
    grouped: true,
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "base",
          "width",
          "height"
        ]
      }
    }
  });
  __publicField(BarController, "overrides", {
    scales: {
      _index_: {
        type: "category",
        offset: true,
        grid: {
          offset: true
        }
      },
      _value_: {
        type: "linear",
        beginAtZero: true
      }
    }
  });
  var BubbleController = class extends DatasetController {
    initialize() {
      this.enableOptionSharing = true;
      super.initialize();
    }
    parsePrimitiveData(meta, data, start3, count) {
      const parsed = super.parsePrimitiveData(meta, data, start3, count);
      for (let i3 = 0; i3 < parsed.length; i3++) {
        parsed[i3]._custom = this.resolveDataElementOptions(i3 + start3).radius;
      }
      return parsed;
    }
    parseArrayData(meta, data, start3, count) {
      const parsed = super.parseArrayData(meta, data, start3, count);
      for (let i3 = 0; i3 < parsed.length; i3++) {
        const item = data[start3 + i3];
        parsed[i3]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i3 + start3).radius);
      }
      return parsed;
    }
    parseObjectData(meta, data, start3, count) {
      const parsed = super.parseObjectData(meta, data, start3, count);
      for (let i3 = 0; i3 < parsed.length; i3++) {
        const item = data[start3 + i3];
        parsed[i3]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i3 + start3).radius);
      }
      return parsed;
    }
    getMaxOverflow() {
      const data = this._cachedMeta.data;
      let max2 = 0;
      for (let i3 = data.length - 1; i3 >= 0; --i3) {
        max2 = Math.max(max2, data[i3].size(this.resolveDataElementOptions(i3)) / 2);
      }
      return max2 > 0 && max2;
    }
    getLabelAndValue(index2) {
      const meta = this._cachedMeta;
      const labels = this.chart.data.labels || [];
      const { xScale, yScale } = meta;
      const parsed = this.getParsed(index2);
      const x2 = xScale.getLabelForValue(parsed.x);
      const y3 = yScale.getLabelForValue(parsed.y);
      const r2 = parsed._custom;
      return {
        label: labels[index2] || "",
        value: "(" + x2 + ", " + y3 + (r2 ? ", " + r2 : "") + ")"
      };
    }
    update(mode) {
      const points = this._cachedMeta.data;
      this.updateElements(points, 0, points.length, mode);
    }
    updateElements(points, start3, count, mode) {
      const reset = mode === "reset";
      const { iScale, vScale } = this._cachedMeta;
      const { sharedOptions, includeOptions } = this._getSharedOptions(start3, mode);
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      for (let i3 = start3; i3 < start3 + count; i3++) {
        const point = points[i3];
        const parsed = !reset && this.getParsed(i3);
        const properties = {};
        const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
        const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
        properties.skip = isNaN(iPixel) || isNaN(vPixel);
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i3, point.active ? "active" : mode);
          if (reset) {
            properties.options.radius = 0;
          }
        }
        this.updateElement(point, i3, properties, mode);
      }
    }
    resolveDataElementOptions(index2, mode) {
      const parsed = this.getParsed(index2);
      let values = super.resolveDataElementOptions(index2, mode);
      if (values.$shared) {
        values = Object.assign({}, values, {
          $shared: false
        });
      }
      const radius = values.radius;
      if (mode !== "active") {
        values.radius = 0;
      }
      values.radius += valueOrDefault(parsed && parsed._custom, radius);
      return values;
    }
  };
  __publicField(BubbleController, "id", "bubble");
  __publicField(BubbleController, "defaults", {
    datasetElementType: false,
    dataElementType: "point",
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "borderWidth",
          "radius"
        ]
      }
    }
  });
  __publicField(BubbleController, "overrides", {
    scales: {
      x: {
        type: "linear"
      },
      y: {
        type: "linear"
      }
    }
  });
  function getRatioAndOffset(rotation, circumference, cutout) {
    let ratioX = 1;
    let ratioY = 1;
    let offsetX = 0;
    let offsetY = 0;
    if (circumference < TAU) {
      const startAngle = rotation;
      const endAngle = startAngle + circumference;
      const startX = Math.cos(startAngle);
      const startY = Math.sin(startAngle);
      const endX = Math.cos(endAngle);
      const endY = Math.sin(endAngle);
      const calcMax = (angle, a4, b2) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a4, a4 * cutout, b2, b2 * cutout);
      const calcMin = (angle, a4, b2) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a4, a4 * cutout, b2, b2 * cutout);
      const maxX = calcMax(0, startX, endX);
      const maxY = calcMax(HALF_PI, startY, endY);
      const minX = calcMin(PI, startX, endX);
      const minY = calcMin(PI + HALF_PI, startY, endY);
      ratioX = (maxX - minX) / 2;
      ratioY = (maxY - minY) / 2;
      offsetX = -(maxX + minX) / 2;
      offsetY = -(maxY + minY) / 2;
    }
    return {
      ratioX,
      ratioY,
      offsetX,
      offsetY
    };
  }
  var DoughnutController = class extends DatasetController {
    constructor(chart, datasetIndex) {
      super(chart, datasetIndex);
      this.enableOptionSharing = true;
      this.innerRadius = void 0;
      this.outerRadius = void 0;
      this.offsetX = void 0;
      this.offsetY = void 0;
    }
    linkScales() {
    }
    parse(start3, count) {
      const data = this.getDataset().data;
      const meta = this._cachedMeta;
      if (this._parsing === false) {
        meta._parsed = data;
      } else {
        let getter = (i4) => +data[i4];
        if (isObject(data[start3])) {
          const { key = "value" } = this._parsing;
          getter = (i4) => +resolveObjectKey(data[i4], key);
        }
        let i3, ilen;
        for (i3 = start3, ilen = start3 + count; i3 < ilen; ++i3) {
          meta._parsed[i3] = getter(i3);
        }
      }
    }
    _getRotation() {
      return toRadians(this.options.rotation - 90);
    }
    _getCircumference() {
      return toRadians(this.options.circumference);
    }
    _getRotationExtents() {
      let min2 = TAU;
      let max2 = -TAU;
      for (let i3 = 0; i3 < this.chart.data.datasets.length; ++i3) {
        if (this.chart.isDatasetVisible(i3) && this.chart.getDatasetMeta(i3).type === this._type) {
          const controller = this.chart.getDatasetMeta(i3).controller;
          const rotation = controller._getRotation();
          const circumference = controller._getCircumference();
          min2 = Math.min(min2, rotation);
          max2 = Math.max(max2, rotation + circumference);
        }
      }
      return {
        rotation: min2,
        circumference: max2 - min2
      };
    }
    update(mode) {
      const chart = this.chart;
      const { chartArea } = chart;
      const meta = this._cachedMeta;
      const arcs = meta.data;
      const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
      const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
      const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
      const chartWeight = this._getRingWeight(this.index);
      const { circumference, rotation } = this._getRotationExtents();
      const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);
      const maxWidth = (chartArea.width - spacing) / ratioX;
      const maxHeight = (chartArea.height - spacing) / ratioY;
      const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
      const outerRadius = toDimension(this.options.radius, maxRadius);
      const innerRadius = Math.max(outerRadius * cutout, 0);
      const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
      this.offsetX = offsetX * outerRadius;
      this.offsetY = offsetY * outerRadius;
      meta.total = this.calculateTotal();
      this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
      this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
      this.updateElements(arcs, 0, arcs.length, mode);
    }
    _circumference(i3, reset) {
      const opts = this.options;
      const meta = this._cachedMeta;
      const circumference = this._getCircumference();
      if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i3) || meta._parsed[i3] === null || meta.data[i3].hidden) {
        return 0;
      }
      return this.calculateCircumference(meta._parsed[i3] * circumference / TAU);
    }
    updateElements(arcs, start3, count, mode) {
      const reset = mode === "reset";
      const chart = this.chart;
      const chartArea = chart.chartArea;
      const opts = chart.options;
      const animationOpts = opts.animation;
      const centerX = (chartArea.left + chartArea.right) / 2;
      const centerY = (chartArea.top + chartArea.bottom) / 2;
      const animateScale = reset && animationOpts.animateScale;
      const innerRadius = animateScale ? 0 : this.innerRadius;
      const outerRadius = animateScale ? 0 : this.outerRadius;
      const { sharedOptions, includeOptions } = this._getSharedOptions(start3, mode);
      let startAngle = this._getRotation();
      let i3;
      for (i3 = 0; i3 < start3; ++i3) {
        startAngle += this._circumference(i3, reset);
      }
      for (i3 = start3; i3 < start3 + count; ++i3) {
        const circumference = this._circumference(i3, reset);
        const arc = arcs[i3];
        const properties = {
          x: centerX + this.offsetX,
          y: centerY + this.offsetY,
          startAngle,
          endAngle: startAngle + circumference,
          circumference,
          outerRadius,
          innerRadius
        };
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i3, arc.active ? "active" : mode);
        }
        startAngle += circumference;
        this.updateElement(arc, i3, properties, mode);
      }
    }
    calculateTotal() {
      const meta = this._cachedMeta;
      const metaData = meta.data;
      let total = 0;
      let i3;
      for (i3 = 0; i3 < metaData.length; i3++) {
        const value = meta._parsed[i3];
        if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i3) && !metaData[i3].hidden) {
          total += Math.abs(value);
        }
      }
      return total;
    }
    calculateCircumference(value) {
      const total = this._cachedMeta.total;
      if (total > 0 && !isNaN(value)) {
        return TAU * (Math.abs(value) / total);
      }
      return 0;
    }
    getLabelAndValue(index2) {
      const meta = this._cachedMeta;
      const chart = this.chart;
      const labels = chart.data.labels || [];
      const value = formatNumber(meta._parsed[index2], chart.options.locale);
      return {
        label: labels[index2] || "",
        value
      };
    }
    getMaxBorderWidth(arcs) {
      let max2 = 0;
      const chart = this.chart;
      let i3, ilen, meta, controller, options2;
      if (!arcs) {
        for (i3 = 0, ilen = chart.data.datasets.length; i3 < ilen; ++i3) {
          if (chart.isDatasetVisible(i3)) {
            meta = chart.getDatasetMeta(i3);
            arcs = meta.data;
            controller = meta.controller;
            break;
          }
        }
      }
      if (!arcs) {
        return 0;
      }
      for (i3 = 0, ilen = arcs.length; i3 < ilen; ++i3) {
        options2 = controller.resolveDataElementOptions(i3);
        if (options2.borderAlign !== "inner") {
          max2 = Math.max(max2, options2.borderWidth || 0, options2.hoverBorderWidth || 0);
        }
      }
      return max2;
    }
    getMaxOffset(arcs) {
      let max2 = 0;
      for (let i3 = 0, ilen = arcs.length; i3 < ilen; ++i3) {
        const options2 = this.resolveDataElementOptions(i3);
        max2 = Math.max(max2, options2.offset || 0, options2.hoverOffset || 0);
      }
      return max2;
    }
    _getRingWeightOffset(datasetIndex) {
      let ringWeightOffset = 0;
      for (let i3 = 0; i3 < datasetIndex; ++i3) {
        if (this.chart.isDatasetVisible(i3)) {
          ringWeightOffset += this._getRingWeight(i3);
        }
      }
      return ringWeightOffset;
    }
    _getRingWeight(datasetIndex) {
      return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
    }
    _getVisibleDatasetWeightTotal() {
      return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
    }
  };
  __publicField(DoughnutController, "id", "doughnut");
  __publicField(DoughnutController, "defaults", {
    datasetElementType: false,
    dataElementType: "arc",
    animation: {
      animateRotate: true,
      animateScale: false
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "circumference",
          "endAngle",
          "innerRadius",
          "outerRadius",
          "startAngle",
          "x",
          "y",
          "offset",
          "borderWidth",
          "spacing"
        ]
      }
    },
    cutout: "50%",
    rotation: 0,
    circumference: 360,
    radius: "100%",
    spacing: 0,
    indexAxis: "r"
  });
  __publicField(DoughnutController, "descriptors", {
    _scriptable: (name2) => name2 !== "spacing",
    _indexable: (name2) => name2 !== "spacing"
  });
  __publicField(DoughnutController, "overrides", {
    aspectRatio: 1,
    plugins: {
      legend: {
        labels: {
          generateLabels(chart) {
            const data = chart.data;
            if (data.labels.length && data.datasets.length) {
              const { labels: { pointStyle, color: color2 } } = chart.legend.options;
              return data.labels.map((label, i3) => {
                const meta = chart.getDatasetMeta(0);
                const style = meta.controller.getStyle(i3);
                return {
                  text: label,
                  fillStyle: style.backgroundColor,
                  strokeStyle: style.borderColor,
                  fontColor: color2,
                  lineWidth: style.borderWidth,
                  pointStyle,
                  hidden: !chart.getDataVisibility(i3),
                  index: i3
                };
              });
            }
            return [];
          }
        },
        onClick(e3, legendItem, legend) {
          legend.chart.toggleDataVisibility(legendItem.index);
          legend.chart.update();
        }
      }
    }
  });
  var LineController = class extends DatasetController {
    initialize() {
      this.enableOptionSharing = true;
      this.supportsDecimation = true;
      super.initialize();
    }
    update(mode) {
      const meta = this._cachedMeta;
      const { dataset: line, data: points = [], _dataset } = meta;
      const animationsDisabled = this.chart._animationsDisabled;
      let { start: start3, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
      this._drawStart = start3;
      this._drawCount = count;
      if (_scaleRangesChanged(meta)) {
        start3 = 0;
        count = points.length;
      }
      line._chart = this.chart;
      line._datasetIndex = this.index;
      line._decimated = !!_dataset._decimated;
      line.points = points;
      const options2 = this.resolveDatasetElementOptions(mode);
      if (!this.options.showLine) {
        options2.borderWidth = 0;
      }
      options2.segment = this.options.segment;
      this.updateElement(line, void 0, {
        animated: !animationsDisabled,
        options: options2
      }, mode);
      this.updateElements(points, start3, count, mode);
    }
    updateElements(points, start3, count, mode) {
      const reset = mode === "reset";
      const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
      const { sharedOptions, includeOptions } = this._getSharedOptions(start3, mode);
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      const { spanGaps, segment } = this.options;
      const maxGapLength = isNumber2(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
      const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
      const end2 = start3 + count;
      const pointsCount = points.length;
      let prevParsed = start3 > 0 && this.getParsed(start3 - 1);
      for (let i3 = 0; i3 < pointsCount; ++i3) {
        const point = points[i3];
        const properties = directUpdate ? point : {};
        if (i3 < start3 || i3 >= end2) {
          properties.skip = true;
          continue;
        }
        const parsed = this.getParsed(i3);
        const nullData = isNullOrUndef(parsed[vAxis]);
        const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i3);
        const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i3);
        properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
        properties.stop = i3 > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
        if (segment) {
          properties.parsed = parsed;
          properties.raw = _dataset.data[i3];
        }
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i3, point.active ? "active" : mode);
        }
        if (!directUpdate) {
          this.updateElement(point, i3, properties, mode);
        }
        prevParsed = parsed;
      }
    }
    getMaxOverflow() {
      const meta = this._cachedMeta;
      const dataset = meta.dataset;
      const border = dataset.options && dataset.options.borderWidth || 0;
      const data = meta.data || [];
      if (!data.length) {
        return border;
      }
      const firstPoint = data[0].size(this.resolveDataElementOptions(0));
      const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
      return Math.max(border, firstPoint, lastPoint) / 2;
    }
    draw() {
      const meta = this._cachedMeta;
      meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
      super.draw();
    }
  };
  __publicField(LineController, "id", "line");
  __publicField(LineController, "defaults", {
    datasetElementType: "line",
    dataElementType: "point",
    showLine: true,
    spanGaps: false
  });
  __publicField(LineController, "overrides", {
    scales: {
      _index_: {
        type: "category"
      },
      _value_: {
        type: "linear"
      }
    }
  });
  var PolarAreaController = class extends DatasetController {
    constructor(chart, datasetIndex) {
      super(chart, datasetIndex);
      this.innerRadius = void 0;
      this.outerRadius = void 0;
    }
    getLabelAndValue(index2) {
      const meta = this._cachedMeta;
      const chart = this.chart;
      const labels = chart.data.labels || [];
      const value = formatNumber(meta._parsed[index2].r, chart.options.locale);
      return {
        label: labels[index2] || "",
        value
      };
    }
    parseObjectData(meta, data, start3, count) {
      return _parseObjectDataRadialScale.bind(this)(meta, data, start3, count);
    }
    update(mode) {
      const arcs = this._cachedMeta.data;
      this._updateRadius();
      this.updateElements(arcs, 0, arcs.length, mode);
    }
    getMinMax() {
      const meta = this._cachedMeta;
      const range = {
        min: Number.POSITIVE_INFINITY,
        max: Number.NEGATIVE_INFINITY
      };
      meta.data.forEach((element, index2) => {
        const parsed = this.getParsed(index2).r;
        if (!isNaN(parsed) && this.chart.getDataVisibility(index2)) {
          if (parsed < range.min) {
            range.min = parsed;
          }
          if (parsed > range.max) {
            range.max = parsed;
          }
        }
      });
      return range;
    }
    _updateRadius() {
      const chart = this.chart;
      const chartArea = chart.chartArea;
      const opts = chart.options;
      const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
      const outerRadius = Math.max(minSize / 2, 0);
      const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
      const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
      this.outerRadius = outerRadius - radiusLength * this.index;
      this.innerRadius = this.outerRadius - radiusLength;
    }
    updateElements(arcs, start3, count, mode) {
      const reset = mode === "reset";
      const chart = this.chart;
      const opts = chart.options;
      const animationOpts = opts.animation;
      const scale = this._cachedMeta.rScale;
      const centerX = scale.xCenter;
      const centerY = scale.yCenter;
      const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;
      let angle = datasetStartAngle;
      let i3;
      const defaultAngle = 360 / this.countVisibleElements();
      for (i3 = 0; i3 < start3; ++i3) {
        angle += this._computeAngle(i3, mode, defaultAngle);
      }
      for (i3 = start3; i3 < start3 + count; i3++) {
        const arc = arcs[i3];
        let startAngle = angle;
        let endAngle = angle + this._computeAngle(i3, mode, defaultAngle);
        let outerRadius = chart.getDataVisibility(i3) ? scale.getDistanceFromCenterForValue(this.getParsed(i3).r) : 0;
        angle = endAngle;
        if (reset) {
          if (animationOpts.animateScale) {
            outerRadius = 0;
          }
          if (animationOpts.animateRotate) {
            startAngle = endAngle = datasetStartAngle;
          }
        }
        const properties = {
          x: centerX,
          y: centerY,
          innerRadius: 0,
          outerRadius,
          startAngle,
          endAngle,
          options: this.resolveDataElementOptions(i3, arc.active ? "active" : mode)
        };
        this.updateElement(arc, i3, properties, mode);
      }
    }
    countVisibleElements() {
      const meta = this._cachedMeta;
      let count = 0;
      meta.data.forEach((element, index2) => {
        if (!isNaN(this.getParsed(index2).r) && this.chart.getDataVisibility(index2)) {
          count++;
        }
      });
      return count;
    }
    _computeAngle(index2, mode, defaultAngle) {
      return this.chart.getDataVisibility(index2) ? toRadians(this.resolveDataElementOptions(index2, mode).angle || defaultAngle) : 0;
    }
  };
  __publicField(PolarAreaController, "id", "polarArea");
  __publicField(PolarAreaController, "defaults", {
    dataElementType: "arc",
    animation: {
      animateRotate: true,
      animateScale: true
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "startAngle",
          "endAngle",
          "innerRadius",
          "outerRadius"
        ]
      }
    },
    indexAxis: "r",
    startAngle: 0
  });
  __publicField(PolarAreaController, "overrides", {
    aspectRatio: 1,
    plugins: {
      legend: {
        labels: {
          generateLabels(chart) {
            const data = chart.data;
            if (data.labels.length && data.datasets.length) {
              const { labels: { pointStyle, color: color2 } } = chart.legend.options;
              return data.labels.map((label, i3) => {
                const meta = chart.getDatasetMeta(0);
                const style = meta.controller.getStyle(i3);
                return {
                  text: label,
                  fillStyle: style.backgroundColor,
                  strokeStyle: style.borderColor,
                  fontColor: color2,
                  lineWidth: style.borderWidth,
                  pointStyle,
                  hidden: !chart.getDataVisibility(i3),
                  index: i3
                };
              });
            }
            return [];
          }
        },
        onClick(e3, legendItem, legend) {
          legend.chart.toggleDataVisibility(legendItem.index);
          legend.chart.update();
        }
      }
    },
    scales: {
      r: {
        type: "radialLinear",
        angleLines: {
          display: false
        },
        beginAtZero: true,
        grid: {
          circular: true
        },
        pointLabels: {
          display: false
        },
        startAngle: 0
      }
    }
  });
  var PieController = class extends DoughnutController {
  };
  __publicField(PieController, "id", "pie");
  __publicField(PieController, "defaults", {
    cutout: 0,
    rotation: 0,
    circumference: 360,
    radius: "100%"
  });
  var RadarController = class extends DatasetController {
    getLabelAndValue(index2) {
      const vScale = this._cachedMeta.vScale;
      const parsed = this.getParsed(index2);
      return {
        label: vScale.getLabels()[index2],
        value: "" + vScale.getLabelForValue(parsed[vScale.axis])
      };
    }
    parseObjectData(meta, data, start3, count) {
      return _parseObjectDataRadialScale.bind(this)(meta, data, start3, count);
    }
    update(mode) {
      const meta = this._cachedMeta;
      const line = meta.dataset;
      const points = meta.data || [];
      const labels = meta.iScale.getLabels();
      line.points = points;
      if (mode !== "resize") {
        const options2 = this.resolveDatasetElementOptions(mode);
        if (!this.options.showLine) {
          options2.borderWidth = 0;
        }
        const properties = {
          _loop: true,
          _fullLoop: labels.length === points.length,
          options: options2
        };
        this.updateElement(line, void 0, properties, mode);
      }
      this.updateElements(points, 0, points.length, mode);
    }
    updateElements(points, start3, count, mode) {
      const scale = this._cachedMeta.rScale;
      const reset = mode === "reset";
      for (let i3 = start3; i3 < start3 + count; i3++) {
        const point = points[i3];
        const options2 = this.resolveDataElementOptions(i3, point.active ? "active" : mode);
        const pointPosition = scale.getPointPositionForValue(i3, this.getParsed(i3).r);
        const x2 = reset ? scale.xCenter : pointPosition.x;
        const y3 = reset ? scale.yCenter : pointPosition.y;
        const properties = {
          x: x2,
          y: y3,
          angle: pointPosition.angle,
          skip: isNaN(x2) || isNaN(y3),
          options: options2
        };
        this.updateElement(point, i3, properties, mode);
      }
    }
  };
  __publicField(RadarController, "id", "radar");
  __publicField(RadarController, "defaults", {
    datasetElementType: "line",
    dataElementType: "point",
    indexAxis: "r",
    showLine: true,
    elements: {
      line: {
        fill: "start"
      }
    }
  });
  __publicField(RadarController, "overrides", {
    aspectRatio: 1,
    scales: {
      r: {
        type: "radialLinear"
      }
    }
  });
  var ScatterController = class extends DatasetController {
    getLabelAndValue(index2) {
      const meta = this._cachedMeta;
      const labels = this.chart.data.labels || [];
      const { xScale, yScale } = meta;
      const parsed = this.getParsed(index2);
      const x2 = xScale.getLabelForValue(parsed.x);
      const y3 = yScale.getLabelForValue(parsed.y);
      return {
        label: labels[index2] || "",
        value: "(" + x2 + ", " + y3 + ")"
      };
    }
    update(mode) {
      const meta = this._cachedMeta;
      const { data: points = [] } = meta;
      const animationsDisabled = this.chart._animationsDisabled;
      let { start: start3, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
      this._drawStart = start3;
      this._drawCount = count;
      if (_scaleRangesChanged(meta)) {
        start3 = 0;
        count = points.length;
      }
      if (this.options.showLine) {
        const { dataset: line, _dataset } = meta;
        line._chart = this.chart;
        line._datasetIndex = this.index;
        line._decimated = !!_dataset._decimated;
        line.points = points;
        const options2 = this.resolveDatasetElementOptions(mode);
        options2.segment = this.options.segment;
        this.updateElement(line, void 0, {
          animated: !animationsDisabled,
          options: options2
        }, mode);
      }
      this.updateElements(points, start3, count, mode);
    }
    addElements() {
      const { showLine } = this.options;
      if (!this.datasetElementType && showLine) {
        this.datasetElementType = this.chart.registry.getElement("line");
      }
      super.addElements();
    }
    updateElements(points, start3, count, mode) {
      const reset = mode === "reset";
      const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
      const firstOpts = this.resolveDataElementOptions(start3, mode);
      const sharedOptions = this.getSharedOptions(firstOpts);
      const includeOptions = this.includeOptions(mode, sharedOptions);
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      const { spanGaps, segment } = this.options;
      const maxGapLength = isNumber2(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
      const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
      let prevParsed = start3 > 0 && this.getParsed(start3 - 1);
      for (let i3 = start3; i3 < start3 + count; ++i3) {
        const point = points[i3];
        const parsed = this.getParsed(i3);
        const properties = directUpdate ? point : {};
        const nullData = isNullOrUndef(parsed[vAxis]);
        const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i3);
        const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i3);
        properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
        properties.stop = i3 > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
        if (segment) {
          properties.parsed = parsed;
          properties.raw = _dataset.data[i3];
        }
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i3, point.active ? "active" : mode);
        }
        if (!directUpdate) {
          this.updateElement(point, i3, properties, mode);
        }
        prevParsed = parsed;
      }
      this.updateSharedOptions(sharedOptions, mode, firstOpts);
    }
    getMaxOverflow() {
      const meta = this._cachedMeta;
      const data = meta.data || [];
      if (!this.options.showLine) {
        let max2 = 0;
        for (let i3 = data.length - 1; i3 >= 0; --i3) {
          max2 = Math.max(max2, data[i3].size(this.resolveDataElementOptions(i3)) / 2);
        }
        return max2 > 0 && max2;
      }
      const dataset = meta.dataset;
      const border = dataset.options && dataset.options.borderWidth || 0;
      if (!data.length) {
        return border;
      }
      const firstPoint = data[0].size(this.resolveDataElementOptions(0));
      const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
      return Math.max(border, firstPoint, lastPoint) / 2;
    }
  };
  __publicField(ScatterController, "id", "scatter");
  __publicField(ScatterController, "defaults", {
    datasetElementType: false,
    dataElementType: "point",
    showLine: false,
    fill: false
  });
  __publicField(ScatterController, "overrides", {
    interaction: {
      mode: "point"
    },
    scales: {
      x: {
        type: "linear"
      },
      y: {
        type: "linear"
      }
    }
  });
  var controllers = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    BarController,
    BubbleController,
    DoughnutController,
    LineController,
    PolarAreaController,
    PieController,
    RadarController,
    ScatterController
  });
  function abstract() {
    throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
  }
  var DateAdapterBase = class {
    static override(members) {
      Object.assign(DateAdapterBase.prototype, members);
    }
    constructor(options2) {
      this.options = options2 || {};
    }
    init() {
    }
    formats() {
      return abstract();
    }
    parse() {
      return abstract();
    }
    format() {
      return abstract();
    }
    add() {
      return abstract();
    }
    diff() {
      return abstract();
    }
    startOf() {
      return abstract();
    }
    endOf() {
      return abstract();
    }
  };
  var adapters2 = {
    _date: DateAdapterBase
  };
  function binarySearch(metaset, axis, value, intersect) {
    const { controller, data, _sorted } = metaset;
    const iScale = controller._cachedMeta.iScale;
    if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
      const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
      if (!intersect) {
        return lookupMethod(data, axis, value);
      } else if (controller._sharedOptions) {
        const el = data[0];
        const range = typeof el.getRange === "function" && el.getRange(axis);
        if (range) {
          const start3 = lookupMethod(data, axis, value - range);
          const end2 = lookupMethod(data, axis, value + range);
          return {
            lo: start3.lo,
            hi: end2.hi
          };
        }
      }
    }
    return {
      lo: 0,
      hi: data.length - 1
    };
  }
  function evaluateInteractionItems(chart, axis, position, handler, intersect) {
    const metasets = chart.getSortedVisibleDatasetMetas();
    const value = position[axis];
    for (let i3 = 0, ilen = metasets.length; i3 < ilen; ++i3) {
      const { index: index2, data } = metasets[i3];
      const { lo, hi } = binarySearch(metasets[i3], axis, value, intersect);
      for (let j = lo; j <= hi; ++j) {
        const element = data[j];
        if (!element.skip) {
          handler(element, index2, j);
        }
      }
    }
  }
  function getDistanceMetricForAxis(axis) {
    const useX = axis.indexOf("x") !== -1;
    const useY = axis.indexOf("y") !== -1;
    return function(pt1, pt2) {
      const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
      const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
      return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
    };
  }
  function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
    const items = [];
    if (!includeInvisible && !chart.isPointInArea(position)) {
      return items;
    }
    const evaluationFunc = function(element, datasetIndex, index2) {
      if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {
        return;
      }
      if (element.inRange(position.x, position.y, useFinalPosition)) {
        items.push({
          element,
          datasetIndex,
          index: index2
        });
      }
    };
    evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
    return items;
  }
  function getNearestRadialItems(chart, position, axis, useFinalPosition) {
    let items = [];
    function evaluationFunc(element, datasetIndex, index2) {
      const { startAngle, endAngle } = element.getProps([
        "startAngle",
        "endAngle"
      ], useFinalPosition);
      const { angle } = getAngleFromPoint(element, {
        x: position.x,
        y: position.y
      });
      if (_angleBetween(angle, startAngle, endAngle)) {
        items.push({
          element,
          datasetIndex,
          index: index2
        });
      }
    }
    evaluateInteractionItems(chart, axis, position, evaluationFunc);
    return items;
  }
  function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
    let items = [];
    const distanceMetric = getDistanceMetricForAxis(axis);
    let minDistance = Number.POSITIVE_INFINITY;
    function evaluationFunc(element, datasetIndex, index2) {
      const inRange2 = element.inRange(position.x, position.y, useFinalPosition);
      if (intersect && !inRange2) {
        return;
      }
      const center = element.getCenterPoint(useFinalPosition);
      const pointInArea = !!includeInvisible || chart.isPointInArea(center);
      if (!pointInArea && !inRange2) {
        return;
      }
      const distance = distanceMetric(position, center);
      if (distance < minDistance) {
        items = [
          {
            element,
            datasetIndex,
            index: index2
          }
        ];
        minDistance = distance;
      } else if (distance === minDistance) {
        items.push({
          element,
          datasetIndex,
          index: index2
        });
      }
    }
    evaluateInteractionItems(chart, axis, position, evaluationFunc);
    return items;
  }
  function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
    if (!includeInvisible && !chart.isPointInArea(position)) {
      return [];
    }
    return axis === "r" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);
  }
  function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
    const items = [];
    const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
    let intersectsItem = false;
    evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index2) => {
      if (element[rangeMethod](position[axis], useFinalPosition)) {
        items.push({
          element,
          datasetIndex,
          index: index2
        });
        intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
      }
    });
    if (intersect && !intersectsItem) {
      return [];
    }
    return items;
  }
  var Interaction = {
    evaluateInteractionItems,
    modes: {
      index(chart, e3, options2, useFinalPosition) {
        const position = getRelativePosition(e3, chart);
        const axis = options2.axis || "x";
        const includeInvisible = options2.includeInvisible || false;
        const items = options2.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
        const elements3 = [];
        if (!items.length) {
          return [];
        }
        chart.getSortedVisibleDatasetMetas().forEach((meta) => {
          const index2 = items[0].index;
          const element = meta.data[index2];
          if (element && !element.skip) {
            elements3.push({
              element,
              datasetIndex: meta.index,
              index: index2
            });
          }
        });
        return elements3;
      },
      dataset(chart, e3, options2, useFinalPosition) {
        const position = getRelativePosition(e3, chart);
        const axis = options2.axis || "xy";
        const includeInvisible = options2.includeInvisible || false;
        let items = options2.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
        if (items.length > 0) {
          const datasetIndex = items[0].datasetIndex;
          const data = chart.getDatasetMeta(datasetIndex).data;
          items = [];
          for (let i3 = 0; i3 < data.length; ++i3) {
            items.push({
              element: data[i3],
              datasetIndex,
              index: i3
            });
          }
        }
        return items;
      },
      point(chart, e3, options2, useFinalPosition) {
        const position = getRelativePosition(e3, chart);
        const axis = options2.axis || "xy";
        const includeInvisible = options2.includeInvisible || false;
        return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
      },
      nearest(chart, e3, options2, useFinalPosition) {
        const position = getRelativePosition(e3, chart);
        const axis = options2.axis || "xy";
        const includeInvisible = options2.includeInvisible || false;
        return getNearestItems(chart, position, axis, options2.intersect, useFinalPosition, includeInvisible);
      },
      x(chart, e3, options2, useFinalPosition) {
        const position = getRelativePosition(e3, chart);
        return getAxisItems(chart, position, "x", options2.intersect, useFinalPosition);
      },
      y(chart, e3, options2, useFinalPosition) {
        const position = getRelativePosition(e3, chart);
        return getAxisItems(chart, position, "y", options2.intersect, useFinalPosition);
      }
    }
  };
  var STATIC_POSITIONS = [
    "left",
    "top",
    "right",
    "bottom"
  ];
  function filterByPosition(array, position) {
    return array.filter((v) => v.pos === position);
  }
  function filterDynamicPositionByAxis(array, axis) {
    return array.filter((v) => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
  }
  function sortByWeight(array, reverse) {
    return array.sort((a4, b2) => {
      const v0 = reverse ? b2 : a4;
      const v1 = reverse ? a4 : b2;
      return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
    });
  }
  function wrapBoxes(boxes) {
    const layoutBoxes = [];
    let i3, ilen, box, pos, stack, stackWeight;
    for (i3 = 0, ilen = (boxes || []).length; i3 < ilen; ++i3) {
      box = boxes[i3];
      ({ position: pos, options: { stack, stackWeight = 1 } } = box);
      layoutBoxes.push({
        index: i3,
        box,
        pos,
        horizontal: box.isHorizontal(),
        weight: box.weight,
        stack: stack && pos + stack,
        stackWeight
      });
    }
    return layoutBoxes;
  }
  function buildStacks(layouts2) {
    const stacks = {};
    for (const wrap2 of layouts2) {
      const { stack, pos, stackWeight } = wrap2;
      if (!stack || !STATIC_POSITIONS.includes(pos)) {
        continue;
      }
      const _stack = stacks[stack] || (stacks[stack] = {
        count: 0,
        placed: 0,
        weight: 0,
        size: 0
      });
      _stack.count++;
      _stack.weight += stackWeight;
    }
    return stacks;
  }
  function setLayoutDims(layouts2, params) {
    const stacks = buildStacks(layouts2);
    const { vBoxMaxWidth, hBoxMaxHeight } = params;
    let i3, ilen, layout;
    for (i3 = 0, ilen = layouts2.length; i3 < ilen; ++i3) {
      layout = layouts2[i3];
      const { fullSize } = layout.box;
      const stack = stacks[layout.stack];
      const factor = stack && layout.stackWeight / stack.weight;
      if (layout.horizontal) {
        layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
        layout.height = hBoxMaxHeight;
      } else {
        layout.width = vBoxMaxWidth;
        layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
      }
    }
    return stacks;
  }
  function buildLayoutBoxes(boxes) {
    const layoutBoxes = wrapBoxes(boxes);
    const fullSize = sortByWeight(layoutBoxes.filter((wrap2) => wrap2.box.fullSize), true);
    const left2 = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
    const right2 = sortByWeight(filterByPosition(layoutBoxes, "right"));
    const top2 = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
    const bottom2 = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
    const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
    const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
    return {
      fullSize,
      leftAndTop: left2.concat(top2),
      rightAndBottom: right2.concat(centerVertical).concat(bottom2).concat(centerHorizontal),
      chartArea: filterByPosition(layoutBoxes, "chartArea"),
      vertical: left2.concat(right2).concat(centerVertical),
      horizontal: top2.concat(bottom2).concat(centerHorizontal)
    };
  }
  function getCombinedMax(maxPadding, chartArea, a4, b2) {
    return Math.max(maxPadding[a4], chartArea[a4]) + Math.max(maxPadding[b2], chartArea[b2]);
  }
  function updateMaxPadding(maxPadding, boxPadding) {
    maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
    maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
    maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
    maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
  }
  function updateDims(chartArea, params, layout, stacks) {
    const { pos, box } = layout;
    const maxPadding = chartArea.maxPadding;
    if (!isObject(pos)) {
      if (layout.size) {
        chartArea[pos] -= layout.size;
      }
      const stack = stacks[layout.stack] || {
        size: 0,
        count: 1
      };
      stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
      layout.size = stack.size / stack.count;
      chartArea[pos] += layout.size;
    }
    if (box.getPadding) {
      updateMaxPadding(maxPadding, box.getPadding());
    }
    const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
    const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
    const widthChanged = newWidth !== chartArea.w;
    const heightChanged = newHeight !== chartArea.h;
    chartArea.w = newWidth;
    chartArea.h = newHeight;
    return layout.horizontal ? {
      same: widthChanged,
      other: heightChanged
    } : {
      same: heightChanged,
      other: widthChanged
    };
  }
  function handleMaxPadding(chartArea) {
    const maxPadding = chartArea.maxPadding;
    function updatePos(pos) {
      const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
      chartArea[pos] += change;
      return change;
    }
    chartArea.y += updatePos("top");
    chartArea.x += updatePos("left");
    updatePos("right");
    updatePos("bottom");
  }
  function getMargins(horizontal, chartArea) {
    const maxPadding = chartArea.maxPadding;
    function marginForPositions(positions2) {
      const margin = {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      };
      positions2.forEach((pos) => {
        margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
      });
      return margin;
    }
    return horizontal ? marginForPositions([
      "left",
      "right"
    ]) : marginForPositions([
      "top",
      "bottom"
    ]);
  }
  function fitBoxes(boxes, chartArea, params, stacks) {
    const refitBoxes = [];
    let i3, ilen, layout, box, refit, changed;
    for (i3 = 0, ilen = boxes.length, refit = 0; i3 < ilen; ++i3) {
      layout = boxes[i3];
      box = layout.box;
      box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
      const { same, other } = updateDims(chartArea, params, layout, stacks);
      refit |= same && refitBoxes.length;
      changed = changed || other;
      if (!box.fullSize) {
        refitBoxes.push(layout);
      }
    }
    return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
  }
  function setBoxDims(box, left2, top2, width, height) {
    box.top = top2;
    box.left = left2;
    box.right = left2 + width;
    box.bottom = top2 + height;
    box.width = width;
    box.height = height;
  }
  function placeBoxes(boxes, chartArea, params, stacks) {
    const userPadding = params.padding;
    let { x: x2, y: y3 } = chartArea;
    for (const layout of boxes) {
      const box = layout.box;
      const stack = stacks[layout.stack] || {
        count: 1,
        placed: 0,
        weight: 1
      };
      const weight = layout.stackWeight / stack.weight || 1;
      if (layout.horizontal) {
        const width = chartArea.w * weight;
        const height = stack.size || box.height;
        if (defined(stack.start)) {
          y3 = stack.start;
        }
        if (box.fullSize) {
          setBoxDims(box, userPadding.left, y3, params.outerWidth - userPadding.right - userPadding.left, height);
        } else {
          setBoxDims(box, chartArea.left + stack.placed, y3, width, height);
        }
        stack.start = y3;
        stack.placed += width;
        y3 = box.bottom;
      } else {
        const height1 = chartArea.h * weight;
        const width1 = stack.size || box.width;
        if (defined(stack.start)) {
          x2 = stack.start;
        }
        if (box.fullSize) {
          setBoxDims(box, x2, userPadding.top, width1, params.outerHeight - userPadding.bottom - userPadding.top);
        } else {
          setBoxDims(box, x2, chartArea.top + stack.placed, width1, height1);
        }
        stack.start = x2;
        stack.placed += height1;
        x2 = box.right;
      }
    }
    chartArea.x = x2;
    chartArea.y = y3;
  }
  var layouts = {
    addBox(chart, item) {
      if (!chart.boxes) {
        chart.boxes = [];
      }
      item.fullSize = item.fullSize || false;
      item.position = item.position || "top";
      item.weight = item.weight || 0;
      item._layers = item._layers || function() {
        return [
          {
            z: 0,
            draw(chartArea) {
              item.draw(chartArea);
            }
          }
        ];
      };
      chart.boxes.push(item);
    },
    removeBox(chart, layoutItem) {
      const index2 = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
      if (index2 !== -1) {
        chart.boxes.splice(index2, 1);
      }
    },
    configure(chart, item, options2) {
      item.fullSize = options2.fullSize;
      item.position = options2.position;
      item.weight = options2.weight;
    },
    update(chart, width, height, minPadding) {
      if (!chart) {
        return;
      }
      const padding = toPadding(chart.options.layout.padding);
      const availableWidth = Math.max(width - padding.width, 0);
      const availableHeight = Math.max(height - padding.height, 0);
      const boxes = buildLayoutBoxes(chart.boxes);
      const verticalBoxes = boxes.vertical;
      const horizontalBoxes = boxes.horizontal;
      each(chart.boxes, (box) => {
        if (typeof box.beforeLayout === "function") {
          box.beforeLayout();
        }
      });
      const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap2) => wrap2.box.options && wrap2.box.options.display === false ? total : total + 1, 0) || 1;
      const params = Object.freeze({
        outerWidth: width,
        outerHeight: height,
        padding,
        availableWidth,
        availableHeight,
        vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
        hBoxMaxHeight: availableHeight / 2
      });
      const maxPadding = Object.assign({}, padding);
      updateMaxPadding(maxPadding, toPadding(minPadding));
      const chartArea = Object.assign({
        maxPadding,
        w: availableWidth,
        h: availableHeight,
        x: padding.left,
        y: padding.top
      }, padding);
      const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
      fitBoxes(boxes.fullSize, chartArea, params, stacks);
      fitBoxes(verticalBoxes, chartArea, params, stacks);
      if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
        fitBoxes(verticalBoxes, chartArea, params, stacks);
      }
      handleMaxPadding(chartArea);
      placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
      chartArea.x += chartArea.w;
      chartArea.y += chartArea.h;
      placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
      chart.chartArea = {
        left: chartArea.left,
        top: chartArea.top,
        right: chartArea.left + chartArea.w,
        bottom: chartArea.top + chartArea.h,
        height: chartArea.h,
        width: chartArea.w
      };
      each(boxes.chartArea, (layout) => {
        const box = layout.box;
        Object.assign(box, chart.chartArea);
        box.update(chartArea.w, chartArea.h, {
          left: 0,
          top: 0,
          right: 0,
          bottom: 0
        });
      });
    }
  };
  var BasePlatform = class {
    acquireContext(canvas, aspectRatio) {
    }
    releaseContext(context) {
      return false;
    }
    addEventListener(chart, type, listener) {
    }
    removeEventListener(chart, type, listener) {
    }
    getDevicePixelRatio() {
      return 1;
    }
    getMaximumSize(element, width, height, aspectRatio) {
      width = Math.max(0, width || element.width);
      height = height || element.height;
      return {
        width,
        height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
      };
    }
    isAttached(canvas) {
      return true;
    }
    updateConfig(config) {
    }
  };
  var BasicPlatform = class extends BasePlatform {
    acquireContext(item) {
      return item && item.getContext && item.getContext("2d") || null;
    }
    updateConfig(config) {
      config.options.animation = false;
    }
  };
  var EXPANDO_KEY = "$chartjs";
  var EVENT_TYPES = {
    touchstart: "mousedown",
    touchmove: "mousemove",
    touchend: "mouseup",
    pointerenter: "mouseenter",
    pointerdown: "mousedown",
    pointermove: "mousemove",
    pointerup: "mouseup",
    pointerleave: "mouseout",
    pointerout: "mouseout"
  };
  var isNullOrEmpty = (value) => value === null || value === "";
  function initCanvas(canvas, aspectRatio) {
    const style = canvas.style;
    const renderHeight = canvas.getAttribute("height");
    const renderWidth = canvas.getAttribute("width");
    canvas[EXPANDO_KEY] = {
      initial: {
        height: renderHeight,
        width: renderWidth,
        style: {
          display: style.display,
          height: style.height,
          width: style.width
        }
      }
    };
    style.display = style.display || "block";
    style.boxSizing = style.boxSizing || "border-box";
    if (isNullOrEmpty(renderWidth)) {
      const displayWidth = readUsedSize(canvas, "width");
      if (displayWidth !== void 0) {
        canvas.width = displayWidth;
      }
    }
    if (isNullOrEmpty(renderHeight)) {
      if (canvas.style.height === "") {
        canvas.height = canvas.width / (aspectRatio || 2);
      } else {
        const displayHeight = readUsedSize(canvas, "height");
        if (displayHeight !== void 0) {
          canvas.height = displayHeight;
        }
      }
    }
    return canvas;
  }
  var eventListenerOptions = supportsEventListenerOptions ? {
    passive: true
  } : false;
  function addListener(node, type, listener) {
    node.addEventListener(type, listener, eventListenerOptions);
  }
  function removeListener(chart, type, listener) {
    chart.canvas.removeEventListener(type, listener, eventListenerOptions);
  }
  function fromNativeEvent(event, chart) {
    const type = EVENT_TYPES[event.type] || event.type;
    const { x: x2, y: y3 } = getRelativePosition(event, chart);
    return {
      type,
      chart,
      native: event,
      x: x2 !== void 0 ? x2 : null,
      y: y3 !== void 0 ? y3 : null
    };
  }
  function nodeListContains(nodeList, canvas) {
    for (const node of nodeList) {
      if (node === canvas || node.contains(canvas)) {
        return true;
      }
    }
  }
  function createAttachObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const observer = new MutationObserver((entries) => {
      let trigger = false;
      for (const entry of entries) {
        trigger = trigger || nodeListContains(entry.addedNodes, canvas);
        trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
      }
      if (trigger) {
        listener();
      }
    });
    observer.observe(document, {
      childList: true,
      subtree: true
    });
    return observer;
  }
  function createDetachObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const observer = new MutationObserver((entries) => {
      let trigger = false;
      for (const entry of entries) {
        trigger = trigger || nodeListContains(entry.removedNodes, canvas);
        trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
      }
      if (trigger) {
        listener();
      }
    });
    observer.observe(document, {
      childList: true,
      subtree: true
    });
    return observer;
  }
  var drpListeningCharts = /* @__PURE__ */ new Map();
  var oldDevicePixelRatio = 0;
  function onWindowResize() {
    const dpr = window.devicePixelRatio;
    if (dpr === oldDevicePixelRatio) {
      return;
    }
    oldDevicePixelRatio = dpr;
    drpListeningCharts.forEach((resize2, chart) => {
      if (chart.currentDevicePixelRatio !== dpr) {
        resize2();
      }
    });
  }
  function listenDevicePixelRatioChanges(chart, resize2) {
    if (!drpListeningCharts.size) {
      window.addEventListener("resize", onWindowResize);
    }
    drpListeningCharts.set(chart, resize2);
  }
  function unlistenDevicePixelRatioChanges(chart) {
    drpListeningCharts.delete(chart);
    if (!drpListeningCharts.size) {
      window.removeEventListener("resize", onWindowResize);
    }
  }
  function createResizeObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const container = canvas && _getParentNode(canvas);
    if (!container) {
      return;
    }
    const resize2 = throttled((width, height) => {
      const w2 = container.clientWidth;
      listener(width, height);
      if (w2 < container.clientWidth) {
        listener();
      }
    }, window);
    const observer = new ResizeObserver((entries) => {
      const entry = entries[0];
      const width = entry.contentRect.width;
      const height = entry.contentRect.height;
      if (width === 0 && height === 0) {
        return;
      }
      resize2(width, height);
    });
    observer.observe(container);
    listenDevicePixelRatioChanges(chart, resize2);
    return observer;
  }
  function releaseObserver(chart, type, observer) {
    if (observer) {
      observer.disconnect();
    }
    if (type === "resize") {
      unlistenDevicePixelRatioChanges(chart);
    }
  }
  function createProxyAndListen(chart, type, listener) {
    const canvas = chart.canvas;
    const proxy = throttled((event) => {
      if (chart.ctx !== null) {
        listener(fromNativeEvent(event, chart));
      }
    }, chart);
    addListener(canvas, type, proxy);
    return proxy;
  }
  var DomPlatform = class extends BasePlatform {
    acquireContext(canvas, aspectRatio) {
      const context = canvas && canvas.getContext && canvas.getContext("2d");
      if (context && context.canvas === canvas) {
        initCanvas(canvas, aspectRatio);
        return context;
      }
      return null;
    }
    releaseContext(context) {
      const canvas = context.canvas;
      if (!canvas[EXPANDO_KEY]) {
        return false;
      }
      const initial = canvas[EXPANDO_KEY].initial;
      [
        "height",
        "width"
      ].forEach((prop) => {
        const value = initial[prop];
        if (isNullOrUndef(value)) {
          canvas.removeAttribute(prop);
        } else {
          canvas.setAttribute(prop, value);
        }
      });
      const style = initial.style || {};
      Object.keys(style).forEach((key) => {
        canvas.style[key] = style[key];
      });
      canvas.width = canvas.width;
      delete canvas[EXPANDO_KEY];
      return true;
    }
    addEventListener(chart, type, listener) {
      this.removeEventListener(chart, type);
      const proxies = chart.$proxies || (chart.$proxies = {});
      const handlers = {
        attach: createAttachObserver,
        detach: createDetachObserver,
        resize: createResizeObserver
      };
      const handler = handlers[type] || createProxyAndListen;
      proxies[type] = handler(chart, type, listener);
    }
    removeEventListener(chart, type) {
      const proxies = chart.$proxies || (chart.$proxies = {});
      const proxy = proxies[type];
      if (!proxy) {
        return;
      }
      const handlers = {
        attach: releaseObserver,
        detach: releaseObserver,
        resize: releaseObserver
      };
      const handler = handlers[type] || removeListener;
      handler(chart, type, proxy);
      proxies[type] = void 0;
    }
    getDevicePixelRatio() {
      return window.devicePixelRatio;
    }
    getMaximumSize(canvas, width, height, aspectRatio) {
      return getMaximumSize(canvas, width, height, aspectRatio);
    }
    isAttached(canvas) {
      const container = _getParentNode(canvas);
      return !!(container && container.isConnected);
    }
  };
  function _detectPlatform(canvas) {
    if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) {
      return BasicPlatform;
    }
    return DomPlatform;
  }
  var Element2 = class {
    active = false;
    tooltipPosition(useFinalPosition) {
      const { x: x2, y: y3 } = this.getProps([
        "x",
        "y"
      ], useFinalPosition);
      return {
        x: x2,
        y: y3
      };
    }
    hasValue() {
      return isNumber2(this.x) && isNumber2(this.y);
    }
    getProps(props, final) {
      const anims = this.$animations;
      if (!final || !anims) {
        return this;
      }
      const ret = {};
      props.forEach((prop) => {
        ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
      });
      return ret;
    }
  };
  __publicField(Element2, "defaults", {});
  __publicField(Element2, "defaultRoutes");
  function autoSkip(scale, ticks) {
    const tickOpts = scale.options.ticks;
    const determinedMaxTicks = determineMaxTicks(scale);
    const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);
    const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
    const numMajorIndices = majorIndices.length;
    const first = majorIndices[0];
    const last = majorIndices[numMajorIndices - 1];
    const newTicks = [];
    if (numMajorIndices > ticksLimit) {
      skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
      return newTicks;
    }
    const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
    if (numMajorIndices > 0) {
      let i3, ilen;
      const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
      skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
      for (i3 = 0, ilen = numMajorIndices - 1; i3 < ilen; i3++) {
        skip(ticks, newTicks, spacing, majorIndices[i3], majorIndices[i3 + 1]);
      }
      skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
      return newTicks;
    }
    skip(ticks, newTicks, spacing);
    return newTicks;
  }
  function determineMaxTicks(scale) {
    const offset2 = scale.options.offset;
    const tickLength = scale._tickSize();
    const maxScale = scale._length / tickLength + (offset2 ? 0 : 1);
    const maxChart = scale._maxLength / tickLength;
    return Math.floor(Math.min(maxScale, maxChart));
  }
  function calculateSpacing(majorIndices, ticks, ticksLimit) {
    const evenMajorSpacing = getEvenSpacing(majorIndices);
    const spacing = ticks.length / ticksLimit;
    if (!evenMajorSpacing) {
      return Math.max(spacing, 1);
    }
    const factors = _factorize(evenMajorSpacing);
    for (let i3 = 0, ilen = factors.length - 1; i3 < ilen; i3++) {
      const factor = factors[i3];
      if (factor > spacing) {
        return factor;
      }
    }
    return Math.max(spacing, 1);
  }
  function getMajorIndices(ticks) {
    const result = [];
    let i3, ilen;
    for (i3 = 0, ilen = ticks.length; i3 < ilen; i3++) {
      if (ticks[i3].major) {
        result.push(i3);
      }
    }
    return result;
  }
  function skipMajors(ticks, newTicks, majorIndices, spacing) {
    let count = 0;
    let next = majorIndices[0];
    let i3;
    spacing = Math.ceil(spacing);
    for (i3 = 0; i3 < ticks.length; i3++) {
      if (i3 === next) {
        newTicks.push(ticks[i3]);
        count++;
        next = majorIndices[count * spacing];
      }
    }
  }
  function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
    const start3 = valueOrDefault(majorStart, 0);
    const end2 = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
    let count = 0;
    let length, i3, next;
    spacing = Math.ceil(spacing);
    if (majorEnd) {
      length = majorEnd - majorStart;
      spacing = length / Math.floor(length / spacing);
    }
    next = start3;
    while (next < 0) {
      count++;
      next = Math.round(start3 + count * spacing);
    }
    for (i3 = Math.max(start3, 0); i3 < end2; i3++) {
      if (i3 === next) {
        newTicks.push(ticks[i3]);
        count++;
        next = Math.round(start3 + count * spacing);
      }
    }
  }
  function getEvenSpacing(arr) {
    const len = arr.length;
    let i3, diff;
    if (len < 2) {
      return false;
    }
    for (diff = arr[0], i3 = 1; i3 < len; ++i3) {
      if (arr[i3] - arr[i3 - 1] !== diff) {
        return false;
      }
    }
    return diff;
  }
  var reverseAlign = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
  var offsetFromEdge = (scale, edge, offset2) => edge === "top" || edge === "left" ? scale[edge] + offset2 : scale[edge] - offset2;
  var getTicksLimit = (ticksLength, maxTicksLimit) => Math.min(maxTicksLimit || ticksLength, ticksLength);
  function sample(arr, numItems) {
    const result = [];
    const increment = arr.length / numItems;
    const len = arr.length;
    let i3 = 0;
    for (; i3 < len; i3 += increment) {
      result.push(arr[Math.floor(i3)]);
    }
    return result;
  }
  function getPixelForGridLine(scale, index2, offsetGridLines) {
    const length = scale.ticks.length;
    const validIndex2 = Math.min(index2, length - 1);
    const start3 = scale._startPixel;
    const end2 = scale._endPixel;
    const epsilon = 1e-6;
    let lineValue = scale.getPixelForTick(validIndex2);
    let offset2;
    if (offsetGridLines) {
      if (length === 1) {
        offset2 = Math.max(lineValue - start3, end2 - lineValue);
      } else if (index2 === 0) {
        offset2 = (scale.getPixelForTick(1) - lineValue) / 2;
      } else {
        offset2 = (lineValue - scale.getPixelForTick(validIndex2 - 1)) / 2;
      }
      lineValue += validIndex2 < index2 ? offset2 : -offset2;
      if (lineValue < start3 - epsilon || lineValue > end2 + epsilon) {
        return;
      }
    }
    return lineValue;
  }
  function garbageCollect(caches, length) {
    each(caches, (cache) => {
      const gc = cache.gc;
      const gcLen = gc.length / 2;
      let i3;
      if (gcLen > length) {
        for (i3 = 0; i3 < gcLen; ++i3) {
          delete cache.data[gc[i3]];
        }
        gc.splice(0, gcLen);
      }
    });
  }
  function getTickMarkLength(options2) {
    return options2.drawTicks ? options2.tickLength : 0;
  }
  function getTitleHeight(options2, fallback) {
    if (!options2.display) {
      return 0;
    }
    const font = toFont(options2.font, fallback);
    const padding = toPadding(options2.padding);
    const lines = isArray2(options2.text) ? options2.text.length : 1;
    return lines * font.lineHeight + padding.height;
  }
  function createScaleContext(parent, scale) {
    return createContext(parent, {
      scale,
      type: "scale"
    });
  }
  function createTickContext(parent, index2, tick) {
    return createContext(parent, {
      tick,
      index: index2,
      type: "tick"
    });
  }
  function titleAlign(align, position, reverse) {
    let ret = _toLeftRightCenter(align);
    if (reverse && position !== "right" || !reverse && position === "right") {
      ret = reverseAlign(ret);
    }
    return ret;
  }
  function titleArgs(scale, offset2, position, align) {
    const { top: top2, left: left2, bottom: bottom2, right: right2, chart } = scale;
    const { chartArea, scales: scales2 } = chart;
    let rotation = 0;
    let maxWidth, titleX, titleY;
    const height = bottom2 - top2;
    const width = right2 - left2;
    if (scale.isHorizontal()) {
      titleX = _alignStartEnd(align, left2, right2);
      if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        titleY = scales2[positionAxisID].getPixelForValue(value) + height - offset2;
      } else if (position === "center") {
        titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset2;
      } else {
        titleY = offsetFromEdge(scale, position, offset2);
      }
      maxWidth = right2 - left2;
    } else {
      if (isObject(position)) {
        const positionAxisID1 = Object.keys(position)[0];
        const value1 = position[positionAxisID1];
        titleX = scales2[positionAxisID1].getPixelForValue(value1) - width + offset2;
      } else if (position === "center") {
        titleX = (chartArea.left + chartArea.right) / 2 - width + offset2;
      } else {
        titleX = offsetFromEdge(scale, position, offset2);
      }
      titleY = _alignStartEnd(align, bottom2, top2);
      rotation = position === "left" ? -HALF_PI : HALF_PI;
    }
    return {
      titleX,
      titleY,
      maxWidth,
      rotation
    };
  }
  var Scale = class extends Element2 {
    constructor(cfg) {
      super();
      this.id = cfg.id;
      this.type = cfg.type;
      this.options = void 0;
      this.ctx = cfg.ctx;
      this.chart = cfg.chart;
      this.top = void 0;
      this.bottom = void 0;
      this.left = void 0;
      this.right = void 0;
      this.width = void 0;
      this.height = void 0;
      this._margins = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      };
      this.maxWidth = void 0;
      this.maxHeight = void 0;
      this.paddingTop = void 0;
      this.paddingBottom = void 0;
      this.paddingLeft = void 0;
      this.paddingRight = void 0;
      this.axis = void 0;
      this.labelRotation = void 0;
      this.min = void 0;
      this.max = void 0;
      this._range = void 0;
      this.ticks = [];
      this._gridLineItems = null;
      this._labelItems = null;
      this._labelSizes = null;
      this._length = 0;
      this._maxLength = 0;
      this._longestTextCache = {};
      this._startPixel = void 0;
      this._endPixel = void 0;
      this._reversePixels = false;
      this._userMax = void 0;
      this._userMin = void 0;
      this._suggestedMax = void 0;
      this._suggestedMin = void 0;
      this._ticksLength = 0;
      this._borderValue = 0;
      this._cache = {};
      this._dataLimitsCached = false;
      this.$context = void 0;
    }
    init(options2) {
      this.options = options2.setContext(this.getContext());
      this.axis = options2.axis;
      this._userMin = this.parse(options2.min);
      this._userMax = this.parse(options2.max);
      this._suggestedMin = this.parse(options2.suggestedMin);
      this._suggestedMax = this.parse(options2.suggestedMax);
    }
    parse(raw, index2) {
      return raw;
    }
    getUserBounds() {
      let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
      _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
      _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
      _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
      _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
      return {
        min: finiteOrDefault(_userMin, _suggestedMin),
        max: finiteOrDefault(_userMax, _suggestedMax),
        minDefined: isNumberFinite(_userMin),
        maxDefined: isNumberFinite(_userMax)
      };
    }
    getMinMax(canStack) {
      let { min: min2, max: max2, minDefined, maxDefined } = this.getUserBounds();
      let range;
      if (minDefined && maxDefined) {
        return {
          min: min2,
          max: max2
        };
      }
      const metas = this.getMatchingVisibleMetas();
      for (let i3 = 0, ilen = metas.length; i3 < ilen; ++i3) {
        range = metas[i3].controller.getMinMax(this, canStack);
        if (!minDefined) {
          min2 = Math.min(min2, range.min);
        }
        if (!maxDefined) {
          max2 = Math.max(max2, range.max);
        }
      }
      min2 = maxDefined && min2 > max2 ? max2 : min2;
      max2 = minDefined && min2 > max2 ? min2 : max2;
      return {
        min: finiteOrDefault(min2, finiteOrDefault(max2, min2)),
        max: finiteOrDefault(max2, finiteOrDefault(min2, max2))
      };
    }
    getPadding() {
      return {
        left: this.paddingLeft || 0,
        top: this.paddingTop || 0,
        right: this.paddingRight || 0,
        bottom: this.paddingBottom || 0
      };
    }
    getTicks() {
      return this.ticks;
    }
    getLabels() {
      const data = this.chart.data;
      return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
    }
    getLabelItems(chartArea = this.chart.chartArea) {
      const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
      return items;
    }
    beforeLayout() {
      this._cache = {};
      this._dataLimitsCached = false;
    }
    beforeUpdate() {
      callback(this.options.beforeUpdate, [
        this
      ]);
    }
    update(maxWidth, maxHeight, margins) {
      const { beginAtZero, grace, ticks: tickOpts } = this.options;
      const sampleSize = tickOpts.sampleSize;
      this.beforeUpdate();
      this.maxWidth = maxWidth;
      this.maxHeight = maxHeight;
      this._margins = margins = Object.assign({
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      }, margins);
      this.ticks = null;
      this._labelSizes = null;
      this._gridLineItems = null;
      this._labelItems = null;
      this.beforeSetDimensions();
      this.setDimensions();
      this.afterSetDimensions();
      this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
      if (!this._dataLimitsCached) {
        this.beforeDataLimits();
        this.determineDataLimits();
        this.afterDataLimits();
        this._range = _addGrace(this, grace, beginAtZero);
        this._dataLimitsCached = true;
      }
      this.beforeBuildTicks();
      this.ticks = this.buildTicks() || [];
      this.afterBuildTicks();
      const samplingEnabled = sampleSize < this.ticks.length;
      this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
      this.configure();
      this.beforeCalculateLabelRotation();
      this.calculateLabelRotation();
      this.afterCalculateLabelRotation();
      if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
        this.ticks = autoSkip(this, this.ticks);
        this._labelSizes = null;
        this.afterAutoSkip();
      }
      if (samplingEnabled) {
        this._convertTicksToLabels(this.ticks);
      }
      this.beforeFit();
      this.fit();
      this.afterFit();
      this.afterUpdate();
    }
    configure() {
      let reversePixels = this.options.reverse;
      let startPixel, endPixel;
      if (this.isHorizontal()) {
        startPixel = this.left;
        endPixel = this.right;
      } else {
        startPixel = this.top;
        endPixel = this.bottom;
        reversePixels = !reversePixels;
      }
      this._startPixel = startPixel;
      this._endPixel = endPixel;
      this._reversePixels = reversePixels;
      this._length = endPixel - startPixel;
      this._alignToPixels = this.options.alignToPixels;
    }
    afterUpdate() {
      callback(this.options.afterUpdate, [
        this
      ]);
    }
    beforeSetDimensions() {
      callback(this.options.beforeSetDimensions, [
        this
      ]);
    }
    setDimensions() {
      if (this.isHorizontal()) {
        this.width = this.maxWidth;
        this.left = 0;
        this.right = this.width;
      } else {
        this.height = this.maxHeight;
        this.top = 0;
        this.bottom = this.height;
      }
      this.paddingLeft = 0;
      this.paddingTop = 0;
      this.paddingRight = 0;
      this.paddingBottom = 0;
    }
    afterSetDimensions() {
      callback(this.options.afterSetDimensions, [
        this
      ]);
    }
    _callHooks(name2) {
      this.chart.notifyPlugins(name2, this.getContext());
      callback(this.options[name2], [
        this
      ]);
    }
    beforeDataLimits() {
      this._callHooks("beforeDataLimits");
    }
    determineDataLimits() {
    }
    afterDataLimits() {
      this._callHooks("afterDataLimits");
    }
    beforeBuildTicks() {
      this._callHooks("beforeBuildTicks");
    }
    buildTicks() {
      return [];
    }
    afterBuildTicks() {
      this._callHooks("afterBuildTicks");
    }
    beforeTickToLabelConversion() {
      callback(this.options.beforeTickToLabelConversion, [
        this
      ]);
    }
    generateTickLabels(ticks) {
      const tickOpts = this.options.ticks;
      let i3, ilen, tick;
      for (i3 = 0, ilen = ticks.length; i3 < ilen; i3++) {
        tick = ticks[i3];
        tick.label = callback(tickOpts.callback, [
          tick.value,
          i3,
          ticks
        ], this);
      }
    }
    afterTickToLabelConversion() {
      callback(this.options.afterTickToLabelConversion, [
        this
      ]);
    }
    beforeCalculateLabelRotation() {
      callback(this.options.beforeCalculateLabelRotation, [
        this
      ]);
    }
    calculateLabelRotation() {
      const options2 = this.options;
      const tickOpts = options2.ticks;
      const numTicks = getTicksLimit(this.ticks.length, options2.ticks.maxTicksLimit);
      const minRotation = tickOpts.minRotation || 0;
      const maxRotation = tickOpts.maxRotation;
      let labelRotation = minRotation;
      let tickWidth, maxHeight, maxLabelDiagonal;
      if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
        this.labelRotation = minRotation;
        return;
      }
      const labelSizes = this._getLabelSizes();
      const maxLabelWidth = labelSizes.widest.width;
      const maxLabelHeight = labelSizes.highest.height;
      const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
      tickWidth = options2.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
      if (maxLabelWidth + 6 > tickWidth) {
        tickWidth = maxWidth / (numTicks - (options2.offset ? 0.5 : 1));
        maxHeight = this.maxHeight - getTickMarkLength(options2.grid) - tickOpts.padding - getTitleHeight(options2.title, this.chart.options.font);
        maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
        labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
        labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
      }
      this.labelRotation = labelRotation;
    }
    afterCalculateLabelRotation() {
      callback(this.options.afterCalculateLabelRotation, [
        this
      ]);
    }
    afterAutoSkip() {
    }
    beforeFit() {
      callback(this.options.beforeFit, [
        this
      ]);
    }
    fit() {
      const minSize = {
        width: 0,
        height: 0
      };
      const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;
      const display = this._isVisible();
      const isHorizontal = this.isHorizontal();
      if (display) {
        const titleHeight = getTitleHeight(titleOpts, chart.options.font);
        if (isHorizontal) {
          minSize.width = this.maxWidth;
          minSize.height = getTickMarkLength(gridOpts) + titleHeight;
        } else {
          minSize.height = this.maxHeight;
          minSize.width = getTickMarkLength(gridOpts) + titleHeight;
        }
        if (tickOpts.display && this.ticks.length) {
          const { first, last, widest, highest } = this._getLabelSizes();
          const tickPadding = tickOpts.padding * 2;
          const angleRadians = toRadians(this.labelRotation);
          const cos = Math.cos(angleRadians);
          const sin = Math.sin(angleRadians);
          if (isHorizontal) {
            const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
            minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
          } else {
            const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
            minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
          }
          this._calculatePadding(first, last, sin, cos);
        }
      }
      this._handleMargins();
      if (isHorizontal) {
        this.width = this._length = chart.width - this._margins.left - this._margins.right;
        this.height = minSize.height;
      } else {
        this.width = minSize.width;
        this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
      }
    }
    _calculatePadding(first, last, sin, cos) {
      const { ticks: { align, padding }, position } = this.options;
      const isRotated = this.labelRotation !== 0;
      const labelsBelowTicks = position !== "top" && this.axis === "x";
      if (this.isHorizontal()) {
        const offsetLeft = this.getPixelForTick(0) - this.left;
        const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
        let paddingLeft = 0;
        let paddingRight = 0;
        if (isRotated) {
          if (labelsBelowTicks) {
            paddingLeft = cos * first.width;
            paddingRight = sin * last.height;
          } else {
            paddingLeft = sin * first.height;
            paddingRight = cos * last.width;
          }
        } else if (align === "start") {
          paddingRight = last.width;
        } else if (align === "end") {
          paddingLeft = first.width;
        } else if (align !== "inner") {
          paddingLeft = first.width / 2;
          paddingRight = last.width / 2;
        }
        this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
        this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
      } else {
        let paddingTop = last.height / 2;
        let paddingBottom = first.height / 2;
        if (align === "start") {
          paddingTop = 0;
          paddingBottom = first.height;
        } else if (align === "end") {
          paddingTop = last.height;
          paddingBottom = 0;
        }
        this.paddingTop = paddingTop + padding;
        this.paddingBottom = paddingBottom + padding;
      }
    }
    _handleMargins() {
      if (this._margins) {
        this._margins.left = Math.max(this.paddingLeft, this._margins.left);
        this._margins.top = Math.max(this.paddingTop, this._margins.top);
        this._margins.right = Math.max(this.paddingRight, this._margins.right);
        this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
      }
    }
    afterFit() {
      callback(this.options.afterFit, [
        this
      ]);
    }
    isHorizontal() {
      const { axis, position } = this.options;
      return position === "top" || position === "bottom" || axis === "x";
    }
    isFullSize() {
      return this.options.fullSize;
    }
    _convertTicksToLabels(ticks) {
      this.beforeTickToLabelConversion();
      this.generateTickLabels(ticks);
      let i3, ilen;
      for (i3 = 0, ilen = ticks.length; i3 < ilen; i3++) {
        if (isNullOrUndef(ticks[i3].label)) {
          ticks.splice(i3, 1);
          ilen--;
          i3--;
        }
      }
      this.afterTickToLabelConversion();
    }
    _getLabelSizes() {
      let labelSizes = this._labelSizes;
      if (!labelSizes) {
        const sampleSize = this.options.ticks.sampleSize;
        let ticks = this.ticks;
        if (sampleSize < ticks.length) {
          ticks = sample(ticks, sampleSize);
        }
        this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);
      }
      return labelSizes;
    }
    _computeLabelSizes(ticks, length, maxTicksLimit) {
      const { ctx, _longestTextCache: caches } = this;
      const widths = [];
      const heights = [];
      const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));
      let widestLabelSize = 0;
      let highestLabelSize = 0;
      let i3, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;
      for (i3 = 0; i3 < length; i3 += increment) {
        label = ticks[i3].label;
        tickFont = this._resolveTickFontOptions(i3);
        ctx.font = fontString = tickFont.string;
        cache = caches[fontString] = caches[fontString] || {
          data: {},
          gc: []
        };
        lineHeight = tickFont.lineHeight;
        width = height = 0;
        if (!isNullOrUndef(label) && !isArray2(label)) {
          width = _measureText(ctx, cache.data, cache.gc, width, label);
          height = lineHeight;
        } else if (isArray2(label)) {
          for (j = 0, jlen = label.length; j < jlen; ++j) {
            nestedLabel = label[j];
            if (!isNullOrUndef(nestedLabel) && !isArray2(nestedLabel)) {
              width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
              height += lineHeight;
            }
          }
        }
        widths.push(width);
        heights.push(height);
        widestLabelSize = Math.max(width, widestLabelSize);
        highestLabelSize = Math.max(height, highestLabelSize);
      }
      garbageCollect(caches, length);
      const widest = widths.indexOf(widestLabelSize);
      const highest = heights.indexOf(highestLabelSize);
      const valueAt = (idx) => ({
        width: widths[idx] || 0,
        height: heights[idx] || 0
      });
      return {
        first: valueAt(0),
        last: valueAt(length - 1),
        widest: valueAt(widest),
        highest: valueAt(highest),
        widths,
        heights
      };
    }
    getLabelForValue(value) {
      return value;
    }
    getPixelForValue(value, index2) {
      return NaN;
    }
    getValueForPixel(pixel) {
    }
    getPixelForTick(index2) {
      const ticks = this.ticks;
      if (index2 < 0 || index2 > ticks.length - 1) {
        return null;
      }
      return this.getPixelForValue(ticks[index2].value);
    }
    getPixelForDecimal(decimal) {
      if (this._reversePixels) {
        decimal = 1 - decimal;
      }
      const pixel = this._startPixel + decimal * this._length;
      return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
    }
    getDecimalForPixel(pixel) {
      const decimal = (pixel - this._startPixel) / this._length;
      return this._reversePixels ? 1 - decimal : decimal;
    }
    getBasePixel() {
      return this.getPixelForValue(this.getBaseValue());
    }
    getBaseValue() {
      const { min: min2, max: max2 } = this;
      return min2 < 0 && max2 < 0 ? max2 : min2 > 0 && max2 > 0 ? min2 : 0;
    }
    getContext(index2) {
      const ticks = this.ticks || [];
      if (index2 >= 0 && index2 < ticks.length) {
        const tick = ticks[index2];
        return tick.$context || (tick.$context = createTickContext(this.getContext(), index2, tick));
      }
      return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
    }
    _tickSize() {
      const optionTicks = this.options.ticks;
      const rot = toRadians(this.labelRotation);
      const cos = Math.abs(Math.cos(rot));
      const sin = Math.abs(Math.sin(rot));
      const labelSizes = this._getLabelSizes();
      const padding = optionTicks.autoSkipPadding || 0;
      const w2 = labelSizes ? labelSizes.widest.width + padding : 0;
      const h5 = labelSizes ? labelSizes.highest.height + padding : 0;
      return this.isHorizontal() ? h5 * cos > w2 * sin ? w2 / cos : h5 / sin : h5 * sin < w2 * cos ? h5 / cos : w2 / sin;
    }
    _isVisible() {
      const display = this.options.display;
      if (display !== "auto") {
        return !!display;
      }
      return this.getMatchingVisibleMetas().length > 0;
    }
    _computeGridLineItems(chartArea) {
      const axis = this.axis;
      const chart = this.chart;
      const options2 = this.options;
      const { grid, position, border } = options2;
      const offset2 = grid.offset;
      const isHorizontal = this.isHorizontal();
      const ticks = this.ticks;
      const ticksLength = ticks.length + (offset2 ? 1 : 0);
      const tl = getTickMarkLength(grid);
      const items = [];
      const borderOpts = border.setContext(this.getContext());
      const axisWidth = borderOpts.display ? borderOpts.width : 0;
      const axisHalfWidth = axisWidth / 2;
      const alignBorderValue = function(pixel) {
        return _alignPixel(chart, pixel, axisWidth);
      };
      let borderValue, i3, lineValue, alignedLineValue;
      let tx1, ty1, tx2, ty2, x1, y1, x2, y22;
      if (position === "top") {
        borderValue = alignBorderValue(this.bottom);
        ty1 = this.bottom - tl;
        ty2 = borderValue - axisHalfWidth;
        y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
        y22 = chartArea.bottom;
      } else if (position === "bottom") {
        borderValue = alignBorderValue(this.top);
        y1 = chartArea.top;
        y22 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
        ty1 = borderValue + axisHalfWidth;
        ty2 = this.top + tl;
      } else if (position === "left") {
        borderValue = alignBorderValue(this.right);
        tx1 = this.right - tl;
        tx2 = borderValue - axisHalfWidth;
        x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
        x2 = chartArea.right;
      } else if (position === "right") {
        borderValue = alignBorderValue(this.left);
        x1 = chartArea.left;
        x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
        tx1 = borderValue + axisHalfWidth;
        tx2 = this.left + tl;
      } else if (axis === "x") {
        if (position === "center") {
          borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
        } else if (isObject(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
        }
        y1 = chartArea.top;
        y22 = chartArea.bottom;
        ty1 = borderValue + axisHalfWidth;
        ty2 = ty1 + tl;
      } else if (axis === "y") {
        if (position === "center") {
          borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
        } else if (isObject(position)) {
          const positionAxisID1 = Object.keys(position)[0];
          const value1 = position[positionAxisID1];
          borderValue = alignBorderValue(this.chart.scales[positionAxisID1].getPixelForValue(value1));
        }
        tx1 = borderValue - axisHalfWidth;
        tx2 = tx1 - tl;
        x1 = chartArea.left;
        x2 = chartArea.right;
      }
      const limit = valueOrDefault(options2.ticks.maxTicksLimit, ticksLength);
      const step = Math.max(1, Math.ceil(ticksLength / limit));
      for (i3 = 0; i3 < ticksLength; i3 += step) {
        const context = this.getContext(i3);
        const optsAtIndex = grid.setContext(context);
        const optsAtIndexBorder = border.setContext(context);
        const lineWidth = optsAtIndex.lineWidth;
        const lineColor = optsAtIndex.color;
        const borderDash = optsAtIndexBorder.dash || [];
        const borderDashOffset = optsAtIndexBorder.dashOffset;
        const tickWidth = optsAtIndex.tickWidth;
        const tickColor = optsAtIndex.tickColor;
        const tickBorderDash = optsAtIndex.tickBorderDash || [];
        const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
        lineValue = getPixelForGridLine(this, i3, offset2);
        if (lineValue === void 0) {
          continue;
        }
        alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
        if (isHorizontal) {
          tx1 = tx2 = x1 = x2 = alignedLineValue;
        } else {
          ty1 = ty2 = y1 = y22 = alignedLineValue;
        }
        items.push({
          tx1,
          ty1,
          tx2,
          ty2,
          x1,
          y1,
          x2,
          y2: y22,
          width: lineWidth,
          color: lineColor,
          borderDash,
          borderDashOffset,
          tickWidth,
          tickColor,
          tickBorderDash,
          tickBorderDashOffset
        });
      }
      this._ticksLength = ticksLength;
      this._borderValue = borderValue;
      return items;
    }
    _computeLabelItems(chartArea) {
      const axis = this.axis;
      const options2 = this.options;
      const { position, ticks: optionTicks } = options2;
      const isHorizontal = this.isHorizontal();
      const ticks = this.ticks;
      const { align, crossAlign, padding, mirror } = optionTicks;
      const tl = getTickMarkLength(options2.grid);
      const tickAndPadding = tl + padding;
      const hTickAndPadding = mirror ? -padding : tickAndPadding;
      const rotation = -toRadians(this.labelRotation);
      const items = [];
      let i3, ilen, tick, label, x2, y3, textAlign, pixel, font, lineHeight, lineCount, textOffset;
      let textBaseline = "middle";
      if (position === "top") {
        y3 = this.bottom - hTickAndPadding;
        textAlign = this._getXAxisLabelAlignment();
      } else if (position === "bottom") {
        y3 = this.top + hTickAndPadding;
        textAlign = this._getXAxisLabelAlignment();
      } else if (position === "left") {
        const ret = this._getYAxisLabelAlignment(tl);
        textAlign = ret.textAlign;
        x2 = ret.x;
      } else if (position === "right") {
        const ret1 = this._getYAxisLabelAlignment(tl);
        textAlign = ret1.textAlign;
        x2 = ret1.x;
      } else if (axis === "x") {
        if (position === "center") {
          y3 = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
        } else if (isObject(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          y3 = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
        }
        textAlign = this._getXAxisLabelAlignment();
      } else if (axis === "y") {
        if (position === "center") {
          x2 = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
        } else if (isObject(position)) {
          const positionAxisID1 = Object.keys(position)[0];
          const value1 = position[positionAxisID1];
          x2 = this.chart.scales[positionAxisID1].getPixelForValue(value1);
        }
        textAlign = this._getYAxisLabelAlignment(tl).textAlign;
      }
      if (axis === "y") {
        if (align === "start") {
          textBaseline = "top";
        } else if (align === "end") {
          textBaseline = "bottom";
        }
      }
      const labelSizes = this._getLabelSizes();
      for (i3 = 0, ilen = ticks.length; i3 < ilen; ++i3) {
        tick = ticks[i3];
        label = tick.label;
        const optsAtIndex = optionTicks.setContext(this.getContext(i3));
        pixel = this.getPixelForTick(i3) + optionTicks.labelOffset;
        font = this._resolveTickFontOptions(i3);
        lineHeight = font.lineHeight;
        lineCount = isArray2(label) ? label.length : 1;
        const halfCount = lineCount / 2;
        const color2 = optsAtIndex.color;
        const strokeColor = optsAtIndex.textStrokeColor;
        const strokeWidth = optsAtIndex.textStrokeWidth;
        let tickTextAlign = textAlign;
        if (isHorizontal) {
          x2 = pixel;
          if (textAlign === "inner") {
            if (i3 === ilen - 1) {
              tickTextAlign = !this.options.reverse ? "right" : "left";
            } else if (i3 === 0) {
              tickTextAlign = !this.options.reverse ? "left" : "right";
            } else {
              tickTextAlign = "center";
            }
          }
          if (position === "top") {
            if (crossAlign === "near" || rotation !== 0) {
              textOffset = -lineCount * lineHeight + lineHeight / 2;
            } else if (crossAlign === "center") {
              textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
            } else {
              textOffset = -labelSizes.highest.height + lineHeight / 2;
            }
          } else {
            if (crossAlign === "near" || rotation !== 0) {
              textOffset = lineHeight / 2;
            } else if (crossAlign === "center") {
              textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
            } else {
              textOffset = labelSizes.highest.height - lineCount * lineHeight;
            }
          }
          if (mirror) {
            textOffset *= -1;
          }
          if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {
            x2 += lineHeight / 2 * Math.sin(rotation);
          }
        } else {
          y3 = pixel;
          textOffset = (1 - lineCount) * lineHeight / 2;
        }
        let backdrop;
        if (optsAtIndex.showLabelBackdrop) {
          const labelPadding = toPadding(optsAtIndex.backdropPadding);
          const height = labelSizes.heights[i3];
          const width = labelSizes.widths[i3];
          let top2 = textOffset - labelPadding.top;
          let left2 = 0 - labelPadding.left;
          switch (textBaseline) {
            case "middle":
              top2 -= height / 2;
              break;
            case "bottom":
              top2 -= height;
              break;
          }
          switch (textAlign) {
            case "center":
              left2 -= width / 2;
              break;
            case "right":
              left2 -= width;
              break;
          }
          backdrop = {
            left: left2,
            top: top2,
            width: width + labelPadding.width,
            height: height + labelPadding.height,
            color: optsAtIndex.backdropColor
          };
        }
        items.push({
          label,
          font,
          textOffset,
          options: {
            rotation,
            color: color2,
            strokeColor,
            strokeWidth,
            textAlign: tickTextAlign,
            textBaseline,
            translation: [
              x2,
              y3
            ],
            backdrop
          }
        });
      }
      return items;
    }
    _getXAxisLabelAlignment() {
      const { position, ticks } = this.options;
      const rotation = -toRadians(this.labelRotation);
      if (rotation) {
        return position === "top" ? "left" : "right";
      }
      let align = "center";
      if (ticks.align === "start") {
        align = "left";
      } else if (ticks.align === "end") {
        align = "right";
      } else if (ticks.align === "inner") {
        align = "inner";
      }
      return align;
    }
    _getYAxisLabelAlignment(tl) {
      const { position, ticks: { crossAlign, mirror, padding } } = this.options;
      const labelSizes = this._getLabelSizes();
      const tickAndPadding = tl + padding;
      const widest = labelSizes.widest.width;
      let textAlign;
      let x2;
      if (position === "left") {
        if (mirror) {
          x2 = this.right + padding;
          if (crossAlign === "near") {
            textAlign = "left";
          } else if (crossAlign === "center") {
            textAlign = "center";
            x2 += widest / 2;
          } else {
            textAlign = "right";
            x2 += widest;
          }
        } else {
          x2 = this.right - tickAndPadding;
          if (crossAlign === "near") {
            textAlign = "right";
          } else if (crossAlign === "center") {
            textAlign = "center";
            x2 -= widest / 2;
          } else {
            textAlign = "left";
            x2 = this.left;
          }
        }
      } else if (position === "right") {
        if (mirror) {
          x2 = this.left + padding;
          if (crossAlign === "near") {
            textAlign = "right";
          } else if (crossAlign === "center") {
            textAlign = "center";
            x2 -= widest / 2;
          } else {
            textAlign = "left";
            x2 -= widest;
          }
        } else {
          x2 = this.left + tickAndPadding;
          if (crossAlign === "near") {
            textAlign = "left";
          } else if (crossAlign === "center") {
            textAlign = "center";
            x2 += widest / 2;
          } else {
            textAlign = "right";
            x2 = this.right;
          }
        }
      } else {
        textAlign = "right";
      }
      return {
        textAlign,
        x: x2
      };
    }
    _computeLabelArea() {
      if (this.options.ticks.mirror) {
        return;
      }
      const chart = this.chart;
      const position = this.options.position;
      if (position === "left" || position === "right") {
        return {
          top: 0,
          left: this.left,
          bottom: chart.height,
          right: this.right
        };
      }
      if (position === "top" || position === "bottom") {
        return {
          top: this.top,
          left: 0,
          bottom: this.bottom,
          right: chart.width
        };
      }
    }
    drawBackground() {
      const { ctx, options: { backgroundColor }, left: left2, top: top2, width, height } = this;
      if (backgroundColor) {
        ctx.save();
        ctx.fillStyle = backgroundColor;
        ctx.fillRect(left2, top2, width, height);
        ctx.restore();
      }
    }
    getLineWidthForValue(value) {
      const grid = this.options.grid;
      if (!this._isVisible() || !grid.display) {
        return 0;
      }
      const ticks = this.ticks;
      const index2 = ticks.findIndex((t2) => t2.value === value);
      if (index2 >= 0) {
        const opts = grid.setContext(this.getContext(index2));
        return opts.lineWidth;
      }
      return 0;
    }
    drawGrid(chartArea) {
      const grid = this.options.grid;
      const ctx = this.ctx;
      const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
      let i3, ilen;
      const drawLine = (p1, p2, style) => {
        if (!style.width || !style.color) {
          return;
        }
        ctx.save();
        ctx.lineWidth = style.width;
        ctx.strokeStyle = style.color;
        ctx.setLineDash(style.borderDash || []);
        ctx.lineDashOffset = style.borderDashOffset;
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
        ctx.restore();
      };
      if (grid.display) {
        for (i3 = 0, ilen = items.length; i3 < ilen; ++i3) {
          const item = items[i3];
          if (grid.drawOnChartArea) {
            drawLine({
              x: item.x1,
              y: item.y1
            }, {
              x: item.x2,
              y: item.y2
            }, item);
          }
          if (grid.drawTicks) {
            drawLine({
              x: item.tx1,
              y: item.ty1
            }, {
              x: item.tx2,
              y: item.ty2
            }, {
              color: item.tickColor,
              width: item.tickWidth,
              borderDash: item.tickBorderDash,
              borderDashOffset: item.tickBorderDashOffset
            });
          }
        }
      }
    }
    drawBorder() {
      const { chart, ctx, options: { border, grid } } = this;
      const borderOpts = border.setContext(this.getContext());
      const axisWidth = border.display ? borderOpts.width : 0;
      if (!axisWidth) {
        return;
      }
      const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
      const borderValue = this._borderValue;
      let x1, x2, y1, y22;
      if (this.isHorizontal()) {
        x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
        x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
        y1 = y22 = borderValue;
      } else {
        y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
        y22 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
        x1 = x2 = borderValue;
      }
      ctx.save();
      ctx.lineWidth = borderOpts.width;
      ctx.strokeStyle = borderOpts.color;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y22);
      ctx.stroke();
      ctx.restore();
    }
    drawLabels(chartArea) {
      const optionTicks = this.options.ticks;
      if (!optionTicks.display) {
        return;
      }
      const ctx = this.ctx;
      const area = this._computeLabelArea();
      if (area) {
        clipArea(ctx, area);
      }
      const items = this.getLabelItems(chartArea);
      for (const item of items) {
        const renderTextOptions = item.options;
        const tickFont = item.font;
        const label = item.label;
        const y3 = item.textOffset;
        renderText(ctx, label, 0, y3, tickFont, renderTextOptions);
      }
      if (area) {
        unclipArea(ctx);
      }
    }
    drawTitle() {
      const { ctx, options: { position, title, reverse } } = this;
      if (!title.display) {
        return;
      }
      const font = toFont(title.font);
      const padding = toPadding(title.padding);
      const align = title.align;
      let offset2 = font.lineHeight / 2;
      if (position === "bottom" || position === "center" || isObject(position)) {
        offset2 += padding.bottom;
        if (isArray2(title.text)) {
          offset2 += font.lineHeight * (title.text.length - 1);
        }
      } else {
        offset2 += padding.top;
      }
      const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset2, position, align);
      renderText(ctx, title.text, 0, 0, font, {
        color: title.color,
        maxWidth,
        rotation,
        textAlign: titleAlign(align, position, reverse),
        textBaseline: "middle",
        translation: [
          titleX,
          titleY
        ]
      });
    }
    draw(chartArea) {
      if (!this._isVisible()) {
        return;
      }
      this.drawBackground();
      this.drawGrid(chartArea);
      this.drawBorder();
      this.drawTitle();
      this.drawLabels(chartArea);
    }
    _layers() {
      const opts = this.options;
      const tz = opts.ticks && opts.ticks.z || 0;
      const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
      const bz = valueOrDefault(opts.border && opts.border.z, 0);
      if (!this._isVisible() || this.draw !== Scale.prototype.draw) {
        return [
          {
            z: tz,
            draw: (chartArea) => {
              this.draw(chartArea);
            }
          }
        ];
      }
      return [
        {
          z: gz,
          draw: (chartArea) => {
            this.drawBackground();
            this.drawGrid(chartArea);
            this.drawTitle();
          }
        },
        {
          z: bz,
          draw: () => {
            this.drawBorder();
          }
        },
        {
          z: tz,
          draw: (chartArea) => {
            this.drawLabels(chartArea);
          }
        }
      ];
    }
    getMatchingVisibleMetas(type) {
      const metas = this.chart.getSortedVisibleDatasetMetas();
      const axisID = this.axis + "AxisID";
      const result = [];
      let i3, ilen;
      for (i3 = 0, ilen = metas.length; i3 < ilen; ++i3) {
        const meta = metas[i3];
        if (meta[axisID] === this.id && (!type || meta.type === type)) {
          result.push(meta);
        }
      }
      return result;
    }
    _resolveTickFontOptions(index2) {
      const opts = this.options.ticks.setContext(this.getContext(index2));
      return toFont(opts.font);
    }
    _maxDigits() {
      const fontSize = this._resolveTickFontOptions(0).lineHeight;
      return (this.isHorizontal() ? this.width : this.height) / fontSize;
    }
  };
  var TypedRegistry = class {
    constructor(type, scope, override) {
      this.type = type;
      this.scope = scope;
      this.override = override;
      this.items = Object.create(null);
    }
    isForType(type) {
      return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
    }
    register(item) {
      const proto = Object.getPrototypeOf(item);
      let parentScope;
      if (isIChartComponent(proto)) {
        parentScope = this.register(proto);
      }
      const items = this.items;
      const id = item.id;
      const scope = this.scope + "." + id;
      if (!id) {
        throw new Error("class does not have id: " + item);
      }
      if (id in items) {
        return scope;
      }
      items[id] = item;
      registerDefaults(item, scope, parentScope);
      if (this.override) {
        defaults.override(item.id, item.overrides);
      }
      return scope;
    }
    get(id) {
      return this.items[id];
    }
    unregister(item) {
      const items = this.items;
      const id = item.id;
      const scope = this.scope;
      if (id in items) {
        delete items[id];
      }
      if (scope && id in defaults[scope]) {
        delete defaults[scope][id];
        if (this.override) {
          delete overrides[id];
        }
      }
    }
  };
  function registerDefaults(item, scope, parentScope) {
    const itemDefaults = merge2(Object.create(null), [
      parentScope ? defaults.get(parentScope) : {},
      defaults.get(scope),
      item.defaults
    ]);
    defaults.set(scope, itemDefaults);
    if (item.defaultRoutes) {
      routeDefaults(scope, item.defaultRoutes);
    }
    if (item.descriptors) {
      defaults.describe(scope, item.descriptors);
    }
  }
  function routeDefaults(scope, routes) {
    Object.keys(routes).forEach((property) => {
      const propertyParts = property.split(".");
      const sourceName = propertyParts.pop();
      const sourceScope = [
        scope
      ].concat(propertyParts).join(".");
      const parts = routes[property].split(".");
      const targetName = parts.pop();
      const targetScope = parts.join(".");
      defaults.route(sourceScope, sourceName, targetScope, targetName);
    });
  }
  function isIChartComponent(proto) {
    return "id" in proto && "defaults" in proto;
  }
  var Registry = class {
    constructor() {
      this.controllers = new TypedRegistry(DatasetController, "datasets", true);
      this.elements = new TypedRegistry(Element2, "elements");
      this.plugins = new TypedRegistry(Object, "plugins");
      this.scales = new TypedRegistry(Scale, "scales");
      this._typedRegistries = [
        this.controllers,
        this.scales,
        this.elements
      ];
    }
    add(...args) {
      this._each("register", args);
    }
    remove(...args) {
      this._each("unregister", args);
    }
    addControllers(...args) {
      this._each("register", args, this.controllers);
    }
    addElements(...args) {
      this._each("register", args, this.elements);
    }
    addPlugins(...args) {
      this._each("register", args, this.plugins);
    }
    addScales(...args) {
      this._each("register", args, this.scales);
    }
    getController(id) {
      return this._get(id, this.controllers, "controller");
    }
    getElement(id) {
      return this._get(id, this.elements, "element");
    }
    getPlugin(id) {
      return this._get(id, this.plugins, "plugin");
    }
    getScale(id) {
      return this._get(id, this.scales, "scale");
    }
    removeControllers(...args) {
      this._each("unregister", args, this.controllers);
    }
    removeElements(...args) {
      this._each("unregister", args, this.elements);
    }
    removePlugins(...args) {
      this._each("unregister", args, this.plugins);
    }
    removeScales(...args) {
      this._each("unregister", args, this.scales);
    }
    _each(method, args, typedRegistry) {
      [
        ...args
      ].forEach((arg) => {
        const reg = typedRegistry || this._getRegistryForType(arg);
        if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
          this._exec(method, reg, arg);
        } else {
          each(arg, (item) => {
            const itemReg = typedRegistry || this._getRegistryForType(item);
            this._exec(method, itemReg, item);
          });
        }
      });
    }
    _exec(method, registry2, component) {
      const camelMethod = _capitalize(method);
      callback(component["before" + camelMethod], [], component);
      registry2[method](component);
      callback(component["after" + camelMethod], [], component);
    }
    _getRegistryForType(type) {
      for (let i3 = 0; i3 < this._typedRegistries.length; i3++) {
        const reg = this._typedRegistries[i3];
        if (reg.isForType(type)) {
          return reg;
        }
      }
      return this.plugins;
    }
    _get(id, typedRegistry, type) {
      const item = typedRegistry.get(id);
      if (item === void 0) {
        throw new Error('"' + id + '" is not a registered ' + type + ".");
      }
      return item;
    }
  };
  var registry = /* @__PURE__ */ new Registry();
  var PluginService = class {
    constructor() {
      this._init = [];
    }
    notify(chart, hook, args, filter) {
      if (hook === "beforeInit") {
        this._init = this._createDescriptors(chart, true);
        this._notify(this._init, chart, "install");
      }
      const descriptors2 = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
      const result = this._notify(descriptors2, chart, hook, args);
      if (hook === "afterDestroy") {
        this._notify(descriptors2, chart, "stop");
        this._notify(this._init, chart, "uninstall");
      }
      return result;
    }
    _notify(descriptors2, chart, hook, args) {
      args = args || {};
      for (const descriptor of descriptors2) {
        const plugin = descriptor.plugin;
        const method = plugin[hook];
        const params = [
          chart,
          args,
          descriptor.options
        ];
        if (callback(method, params, plugin) === false && args.cancelable) {
          return false;
        }
      }
      return true;
    }
    invalidate() {
      if (!isNullOrUndef(this._cache)) {
        this._oldCache = this._cache;
        this._cache = void 0;
      }
    }
    _descriptors(chart) {
      if (this._cache) {
        return this._cache;
      }
      const descriptors2 = this._cache = this._createDescriptors(chart);
      this._notifyStateChanges(chart);
      return descriptors2;
    }
    _createDescriptors(chart, all) {
      const config = chart && chart.config;
      const options2 = valueOrDefault(config.options && config.options.plugins, {});
      const plugins2 = allPlugins(config);
      return options2 === false && !all ? [] : createDescriptors(chart, plugins2, options2, all);
    }
    _notifyStateChanges(chart) {
      const previousDescriptors = this._oldCache || [];
      const descriptors2 = this._cache;
      const diff = (a4, b2) => a4.filter((x2) => !b2.some((y3) => x2.plugin.id === y3.plugin.id));
      this._notify(diff(previousDescriptors, descriptors2), chart, "stop");
      this._notify(diff(descriptors2, previousDescriptors), chart, "start");
    }
  };
  function allPlugins(config) {
    const localIds = {};
    const plugins2 = [];
    const keys = Object.keys(registry.plugins.items);
    for (let i3 = 0; i3 < keys.length; i3++) {
      plugins2.push(registry.getPlugin(keys[i3]));
    }
    const local = config.plugins || [];
    for (let i1 = 0; i1 < local.length; i1++) {
      const plugin = local[i1];
      if (plugins2.indexOf(plugin) === -1) {
        plugins2.push(plugin);
        localIds[plugin.id] = true;
      }
    }
    return {
      plugins: plugins2,
      localIds
    };
  }
  function getOpts(options2, all) {
    if (!all && options2 === false) {
      return null;
    }
    if (options2 === true) {
      return {};
    }
    return options2;
  }
  function createDescriptors(chart, { plugins: plugins2, localIds }, options2, all) {
    const result = [];
    const context = chart.getContext();
    for (const plugin of plugins2) {
      const id = plugin.id;
      const opts = getOpts(options2[id], all);
      if (opts === null) {
        continue;
      }
      result.push({
        plugin,
        options: pluginOpts(chart.config, {
          plugin,
          local: localIds[id]
        }, opts, context)
      });
    }
    return result;
  }
  function pluginOpts(config, { plugin, local }, opts, context) {
    const keys = config.pluginScopeKeys(plugin);
    const scopes = config.getOptionScopes(opts, keys);
    if (local && plugin.defaults) {
      scopes.push(plugin.defaults);
    }
    return config.createResolver(scopes, context, [
      ""
    ], {
      scriptable: false,
      indexable: false,
      allKeys: true
    });
  }
  function getIndexAxis(type, options2) {
    const datasetDefaults = defaults.datasets[type] || {};
    const datasetOptions = (options2.datasets || {})[type] || {};
    return datasetOptions.indexAxis || options2.indexAxis || datasetDefaults.indexAxis || "x";
  }
  function getAxisFromDefaultScaleID(id, indexAxis) {
    let axis = id;
    if (id === "_index_") {
      axis = indexAxis;
    } else if (id === "_value_") {
      axis = indexAxis === "x" ? "y" : "x";
    }
    return axis;
  }
  function getDefaultScaleIDFromAxis(axis, indexAxis) {
    return axis === indexAxis ? "_index_" : "_value_";
  }
  function axisFromPosition(position) {
    if (position === "top" || position === "bottom") {
      return "x";
    }
    if (position === "left" || position === "right") {
      return "y";
    }
  }
  function determineAxis(id, scaleOptions) {
    if (id === "x" || id === "y" || id === "r") {
      return id;
    }
    id = scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.length > 1 && determineAxis(id[0].toLowerCase(), scaleOptions);
    if (id) {
      return id;
    }
    throw new Error(`Cannot determine type of '${name}' axis. Please provide 'axis' or 'position' option.`);
  }
  function mergeScaleConfig(config, options2) {
    const chartDefaults = overrides[config.type] || {
      scales: {}
    };
    const configScales = options2.scales || {};
    const chartIndexAxis = getIndexAxis(config.type, options2);
    const scales2 = Object.create(null);
    Object.keys(configScales).forEach((id) => {
      const scaleConf = configScales[id];
      if (!isObject(scaleConf)) {
        return console.error(`Invalid scale configuration for scale: ${id}`);
      }
      if (scaleConf._proxy) {
        return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
      }
      const axis = determineAxis(id, scaleConf);
      const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
      const defaultScaleOptions = chartDefaults.scales || {};
      scales2[id] = mergeIf(Object.create(null), [
        {
          axis
        },
        scaleConf,
        defaultScaleOptions[axis],
        defaultScaleOptions[defaultId]
      ]);
    });
    config.data.datasets.forEach((dataset) => {
      const type = dataset.type || config.type;
      const indexAxis = dataset.indexAxis || getIndexAxis(type, options2);
      const datasetDefaults = overrides[type] || {};
      const defaultScaleOptions = datasetDefaults.scales || {};
      Object.keys(defaultScaleOptions).forEach((defaultID) => {
        const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
        const id = dataset[axis + "AxisID"] || axis;
        scales2[id] = scales2[id] || Object.create(null);
        mergeIf(scales2[id], [
          {
            axis
          },
          configScales[id],
          defaultScaleOptions[defaultID]
        ]);
      });
    });
    Object.keys(scales2).forEach((key) => {
      const scale = scales2[key];
      mergeIf(scale, [
        defaults.scales[scale.type],
        defaults.scale
      ]);
    });
    return scales2;
  }
  function initOptions(config) {
    const options2 = config.options || (config.options = {});
    options2.plugins = valueOrDefault(options2.plugins, {});
    options2.scales = mergeScaleConfig(config, options2);
  }
  function initData(data) {
    data = data || {};
    data.datasets = data.datasets || [];
    data.labels = data.labels || [];
    return data;
  }
  function initConfig(config) {
    config = config || {};
    config.data = initData(config.data);
    initOptions(config);
    return config;
  }
  var keyCache = /* @__PURE__ */ new Map();
  var keysCached = /* @__PURE__ */ new Set();
  function cachedKeys(cacheKey, generate) {
    let keys = keyCache.get(cacheKey);
    if (!keys) {
      keys = generate();
      keyCache.set(cacheKey, keys);
      keysCached.add(keys);
    }
    return keys;
  }
  var addIfFound = (set2, obj, key) => {
    const opts = resolveObjectKey(obj, key);
    if (opts !== void 0) {
      set2.add(opts);
    }
  };
  var Config = class {
    constructor(config) {
      this._config = initConfig(config);
      this._scopeCache = /* @__PURE__ */ new Map();
      this._resolverCache = /* @__PURE__ */ new Map();
    }
    get platform() {
      return this._config.platform;
    }
    get type() {
      return this._config.type;
    }
    set type(type) {
      this._config.type = type;
    }
    get data() {
      return this._config.data;
    }
    set data(data) {
      this._config.data = initData(data);
    }
    get options() {
      return this._config.options;
    }
    set options(options2) {
      this._config.options = options2;
    }
    get plugins() {
      return this._config.plugins;
    }
    update() {
      const config = this._config;
      this.clearCache();
      initOptions(config);
    }
    clearCache() {
      this._scopeCache.clear();
      this._resolverCache.clear();
    }
    datasetScopeKeys(datasetType) {
      return cachedKeys(datasetType, () => [
        [
          `datasets.${datasetType}`,
          ""
        ]
      ]);
    }
    datasetAnimationScopeKeys(datasetType, transition) {
      return cachedKeys(`${datasetType}.transition.${transition}`, () => [
        [
          `datasets.${datasetType}.transitions.${transition}`,
          `transitions.${transition}`
        ],
        [
          `datasets.${datasetType}`,
          ""
        ]
      ]);
    }
    datasetElementScopeKeys(datasetType, elementType2) {
      return cachedKeys(`${datasetType}-${elementType2}`, () => [
        [
          `datasets.${datasetType}.elements.${elementType2}`,
          `datasets.${datasetType}`,
          `elements.${elementType2}`,
          ""
        ]
      ]);
    }
    pluginScopeKeys(plugin) {
      const id = plugin.id;
      const type = this.type;
      return cachedKeys(`${type}-plugin-${id}`, () => [
        [
          `plugins.${id}`,
          ...plugin.additionalOptionScopes || []
        ]
      ]);
    }
    _cachedScopes(mainScope, resetCache) {
      const _scopeCache = this._scopeCache;
      let cache = _scopeCache.get(mainScope);
      if (!cache || resetCache) {
        cache = /* @__PURE__ */ new Map();
        _scopeCache.set(mainScope, cache);
      }
      return cache;
    }
    getOptionScopes(mainScope, keyLists, resetCache) {
      const { options: options2, type } = this;
      const cache = this._cachedScopes(mainScope, resetCache);
      const cached = cache.get(keyLists);
      if (cached) {
        return cached;
      }
      const scopes = /* @__PURE__ */ new Set();
      keyLists.forEach((keys) => {
        if (mainScope) {
          scopes.add(mainScope);
          keys.forEach((key) => addIfFound(scopes, mainScope, key));
        }
        keys.forEach((key) => addIfFound(scopes, options2, key));
        keys.forEach((key) => addIfFound(scopes, overrides[type] || {}, key));
        keys.forEach((key) => addIfFound(scopes, defaults, key));
        keys.forEach((key) => addIfFound(scopes, descriptors, key));
      });
      const array = Array.from(scopes);
      if (array.length === 0) {
        array.push(Object.create(null));
      }
      if (keysCached.has(keyLists)) {
        cache.set(keyLists, array);
      }
      return array;
    }
    chartOptionScopes() {
      const { options: options2, type } = this;
      return [
        options2,
        overrides[type] || {},
        defaults.datasets[type] || {},
        {
          type
        },
        defaults,
        descriptors
      ];
    }
    resolveNamedOptions(scopes, names2, context, prefixes = [
      ""
    ]) {
      const result = {
        $shared: true
      };
      const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);
      let options2 = resolver;
      if (needContext(resolver, names2)) {
        result.$shared = false;
        context = isFunction2(context) ? context() : context;
        const subResolver = this.createResolver(scopes, context, subPrefixes);
        options2 = _attachContext(resolver, context, subResolver);
      }
      for (const prop of names2) {
        result[prop] = options2[prop];
      }
      return result;
    }
    createResolver(scopes, context, prefixes = [
      ""
    ], descriptorDefaults) {
      const { resolver } = getResolver(this._resolverCache, scopes, prefixes);
      return isObject(context) ? _attachContext(resolver, context, void 0, descriptorDefaults) : resolver;
    }
  };
  function getResolver(resolverCache, scopes, prefixes) {
    let cache = resolverCache.get(scopes);
    if (!cache) {
      cache = /* @__PURE__ */ new Map();
      resolverCache.set(scopes, cache);
    }
    const cacheKey = prefixes.join();
    let cached = cache.get(cacheKey);
    if (!cached) {
      const resolver = _createResolver(scopes, prefixes);
      cached = {
        resolver,
        subPrefixes: prefixes.filter((p) => !p.toLowerCase().includes("hover"))
      };
      cache.set(cacheKey, cached);
    }
    return cached;
  }
  var hasFunction = (value) => isObject(value) && Object.getOwnPropertyNames(value).reduce((acc, key) => acc || isFunction2(value[key]), false);
  function needContext(proxy, names2) {
    const { isScriptable, isIndexable } = _descriptors(proxy);
    for (const prop of names2) {
      const scriptable = isScriptable(prop);
      const indexable = isIndexable(prop);
      const value = (indexable || scriptable) && proxy[prop];
      if (scriptable && (isFunction2(value) || hasFunction(value)) || indexable && isArray2(value)) {
        return true;
      }
    }
    return false;
  }
  var version = "4.2.1";
  var KNOWN_POSITIONS = [
    "top",
    "bottom",
    "left",
    "right",
    "chartArea"
  ];
  function positionIsHorizontal(position, axis) {
    return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
  }
  function compare2Level(l1, l2) {
    return function(a4, b2) {
      return a4[l1] === b2[l1] ? a4[l2] - b2[l2] : a4[l1] - b2[l1];
    };
  }
  function onAnimationsComplete(context) {
    const chart = context.chart;
    const animationOptions = chart.options.animation;
    chart.notifyPlugins("afterRender");
    callback(animationOptions && animationOptions.onComplete, [
      context
    ], chart);
  }
  function onAnimationProgress(context) {
    const chart = context.chart;
    const animationOptions = chart.options.animation;
    callback(animationOptions && animationOptions.onProgress, [
      context
    ], chart);
  }
  function getCanvas(item) {
    if (_isDomSupported() && typeof item === "string") {
      item = document.getElementById(item);
    } else if (item && item.length) {
      item = item[0];
    }
    if (item && item.canvas) {
      item = item.canvas;
    }
    return item;
  }
  var instances = {};
  var getChart = (key) => {
    const canvas = getCanvas(key);
    return Object.values(instances).filter((c2) => c2.canvas === canvas).pop();
  };
  function moveNumericKeys(obj, start3, move) {
    const keys = Object.keys(obj);
    for (const key of keys) {
      const intKey = +key;
      if (intKey >= start3) {
        const value = obj[key];
        delete obj[key];
        if (move > 0 || intKey > start3) {
          obj[intKey + move] = value;
        }
      }
    }
  }
  function determineLastEvent(e3, lastEvent, inChartArea, isClick) {
    if (!inChartArea || e3.type === "mouseout") {
      return null;
    }
    if (isClick) {
      return lastEvent;
    }
    return e3;
  }
  function getDatasetArea(meta) {
    const { xScale, yScale } = meta;
    if (xScale && yScale) {
      return {
        left: xScale.left,
        right: xScale.right,
        top: yScale.top,
        bottom: yScale.bottom
      };
    }
  }
  var Chart3 = class {
    static register(...items) {
      registry.add(...items);
      invalidatePlugins();
    }
    static unregister(...items) {
      registry.remove(...items);
      invalidatePlugins();
    }
    constructor(item, userConfig) {
      const config = this.config = new Config(userConfig);
      const initialCanvas = getCanvas(item);
      const existingChart = getChart(initialCanvas);
      if (existingChart) {
        throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas with ID '" + existingChart.canvas.id + "' can be reused.");
      }
      const options2 = config.createResolver(config.chartOptionScopes(), this.getContext());
      this.platform = new (config.platform || _detectPlatform(initialCanvas))();
      this.platform.updateConfig(config);
      const context = this.platform.acquireContext(initialCanvas, options2.aspectRatio);
      const canvas = context && context.canvas;
      const height = canvas && canvas.height;
      const width = canvas && canvas.width;
      this.id = uid();
      this.ctx = context;
      this.canvas = canvas;
      this.width = width;
      this.height = height;
      this._options = options2;
      this._aspectRatio = this.aspectRatio;
      this._layers = [];
      this._metasets = [];
      this._stacks = void 0;
      this.boxes = [];
      this.currentDevicePixelRatio = void 0;
      this.chartArea = void 0;
      this._active = [];
      this._lastEvent = void 0;
      this._listeners = {};
      this._responsiveListeners = void 0;
      this._sortedMetasets = [];
      this.scales = {};
      this._plugins = new PluginService();
      this.$proxies = {};
      this._hiddenIndices = {};
      this.attached = false;
      this._animationsDisabled = void 0;
      this.$context = void 0;
      this._doResize = debounce((mode) => this.update(mode), options2.resizeDelay || 0);
      this._dataChanges = [];
      instances[this.id] = this;
      if (!context || !canvas) {
        console.error("Failed to create chart: can't acquire context from the given item");
        return;
      }
      animator.listen(this, "complete", onAnimationsComplete);
      animator.listen(this, "progress", onAnimationProgress);
      this._initialize();
      if (this.attached) {
        this.update();
      }
    }
    get aspectRatio() {
      const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;
      if (!isNullOrUndef(aspectRatio)) {
        return aspectRatio;
      }
      if (maintainAspectRatio && _aspectRatio) {
        return _aspectRatio;
      }
      return height ? width / height : null;
    }
    get data() {
      return this.config.data;
    }
    set data(data) {
      this.config.data = data;
    }
    get options() {
      return this._options;
    }
    set options(options2) {
      this.config.options = options2;
    }
    get registry() {
      return registry;
    }
    _initialize() {
      this.notifyPlugins("beforeInit");
      if (this.options.responsive) {
        this.resize();
      } else {
        retinaScale(this, this.options.devicePixelRatio);
      }
      this.bindEvents();
      this.notifyPlugins("afterInit");
      return this;
    }
    clear() {
      clearCanvas(this.canvas, this.ctx);
      return this;
    }
    stop() {
      animator.stop(this);
      return this;
    }
    resize(width, height) {
      if (!animator.running(this)) {
        this._resize(width, height);
      } else {
        this._resizeBeforeDraw = {
          width,
          height
        };
      }
    }
    _resize(width, height) {
      const options2 = this.options;
      const canvas = this.canvas;
      const aspectRatio = options2.maintainAspectRatio && this.aspectRatio;
      const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
      const newRatio = options2.devicePixelRatio || this.platform.getDevicePixelRatio();
      const mode = this.width ? "resize" : "attach";
      this.width = newSize.width;
      this.height = newSize.height;
      this._aspectRatio = this.aspectRatio;
      if (!retinaScale(this, newRatio, true)) {
        return;
      }
      this.notifyPlugins("resize", {
        size: newSize
      });
      callback(options2.onResize, [
        this,
        newSize
      ], this);
      if (this.attached) {
        if (this._doResize(mode)) {
          this.render();
        }
      }
    }
    ensureScalesHaveIDs() {
      const options2 = this.options;
      const scalesOptions = options2.scales || {};
      each(scalesOptions, (axisOptions, axisID) => {
        axisOptions.id = axisID;
      });
    }
    buildOrUpdateScales() {
      const options2 = this.options;
      const scaleOpts = options2.scales;
      const scales2 = this.scales;
      const updated = Object.keys(scales2).reduce((obj, id) => {
        obj[id] = false;
        return obj;
      }, {});
      let items = [];
      if (scaleOpts) {
        items = items.concat(Object.keys(scaleOpts).map((id) => {
          const scaleOptions = scaleOpts[id];
          const axis = determineAxis(id, scaleOptions);
          const isRadial = axis === "r";
          const isHorizontal = axis === "x";
          return {
            options: scaleOptions,
            dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
            dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
          };
        }));
      }
      each(items, (item) => {
        const scaleOptions = item.options;
        const id = scaleOptions.id;
        const axis = determineAxis(id, scaleOptions);
        const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
        if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
          scaleOptions.position = item.dposition;
        }
        updated[id] = true;
        let scale = null;
        if (id in scales2 && scales2[id].type === scaleType) {
          scale = scales2[id];
        } else {
          const scaleClass = registry.getScale(scaleType);
          scale = new scaleClass({
            id,
            type: scaleType,
            ctx: this.ctx,
            chart: this
          });
          scales2[scale.id] = scale;
        }
        scale.init(scaleOptions, options2);
      });
      each(updated, (hasUpdated, id) => {
        if (!hasUpdated) {
          delete scales2[id];
        }
      });
      each(scales2, (scale) => {
        layouts.configure(this, scale, scale.options);
        layouts.addBox(this, scale);
      });
    }
    _updateMetasets() {
      const metasets = this._metasets;
      const numData = this.data.datasets.length;
      const numMeta = metasets.length;
      metasets.sort((a4, b2) => a4.index - b2.index);
      if (numMeta > numData) {
        for (let i3 = numData; i3 < numMeta; ++i3) {
          this._destroyDatasetMeta(i3);
        }
        metasets.splice(numData, numMeta - numData);
      }
      this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
    }
    _removeUnreferencedMetasets() {
      const { _metasets: metasets, data: { datasets } } = this;
      if (metasets.length > datasets.length) {
        delete this._stacks;
      }
      metasets.forEach((meta, index2) => {
        if (datasets.filter((x2) => x2 === meta._dataset).length === 0) {
          this._destroyDatasetMeta(index2);
        }
      });
    }
    buildOrUpdateControllers() {
      const newControllers = [];
      const datasets = this.data.datasets;
      let i3, ilen;
      this._removeUnreferencedMetasets();
      for (i3 = 0, ilen = datasets.length; i3 < ilen; i3++) {
        const dataset = datasets[i3];
        let meta = this.getDatasetMeta(i3);
        const type = dataset.type || this.config.type;
        if (meta.type && meta.type !== type) {
          this._destroyDatasetMeta(i3);
          meta = this.getDatasetMeta(i3);
        }
        meta.type = type;
        meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
        meta.order = dataset.order || 0;
        meta.index = i3;
        meta.label = "" + dataset.label;
        meta.visible = this.isDatasetVisible(i3);
        if (meta.controller) {
          meta.controller.updateIndex(i3);
          meta.controller.linkScales();
        } else {
          const ControllerClass = registry.getController(type);
          const { datasetElementType, dataElementType } = defaults.datasets[type];
          Object.assign(ControllerClass, {
            dataElementType: registry.getElement(dataElementType),
            datasetElementType: datasetElementType && registry.getElement(datasetElementType)
          });
          meta.controller = new ControllerClass(this, i3);
          newControllers.push(meta.controller);
        }
      }
      this._updateMetasets();
      return newControllers;
    }
    _resetElements() {
      each(this.data.datasets, (dataset, datasetIndex) => {
        this.getDatasetMeta(datasetIndex).controller.reset();
      }, this);
    }
    reset() {
      this._resetElements();
      this.notifyPlugins("reset");
    }
    update(mode) {
      const config = this.config;
      config.update();
      const options2 = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
      const animsDisabled = this._animationsDisabled = !options2.animation;
      this._updateScales();
      this._checkEventBindings();
      this._updateHiddenIndices();
      this._plugins.invalidate();
      if (this.notifyPlugins("beforeUpdate", {
        mode,
        cancelable: true
      }) === false) {
        return;
      }
      const newControllers = this.buildOrUpdateControllers();
      this.notifyPlugins("beforeElementsUpdate");
      let minPadding = 0;
      for (let i3 = 0, ilen = this.data.datasets.length; i3 < ilen; i3++) {
        const { controller } = this.getDatasetMeta(i3);
        const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
        controller.buildOrUpdateElements(reset);
        minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
      }
      minPadding = this._minPadding = options2.layout.autoPadding ? minPadding : 0;
      this._updateLayout(minPadding);
      if (!animsDisabled) {
        each(newControllers, (controller) => {
          controller.reset();
        });
      }
      this._updateDatasets(mode);
      this.notifyPlugins("afterUpdate", {
        mode
      });
      this._layers.sort(compare2Level("z", "_idx"));
      const { _active, _lastEvent } = this;
      if (_lastEvent) {
        this._eventHandler(_lastEvent, true);
      } else if (_active.length) {
        this._updateHoverStyles(_active, _active, true);
      }
      this.render();
    }
    _updateScales() {
      each(this.scales, (scale) => {
        layouts.removeBox(this, scale);
      });
      this.ensureScalesHaveIDs();
      this.buildOrUpdateScales();
    }
    _checkEventBindings() {
      const options2 = this.options;
      const existingEvents = new Set(Object.keys(this._listeners));
      const newEvents = new Set(options2.events);
      if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options2.responsive) {
        this.unbindEvents();
        this.bindEvents();
      }
    }
    _updateHiddenIndices() {
      const { _hiddenIndices } = this;
      const changes = this._getUniformDataChanges() || [];
      for (const { method, start: start3, count } of changes) {
        const move = method === "_removeElements" ? -count : count;
        moveNumericKeys(_hiddenIndices, start3, move);
      }
    }
    _getUniformDataChanges() {
      const _dataChanges = this._dataChanges;
      if (!_dataChanges || !_dataChanges.length) {
        return;
      }
      this._dataChanges = [];
      const datasetCount = this.data.datasets.length;
      const makeSet = (idx) => new Set(_dataChanges.filter((c2) => c2[0] === idx).map((c2, i3) => i3 + "," + c2.splice(1).join(",")));
      const changeSet = makeSet(0);
      for (let i3 = 1; i3 < datasetCount; i3++) {
        if (!setsEqual(changeSet, makeSet(i3))) {
          return;
        }
      }
      return Array.from(changeSet).map((c2) => c2.split(",")).map((a4) => ({
        method: a4[1],
        start: +a4[2],
        count: +a4[3]
      }));
    }
    _updateLayout(minPadding) {
      if (this.notifyPlugins("beforeLayout", {
        cancelable: true
      }) === false) {
        return;
      }
      layouts.update(this, this.width, this.height, minPadding);
      const area = this.chartArea;
      const noArea = area.width <= 0 || area.height <= 0;
      this._layers = [];
      each(this.boxes, (box) => {
        if (noArea && box.position === "chartArea") {
          return;
        }
        if (box.configure) {
          box.configure();
        }
        this._layers.push(...box._layers());
      }, this);
      this._layers.forEach((item, index2) => {
        item._idx = index2;
      });
      this.notifyPlugins("afterLayout");
    }
    _updateDatasets(mode) {
      if (this.notifyPlugins("beforeDatasetsUpdate", {
        mode,
        cancelable: true
      }) === false) {
        return;
      }
      for (let i3 = 0, ilen = this.data.datasets.length; i3 < ilen; ++i3) {
        this.getDatasetMeta(i3).controller.configure();
      }
      for (let i1 = 0, ilen1 = this.data.datasets.length; i1 < ilen1; ++i1) {
        this._updateDataset(i1, isFunction2(mode) ? mode({
          datasetIndex: i1
        }) : mode);
      }
      this.notifyPlugins("afterDatasetsUpdate", {
        mode
      });
    }
    _updateDataset(index2, mode) {
      const meta = this.getDatasetMeta(index2);
      const args = {
        meta,
        index: index2,
        mode,
        cancelable: true
      };
      if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
        return;
      }
      meta.controller._update(mode);
      args.cancelable = false;
      this.notifyPlugins("afterDatasetUpdate", args);
    }
    render() {
      if (this.notifyPlugins("beforeRender", {
        cancelable: true
      }) === false) {
        return;
      }
      if (animator.has(this)) {
        if (this.attached && !animator.running(this)) {
          animator.start(this);
        }
      } else {
        this.draw();
        onAnimationsComplete({
          chart: this
        });
      }
    }
    draw() {
      let i3;
      if (this._resizeBeforeDraw) {
        const { width, height } = this._resizeBeforeDraw;
        this._resize(width, height);
        this._resizeBeforeDraw = null;
      }
      this.clear();
      if (this.width <= 0 || this.height <= 0) {
        return;
      }
      if (this.notifyPlugins("beforeDraw", {
        cancelable: true
      }) === false) {
        return;
      }
      const layers = this._layers;
      for (i3 = 0; i3 < layers.length && layers[i3].z <= 0; ++i3) {
        layers[i3].draw(this.chartArea);
      }
      this._drawDatasets();
      for (; i3 < layers.length; ++i3) {
        layers[i3].draw(this.chartArea);
      }
      this.notifyPlugins("afterDraw");
    }
    _getSortedDatasetMetas(filterVisible) {
      const metasets = this._sortedMetasets;
      const result = [];
      let i3, ilen;
      for (i3 = 0, ilen = metasets.length; i3 < ilen; ++i3) {
        const meta = metasets[i3];
        if (!filterVisible || meta.visible) {
          result.push(meta);
        }
      }
      return result;
    }
    getSortedVisibleDatasetMetas() {
      return this._getSortedDatasetMetas(true);
    }
    _drawDatasets() {
      if (this.notifyPlugins("beforeDatasetsDraw", {
        cancelable: true
      }) === false) {
        return;
      }
      const metasets = this.getSortedVisibleDatasetMetas();
      for (let i3 = metasets.length - 1; i3 >= 0; --i3) {
        this._drawDataset(metasets[i3]);
      }
      this.notifyPlugins("afterDatasetsDraw");
    }
    _drawDataset(meta) {
      const ctx = this.ctx;
      const clip = meta._clip;
      const useClip = !clip.disabled;
      const area = getDatasetArea(meta) || this.chartArea;
      const args = {
        meta,
        index: meta.index,
        cancelable: true
      };
      if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
        return;
      }
      if (useClip) {
        clipArea(ctx, {
          left: clip.left === false ? 0 : area.left - clip.left,
          right: clip.right === false ? this.width : area.right + clip.right,
          top: clip.top === false ? 0 : area.top - clip.top,
          bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
        });
      }
      meta.controller.draw();
      if (useClip) {
        unclipArea(ctx);
      }
      args.cancelable = false;
      this.notifyPlugins("afterDatasetDraw", args);
    }
    isPointInArea(point) {
      return _isPointInArea(point, this.chartArea, this._minPadding);
    }
    getElementsAtEventForMode(e3, mode, options2, useFinalPosition) {
      const method = Interaction.modes[mode];
      if (typeof method === "function") {
        return method(this, e3, options2, useFinalPosition);
      }
      return [];
    }
    getDatasetMeta(datasetIndex) {
      const dataset = this.data.datasets[datasetIndex];
      const metasets = this._metasets;
      let meta = metasets.filter((x2) => x2 && x2._dataset === dataset).pop();
      if (!meta) {
        meta = {
          type: null,
          data: [],
          dataset: null,
          controller: null,
          hidden: null,
          xAxisID: null,
          yAxisID: null,
          order: dataset && dataset.order || 0,
          index: datasetIndex,
          _dataset: dataset,
          _parsed: [],
          _sorted: false
        };
        metasets.push(meta);
      }
      return meta;
    }
    getContext() {
      return this.$context || (this.$context = createContext(null, {
        chart: this,
        type: "chart"
      }));
    }
    getVisibleDatasetCount() {
      return this.getSortedVisibleDatasetMetas().length;
    }
    isDatasetVisible(datasetIndex) {
      const dataset = this.data.datasets[datasetIndex];
      if (!dataset) {
        return false;
      }
      const meta = this.getDatasetMeta(datasetIndex);
      return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
    }
    setDatasetVisibility(datasetIndex, visible) {
      const meta = this.getDatasetMeta(datasetIndex);
      meta.hidden = !visible;
    }
    toggleDataVisibility(index2) {
      this._hiddenIndices[index2] = !this._hiddenIndices[index2];
    }
    getDataVisibility(index2) {
      return !this._hiddenIndices[index2];
    }
    _updateVisibility(datasetIndex, dataIndex, visible) {
      const mode = visible ? "show" : "hide";
      const meta = this.getDatasetMeta(datasetIndex);
      const anims = meta.controller._resolveAnimations(void 0, mode);
      if (defined(dataIndex)) {
        meta.data[dataIndex].hidden = !visible;
        this.update();
      } else {
        this.setDatasetVisibility(datasetIndex, visible);
        anims.update(meta, {
          visible
        });
        this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : void 0);
      }
    }
    hide(datasetIndex, dataIndex) {
      this._updateVisibility(datasetIndex, dataIndex, false);
    }
    show(datasetIndex, dataIndex) {
      this._updateVisibility(datasetIndex, dataIndex, true);
    }
    _destroyDatasetMeta(datasetIndex) {
      const meta = this._metasets[datasetIndex];
      if (meta && meta.controller) {
        meta.controller._destroy();
      }
      delete this._metasets[datasetIndex];
    }
    _stop() {
      let i3, ilen;
      this.stop();
      animator.remove(this);
      for (i3 = 0, ilen = this.data.datasets.length; i3 < ilen; ++i3) {
        this._destroyDatasetMeta(i3);
      }
    }
    destroy() {
      this.notifyPlugins("beforeDestroy");
      const { canvas, ctx } = this;
      this._stop();
      this.config.clearCache();
      if (canvas) {
        this.unbindEvents();
        clearCanvas(canvas, ctx);
        this.platform.releaseContext(ctx);
        this.canvas = null;
        this.ctx = null;
      }
      delete instances[this.id];
      this.notifyPlugins("afterDestroy");
    }
    toBase64Image(...args) {
      return this.canvas.toDataURL(...args);
    }
    bindEvents() {
      this.bindUserEvents();
      if (this.options.responsive) {
        this.bindResponsiveEvents();
      } else {
        this.attached = true;
      }
    }
    bindUserEvents() {
      const listeners = this._listeners;
      const platform = this.platform;
      const _add = (type, listener2) => {
        platform.addEventListener(this, type, listener2);
        listeners[type] = listener2;
      };
      const listener = (e3, x2, y3) => {
        e3.offsetX = x2;
        e3.offsetY = y3;
        this._eventHandler(e3);
      };
      each(this.options.events, (type) => _add(type, listener));
    }
    bindResponsiveEvents() {
      if (!this._responsiveListeners) {
        this._responsiveListeners = {};
      }
      const listeners = this._responsiveListeners;
      const platform = this.platform;
      const _add = (type, listener2) => {
        platform.addEventListener(this, type, listener2);
        listeners[type] = listener2;
      };
      const _remove = (type, listener2) => {
        if (listeners[type]) {
          platform.removeEventListener(this, type, listener2);
          delete listeners[type];
        }
      };
      const listener = (width, height) => {
        if (this.canvas) {
          this.resize(width, height);
        }
      };
      let detached;
      const attached = () => {
        _remove("attach", attached);
        this.attached = true;
        this.resize();
        _add("resize", listener);
        _add("detach", detached);
      };
      detached = () => {
        this.attached = false;
        _remove("resize", listener);
        this._stop();
        this._resize(0, 0);
        _add("attach", attached);
      };
      if (platform.isAttached(this.canvas)) {
        attached();
      } else {
        detached();
      }
    }
    unbindEvents() {
      each(this._listeners, (listener, type) => {
        this.platform.removeEventListener(this, type, listener);
      });
      this._listeners = {};
      each(this._responsiveListeners, (listener, type) => {
        this.platform.removeEventListener(this, type, listener);
      });
      this._responsiveListeners = void 0;
    }
    updateHoverStyle(items, mode, enabled) {
      const prefix = enabled ? "set" : "remove";
      let meta, item, i3, ilen;
      if (mode === "dataset") {
        meta = this.getDatasetMeta(items[0].datasetIndex);
        meta.controller["_" + prefix + "DatasetHoverStyle"]();
      }
      for (i3 = 0, ilen = items.length; i3 < ilen; ++i3) {
        item = items[i3];
        const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
        if (controller) {
          controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
        }
      }
    }
    getActiveElements() {
      return this._active || [];
    }
    setActiveElements(activeElements) {
      const lastActive = this._active || [];
      const active = activeElements.map(({ datasetIndex, index: index2 }) => {
        const meta = this.getDatasetMeta(datasetIndex);
        if (!meta) {
          throw new Error("No dataset found at index " + datasetIndex);
        }
        return {
          datasetIndex,
          element: meta.data[index2],
          index: index2
        };
      });
      const changed = !_elementsEqual(active, lastActive);
      if (changed) {
        this._active = active;
        this._lastEvent = null;
        this._updateHoverStyles(active, lastActive);
      }
    }
    notifyPlugins(hook, args, filter) {
      return this._plugins.notify(this, hook, args, filter);
    }
    isPluginEnabled(pluginId) {
      return this._plugins._cache.filter((p) => p.plugin.id === pluginId).length === 1;
    }
    _updateHoverStyles(active, lastActive, replay) {
      const hoverOptions = this.options.hover;
      const diff = (a4, b2) => a4.filter((x2) => !b2.some((y3) => x2.datasetIndex === y3.datasetIndex && x2.index === y3.index));
      const deactivated = diff(lastActive, active);
      const activated = replay ? active : diff(active, lastActive);
      if (deactivated.length) {
        this.updateHoverStyle(deactivated, hoverOptions.mode, false);
      }
      if (activated.length && hoverOptions.mode) {
        this.updateHoverStyle(activated, hoverOptions.mode, true);
      }
    }
    _eventHandler(e3, replay) {
      const args = {
        event: e3,
        replay,
        cancelable: true,
        inChartArea: this.isPointInArea(e3)
      };
      const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e3.native.type);
      if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
        return;
      }
      const changed = this._handleEvent(e3, replay, args.inChartArea);
      args.cancelable = false;
      this.notifyPlugins("afterEvent", args, eventFilter);
      if (changed || args.changed) {
        this.render();
      }
      return this;
    }
    _handleEvent(e3, replay, inChartArea) {
      const { _active: lastActive = [], options: options2 } = this;
      const useFinalPosition = replay;
      const active = this._getActiveElements(e3, lastActive, inChartArea, useFinalPosition);
      const isClick = _isClickEvent(e3);
      const lastEvent = determineLastEvent(e3, this._lastEvent, inChartArea, isClick);
      if (inChartArea) {
        this._lastEvent = null;
        callback(options2.onHover, [
          e3,
          active,
          this
        ], this);
        if (isClick) {
          callback(options2.onClick, [
            e3,
            active,
            this
          ], this);
        }
      }
      const changed = !_elementsEqual(active, lastActive);
      if (changed || replay) {
        this._active = active;
        this._updateHoverStyles(active, lastActive, replay);
      }
      this._lastEvent = lastEvent;
      return changed;
    }
    _getActiveElements(e3, lastActive, inChartArea, useFinalPosition) {
      if (e3.type === "mouseout") {
        return [];
      }
      if (!inChartArea) {
        return lastActive;
      }
      const hoverOptions = this.options.hover;
      return this.getElementsAtEventForMode(e3, hoverOptions.mode, hoverOptions, useFinalPosition);
    }
  };
  __publicField(Chart3, "defaults", defaults);
  __publicField(Chart3, "instances", instances);
  __publicField(Chart3, "overrides", overrides);
  __publicField(Chart3, "registry", registry);
  __publicField(Chart3, "version", version);
  __publicField(Chart3, "getChart", getChart);
  function invalidatePlugins() {
    return each(Chart3.instances, (chart) => chart._plugins.invalidate());
  }
  function clipArc(ctx, element, endAngle) {
    const { startAngle, pixelMargin, x: x2, y: y3, outerRadius, innerRadius } = element;
    let angleMargin = pixelMargin / outerRadius;
    ctx.beginPath();
    ctx.arc(x2, y3, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
    if (innerRadius > pixelMargin) {
      angleMargin = pixelMargin / innerRadius;
      ctx.arc(x2, y3, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
    } else {
      ctx.arc(x2, y3, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
    }
    ctx.closePath();
    ctx.clip();
  }
  function toRadiusCorners(value) {
    return _readValueToProps(value, [
      "outerStart",
      "outerEnd",
      "innerStart",
      "innerEnd"
    ]);
  }
  function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
    const o2 = toRadiusCorners(arc.options.borderRadius);
    const halfThickness = (outerRadius - innerRadius) / 2;
    const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
    const computeOuterLimit = (val) => {
      const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
      return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
    };
    return {
      outerStart: computeOuterLimit(o2.outerStart),
      outerEnd: computeOuterLimit(o2.outerEnd),
      innerStart: _limitValue(o2.innerStart, 0, innerLimit),
      innerEnd: _limitValue(o2.innerEnd, 0, innerLimit)
    };
  }
  function rThetaToXY(r2, theta, x2, y3) {
    return {
      x: x2 + r2 * Math.cos(theta),
      y: y3 + r2 * Math.sin(theta)
    };
  }
  function pathArc(ctx, element, offset2, spacing, end2, circular) {
    const { x: x2, y: y3, startAngle: start3, pixelMargin, innerRadius: innerR } = element;
    const outerRadius = Math.max(element.outerRadius + spacing + offset2 - pixelMargin, 0);
    const innerRadius = innerR > 0 ? innerR + spacing + offset2 + pixelMargin : 0;
    let spacingOffset = 0;
    const alpha2 = end2 - start3;
    if (spacing) {
      const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
      const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
      const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
      const adjustedAngle = avNogSpacingRadius !== 0 ? alpha2 * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha2;
      spacingOffset = (alpha2 - adjustedAngle) / 2;
    }
    const beta = Math.max(1e-3, alpha2 * outerRadius - offset2 / PI) / outerRadius;
    const angleOffset = (alpha2 - beta) / 2;
    const startAngle = start3 + angleOffset + spacingOffset;
    const endAngle = end2 - angleOffset - spacingOffset;
    const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
    const outerStartAdjustedRadius = outerRadius - outerStart;
    const outerEndAdjustedRadius = outerRadius - outerEnd;
    const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
    const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
    const innerStartAdjustedRadius = innerRadius + innerStart;
    const innerEndAdjustedRadius = innerRadius + innerEnd;
    const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
    const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
    ctx.beginPath();
    if (circular) {
      const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;
      ctx.arc(x2, y3, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);
      ctx.arc(x2, y3, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);
      if (outerEnd > 0) {
        const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x2, y3);
        ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
      }
      const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x2, y3);
      ctx.lineTo(p4.x, p4.y);
      if (innerEnd > 0) {
        const pCenter1 = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x2, y3);
        ctx.arc(pCenter1.x, pCenter1.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
      }
      const innerMidAdjustedAngle = (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;
      ctx.arc(x2, y3, innerRadius, endAngle - innerEnd / innerRadius, innerMidAdjustedAngle, true);
      ctx.arc(x2, y3, innerRadius, innerMidAdjustedAngle, startAngle + innerStart / innerRadius, true);
      if (innerStart > 0) {
        const pCenter2 = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x2, y3);
        ctx.arc(pCenter2.x, pCenter2.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
      }
      const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x2, y3);
      ctx.lineTo(p8.x, p8.y);
      if (outerStart > 0) {
        const pCenter3 = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x2, y3);
        ctx.arc(pCenter3.x, pCenter3.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
      }
    } else {
      ctx.moveTo(x2, y3);
      const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x2;
      const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y3;
      ctx.lineTo(outerStartX, outerStartY);
      const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x2;
      const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y3;
      ctx.lineTo(outerEndX, outerEndY);
    }
    ctx.closePath();
  }
  function drawArc(ctx, element, offset2, spacing, circular) {
    const { fullCircles, startAngle, circumference } = element;
    let endAngle = element.endAngle;
    if (fullCircles) {
      pathArc(ctx, element, offset2, spacing, endAngle, circular);
      for (let i3 = 0; i3 < fullCircles; ++i3) {
        ctx.fill();
      }
      if (!isNaN(circumference)) {
        endAngle = startAngle + (circumference % TAU || TAU);
      }
    }
    pathArc(ctx, element, offset2, spacing, endAngle, circular);
    ctx.fill();
    return endAngle;
  }
  function drawBorder(ctx, element, offset2, spacing, circular) {
    const { fullCircles, startAngle, circumference, options: options2 } = element;
    const { borderWidth, borderJoinStyle } = options2;
    const inner = options2.borderAlign === "inner";
    if (!borderWidth) {
      return;
    }
    if (inner) {
      ctx.lineWidth = borderWidth * 2;
      ctx.lineJoin = borderJoinStyle || "round";
    } else {
      ctx.lineWidth = borderWidth;
      ctx.lineJoin = borderJoinStyle || "bevel";
    }
    let endAngle = element.endAngle;
    if (fullCircles) {
      pathArc(ctx, element, offset2, spacing, endAngle, circular);
      for (let i3 = 0; i3 < fullCircles; ++i3) {
        ctx.stroke();
      }
      if (!isNaN(circumference)) {
        endAngle = startAngle + (circumference % TAU || TAU);
      }
    }
    if (inner) {
      clipArc(ctx, element, endAngle);
    }
    if (!fullCircles) {
      pathArc(ctx, element, offset2, spacing, endAngle, circular);
      ctx.stroke();
    }
  }
  var ArcElement = class extends Element2 {
    constructor(cfg) {
      super();
      this.options = void 0;
      this.circumference = void 0;
      this.startAngle = void 0;
      this.endAngle = void 0;
      this.innerRadius = void 0;
      this.outerRadius = void 0;
      this.pixelMargin = 0;
      this.fullCircles = 0;
      if (cfg) {
        Object.assign(this, cfg);
      }
    }
    inRange(chartX, chartY, useFinalPosition) {
      const point = this.getProps([
        "x",
        "y"
      ], useFinalPosition);
      const { angle, distance } = getAngleFromPoint(point, {
        x: chartX,
        y: chartY
      });
      const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([
        "startAngle",
        "endAngle",
        "innerRadius",
        "outerRadius",
        "circumference"
      ], useFinalPosition);
      const rAdjust = this.options.spacing / 2;
      const _circumference = valueOrDefault(circumference, endAngle - startAngle);
      const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);
      const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
      return betweenAngles && withinRadius;
    }
    getCenterPoint(useFinalPosition) {
      const { x: x2, y: y3, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([
        "x",
        "y",
        "startAngle",
        "endAngle",
        "innerRadius",
        "outerRadius"
      ], useFinalPosition);
      const { offset: offset2, spacing } = this.options;
      const halfAngle = (startAngle + endAngle) / 2;
      const halfRadius = (innerRadius + outerRadius + spacing + offset2) / 2;
      return {
        x: x2 + Math.cos(halfAngle) * halfRadius,
        y: y3 + Math.sin(halfAngle) * halfRadius
      };
    }
    tooltipPosition(useFinalPosition) {
      return this.getCenterPoint(useFinalPosition);
    }
    draw(ctx) {
      const { options: options2, circumference } = this;
      const offset2 = (options2.offset || 0) / 4;
      const spacing = (options2.spacing || 0) / 2;
      const circular = options2.circular;
      this.pixelMargin = options2.borderAlign === "inner" ? 0.33 : 0;
      this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
      if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
        return;
      }
      ctx.save();
      const halfAngle = (this.startAngle + this.endAngle) / 2;
      ctx.translate(Math.cos(halfAngle) * offset2, Math.sin(halfAngle) * offset2);
      const fix = 1 - Math.sin(Math.min(PI, circumference || 0));
      const radiusOffset = offset2 * fix;
      ctx.fillStyle = options2.backgroundColor;
      ctx.strokeStyle = options2.borderColor;
      drawArc(ctx, this, radiusOffset, spacing, circular);
      drawBorder(ctx, this, radiusOffset, spacing, circular);
      ctx.restore();
    }
  };
  __publicField(ArcElement, "id", "arc");
  __publicField(ArcElement, "defaults", {
    borderAlign: "center",
    borderColor: "#fff",
    borderJoinStyle: void 0,
    borderRadius: 0,
    borderWidth: 2,
    offset: 0,
    spacing: 0,
    angle: void 0,
    circular: true
  });
  __publicField(ArcElement, "defaultRoutes", {
    backgroundColor: "backgroundColor"
  });
  function setStyle(ctx, options2, style = options2) {
    ctx.lineCap = valueOrDefault(style.borderCapStyle, options2.borderCapStyle);
    ctx.setLineDash(valueOrDefault(style.borderDash, options2.borderDash));
    ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options2.borderDashOffset);
    ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options2.borderJoinStyle);
    ctx.lineWidth = valueOrDefault(style.borderWidth, options2.borderWidth);
    ctx.strokeStyle = valueOrDefault(style.borderColor, options2.borderColor);
  }
  function lineTo(ctx, previous, target) {
    ctx.lineTo(target.x, target.y);
  }
  function getLineMethod(options2) {
    if (options2.stepped) {
      return _steppedLineTo;
    }
    if (options2.tension || options2.cubicInterpolationMode === "monotone") {
      return _bezierCurveTo;
    }
    return lineTo;
  }
  function pathVars(points, segment, params = {}) {
    const count = points.length;
    const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;
    const { start: segmentStart, end: segmentEnd } = segment;
    const start3 = Math.max(paramsStart, segmentStart);
    const end2 = Math.min(paramsEnd, segmentEnd);
    const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
    return {
      count,
      start: start3,
      loop: segment.loop,
      ilen: end2 < start3 && !outside ? count + end2 - start3 : end2 - start3
    };
  }
  function pathSegment(ctx, line, segment, params) {
    const { points, options: options2 } = line;
    const { count, start: start3, loop, ilen } = pathVars(points, segment, params);
    const lineMethod = getLineMethod(options2);
    let { move = true, reverse } = params || {};
    let i3, point, prev;
    for (i3 = 0; i3 <= ilen; ++i3) {
      point = points[(start3 + (reverse ? ilen - i3 : i3)) % count];
      if (point.skip) {
        continue;
      } else if (move) {
        ctx.moveTo(point.x, point.y);
        move = false;
      } else {
        lineMethod(ctx, prev, point, reverse, options2.stepped);
      }
      prev = point;
    }
    if (loop) {
      point = points[(start3 + (reverse ? ilen : 0)) % count];
      lineMethod(ctx, prev, point, reverse, options2.stepped);
    }
    return !!loop;
  }
  function fastPathSegment(ctx, line, segment, params) {
    const points = line.points;
    const { count, start: start3, ilen } = pathVars(points, segment, params);
    const { move = true, reverse } = params || {};
    let avgX = 0;
    let countX = 0;
    let i3, point, prevX, minY, maxY, lastY;
    const pointIndex = (index2) => (start3 + (reverse ? ilen - index2 : index2)) % count;
    const drawX = () => {
      if (minY !== maxY) {
        ctx.lineTo(avgX, maxY);
        ctx.lineTo(avgX, minY);
        ctx.lineTo(avgX, lastY);
      }
    };
    if (move) {
      point = points[pointIndex(0)];
      ctx.moveTo(point.x, point.y);
    }
    for (i3 = 0; i3 <= ilen; ++i3) {
      point = points[pointIndex(i3)];
      if (point.skip) {
        continue;
      }
      const x2 = point.x;
      const y3 = point.y;
      const truncX = x2 | 0;
      if (truncX === prevX) {
        if (y3 < minY) {
          minY = y3;
        } else if (y3 > maxY) {
          maxY = y3;
        }
        avgX = (countX * avgX + x2) / ++countX;
      } else {
        drawX();
        ctx.lineTo(x2, y3);
        prevX = truncX;
        countX = 0;
        minY = maxY = y3;
      }
      lastY = y3;
    }
    drawX();
  }
  function _getSegmentMethod(line) {
    const opts = line.options;
    const borderDash = opts.borderDash && opts.borderDash.length;
    const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
    return useFastPath ? fastPathSegment : pathSegment;
  }
  function _getInterpolationMethod(options2) {
    if (options2.stepped) {
      return _steppedInterpolation;
    }
    if (options2.tension || options2.cubicInterpolationMode === "monotone") {
      return _bezierInterpolation;
    }
    return _pointInLine;
  }
  function strokePathWithCache(ctx, line, start3, count) {
    let path = line._path;
    if (!path) {
      path = line._path = new Path2D();
      if (line.path(path, start3, count)) {
        path.closePath();
      }
    }
    setStyle(ctx, line.options);
    ctx.stroke(path);
  }
  function strokePathDirect(ctx, line, start3, count) {
    const { segments, options: options2 } = line;
    const segmentMethod = _getSegmentMethod(line);
    for (const segment of segments) {
      setStyle(ctx, options2, segment.style);
      ctx.beginPath();
      if (segmentMethod(ctx, line, segment, {
        start: start3,
        end: start3 + count - 1
      })) {
        ctx.closePath();
      }
      ctx.stroke();
    }
  }
  var usePath2D = typeof Path2D === "function";
  function draw(ctx, line, start3, count) {
    if (usePath2D && !line.options.segment) {
      strokePathWithCache(ctx, line, start3, count);
    } else {
      strokePathDirect(ctx, line, start3, count);
    }
  }
  var LineElement = class extends Element2 {
    constructor(cfg) {
      super();
      this.animated = true;
      this.options = void 0;
      this._chart = void 0;
      this._loop = void 0;
      this._fullLoop = void 0;
      this._path = void 0;
      this._points = void 0;
      this._segments = void 0;
      this._decimated = false;
      this._pointsUpdated = false;
      this._datasetIndex = void 0;
      if (cfg) {
        Object.assign(this, cfg);
      }
    }
    updateControlPoints(chartArea, indexAxis) {
      const options2 = this.options;
      if ((options2.tension || options2.cubicInterpolationMode === "monotone") && !options2.stepped && !this._pointsUpdated) {
        const loop = options2.spanGaps ? this._loop : this._fullLoop;
        _updateBezierControlPoints(this._points, options2, chartArea, loop, indexAxis);
        this._pointsUpdated = true;
      }
    }
    set points(points) {
      this._points = points;
      delete this._segments;
      delete this._path;
      this._pointsUpdated = false;
    }
    get points() {
      return this._points;
    }
    get segments() {
      return this._segments || (this._segments = _computeSegments(this, this.options.segment));
    }
    first() {
      const segments = this.segments;
      const points = this.points;
      return segments.length && points[segments[0].start];
    }
    last() {
      const segments = this.segments;
      const points = this.points;
      const count = segments.length;
      return count && points[segments[count - 1].end];
    }
    interpolate(point, property) {
      const options2 = this.options;
      const value = point[property];
      const points = this.points;
      const segments = _boundSegments(this, {
        property,
        start: value,
        end: value
      });
      if (!segments.length) {
        return;
      }
      const result = [];
      const _interpolate = _getInterpolationMethod(options2);
      let i3, ilen;
      for (i3 = 0, ilen = segments.length; i3 < ilen; ++i3) {
        const { start: start3, end: end2 } = segments[i3];
        const p1 = points[start3];
        const p2 = points[end2];
        if (p1 === p2) {
          result.push(p1);
          continue;
        }
        const t2 = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
        const interpolated = _interpolate(p1, p2, t2, options2.stepped);
        interpolated[property] = point[property];
        result.push(interpolated);
      }
      return result.length === 1 ? result[0] : result;
    }
    pathSegment(ctx, segment, params) {
      const segmentMethod = _getSegmentMethod(this);
      return segmentMethod(ctx, this, segment, params);
    }
    path(ctx, start3, count) {
      const segments = this.segments;
      const segmentMethod = _getSegmentMethod(this);
      let loop = this._loop;
      start3 = start3 || 0;
      count = count || this.points.length - start3;
      for (const segment of segments) {
        loop &= segmentMethod(ctx, this, segment, {
          start: start3,
          end: start3 + count - 1
        });
      }
      return !!loop;
    }
    draw(ctx, chartArea, start3, count) {
      const options2 = this.options || {};
      const points = this.points || [];
      if (points.length && options2.borderWidth) {
        ctx.save();
        draw(ctx, this, start3, count);
        ctx.restore();
      }
      if (this.animated) {
        this._pointsUpdated = false;
        this._path = void 0;
      }
    }
  };
  __publicField(LineElement, "id", "line");
  __publicField(LineElement, "defaults", {
    borderCapStyle: "butt",
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: "miter",
    borderWidth: 3,
    capBezierPoints: true,
    cubicInterpolationMode: "default",
    fill: false,
    spanGaps: false,
    stepped: false,
    tension: 0
  });
  __publicField(LineElement, "defaultRoutes", {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  });
  __publicField(LineElement, "descriptors", {
    _scriptable: true,
    _indexable: (name2) => name2 !== "borderDash" && name2 !== "fill"
  });
  function inRange$1(el, pos, axis, useFinalPosition) {
    const options2 = el.options;
    const { [axis]: value } = el.getProps([
      axis
    ], useFinalPosition);
    return Math.abs(pos - value) < options2.radius + options2.hitRadius;
  }
  var PointElement = class extends Element2 {
    constructor(cfg) {
      super();
      this.options = void 0;
      this.parsed = void 0;
      this.skip = void 0;
      this.stop = void 0;
      if (cfg) {
        Object.assign(this, cfg);
      }
    }
    inRange(mouseX, mouseY, useFinalPosition) {
      const options2 = this.options;
      const { x: x2, y: y3 } = this.getProps([
        "x",
        "y"
      ], useFinalPosition);
      return Math.pow(mouseX - x2, 2) + Math.pow(mouseY - y3, 2) < Math.pow(options2.hitRadius + options2.radius, 2);
    }
    inXRange(mouseX, useFinalPosition) {
      return inRange$1(this, mouseX, "x", useFinalPosition);
    }
    inYRange(mouseY, useFinalPosition) {
      return inRange$1(this, mouseY, "y", useFinalPosition);
    }
    getCenterPoint(useFinalPosition) {
      const { x: x2, y: y3 } = this.getProps([
        "x",
        "y"
      ], useFinalPosition);
      return {
        x: x2,
        y: y3
      };
    }
    size(options2) {
      options2 = options2 || this.options || {};
      let radius = options2.radius || 0;
      radius = Math.max(radius, radius && options2.hoverRadius || 0);
      const borderWidth = radius && options2.borderWidth || 0;
      return (radius + borderWidth) * 2;
    }
    draw(ctx, area) {
      const options2 = this.options;
      if (this.skip || options2.radius < 0.1 || !_isPointInArea(this, area, this.size(options2) / 2)) {
        return;
      }
      ctx.strokeStyle = options2.borderColor;
      ctx.lineWidth = options2.borderWidth;
      ctx.fillStyle = options2.backgroundColor;
      drawPoint(ctx, options2, this.x, this.y);
    }
    getRange() {
      const options2 = this.options || {};
      return options2.radius + options2.hitRadius;
    }
  };
  __publicField(PointElement, "id", "point");
  __publicField(PointElement, "defaults", {
    borderWidth: 1,
    hitRadius: 1,
    hoverBorderWidth: 1,
    hoverRadius: 4,
    pointStyle: "circle",
    radius: 3,
    rotation: 0
  });
  __publicField(PointElement, "defaultRoutes", {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  });
  function getBarBounds(bar, useFinalPosition) {
    const { x: x2, y: y3, base, width, height } = bar.getProps([
      "x",
      "y",
      "base",
      "width",
      "height"
    ], useFinalPosition);
    let left2, right2, top2, bottom2, half;
    if (bar.horizontal) {
      half = height / 2;
      left2 = Math.min(x2, base);
      right2 = Math.max(x2, base);
      top2 = y3 - half;
      bottom2 = y3 + half;
    } else {
      half = width / 2;
      left2 = x2 - half;
      right2 = x2 + half;
      top2 = Math.min(y3, base);
      bottom2 = Math.max(y3, base);
    }
    return {
      left: left2,
      top: top2,
      right: right2,
      bottom: bottom2
    };
  }
  function skipOrLimit(skip2, value, min2, max2) {
    return skip2 ? 0 : _limitValue(value, min2, max2);
  }
  function parseBorderWidth(bar, maxW, maxH) {
    const value = bar.options.borderWidth;
    const skip2 = bar.borderSkipped;
    const o2 = toTRBL(value);
    return {
      t: skipOrLimit(skip2.top, o2.top, 0, maxH),
      r: skipOrLimit(skip2.right, o2.right, 0, maxW),
      b: skipOrLimit(skip2.bottom, o2.bottom, 0, maxH),
      l: skipOrLimit(skip2.left, o2.left, 0, maxW)
    };
  }
  function parseBorderRadius(bar, maxW, maxH) {
    const { enableBorderRadius } = bar.getProps([
      "enableBorderRadius"
    ]);
    const value = bar.options.borderRadius;
    const o2 = toTRBLCorners(value);
    const maxR2 = Math.min(maxW, maxH);
    const skip2 = bar.borderSkipped;
    const enableBorder = enableBorderRadius || isObject(value);
    return {
      topLeft: skipOrLimit(!enableBorder || skip2.top || skip2.left, o2.topLeft, 0, maxR2),
      topRight: skipOrLimit(!enableBorder || skip2.top || skip2.right, o2.topRight, 0, maxR2),
      bottomLeft: skipOrLimit(!enableBorder || skip2.bottom || skip2.left, o2.bottomLeft, 0, maxR2),
      bottomRight: skipOrLimit(!enableBorder || skip2.bottom || skip2.right, o2.bottomRight, 0, maxR2)
    };
  }
  function boundingRects(bar) {
    const bounds = getBarBounds(bar);
    const width = bounds.right - bounds.left;
    const height = bounds.bottom - bounds.top;
    const border = parseBorderWidth(bar, width / 2, height / 2);
    const radius = parseBorderRadius(bar, width / 2, height / 2);
    return {
      outer: {
        x: bounds.left,
        y: bounds.top,
        w: width,
        h: height,
        radius
      },
      inner: {
        x: bounds.left + border.l,
        y: bounds.top + border.t,
        w: width - border.l - border.r,
        h: height - border.t - border.b,
        radius: {
          topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
          topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
          bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
          bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
        }
      }
    };
  }
  function inRange(bar, x2, y3, useFinalPosition) {
    const skipX = x2 === null;
    const skipY = y3 === null;
    const skipBoth = skipX && skipY;
    const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
    return bounds && (skipX || _isBetween(x2, bounds.left, bounds.right)) && (skipY || _isBetween(y3, bounds.top, bounds.bottom));
  }
  function hasRadius(radius) {
    return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
  }
  function addNormalRectPath(ctx, rect) {
    ctx.rect(rect.x, rect.y, rect.w, rect.h);
  }
  function inflateRect(rect, amount, refRect = {}) {
    const x2 = rect.x !== refRect.x ? -amount : 0;
    const y3 = rect.y !== refRect.y ? -amount : 0;
    const w2 = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x2;
    const h5 = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y3;
    return {
      x: rect.x + x2,
      y: rect.y + y3,
      w: rect.w + w2,
      h: rect.h + h5,
      radius: rect.radius
    };
  }
  var BarElement = class extends Element2 {
    constructor(cfg) {
      super();
      this.options = void 0;
      this.horizontal = void 0;
      this.base = void 0;
      this.width = void 0;
      this.height = void 0;
      this.inflateAmount = void 0;
      if (cfg) {
        Object.assign(this, cfg);
      }
    }
    draw(ctx) {
      const { inflateAmount, options: { borderColor, backgroundColor } } = this;
      const { inner, outer } = boundingRects(this);
      const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
      ctx.save();
      if (outer.w !== inner.w || outer.h !== inner.h) {
        ctx.beginPath();
        addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
        ctx.clip();
        addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
        ctx.fillStyle = borderColor;
        ctx.fill("evenodd");
      }
      ctx.beginPath();
      addRectPath(ctx, inflateRect(inner, inflateAmount));
      ctx.fillStyle = backgroundColor;
      ctx.fill();
      ctx.restore();
    }
    inRange(mouseX, mouseY, useFinalPosition) {
      return inRange(this, mouseX, mouseY, useFinalPosition);
    }
    inXRange(mouseX, useFinalPosition) {
      return inRange(this, mouseX, null, useFinalPosition);
    }
    inYRange(mouseY, useFinalPosition) {
      return inRange(this, null, mouseY, useFinalPosition);
    }
    getCenterPoint(useFinalPosition) {
      const { x: x2, y: y3, base, horizontal } = this.getProps([
        "x",
        "y",
        "base",
        "horizontal"
      ], useFinalPosition);
      return {
        x: horizontal ? (x2 + base) / 2 : x2,
        y: horizontal ? y3 : (y3 + base) / 2
      };
    }
    getRange(axis) {
      return axis === "x" ? this.width / 2 : this.height / 2;
    }
  };
  __publicField(BarElement, "id", "bar");
  __publicField(BarElement, "defaults", {
    borderSkipped: "start",
    borderWidth: 0,
    borderRadius: 0,
    inflateAmount: "auto",
    pointStyle: void 0
  });
  __publicField(BarElement, "defaultRoutes", {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  });
  var elements = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    ArcElement,
    LineElement,
    PointElement,
    BarElement
  });
  var BORDER_COLORS = [
    "rgb(54, 162, 235)",
    "rgb(255, 99, 132)",
    "rgb(255, 159, 64)",
    "rgb(255, 205, 86)",
    "rgb(75, 192, 192)",
    "rgb(153, 102, 255)",
    "rgb(201, 203, 207)"
  ];
  var BACKGROUND_COLORS = /* @__PURE__ */ BORDER_COLORS.map((color2) => color2.replace("rgb(", "rgba(").replace(")", ", 0.5)"));
  function getBorderColor(i3) {
    return BORDER_COLORS[i3 % BORDER_COLORS.length];
  }
  function getBackgroundColor(i3) {
    return BACKGROUND_COLORS[i3 % BACKGROUND_COLORS.length];
  }
  function colorizeDefaultDataset(dataset, i3) {
    dataset.borderColor = getBorderColor(i3);
    dataset.backgroundColor = getBackgroundColor(i3);
    return ++i3;
  }
  function colorizeDoughnutDataset(dataset, i3) {
    dataset.backgroundColor = dataset.data.map(() => getBorderColor(i3++));
    return i3;
  }
  function colorizePolarAreaDataset(dataset, i3) {
    dataset.backgroundColor = dataset.data.map(() => getBackgroundColor(i3++));
    return i3;
  }
  function getColorizer(chart) {
    let i3 = 0;
    return (dataset, datasetIndex) => {
      const controller = chart.getDatasetMeta(datasetIndex).controller;
      if (controller instanceof DoughnutController) {
        i3 = colorizeDoughnutDataset(dataset, i3);
      } else if (controller instanceof PolarAreaController) {
        i3 = colorizePolarAreaDataset(dataset, i3);
      } else if (controller) {
        i3 = colorizeDefaultDataset(dataset, i3);
      }
    };
  }
  function containsColorsDefinitions(descriptors2) {
    let k2;
    for (k2 in descriptors2) {
      if (descriptors2[k2].borderColor || descriptors2[k2].backgroundColor) {
        return true;
      }
    }
    return false;
  }
  function containsColorsDefinition(descriptor) {
    return descriptor && (descriptor.borderColor || descriptor.backgroundColor);
  }
  var plugin_colors = {
    id: "colors",
    defaults: {
      enabled: true,
      forceOverride: false
    },
    beforeLayout(chart, _args, options2) {
      if (!options2.enabled) {
        return;
      }
      const { data: { datasets }, options: chartOptions } = chart.config;
      const { elements: elements3 } = chartOptions;
      if (!options2.forceOverride && (containsColorsDefinitions(datasets) || containsColorsDefinition(chartOptions) || elements3 && containsColorsDefinitions(elements3))) {
        return;
      }
      const colorizer = getColorizer(chart);
      datasets.forEach(colorizer);
    }
  };
  function lttbDecimation(data, start3, count, availableWidth, options2) {
    const samples = options2.samples || availableWidth;
    if (samples >= count) {
      return data.slice(start3, start3 + count);
    }
    const decimated = [];
    const bucketWidth = (count - 2) / (samples - 2);
    let sampledIndex = 0;
    const endIndex = start3 + count - 1;
    let a4 = start3;
    let i3, maxAreaPoint, maxArea, area, nextA;
    decimated[sampledIndex++] = data[a4];
    for (i3 = 0; i3 < samples - 2; i3++) {
      let avgX = 0;
      let avgY = 0;
      let j;
      const avgRangeStart = Math.floor((i3 + 1) * bucketWidth) + 1 + start3;
      const avgRangeEnd = Math.min(Math.floor((i3 + 2) * bucketWidth) + 1, count) + start3;
      const avgRangeLength = avgRangeEnd - avgRangeStart;
      for (j = avgRangeStart; j < avgRangeEnd; j++) {
        avgX += data[j].x;
        avgY += data[j].y;
      }
      avgX /= avgRangeLength;
      avgY /= avgRangeLength;
      const rangeOffs = Math.floor(i3 * bucketWidth) + 1 + start3;
      const rangeTo = Math.min(Math.floor((i3 + 1) * bucketWidth) + 1, count) + start3;
      const { x: pointAx, y: pointAy } = data[a4];
      maxArea = area = -1;
      for (j = rangeOffs; j < rangeTo; j++) {
        area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));
        if (area > maxArea) {
          maxArea = area;
          maxAreaPoint = data[j];
          nextA = j;
        }
      }
      decimated[sampledIndex++] = maxAreaPoint;
      a4 = nextA;
    }
    decimated[sampledIndex++] = data[endIndex];
    return decimated;
  }
  function minMaxDecimation(data, start3, count, availableWidth) {
    let avgX = 0;
    let countX = 0;
    let i3, point, x2, y3, prevX, minIndex, maxIndex, startIndex, minY, maxY;
    const decimated = [];
    const endIndex = start3 + count - 1;
    const xMin = data[start3].x;
    const xMax = data[endIndex].x;
    const dx = xMax - xMin;
    for (i3 = start3; i3 < start3 + count; ++i3) {
      point = data[i3];
      x2 = (point.x - xMin) / dx * availableWidth;
      y3 = point.y;
      const truncX = x2 | 0;
      if (truncX === prevX) {
        if (y3 < minY) {
          minY = y3;
          minIndex = i3;
        } else if (y3 > maxY) {
          maxY = y3;
          maxIndex = i3;
        }
        avgX = (countX * avgX + point.x) / ++countX;
      } else {
        const lastIndex = i3 - 1;
        if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {
          const intermediateIndex1 = Math.min(minIndex, maxIndex);
          const intermediateIndex2 = Math.max(minIndex, maxIndex);
          if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
            decimated.push({
              ...data[intermediateIndex1],
              x: avgX
            });
          }
          if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
            decimated.push({
              ...data[intermediateIndex2],
              x: avgX
            });
          }
        }
        if (i3 > 0 && lastIndex !== startIndex) {
          decimated.push(data[lastIndex]);
        }
        decimated.push(point);
        prevX = truncX;
        countX = 0;
        minY = maxY = y3;
        minIndex = maxIndex = startIndex = i3;
      }
    }
    return decimated;
  }
  function cleanDecimatedDataset(dataset) {
    if (dataset._decimated) {
      const data = dataset._data;
      delete dataset._decimated;
      delete dataset._data;
      Object.defineProperty(dataset, "data", {
        configurable: true,
        enumerable: true,
        writable: true,
        value: data
      });
    }
  }
  function cleanDecimatedData(chart) {
    chart.data.datasets.forEach((dataset) => {
      cleanDecimatedDataset(dataset);
    });
  }
  function getStartAndCountOfVisiblePointsSimplified(meta, points) {
    const pointCount = points.length;
    let start3 = 0;
    let count;
    const { iScale } = meta;
    const { min: min2, max: max2, minDefined, maxDefined } = iScale.getUserBounds();
    if (minDefined) {
      start3 = _limitValue(_lookupByKey(points, iScale.axis, min2).lo, 0, pointCount - 1);
    }
    if (maxDefined) {
      count = _limitValue(_lookupByKey(points, iScale.axis, max2).hi + 1, start3, pointCount) - start3;
    } else {
      count = pointCount - start3;
    }
    return {
      start: start3,
      count
    };
  }
  var plugin_decimation = {
    id: "decimation",
    defaults: {
      algorithm: "min-max",
      enabled: false
    },
    beforeElementsUpdate: (chart, args, options2) => {
      if (!options2.enabled) {
        cleanDecimatedData(chart);
        return;
      }
      const availableWidth = chart.width;
      chart.data.datasets.forEach((dataset, datasetIndex) => {
        const { _data, indexAxis } = dataset;
        const meta = chart.getDatasetMeta(datasetIndex);
        const data = _data || dataset.data;
        if (resolve([
          indexAxis,
          chart.options.indexAxis
        ]) === "y") {
          return;
        }
        if (!meta.controller.supportsDecimation) {
          return;
        }
        const xAxis = chart.scales[meta.xAxisID];
        if (xAxis.type !== "linear" && xAxis.type !== "time") {
          return;
        }
        if (chart.options.parsing) {
          return;
        }
        let { start: start3, count } = getStartAndCountOfVisiblePointsSimplified(meta, data);
        const threshold = options2.threshold || 4 * availableWidth;
        if (count <= threshold) {
          cleanDecimatedDataset(dataset);
          return;
        }
        if (isNullOrUndef(_data)) {
          dataset._data = data;
          delete dataset.data;
          Object.defineProperty(dataset, "data", {
            configurable: true,
            enumerable: true,
            get: function() {
              return this._decimated;
            },
            set: function(d3) {
              this._data = d3;
            }
          });
        }
        let decimated;
        switch (options2.algorithm) {
          case "lttb":
            decimated = lttbDecimation(data, start3, count, availableWidth, options2);
            break;
          case "min-max":
            decimated = minMaxDecimation(data, start3, count, availableWidth);
            break;
          default:
            throw new Error(`Unsupported decimation algorithm '${options2.algorithm}'`);
        }
        dataset._decimated = decimated;
      });
    },
    destroy(chart) {
      cleanDecimatedData(chart);
    }
  };
  function _segments(line, target, property) {
    const segments = line.segments;
    const points = line.points;
    const tpoints = target.points;
    const parts = [];
    for (const segment of segments) {
      let { start: start3, end: end2 } = segment;
      end2 = _findSegmentEnd(start3, end2, points);
      const bounds = _getBounds(property, points[start3], points[end2], segment.loop);
      if (!target.segments) {
        parts.push({
          source: segment,
          target: bounds,
          start: points[start3],
          end: points[end2]
        });
        continue;
      }
      const targetSegments = _boundSegments(target, bounds);
      for (const tgt of targetSegments) {
        const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
        const fillSources = _boundSegment(segment, points, subBounds);
        for (const fillSource of fillSources) {
          parts.push({
            source: fillSource,
            target: tgt,
            start: {
              [property]: _getEdge(bounds, subBounds, "start", Math.max)
            },
            end: {
              [property]: _getEdge(bounds, subBounds, "end", Math.min)
            }
          });
        }
      }
    }
    return parts;
  }
  function _getBounds(property, first, last, loop) {
    if (loop) {
      return;
    }
    let start3 = first[property];
    let end2 = last[property];
    if (property === "angle") {
      start3 = _normalizeAngle(start3);
      end2 = _normalizeAngle(end2);
    }
    return {
      property,
      start: start3,
      end: end2
    };
  }
  function _pointsFromSegments(boundary, line) {
    const { x: x2 = null, y: y3 = null } = boundary || {};
    const linePoints = line.points;
    const points = [];
    line.segments.forEach(({ start: start3, end: end2 }) => {
      end2 = _findSegmentEnd(start3, end2, linePoints);
      const first = linePoints[start3];
      const last = linePoints[end2];
      if (y3 !== null) {
        points.push({
          x: first.x,
          y: y3
        });
        points.push({
          x: last.x,
          y: y3
        });
      } else if (x2 !== null) {
        points.push({
          x: x2,
          y: first.y
        });
        points.push({
          x: x2,
          y: last.y
        });
      }
    });
    return points;
  }
  function _findSegmentEnd(start3, end2, points) {
    for (; end2 > start3; end2--) {
      const point = points[end2];
      if (!isNaN(point.x) && !isNaN(point.y)) {
        break;
      }
    }
    return end2;
  }
  function _getEdge(a4, b2, prop, fn2) {
    if (a4 && b2) {
      return fn2(a4[prop], b2[prop]);
    }
    return a4 ? a4[prop] : b2 ? b2[prop] : 0;
  }
  function _createBoundaryLine(boundary, line) {
    let points = [];
    let _loop = false;
    if (isArray2(boundary)) {
      _loop = true;
      points = boundary;
    } else {
      points = _pointsFromSegments(boundary, line);
    }
    return points.length ? new LineElement({
      points,
      options: {
        tension: 0
      },
      _loop,
      _fullLoop: _loop
    }) : null;
  }
  function _shouldApplyFill(source) {
    return source && source.fill !== false;
  }
  function _resolveTarget(sources, index2, propagate) {
    const source = sources[index2];
    let fill2 = source.fill;
    const visited = [
      index2
    ];
    let target;
    if (!propagate) {
      return fill2;
    }
    while (fill2 !== false && visited.indexOf(fill2) === -1) {
      if (!isNumberFinite(fill2)) {
        return fill2;
      }
      target = sources[fill2];
      if (!target) {
        return false;
      }
      if (target.visible) {
        return fill2;
      }
      visited.push(fill2);
      fill2 = target.fill;
    }
    return false;
  }
  function _decodeFill(line, index2, count) {
    const fill2 = parseFillOption(line);
    if (isObject(fill2)) {
      return isNaN(fill2.value) ? false : fill2;
    }
    let target = parseFloat(fill2);
    if (isNumberFinite(target) && Math.floor(target) === target) {
      return decodeTargetIndex(fill2[0], index2, target, count);
    }
    return [
      "origin",
      "start",
      "end",
      "stack",
      "shape"
    ].indexOf(fill2) >= 0 && fill2;
  }
  function decodeTargetIndex(firstCh, index2, target, count) {
    if (firstCh === "-" || firstCh === "+") {
      target = index2 + target;
    }
    if (target === index2 || target < 0 || target >= count) {
      return false;
    }
    return target;
  }
  function _getTargetPixel(fill2, scale) {
    let pixel = null;
    if (fill2 === "start") {
      pixel = scale.bottom;
    } else if (fill2 === "end") {
      pixel = scale.top;
    } else if (isObject(fill2)) {
      pixel = scale.getPixelForValue(fill2.value);
    } else if (scale.getBasePixel) {
      pixel = scale.getBasePixel();
    }
    return pixel;
  }
  function _getTargetValue(fill2, scale, startValue) {
    let value;
    if (fill2 === "start") {
      value = startValue;
    } else if (fill2 === "end") {
      value = scale.options.reverse ? scale.min : scale.max;
    } else if (isObject(fill2)) {
      value = fill2.value;
    } else {
      value = scale.getBaseValue();
    }
    return value;
  }
  function parseFillOption(line) {
    const options2 = line.options;
    const fillOption = options2.fill;
    let fill2 = valueOrDefault(fillOption && fillOption.target, fillOption);
    if (fill2 === void 0) {
      fill2 = !!options2.backgroundColor;
    }
    if (fill2 === false || fill2 === null) {
      return false;
    }
    if (fill2 === true) {
      return "origin";
    }
    return fill2;
  }
  function _buildStackLine(source) {
    const { scale, index: index2, line } = source;
    const points = [];
    const segments = line.segments;
    const sourcePoints = line.points;
    const linesBelow = getLinesBelow(scale, index2);
    linesBelow.push(_createBoundaryLine({
      x: null,
      y: scale.bottom
    }, line));
    for (let i3 = 0; i3 < segments.length; i3++) {
      const segment = segments[i3];
      for (let j = segment.start; j <= segment.end; j++) {
        addPointsBelow(points, sourcePoints[j], linesBelow);
      }
    }
    return new LineElement({
      points,
      options: {}
    });
  }
  function getLinesBelow(scale, index2) {
    const below = [];
    const metas = scale.getMatchingVisibleMetas("line");
    for (let i3 = 0; i3 < metas.length; i3++) {
      const meta = metas[i3];
      if (meta.index === index2) {
        break;
      }
      if (!meta.hidden) {
        below.unshift(meta.dataset);
      }
    }
    return below;
  }
  function addPointsBelow(points, sourcePoint, linesBelow) {
    const postponed = [];
    for (let j = 0; j < linesBelow.length; j++) {
      const line = linesBelow[j];
      const { first, last, point } = findPoint(line, sourcePoint, "x");
      if (!point || first && last) {
        continue;
      }
      if (first) {
        postponed.unshift(point);
      } else {
        points.push(point);
        if (!last) {
          break;
        }
      }
    }
    points.push(...postponed);
  }
  function findPoint(line, sourcePoint, property) {
    const point = line.interpolate(sourcePoint, property);
    if (!point) {
      return {};
    }
    const pointValue = point[property];
    const segments = line.segments;
    const linePoints = line.points;
    let first = false;
    let last = false;
    for (let i3 = 0; i3 < segments.length; i3++) {
      const segment = segments[i3];
      const firstValue = linePoints[segment.start][property];
      const lastValue = linePoints[segment.end][property];
      if (_isBetween(pointValue, firstValue, lastValue)) {
        first = pointValue === firstValue;
        last = pointValue === lastValue;
        break;
      }
    }
    return {
      first,
      last,
      point
    };
  }
  var simpleArc = class {
    constructor(opts) {
      this.x = opts.x;
      this.y = opts.y;
      this.radius = opts.radius;
    }
    pathSegment(ctx, bounds, opts) {
      const { x: x2, y: y3, radius } = this;
      bounds = bounds || {
        start: 0,
        end: TAU
      };
      ctx.arc(x2, y3, radius, bounds.end, bounds.start, true);
      return !opts.bounds;
    }
    interpolate(point) {
      const { x: x2, y: y3, radius } = this;
      const angle = point.angle;
      return {
        x: x2 + Math.cos(angle) * radius,
        y: y3 + Math.sin(angle) * radius,
        angle
      };
    }
  };
  function _getTarget(source) {
    const { chart, fill: fill2, line } = source;
    if (isNumberFinite(fill2)) {
      return getLineByIndex(chart, fill2);
    }
    if (fill2 === "stack") {
      return _buildStackLine(source);
    }
    if (fill2 === "shape") {
      return true;
    }
    const boundary = computeBoundary(source);
    if (boundary instanceof simpleArc) {
      return boundary;
    }
    return _createBoundaryLine(boundary, line);
  }
  function getLineByIndex(chart, index2) {
    const meta = chart.getDatasetMeta(index2);
    const visible = meta && chart.isDatasetVisible(index2);
    return visible ? meta.dataset : null;
  }
  function computeBoundary(source) {
    const scale = source.scale || {};
    if (scale.getPointPositionForValue) {
      return computeCircularBoundary(source);
    }
    return computeLinearBoundary(source);
  }
  function computeLinearBoundary(source) {
    const { scale = {}, fill: fill2 } = source;
    const pixel = _getTargetPixel(fill2, scale);
    if (isNumberFinite(pixel)) {
      const horizontal = scale.isHorizontal();
      return {
        x: horizontal ? pixel : null,
        y: horizontal ? null : pixel
      };
    }
    return null;
  }
  function computeCircularBoundary(source) {
    const { scale, fill: fill2 } = source;
    const options2 = scale.options;
    const length = scale.getLabels().length;
    const start3 = options2.reverse ? scale.max : scale.min;
    const value = _getTargetValue(fill2, scale, start3);
    const target = [];
    if (options2.grid.circular) {
      const center = scale.getPointPositionForValue(0, start3);
      return new simpleArc({
        x: center.x,
        y: center.y,
        radius: scale.getDistanceFromCenterForValue(value)
      });
    }
    for (let i3 = 0; i3 < length; ++i3) {
      target.push(scale.getPointPositionForValue(i3, value));
    }
    return target;
  }
  function _drawfill(ctx, source, area) {
    const target = _getTarget(source);
    const { line, scale, axis } = source;
    const lineOpts = line.options;
    const fillOption = lineOpts.fill;
    const color2 = lineOpts.backgroundColor;
    const { above = color2, below = color2 } = fillOption || {};
    if (target && line.points.length) {
      clipArea(ctx, area);
      doFill(ctx, {
        line,
        target,
        above,
        below,
        area,
        scale,
        axis
      });
      unclipArea(ctx);
    }
  }
  function doFill(ctx, cfg) {
    const { line, target, above, below, area, scale } = cfg;
    const property = line._loop ? "angle" : cfg.axis;
    ctx.save();
    if (property === "x" && below !== above) {
      clipVertical(ctx, target, area.top);
      fill(ctx, {
        line,
        target,
        color: above,
        scale,
        property
      });
      ctx.restore();
      ctx.save();
      clipVertical(ctx, target, area.bottom);
    }
    fill(ctx, {
      line,
      target,
      color: below,
      scale,
      property
    });
    ctx.restore();
  }
  function clipVertical(ctx, target, clipY) {
    const { segments, points } = target;
    let first = true;
    let lineLoop = false;
    ctx.beginPath();
    for (const segment of segments) {
      const { start: start3, end: end2 } = segment;
      const firstPoint = points[start3];
      const lastPoint = points[_findSegmentEnd(start3, end2, points)];
      if (first) {
        ctx.moveTo(firstPoint.x, firstPoint.y);
        first = false;
      } else {
        ctx.lineTo(firstPoint.x, clipY);
        ctx.lineTo(firstPoint.x, firstPoint.y);
      }
      lineLoop = !!target.pathSegment(ctx, segment, {
        move: lineLoop
      });
      if (lineLoop) {
        ctx.closePath();
      } else {
        ctx.lineTo(lastPoint.x, clipY);
      }
    }
    ctx.lineTo(target.first().x, clipY);
    ctx.closePath();
    ctx.clip();
  }
  function fill(ctx, cfg) {
    const { line, target, property, color: color2, scale } = cfg;
    const segments = _segments(line, target, property);
    for (const { source: src, target: tgt, start: start3, end: end2 } of segments) {
      const { style: { backgroundColor = color2 } = {} } = src;
      const notShape = target !== true;
      ctx.save();
      ctx.fillStyle = backgroundColor;
      clipBounds(ctx, scale, notShape && _getBounds(property, start3, end2));
      ctx.beginPath();
      const lineLoop = !!line.pathSegment(ctx, src);
      let loop;
      if (notShape) {
        if (lineLoop) {
          ctx.closePath();
        } else {
          interpolatedLineTo(ctx, target, end2, property);
        }
        const targetLoop = !!target.pathSegment(ctx, tgt, {
          move: lineLoop,
          reverse: true
        });
        loop = lineLoop && targetLoop;
        if (!loop) {
          interpolatedLineTo(ctx, target, start3, property);
        }
      }
      ctx.closePath();
      ctx.fill(loop ? "evenodd" : "nonzero");
      ctx.restore();
    }
  }
  function clipBounds(ctx, scale, bounds) {
    const { top: top2, bottom: bottom2 } = scale.chart.chartArea;
    const { property, start: start3, end: end2 } = bounds || {};
    if (property === "x") {
      ctx.beginPath();
      ctx.rect(start3, top2, end2 - start3, bottom2 - top2);
      ctx.clip();
    }
  }
  function interpolatedLineTo(ctx, target, point, property) {
    const interpolatedPoint = target.interpolate(point, property);
    if (interpolatedPoint) {
      ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
    }
  }
  var index = {
    id: "filler",
    afterDatasetsUpdate(chart, _args, options2) {
      const count = (chart.data.datasets || []).length;
      const sources = [];
      let meta, i3, line, source;
      for (i3 = 0; i3 < count; ++i3) {
        meta = chart.getDatasetMeta(i3);
        line = meta.dataset;
        source = null;
        if (line && line.options && line instanceof LineElement) {
          source = {
            visible: chart.isDatasetVisible(i3),
            index: i3,
            fill: _decodeFill(line, i3, count),
            chart,
            axis: meta.controller.options.indexAxis,
            scale: meta.vScale,
            line
          };
        }
        meta.$filler = source;
        sources.push(source);
      }
      for (i3 = 0; i3 < count; ++i3) {
        source = sources[i3];
        if (!source || source.fill === false) {
          continue;
        }
        source.fill = _resolveTarget(sources, i3, options2.propagate);
      }
    },
    beforeDraw(chart, _args, options2) {
      const draw2 = options2.drawTime === "beforeDraw";
      const metasets = chart.getSortedVisibleDatasetMetas();
      const area = chart.chartArea;
      for (let i3 = metasets.length - 1; i3 >= 0; --i3) {
        const source = metasets[i3].$filler;
        if (!source) {
          continue;
        }
        source.line.updateControlPoints(area, source.axis);
        if (draw2 && source.fill) {
          _drawfill(chart.ctx, source, area);
        }
      }
    },
    beforeDatasetsDraw(chart, _args, options2) {
      if (options2.drawTime !== "beforeDatasetsDraw") {
        return;
      }
      const metasets = chart.getSortedVisibleDatasetMetas();
      for (let i3 = metasets.length - 1; i3 >= 0; --i3) {
        const source = metasets[i3].$filler;
        if (_shouldApplyFill(source)) {
          _drawfill(chart.ctx, source, chart.chartArea);
        }
      }
    },
    beforeDatasetDraw(chart, args, options2) {
      const source = args.meta.$filler;
      if (!_shouldApplyFill(source) || options2.drawTime !== "beforeDatasetDraw") {
        return;
      }
      _drawfill(chart.ctx, source, chart.chartArea);
    },
    defaults: {
      propagate: true,
      drawTime: "beforeDatasetDraw"
    }
  };
  var getBoxSize = (labelOpts, fontSize) => {
    let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
    if (labelOpts.usePointStyle) {
      boxHeight = Math.min(boxHeight, fontSize);
      boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
    }
    return {
      boxWidth,
      boxHeight,
      itemHeight: Math.max(fontSize, boxHeight)
    };
  };
  var itemsEqual = (a4, b2) => a4 !== null && b2 !== null && a4.datasetIndex === b2.datasetIndex && a4.index === b2.index;
  var Legend = class extends Element2 {
    constructor(config) {
      super();
      this._added = false;
      this.legendHitBoxes = [];
      this._hoveredItem = null;
      this.doughnutMode = false;
      this.chart = config.chart;
      this.options = config.options;
      this.ctx = config.ctx;
      this.legendItems = void 0;
      this.columnSizes = void 0;
      this.lineWidths = void 0;
      this.maxHeight = void 0;
      this.maxWidth = void 0;
      this.top = void 0;
      this.bottom = void 0;
      this.left = void 0;
      this.right = void 0;
      this.height = void 0;
      this.width = void 0;
      this._margins = void 0;
      this.position = void 0;
      this.weight = void 0;
      this.fullSize = void 0;
    }
    update(maxWidth, maxHeight, margins) {
      this.maxWidth = maxWidth;
      this.maxHeight = maxHeight;
      this._margins = margins;
      this.setDimensions();
      this.buildLabels();
      this.fit();
    }
    setDimensions() {
      if (this.isHorizontal()) {
        this.width = this.maxWidth;
        this.left = this._margins.left;
        this.right = this.width;
      } else {
        this.height = this.maxHeight;
        this.top = this._margins.top;
        this.bottom = this.height;
      }
    }
    buildLabels() {
      const labelOpts = this.options.labels || {};
      let legendItems = callback(labelOpts.generateLabels, [
        this.chart
      ], this) || [];
      if (labelOpts.filter) {
        legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
      }
      if (labelOpts.sort) {
        legendItems = legendItems.sort((a4, b2) => labelOpts.sort(a4, b2, this.chart.data));
      }
      if (this.options.reverse) {
        legendItems.reverse();
      }
      this.legendItems = legendItems;
    }
    fit() {
      const { options: options2, ctx } = this;
      if (!options2.display) {
        this.width = this.height = 0;
        return;
      }
      const labelOpts = options2.labels;
      const labelFont = toFont(labelOpts.font);
      const fontSize = labelFont.size;
      const titleHeight = this._computeTitleHeight();
      const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
      let width, height;
      ctx.font = labelFont.string;
      if (this.isHorizontal()) {
        width = this.maxWidth;
        height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
      } else {
        height = this.maxHeight;
        width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;
      }
      this.width = Math.min(width, options2.maxWidth || this.maxWidth);
      this.height = Math.min(height, options2.maxHeight || this.maxHeight);
    }
    _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
      const { ctx, maxWidth, options: { labels: { padding } } } = this;
      const hitboxes = this.legendHitBoxes = [];
      const lineWidths = this.lineWidths = [
        0
      ];
      const lineHeight = itemHeight + padding;
      let totalHeight = titleHeight;
      ctx.textAlign = "left";
      ctx.textBaseline = "middle";
      let row = -1;
      let top2 = -lineHeight;
      this.legendItems.forEach((legendItem, i3) => {
        const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
        if (i3 === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
          totalHeight += lineHeight;
          lineWidths[lineWidths.length - (i3 > 0 ? 0 : 1)] = 0;
          top2 += lineHeight;
          row++;
        }
        hitboxes[i3] = {
          left: 0,
          top: top2,
          row,
          width: itemWidth,
          height: itemHeight
        };
        lineWidths[lineWidths.length - 1] += itemWidth + padding;
      });
      return totalHeight;
    }
    _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {
      const { ctx, maxHeight, options: { labels: { padding } } } = this;
      const hitboxes = this.legendHitBoxes = [];
      const columnSizes = this.columnSizes = [];
      const heightLimit = maxHeight - titleHeight;
      let totalWidth = padding;
      let currentColWidth = 0;
      let currentColHeight = 0;
      let left2 = 0;
      let col = 0;
      this.legendItems.forEach((legendItem, i3) => {
        const { itemWidth, itemHeight } = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);
        if (i3 > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
          totalWidth += currentColWidth + padding;
          columnSizes.push({
            width: currentColWidth,
            height: currentColHeight
          });
          left2 += currentColWidth + padding;
          col++;
          currentColWidth = currentColHeight = 0;
        }
        hitboxes[i3] = {
          left: left2,
          top: currentColHeight,
          col,
          width: itemWidth,
          height: itemHeight
        };
        currentColWidth = Math.max(currentColWidth, itemWidth);
        currentColHeight += itemHeight + padding;
      });
      totalWidth += currentColWidth;
      columnSizes.push({
        width: currentColWidth,
        height: currentColHeight
      });
      return totalWidth;
    }
    adjustHitBoxes() {
      if (!this.options.display) {
        return;
      }
      const titleHeight = this._computeTitleHeight();
      const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;
      const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
      if (this.isHorizontal()) {
        let row = 0;
        let left2 = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
        for (const hitbox of hitboxes) {
          if (row !== hitbox.row) {
            row = hitbox.row;
            left2 = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
          }
          hitbox.top += this.top + titleHeight + padding;
          hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left2), hitbox.width);
          left2 += hitbox.width + padding;
        }
      } else {
        let col = 0;
        let top2 = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
        for (const hitbox1 of hitboxes) {
          if (hitbox1.col !== col) {
            col = hitbox1.col;
            top2 = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
          }
          hitbox1.top = top2;
          hitbox1.left += this.left + padding;
          hitbox1.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox1.left), hitbox1.width);
          top2 += hitbox1.height + padding;
        }
      }
    }
    isHorizontal() {
      return this.options.position === "top" || this.options.position === "bottom";
    }
    draw() {
      if (this.options.display) {
        const ctx = this.ctx;
        clipArea(ctx, this);
        this._draw();
        unclipArea(ctx);
      }
    }
    _draw() {
      const { options: opts, columnSizes, lineWidths, ctx } = this;
      const { align, labels: labelOpts } = opts;
      const defaultColor = defaults.color;
      const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
      const labelFont = toFont(labelOpts.font);
      const { padding } = labelOpts;
      const fontSize = labelFont.size;
      const halfFontSize = fontSize / 2;
      let cursor;
      this.drawTitle();
      ctx.textAlign = rtlHelper.textAlign("left");
      ctx.textBaseline = "middle";
      ctx.lineWidth = 0.5;
      ctx.font = labelFont.string;
      const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);
      const drawLegendBox = function(x2, y3, legendItem) {
        if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
          return;
        }
        ctx.save();
        const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
        ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
        ctx.lineCap = valueOrDefault(legendItem.lineCap, "butt");
        ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
        ctx.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
        ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
        if (labelOpts.usePointStyle) {
          const drawOptions = {
            radius: boxHeight * Math.SQRT2 / 2,
            pointStyle: legendItem.pointStyle,
            rotation: legendItem.rotation,
            borderWidth: lineWidth
          };
          const centerX = rtlHelper.xPlus(x2, boxWidth / 2);
          const centerY = y3 + halfFontSize;
          drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
        } else {
          const yBoxTop = y3 + Math.max((fontSize - boxHeight) / 2, 0);
          const xBoxLeft = rtlHelper.leftForLtr(x2, boxWidth);
          const borderRadius = toTRBLCorners(legendItem.borderRadius);
          ctx.beginPath();
          if (Object.values(borderRadius).some((v) => v !== 0)) {
            addRoundedRectPath(ctx, {
              x: xBoxLeft,
              y: yBoxTop,
              w: boxWidth,
              h: boxHeight,
              radius: borderRadius
            });
          } else {
            ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
          }
          ctx.fill();
          if (lineWidth !== 0) {
            ctx.stroke();
          }
        }
        ctx.restore();
      };
      const fillText = function(x2, y3, legendItem) {
        renderText(ctx, legendItem.text, x2, y3 + itemHeight / 2, labelFont, {
          strikethrough: legendItem.hidden,
          textAlign: rtlHelper.textAlign(legendItem.textAlign)
        });
      };
      const isHorizontal = this.isHorizontal();
      const titleHeight = this._computeTitleHeight();
      if (isHorizontal) {
        cursor = {
          x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
          y: this.top + padding + titleHeight,
          line: 0
        };
      } else {
        cursor = {
          x: this.left + padding,
          y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
          line: 0
        };
      }
      overrideTextDirection(this.ctx, opts.textDirection);
      const lineHeight = itemHeight + padding;
      this.legendItems.forEach((legendItem, i3) => {
        ctx.strokeStyle = legendItem.fontColor;
        ctx.fillStyle = legendItem.fontColor;
        const textWidth = ctx.measureText(legendItem.text).width;
        const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
        const width = boxWidth + halfFontSize + textWidth;
        let x2 = cursor.x;
        let y3 = cursor.y;
        rtlHelper.setWidth(this.width);
        if (isHorizontal) {
          if (i3 > 0 && x2 + width + padding > this.right) {
            y3 = cursor.y += lineHeight;
            cursor.line++;
            x2 = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
          }
        } else if (i3 > 0 && y3 + lineHeight > this.bottom) {
          x2 = cursor.x = x2 + columnSizes[cursor.line].width + padding;
          cursor.line++;
          y3 = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
        }
        const realX = rtlHelper.x(x2);
        drawLegendBox(realX, y3, legendItem);
        x2 = _textX(textAlign, x2 + boxWidth + halfFontSize, isHorizontal ? x2 + width : this.right, opts.rtl);
        fillText(rtlHelper.x(x2), y3, legendItem);
        if (isHorizontal) {
          cursor.x += width + padding;
        } else if (typeof legendItem.text !== "string") {
          const fontLineHeight = labelFont.lineHeight;
          cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight);
        } else {
          cursor.y += lineHeight;
        }
      });
      restoreTextDirection(this.ctx, opts.textDirection);
    }
    drawTitle() {
      const opts = this.options;
      const titleOpts = opts.title;
      const titleFont = toFont(titleOpts.font);
      const titlePadding = toPadding(titleOpts.padding);
      if (!titleOpts.display) {
        return;
      }
      const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
      const ctx = this.ctx;
      const position = titleOpts.position;
      const halfFontSize = titleFont.size / 2;
      const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
      let y3;
      let left2 = this.left;
      let maxWidth = this.width;
      if (this.isHorizontal()) {
        maxWidth = Math.max(...this.lineWidths);
        y3 = this.top + topPaddingPlusHalfFontSize;
        left2 = _alignStartEnd(opts.align, left2, this.right - maxWidth);
      } else {
        const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
        y3 = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
      }
      const x2 = _alignStartEnd(position, left2, left2 + maxWidth);
      ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
      ctx.textBaseline = "middle";
      ctx.strokeStyle = titleOpts.color;
      ctx.fillStyle = titleOpts.color;
      ctx.font = titleFont.string;
      renderText(ctx, titleOpts.text, x2, y3, titleFont);
    }
    _computeTitleHeight() {
      const titleOpts = this.options.title;
      const titleFont = toFont(titleOpts.font);
      const titlePadding = toPadding(titleOpts.padding);
      return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
    }
    _getLegendItemAt(x2, y3) {
      let i3, hitBox, lh;
      if (_isBetween(x2, this.left, this.right) && _isBetween(y3, this.top, this.bottom)) {
        lh = this.legendHitBoxes;
        for (i3 = 0; i3 < lh.length; ++i3) {
          hitBox = lh[i3];
          if (_isBetween(x2, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y3, hitBox.top, hitBox.top + hitBox.height)) {
            return this.legendItems[i3];
          }
        }
      }
      return null;
    }
    handleEvent(e3) {
      const opts = this.options;
      if (!isListened(e3.type, opts)) {
        return;
      }
      const hoveredItem = this._getLegendItemAt(e3.x, e3.y);
      if (e3.type === "mousemove" || e3.type === "mouseout") {
        const previous = this._hoveredItem;
        const sameItem = itemsEqual(previous, hoveredItem);
        if (previous && !sameItem) {
          callback(opts.onLeave, [
            e3,
            previous,
            this
          ], this);
        }
        this._hoveredItem = hoveredItem;
        if (hoveredItem && !sameItem) {
          callback(opts.onHover, [
            e3,
            hoveredItem,
            this
          ], this);
        }
      } else if (hoveredItem) {
        callback(opts.onClick, [
          e3,
          hoveredItem,
          this
        ], this);
      }
    }
  };
  function calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {
    const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);
    const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);
    return {
      itemWidth,
      itemHeight
    };
  }
  function calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {
    let legendItemText = legendItem.text;
    if (legendItemText && typeof legendItemText !== "string") {
      legendItemText = legendItemText.reduce((a4, b2) => a4.length > b2.length ? a4 : b2);
    }
    return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;
  }
  function calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {
    let itemHeight = _itemHeight;
    if (typeof legendItem.text !== "string") {
      itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);
    }
    return itemHeight;
  }
  function calculateLegendItemHeight(legendItem, fontLineHeight) {
    const labelHeight = legendItem.text ? legendItem.text.length + 0.5 : 0;
    return fontLineHeight * labelHeight;
  }
  function isListened(type, opts) {
    if ((type === "mousemove" || type === "mouseout") && (opts.onHover || opts.onLeave)) {
      return true;
    }
    if (opts.onClick && (type === "click" || type === "mouseup")) {
      return true;
    }
    return false;
  }
  var plugin_legend = {
    id: "legend",
    _element: Legend,
    start(chart, _args, options2) {
      const legend = chart.legend = new Legend({
        ctx: chart.ctx,
        options: options2,
        chart
      });
      layouts.configure(chart, legend, options2);
      layouts.addBox(chart, legend);
    },
    stop(chart) {
      layouts.removeBox(chart, chart.legend);
      delete chart.legend;
    },
    beforeUpdate(chart, _args, options2) {
      const legend = chart.legend;
      layouts.configure(chart, legend, options2);
      legend.options = options2;
    },
    afterUpdate(chart) {
      const legend = chart.legend;
      legend.buildLabels();
      legend.adjustHitBoxes();
    },
    afterEvent(chart, args) {
      if (!args.replay) {
        chart.legend.handleEvent(args.event);
      }
    },
    defaults: {
      display: true,
      position: "top",
      align: "center",
      fullSize: true,
      reverse: false,
      weight: 1e3,
      onClick(e3, legendItem, legend) {
        const index2 = legendItem.datasetIndex;
        const ci = legend.chart;
        if (ci.isDatasetVisible(index2)) {
          ci.hide(index2);
          legendItem.hidden = true;
        } else {
          ci.show(index2);
          legendItem.hidden = false;
        }
      },
      onHover: null,
      onLeave: null,
      labels: {
        color: (ctx) => ctx.chart.options.color,
        boxWidth: 40,
        padding: 10,
        generateLabels(chart) {
          const datasets = chart.data.datasets;
          const { labels: { usePointStyle, pointStyle, textAlign, color: color2, useBorderRadius, borderRadius } } = chart.legend.options;
          return chart._getSortedDatasetMetas().map((meta) => {
            const style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
            const borderWidth = toPadding(style.borderWidth);
            return {
              text: datasets[meta.index].label,
              fillStyle: style.backgroundColor,
              fontColor: color2,
              hidden: !meta.visible,
              lineCap: style.borderCapStyle,
              lineDash: style.borderDash,
              lineDashOffset: style.borderDashOffset,
              lineJoin: style.borderJoinStyle,
              lineWidth: (borderWidth.width + borderWidth.height) / 4,
              strokeStyle: style.borderColor,
              pointStyle: pointStyle || style.pointStyle,
              rotation: style.rotation,
              textAlign: textAlign || style.textAlign,
              borderRadius: useBorderRadius && (borderRadius || style.borderRadius),
              datasetIndex: meta.index
            };
          }, this);
        }
      },
      title: {
        color: (ctx) => ctx.chart.options.color,
        display: false,
        position: "center",
        text: ""
      }
    },
    descriptors: {
      _scriptable: (name2) => !name2.startsWith("on"),
      labels: {
        _scriptable: (name2) => ![
          "generateLabels",
          "filter",
          "sort"
        ].includes(name2)
      }
    }
  };
  var Title = class extends Element2 {
    constructor(config) {
      super();
      this.chart = config.chart;
      this.options = config.options;
      this.ctx = config.ctx;
      this._padding = void 0;
      this.top = void 0;
      this.bottom = void 0;
      this.left = void 0;
      this.right = void 0;
      this.width = void 0;
      this.height = void 0;
      this.position = void 0;
      this.weight = void 0;
      this.fullSize = void 0;
    }
    update(maxWidth, maxHeight) {
      const opts = this.options;
      this.left = 0;
      this.top = 0;
      if (!opts.display) {
        this.width = this.height = this.right = this.bottom = 0;
        return;
      }
      this.width = this.right = maxWidth;
      this.height = this.bottom = maxHeight;
      const lineCount = isArray2(opts.text) ? opts.text.length : 1;
      this._padding = toPadding(opts.padding);
      const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
      if (this.isHorizontal()) {
        this.height = textSize;
      } else {
        this.width = textSize;
      }
    }
    isHorizontal() {
      const pos = this.options.position;
      return pos === "top" || pos === "bottom";
    }
    _drawArgs(offset2) {
      const { top: top2, left: left2, bottom: bottom2, right: right2, options: options2 } = this;
      const align = options2.align;
      let rotation = 0;
      let maxWidth, titleX, titleY;
      if (this.isHorizontal()) {
        titleX = _alignStartEnd(align, left2, right2);
        titleY = top2 + offset2;
        maxWidth = right2 - left2;
      } else {
        if (options2.position === "left") {
          titleX = left2 + offset2;
          titleY = _alignStartEnd(align, bottom2, top2);
          rotation = PI * -0.5;
        } else {
          titleX = right2 - offset2;
          titleY = _alignStartEnd(align, top2, bottom2);
          rotation = PI * 0.5;
        }
        maxWidth = bottom2 - top2;
      }
      return {
        titleX,
        titleY,
        maxWidth,
        rotation
      };
    }
    draw() {
      const ctx = this.ctx;
      const opts = this.options;
      if (!opts.display) {
        return;
      }
      const fontOpts = toFont(opts.font);
      const lineHeight = fontOpts.lineHeight;
      const offset2 = lineHeight / 2 + this._padding.top;
      const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset2);
      renderText(ctx, opts.text, 0, 0, fontOpts, {
        color: opts.color,
        maxWidth,
        rotation,
        textAlign: _toLeftRightCenter(opts.align),
        textBaseline: "middle",
        translation: [
          titleX,
          titleY
        ]
      });
    }
  };
  function createTitle(chart, titleOpts) {
    const title = new Title({
      ctx: chart.ctx,
      options: titleOpts,
      chart
    });
    layouts.configure(chart, title, titleOpts);
    layouts.addBox(chart, title);
    chart.titleBlock = title;
  }
  var plugin_title = {
    id: "title",
    _element: Title,
    start(chart, _args, options2) {
      createTitle(chart, options2);
    },
    stop(chart) {
      const titleBlock = chart.titleBlock;
      layouts.removeBox(chart, titleBlock);
      delete chart.titleBlock;
    },
    beforeUpdate(chart, _args, options2) {
      const title = chart.titleBlock;
      layouts.configure(chart, title, options2);
      title.options = options2;
    },
    defaults: {
      align: "center",
      display: false,
      font: {
        weight: "bold"
      },
      fullSize: true,
      padding: 10,
      position: "top",
      text: "",
      weight: 2e3
    },
    defaultRoutes: {
      color: "color"
    },
    descriptors: {
      _scriptable: true,
      _indexable: false
    }
  };
  var map2 = /* @__PURE__ */ new WeakMap();
  var plugin_subtitle = {
    id: "subtitle",
    start(chart, _args, options2) {
      const title = new Title({
        ctx: chart.ctx,
        options: options2,
        chart
      });
      layouts.configure(chart, title, options2);
      layouts.addBox(chart, title);
      map2.set(chart, title);
    },
    stop(chart) {
      layouts.removeBox(chart, map2.get(chart));
      map2.delete(chart);
    },
    beforeUpdate(chart, _args, options2) {
      const title = map2.get(chart);
      layouts.configure(chart, title, options2);
      title.options = options2;
    },
    defaults: {
      align: "center",
      display: false,
      font: {
        weight: "normal"
      },
      fullSize: true,
      padding: 0,
      position: "top",
      text: "",
      weight: 1500
    },
    defaultRoutes: {
      color: "color"
    },
    descriptors: {
      _scriptable: true,
      _indexable: false
    }
  };
  var positioners = {
    average(items) {
      if (!items.length) {
        return false;
      }
      let i3, len;
      let x2 = 0;
      let y3 = 0;
      let count = 0;
      for (i3 = 0, len = items.length; i3 < len; ++i3) {
        const el = items[i3].element;
        if (el && el.hasValue()) {
          const pos = el.tooltipPosition();
          x2 += pos.x;
          y3 += pos.y;
          ++count;
        }
      }
      return {
        x: x2 / count,
        y: y3 / count
      };
    },
    nearest(items, eventPosition) {
      if (!items.length) {
        return false;
      }
      let x2 = eventPosition.x;
      let y3 = eventPosition.y;
      let minDistance = Number.POSITIVE_INFINITY;
      let i3, len, nearestElement;
      for (i3 = 0, len = items.length; i3 < len; ++i3) {
        const el = items[i3].element;
        if (el && el.hasValue()) {
          const center = el.getCenterPoint();
          const d3 = distanceBetweenPoints(eventPosition, center);
          if (d3 < minDistance) {
            minDistance = d3;
            nearestElement = el;
          }
        }
      }
      if (nearestElement) {
        const tp = nearestElement.tooltipPosition();
        x2 = tp.x;
        y3 = tp.y;
      }
      return {
        x: x2,
        y: y3
      };
    }
  };
  function pushOrConcat(base, toPush) {
    if (toPush) {
      if (isArray2(toPush)) {
        Array.prototype.push.apply(base, toPush);
      } else {
        base.push(toPush);
      }
    }
    return base;
  }
  function splitNewlines(str) {
    if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
      return str.split("\n");
    }
    return str;
  }
  function createTooltipItem(chart, item) {
    const { element, datasetIndex, index: index2 } = item;
    const controller = chart.getDatasetMeta(datasetIndex).controller;
    const { label, value } = controller.getLabelAndValue(index2);
    return {
      chart,
      label,
      parsed: controller.getParsed(index2),
      raw: chart.data.datasets[datasetIndex].data[index2],
      formattedValue: value,
      dataset: controller.getDataset(),
      dataIndex: index2,
      datasetIndex,
      element
    };
  }
  function getTooltipSize(tooltip, options2) {
    const ctx = tooltip.chart.ctx;
    const { body, footer, title } = tooltip;
    const { boxWidth, boxHeight } = options2;
    const bodyFont = toFont(options2.bodyFont);
    const titleFont = toFont(options2.titleFont);
    const footerFont = toFont(options2.footerFont);
    const titleLineCount = title.length;
    const footerLineCount = footer.length;
    const bodyLineItemCount = body.length;
    const padding = toPadding(options2.padding);
    let height = padding.height;
    let width = 0;
    let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
    combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
    if (titleLineCount) {
      height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options2.titleSpacing + options2.titleMarginBottom;
    }
    if (combinedBodyLength) {
      const bodyLineHeight = options2.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
      height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options2.bodySpacing;
    }
    if (footerLineCount) {
      height += options2.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options2.footerSpacing;
    }
    let widthPadding = 0;
    const maxLineWidth = function(line) {
      width = Math.max(width, ctx.measureText(line).width + widthPadding);
    };
    ctx.save();
    ctx.font = titleFont.string;
    each(tooltip.title, maxLineWidth);
    ctx.font = bodyFont.string;
    each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
    widthPadding = options2.displayColors ? boxWidth + 2 + options2.boxPadding : 0;
    each(body, (bodyItem) => {
      each(bodyItem.before, maxLineWidth);
      each(bodyItem.lines, maxLineWidth);
      each(bodyItem.after, maxLineWidth);
    });
    widthPadding = 0;
    ctx.font = footerFont.string;
    each(tooltip.footer, maxLineWidth);
    ctx.restore();
    width += padding.width;
    return {
      width,
      height
    };
  }
  function determineYAlign(chart, size) {
    const { y: y3, height } = size;
    if (y3 < height / 2) {
      return "top";
    } else if (y3 > chart.height - height / 2) {
      return "bottom";
    }
    return "center";
  }
  function doesNotFitWithAlign(xAlign, chart, options2, size) {
    const { x: x2, width } = size;
    const caret = options2.caretSize + options2.caretPadding;
    if (xAlign === "left" && x2 + width + caret > chart.width) {
      return true;
    }
    if (xAlign === "right" && x2 - width - caret < 0) {
      return true;
    }
  }
  function determineXAlign(chart, options2, size, yAlign) {
    const { x: x2, width } = size;
    const { width: chartWidth, chartArea: { left: left2, right: right2 } } = chart;
    let xAlign = "center";
    if (yAlign === "center") {
      xAlign = x2 <= (left2 + right2) / 2 ? "left" : "right";
    } else if (x2 <= width / 2) {
      xAlign = "left";
    } else if (x2 >= chartWidth - width / 2) {
      xAlign = "right";
    }
    if (doesNotFitWithAlign(xAlign, chart, options2, size)) {
      xAlign = "center";
    }
    return xAlign;
  }
  function determineAlignment(chart, options2, size) {
    const yAlign = size.yAlign || options2.yAlign || determineYAlign(chart, size);
    return {
      xAlign: size.xAlign || options2.xAlign || determineXAlign(chart, options2, size, yAlign),
      yAlign
    };
  }
  function alignX(size, xAlign) {
    let { x: x2, width } = size;
    if (xAlign === "right") {
      x2 -= width;
    } else if (xAlign === "center") {
      x2 -= width / 2;
    }
    return x2;
  }
  function alignY(size, yAlign, paddingAndSize) {
    let { y: y3, height } = size;
    if (yAlign === "top") {
      y3 += paddingAndSize;
    } else if (yAlign === "bottom") {
      y3 -= height + paddingAndSize;
    } else {
      y3 -= height / 2;
    }
    return y3;
  }
  function getBackgroundPoint(options2, size, alignment, chart) {
    const { caretSize, caretPadding, cornerRadius } = options2;
    const { xAlign, yAlign } = alignment;
    const paddingAndSize = caretSize + caretPadding;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
    let x2 = alignX(size, xAlign);
    const y3 = alignY(size, yAlign, paddingAndSize);
    if (yAlign === "center") {
      if (xAlign === "left") {
        x2 += paddingAndSize;
      } else if (xAlign === "right") {
        x2 -= paddingAndSize;
      }
    } else if (xAlign === "left") {
      x2 -= Math.max(topLeft, bottomLeft) + caretSize;
    } else if (xAlign === "right") {
      x2 += Math.max(topRight, bottomRight) + caretSize;
    }
    return {
      x: _limitValue(x2, 0, chart.width - size.width),
      y: _limitValue(y3, 0, chart.height - size.height)
    };
  }
  function getAlignedX(tooltip, align, options2) {
    const padding = toPadding(options2.padding);
    return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
  }
  function getBeforeAfterBodyLines(callback2) {
    return pushOrConcat([], splitNewlines(callback2));
  }
  function createTooltipContext(parent, tooltip, tooltipItems) {
    return createContext(parent, {
      tooltip,
      tooltipItems,
      type: "tooltip"
    });
  }
  function overrideCallbacks(callbacks2, context) {
    const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
    return override ? callbacks2.override(override) : callbacks2;
  }
  var defaultCallbacks = {
    beforeTitle: noop,
    title(tooltipItems) {
      if (tooltipItems.length > 0) {
        const item = tooltipItems[0];
        const labels = item.chart.data.labels;
        const labelCount = labels ? labels.length : 0;
        if (this && this.options && this.options.mode === "dataset") {
          return item.dataset.label || "";
        } else if (item.label) {
          return item.label;
        } else if (labelCount > 0 && item.dataIndex < labelCount) {
          return labels[item.dataIndex];
        }
      }
      return "";
    },
    afterTitle: noop,
    beforeBody: noop,
    beforeLabel: noop,
    label(tooltipItem) {
      if (this && this.options && this.options.mode === "dataset") {
        return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
      }
      let label = tooltipItem.dataset.label || "";
      if (label) {
        label += ": ";
      }
      const value = tooltipItem.formattedValue;
      if (!isNullOrUndef(value)) {
        label += value;
      }
      return label;
    },
    labelColor(tooltipItem) {
      const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
      const options2 = meta.controller.getStyle(tooltipItem.dataIndex);
      return {
        borderColor: options2.borderColor,
        backgroundColor: options2.backgroundColor,
        borderWidth: options2.borderWidth,
        borderDash: options2.borderDash,
        borderDashOffset: options2.borderDashOffset,
        borderRadius: 0
      };
    },
    labelTextColor() {
      return this.options.bodyColor;
    },
    labelPointStyle(tooltipItem) {
      const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
      const options2 = meta.controller.getStyle(tooltipItem.dataIndex);
      return {
        pointStyle: options2.pointStyle,
        rotation: options2.rotation
      };
    },
    afterLabel: noop,
    afterBody: noop,
    beforeFooter: noop,
    footer: noop,
    afterFooter: noop
  };
  function invokeCallbackWithFallback(callbacks2, name2, ctx, arg) {
    const result = callbacks2[name2].call(ctx, arg);
    if (typeof result === "undefined") {
      return defaultCallbacks[name2].call(ctx, arg);
    }
    return result;
  }
  var Tooltip = class extends Element2 {
    constructor(config) {
      super();
      this.opacity = 0;
      this._active = [];
      this._eventPosition = void 0;
      this._size = void 0;
      this._cachedAnimations = void 0;
      this._tooltipItems = [];
      this.$animations = void 0;
      this.$context = void 0;
      this.chart = config.chart;
      this.options = config.options;
      this.dataPoints = void 0;
      this.title = void 0;
      this.beforeBody = void 0;
      this.body = void 0;
      this.afterBody = void 0;
      this.footer = void 0;
      this.xAlign = void 0;
      this.yAlign = void 0;
      this.x = void 0;
      this.y = void 0;
      this.height = void 0;
      this.width = void 0;
      this.caretX = void 0;
      this.caretY = void 0;
      this.labelColors = void 0;
      this.labelPointStyles = void 0;
      this.labelTextColors = void 0;
    }
    initialize(options2) {
      this.options = options2;
      this._cachedAnimations = void 0;
      this.$context = void 0;
    }
    _resolveAnimations() {
      const cached = this._cachedAnimations;
      if (cached) {
        return cached;
      }
      const chart = this.chart;
      const options2 = this.options.setContext(this.getContext());
      const opts = options2.enabled && chart.options.animation && options2.animations;
      const animations = new Animations(this.chart, opts);
      if (opts._cacheable) {
        this._cachedAnimations = Object.freeze(animations);
      }
      return animations;
    }
    getContext() {
      return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
    }
    getTitle(context, options2) {
      const { callbacks: callbacks2 } = options2;
      const beforeTitle = invokeCallbackWithFallback(callbacks2, "beforeTitle", this, context);
      const title = invokeCallbackWithFallback(callbacks2, "title", this, context);
      const afterTitle = invokeCallbackWithFallback(callbacks2, "afterTitle", this, context);
      let lines = [];
      lines = pushOrConcat(lines, splitNewlines(beforeTitle));
      lines = pushOrConcat(lines, splitNewlines(title));
      lines = pushOrConcat(lines, splitNewlines(afterTitle));
      return lines;
    }
    getBeforeBody(tooltipItems, options2) {
      return getBeforeAfterBodyLines(invokeCallbackWithFallback(options2.callbacks, "beforeBody", this, tooltipItems));
    }
    getBody(tooltipItems, options2) {
      const { callbacks: callbacks2 } = options2;
      const bodyItems = [];
      each(tooltipItems, (context) => {
        const bodyItem = {
          before: [],
          lines: [],
          after: []
        };
        const scoped = overrideCallbacks(callbacks2, context);
        pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, "beforeLabel", this, context)));
        pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, "label", this, context));
        pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, "afterLabel", this, context)));
        bodyItems.push(bodyItem);
      });
      return bodyItems;
    }
    getAfterBody(tooltipItems, options2) {
      return getBeforeAfterBodyLines(invokeCallbackWithFallback(options2.callbacks, "afterBody", this, tooltipItems));
    }
    getFooter(tooltipItems, options2) {
      const { callbacks: callbacks2 } = options2;
      const beforeFooter = invokeCallbackWithFallback(callbacks2, "beforeFooter", this, tooltipItems);
      const footer = invokeCallbackWithFallback(callbacks2, "footer", this, tooltipItems);
      const afterFooter = invokeCallbackWithFallback(callbacks2, "afterFooter", this, tooltipItems);
      let lines = [];
      lines = pushOrConcat(lines, splitNewlines(beforeFooter));
      lines = pushOrConcat(lines, splitNewlines(footer));
      lines = pushOrConcat(lines, splitNewlines(afterFooter));
      return lines;
    }
    _createItems(options2) {
      const active = this._active;
      const data = this.chart.data;
      const labelColors = [];
      const labelPointStyles = [];
      const labelTextColors = [];
      let tooltipItems = [];
      let i3, len;
      for (i3 = 0, len = active.length; i3 < len; ++i3) {
        tooltipItems.push(createTooltipItem(this.chart, active[i3]));
      }
      if (options2.filter) {
        tooltipItems = tooltipItems.filter((element, index2, array) => options2.filter(element, index2, array, data));
      }
      if (options2.itemSort) {
        tooltipItems = tooltipItems.sort((a4, b2) => options2.itemSort(a4, b2, data));
      }
      each(tooltipItems, (context) => {
        const scoped = overrideCallbacks(options2.callbacks, context);
        labelColors.push(invokeCallbackWithFallback(scoped, "labelColor", this, context));
        labelPointStyles.push(invokeCallbackWithFallback(scoped, "labelPointStyle", this, context));
        labelTextColors.push(invokeCallbackWithFallback(scoped, "labelTextColor", this, context));
      });
      this.labelColors = labelColors;
      this.labelPointStyles = labelPointStyles;
      this.labelTextColors = labelTextColors;
      this.dataPoints = tooltipItems;
      return tooltipItems;
    }
    update(changed, replay) {
      const options2 = this.options.setContext(this.getContext());
      const active = this._active;
      let properties;
      let tooltipItems = [];
      if (!active.length) {
        if (this.opacity !== 0) {
          properties = {
            opacity: 0
          };
        }
      } else {
        const position = positioners[options2.position].call(this, active, this._eventPosition);
        tooltipItems = this._createItems(options2);
        this.title = this.getTitle(tooltipItems, options2);
        this.beforeBody = this.getBeforeBody(tooltipItems, options2);
        this.body = this.getBody(tooltipItems, options2);
        this.afterBody = this.getAfterBody(tooltipItems, options2);
        this.footer = this.getFooter(tooltipItems, options2);
        const size = this._size = getTooltipSize(this, options2);
        const positionAndSize = Object.assign({}, position, size);
        const alignment = determineAlignment(this.chart, options2, positionAndSize);
        const backgroundPoint = getBackgroundPoint(options2, positionAndSize, alignment, this.chart);
        this.xAlign = alignment.xAlign;
        this.yAlign = alignment.yAlign;
        properties = {
          opacity: 1,
          x: backgroundPoint.x,
          y: backgroundPoint.y,
          width: size.width,
          height: size.height,
          caretX: position.x,
          caretY: position.y
        };
      }
      this._tooltipItems = tooltipItems;
      this.$context = void 0;
      if (properties) {
        this._resolveAnimations().update(this, properties);
      }
      if (changed && options2.external) {
        options2.external.call(this, {
          chart: this.chart,
          tooltip: this,
          replay
        });
      }
    }
    drawCaret(tooltipPoint, ctx, size, options2) {
      const caretPosition = this.getCaretPosition(tooltipPoint, size, options2);
      ctx.lineTo(caretPosition.x1, caretPosition.y1);
      ctx.lineTo(caretPosition.x2, caretPosition.y2);
      ctx.lineTo(caretPosition.x3, caretPosition.y3);
    }
    getCaretPosition(tooltipPoint, size, options2) {
      const { xAlign, yAlign } = this;
      const { caretSize, cornerRadius } = options2;
      const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
      const { x: ptX, y: ptY } = tooltipPoint;
      const { width, height } = size;
      let x1, x2, x3, y1, y22, y3;
      if (yAlign === "center") {
        y22 = ptY + height / 2;
        if (xAlign === "left") {
          x1 = ptX;
          x2 = x1 - caretSize;
          y1 = y22 + caretSize;
          y3 = y22 - caretSize;
        } else {
          x1 = ptX + width;
          x2 = x1 + caretSize;
          y1 = y22 - caretSize;
          y3 = y22 + caretSize;
        }
        x3 = x1;
      } else {
        if (xAlign === "left") {
          x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
        } else if (xAlign === "right") {
          x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
        } else {
          x2 = this.caretX;
        }
        if (yAlign === "top") {
          y1 = ptY;
          y22 = y1 - caretSize;
          x1 = x2 - caretSize;
          x3 = x2 + caretSize;
        } else {
          y1 = ptY + height;
          y22 = y1 + caretSize;
          x1 = x2 + caretSize;
          x3 = x2 - caretSize;
        }
        y3 = y1;
      }
      return {
        x1,
        x2,
        x3,
        y1,
        y2: y22,
        y3
      };
    }
    drawTitle(pt, ctx, options2) {
      const title = this.title;
      const length = title.length;
      let titleFont, titleSpacing, i3;
      if (length) {
        const rtlHelper = getRtlAdapter(options2.rtl, this.x, this.width);
        pt.x = getAlignedX(this, options2.titleAlign, options2);
        ctx.textAlign = rtlHelper.textAlign(options2.titleAlign);
        ctx.textBaseline = "middle";
        titleFont = toFont(options2.titleFont);
        titleSpacing = options2.titleSpacing;
        ctx.fillStyle = options2.titleColor;
        ctx.font = titleFont.string;
        for (i3 = 0; i3 < length; ++i3) {
          ctx.fillText(title[i3], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
          pt.y += titleFont.lineHeight + titleSpacing;
          if (i3 + 1 === length) {
            pt.y += options2.titleMarginBottom - titleSpacing;
          }
        }
      }
    }
    _drawColorBox(ctx, pt, i3, rtlHelper, options2) {
      const labelColors = this.labelColors[i3];
      const labelPointStyle = this.labelPointStyles[i3];
      const { boxHeight, boxWidth, boxPadding } = options2;
      const bodyFont = toFont(options2.bodyFont);
      const colorX = getAlignedX(this, "left", options2);
      const rtlColorX = rtlHelper.x(colorX);
      const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
      const colorY = pt.y + yOffSet;
      if (options2.usePointStyle) {
        const drawOptions = {
          radius: Math.min(boxWidth, boxHeight) / 2,
          pointStyle: labelPointStyle.pointStyle,
          rotation: labelPointStyle.rotation,
          borderWidth: 1
        };
        const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
        const centerY = colorY + boxHeight / 2;
        ctx.strokeStyle = options2.multiKeyBackground;
        ctx.fillStyle = options2.multiKeyBackground;
        drawPoint(ctx, drawOptions, centerX, centerY);
        ctx.strokeStyle = labelColors.borderColor;
        ctx.fillStyle = labelColors.backgroundColor;
        drawPoint(ctx, drawOptions, centerX, centerY);
      } else {
        ctx.lineWidth = isObject(labelColors.borderWidth) ? Math.max(...Object.values(labelColors.borderWidth)) : labelColors.borderWidth || 1;
        ctx.strokeStyle = labelColors.borderColor;
        ctx.setLineDash(labelColors.borderDash || []);
        ctx.lineDashOffset = labelColors.borderDashOffset || 0;
        const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth - boxPadding);
        const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - boxPadding - 2);
        const borderRadius = toTRBLCorners(labelColors.borderRadius);
        if (Object.values(borderRadius).some((v) => v !== 0)) {
          ctx.beginPath();
          ctx.fillStyle = options2.multiKeyBackground;
          addRoundedRectPath(ctx, {
            x: outerX,
            y: colorY,
            w: boxWidth,
            h: boxHeight,
            radius: borderRadius
          });
          ctx.fill();
          ctx.stroke();
          ctx.fillStyle = labelColors.backgroundColor;
          ctx.beginPath();
          addRoundedRectPath(ctx, {
            x: innerX,
            y: colorY + 1,
            w: boxWidth - 2,
            h: boxHeight - 2,
            radius: borderRadius
          });
          ctx.fill();
        } else {
          ctx.fillStyle = options2.multiKeyBackground;
          ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
          ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
          ctx.fillStyle = labelColors.backgroundColor;
          ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
        }
      }
      ctx.fillStyle = this.labelTextColors[i3];
    }
    drawBody(pt, ctx, options2) {
      const { body } = this;
      const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options2;
      const bodyFont = toFont(options2.bodyFont);
      let bodyLineHeight = bodyFont.lineHeight;
      let xLinePadding = 0;
      const rtlHelper = getRtlAdapter(options2.rtl, this.x, this.width);
      const fillLineOfText = function(line) {
        ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
        pt.y += bodyLineHeight + bodySpacing;
      };
      const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
      let bodyItem, textColor, lines, i3, j, ilen, jlen;
      ctx.textAlign = bodyAlign;
      ctx.textBaseline = "middle";
      ctx.font = bodyFont.string;
      pt.x = getAlignedX(this, bodyAlignForCalculation, options2);
      ctx.fillStyle = options2.bodyColor;
      each(this.beforeBody, fillLineOfText);
      xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
      for (i3 = 0, ilen = body.length; i3 < ilen; ++i3) {
        bodyItem = body[i3];
        textColor = this.labelTextColors[i3];
        ctx.fillStyle = textColor;
        each(bodyItem.before, fillLineOfText);
        lines = bodyItem.lines;
        if (displayColors && lines.length) {
          this._drawColorBox(ctx, pt, i3, rtlHelper, options2);
          bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
        }
        for (j = 0, jlen = lines.length; j < jlen; ++j) {
          fillLineOfText(lines[j]);
          bodyLineHeight = bodyFont.lineHeight;
        }
        each(bodyItem.after, fillLineOfText);
      }
      xLinePadding = 0;
      bodyLineHeight = bodyFont.lineHeight;
      each(this.afterBody, fillLineOfText);
      pt.y -= bodySpacing;
    }
    drawFooter(pt, ctx, options2) {
      const footer = this.footer;
      const length = footer.length;
      let footerFont, i3;
      if (length) {
        const rtlHelper = getRtlAdapter(options2.rtl, this.x, this.width);
        pt.x = getAlignedX(this, options2.footerAlign, options2);
        pt.y += options2.footerMarginTop;
        ctx.textAlign = rtlHelper.textAlign(options2.footerAlign);
        ctx.textBaseline = "middle";
        footerFont = toFont(options2.footerFont);
        ctx.fillStyle = options2.footerColor;
        ctx.font = footerFont.string;
        for (i3 = 0; i3 < length; ++i3) {
          ctx.fillText(footer[i3], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
          pt.y += footerFont.lineHeight + options2.footerSpacing;
        }
      }
    }
    drawBackground(pt, ctx, tooltipSize, options2) {
      const { xAlign, yAlign } = this;
      const { x: x2, y: y3 } = pt;
      const { width, height } = tooltipSize;
      const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(options2.cornerRadius);
      ctx.fillStyle = options2.backgroundColor;
      ctx.strokeStyle = options2.borderColor;
      ctx.lineWidth = options2.borderWidth;
      ctx.beginPath();
      ctx.moveTo(x2 + topLeft, y3);
      if (yAlign === "top") {
        this.drawCaret(pt, ctx, tooltipSize, options2);
      }
      ctx.lineTo(x2 + width - topRight, y3);
      ctx.quadraticCurveTo(x2 + width, y3, x2 + width, y3 + topRight);
      if (yAlign === "center" && xAlign === "right") {
        this.drawCaret(pt, ctx, tooltipSize, options2);
      }
      ctx.lineTo(x2 + width, y3 + height - bottomRight);
      ctx.quadraticCurveTo(x2 + width, y3 + height, x2 + width - bottomRight, y3 + height);
      if (yAlign === "bottom") {
        this.drawCaret(pt, ctx, tooltipSize, options2);
      }
      ctx.lineTo(x2 + bottomLeft, y3 + height);
      ctx.quadraticCurveTo(x2, y3 + height, x2, y3 + height - bottomLeft);
      if (yAlign === "center" && xAlign === "left") {
        this.drawCaret(pt, ctx, tooltipSize, options2);
      }
      ctx.lineTo(x2, y3 + topLeft);
      ctx.quadraticCurveTo(x2, y3, x2 + topLeft, y3);
      ctx.closePath();
      ctx.fill();
      if (options2.borderWidth > 0) {
        ctx.stroke();
      }
    }
    _updateAnimationTarget(options2) {
      const chart = this.chart;
      const anims = this.$animations;
      const animX = anims && anims.x;
      const animY = anims && anims.y;
      if (animX || animY) {
        const position = positioners[options2.position].call(this, this._active, this._eventPosition);
        if (!position) {
          return;
        }
        const size = this._size = getTooltipSize(this, options2);
        const positionAndSize = Object.assign({}, position, this._size);
        const alignment = determineAlignment(chart, options2, positionAndSize);
        const point = getBackgroundPoint(options2, positionAndSize, alignment, chart);
        if (animX._to !== point.x || animY._to !== point.y) {
          this.xAlign = alignment.xAlign;
          this.yAlign = alignment.yAlign;
          this.width = size.width;
          this.height = size.height;
          this.caretX = position.x;
          this.caretY = position.y;
          this._resolveAnimations().update(this, point);
        }
      }
    }
    _willRender() {
      return !!this.opacity;
    }
    draw(ctx) {
      const options2 = this.options.setContext(this.getContext());
      let opacity = this.opacity;
      if (!opacity) {
        return;
      }
      this._updateAnimationTarget(options2);
      const tooltipSize = {
        width: this.width,
        height: this.height
      };
      const pt = {
        x: this.x,
        y: this.y
      };
      opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
      const padding = toPadding(options2.padding);
      const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
      if (options2.enabled && hasTooltipContent) {
        ctx.save();
        ctx.globalAlpha = opacity;
        this.drawBackground(pt, ctx, tooltipSize, options2);
        overrideTextDirection(ctx, options2.textDirection);
        pt.y += padding.top;
        this.drawTitle(pt, ctx, options2);
        this.drawBody(pt, ctx, options2);
        this.drawFooter(pt, ctx, options2);
        restoreTextDirection(ctx, options2.textDirection);
        ctx.restore();
      }
    }
    getActiveElements() {
      return this._active || [];
    }
    setActiveElements(activeElements, eventPosition) {
      const lastActive = this._active;
      const active = activeElements.map(({ datasetIndex, index: index2 }) => {
        const meta = this.chart.getDatasetMeta(datasetIndex);
        if (!meta) {
          throw new Error("Cannot find a dataset at index " + datasetIndex);
        }
        return {
          datasetIndex,
          element: meta.data[index2],
          index: index2
        };
      });
      const changed = !_elementsEqual(lastActive, active);
      const positionChanged = this._positionChanged(active, eventPosition);
      if (changed || positionChanged) {
        this._active = active;
        this._eventPosition = eventPosition;
        this._ignoreReplayEvents = true;
        this.update(true);
      }
    }
    handleEvent(e3, replay, inChartArea = true) {
      if (replay && this._ignoreReplayEvents) {
        return false;
      }
      this._ignoreReplayEvents = false;
      const options2 = this.options;
      const lastActive = this._active || [];
      const active = this._getActiveElements(e3, lastActive, replay, inChartArea);
      const positionChanged = this._positionChanged(active, e3);
      const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
      if (changed) {
        this._active = active;
        if (options2.enabled || options2.external) {
          this._eventPosition = {
            x: e3.x,
            y: e3.y
          };
          this.update(true, replay);
        }
      }
      return changed;
    }
    _getActiveElements(e3, lastActive, replay, inChartArea) {
      const options2 = this.options;
      if (e3.type === "mouseout") {
        return [];
      }
      if (!inChartArea) {
        return lastActive;
      }
      const active = this.chart.getElementsAtEventForMode(e3, options2.mode, options2, replay);
      if (options2.reverse) {
        active.reverse();
      }
      return active;
    }
    _positionChanged(active, e3) {
      const { caretX, caretY, options: options2 } = this;
      const position = positioners[options2.position].call(this, active, e3);
      return position !== false && (caretX !== position.x || caretY !== position.y);
    }
  };
  __publicField(Tooltip, "positioners", positioners);
  var plugin_tooltip = {
    id: "tooltip",
    _element: Tooltip,
    positioners,
    afterInit(chart, _args, options2) {
      if (options2) {
        chart.tooltip = new Tooltip({
          chart,
          options: options2
        });
      }
    },
    beforeUpdate(chart, _args, options2) {
      if (chart.tooltip) {
        chart.tooltip.initialize(options2);
      }
    },
    reset(chart, _args, options2) {
      if (chart.tooltip) {
        chart.tooltip.initialize(options2);
      }
    },
    afterDraw(chart) {
      const tooltip = chart.tooltip;
      if (tooltip && tooltip._willRender()) {
        const args = {
          tooltip
        };
        if (chart.notifyPlugins("beforeTooltipDraw", {
          ...args,
          cancelable: true
        }) === false) {
          return;
        }
        tooltip.draw(chart.ctx);
        chart.notifyPlugins("afterTooltipDraw", args);
      }
    },
    afterEvent(chart, args) {
      if (chart.tooltip) {
        const useFinalPosition = args.replay;
        if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
          args.changed = true;
        }
      }
    },
    defaults: {
      enabled: true,
      external: null,
      position: "average",
      backgroundColor: "rgba(0,0,0,0.8)",
      titleColor: "#fff",
      titleFont: {
        weight: "bold"
      },
      titleSpacing: 2,
      titleMarginBottom: 6,
      titleAlign: "left",
      bodyColor: "#fff",
      bodySpacing: 2,
      bodyFont: {},
      bodyAlign: "left",
      footerColor: "#fff",
      footerSpacing: 2,
      footerMarginTop: 6,
      footerFont: {
        weight: "bold"
      },
      footerAlign: "left",
      padding: 6,
      caretPadding: 2,
      caretSize: 5,
      cornerRadius: 6,
      boxHeight: (ctx, opts) => opts.bodyFont.size,
      boxWidth: (ctx, opts) => opts.bodyFont.size,
      multiKeyBackground: "#fff",
      displayColors: true,
      boxPadding: 0,
      borderColor: "rgba(0,0,0,0)",
      borderWidth: 0,
      animation: {
        duration: 400,
        easing: "easeOutQuart"
      },
      animations: {
        numbers: {
          type: "number",
          properties: [
            "x",
            "y",
            "width",
            "height",
            "caretX",
            "caretY"
          ]
        },
        opacity: {
          easing: "linear",
          duration: 200
        }
      },
      callbacks: defaultCallbacks
    },
    defaultRoutes: {
      bodyFont: "font",
      footerFont: "font",
      titleFont: "font"
    },
    descriptors: {
      _scriptable: (name2) => name2 !== "filter" && name2 !== "itemSort" && name2 !== "external",
      _indexable: false,
      callbacks: {
        _scriptable: false,
        _indexable: false
      },
      animation: {
        _fallback: false
      },
      animations: {
        _fallback: "animation"
      }
    },
    additionalOptionScopes: [
      "interaction"
    ]
  };
  var plugins = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    Colors: plugin_colors,
    Decimation: plugin_decimation,
    Filler: index,
    Legend: plugin_legend,
    SubTitle: plugin_subtitle,
    Title: plugin_title,
    Tooltip: plugin_tooltip
  });
  var addIfString = (labels, raw, index2, addedLabels) => {
    if (typeof raw === "string") {
      index2 = labels.push(raw) - 1;
      addedLabels.unshift({
        index: index2,
        label: raw
      });
    } else if (isNaN(raw)) {
      index2 = null;
    }
    return index2;
  };
  function findOrAddLabel(labels, raw, index2, addedLabels) {
    const first = labels.indexOf(raw);
    if (first === -1) {
      return addIfString(labels, raw, index2, addedLabels);
    }
    const last = labels.lastIndexOf(raw);
    return first !== last ? index2 : first;
  }
  var validIndex = (index2, max2) => index2 === null ? null : _limitValue(Math.round(index2), 0, max2);
  function _getLabelForValue(value) {
    const labels = this.getLabels();
    if (value >= 0 && value < labels.length) {
      return labels[value];
    }
    return value;
  }
  var CategoryScale = class extends Scale {
    constructor(cfg) {
      super(cfg);
      this._startValue = void 0;
      this._valueRange = 0;
      this._addedLabels = [];
    }
    init(scaleOptions) {
      const added = this._addedLabels;
      if (added.length) {
        const labels = this.getLabels();
        for (const { index: index2, label } of added) {
          if (labels[index2] === label) {
            labels.splice(index2, 1);
          }
        }
        this._addedLabels = [];
      }
      super.init(scaleOptions);
    }
    parse(raw, index2) {
      if (isNullOrUndef(raw)) {
        return null;
      }
      const labels = this.getLabels();
      index2 = isFinite(index2) && labels[index2] === raw ? index2 : findOrAddLabel(labels, raw, valueOrDefault(index2, raw), this._addedLabels);
      return validIndex(index2, labels.length - 1);
    }
    determineDataLimits() {
      const { minDefined, maxDefined } = this.getUserBounds();
      let { min: min2, max: max2 } = this.getMinMax(true);
      if (this.options.bounds === "ticks") {
        if (!minDefined) {
          min2 = 0;
        }
        if (!maxDefined) {
          max2 = this.getLabels().length - 1;
        }
      }
      this.min = min2;
      this.max = max2;
    }
    buildTicks() {
      const min2 = this.min;
      const max2 = this.max;
      const offset2 = this.options.offset;
      const ticks = [];
      let labels = this.getLabels();
      labels = min2 === 0 && max2 === labels.length - 1 ? labels : labels.slice(min2, max2 + 1);
      this._valueRange = Math.max(labels.length - (offset2 ? 0 : 1), 1);
      this._startValue = this.min - (offset2 ? 0.5 : 0);
      for (let value = min2; value <= max2; value++) {
        ticks.push({
          value
        });
      }
      return ticks;
    }
    getLabelForValue(value) {
      return _getLabelForValue.call(this, value);
    }
    configure() {
      super.configure();
      if (!this.isHorizontal()) {
        this._reversePixels = !this._reversePixels;
      }
    }
    getPixelForValue(value) {
      if (typeof value !== "number") {
        value = this.parse(value);
      }
      return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
    }
    getPixelForTick(index2) {
      const ticks = this.ticks;
      if (index2 < 0 || index2 > ticks.length - 1) {
        return null;
      }
      return this.getPixelForValue(ticks[index2].value);
    }
    getValueForPixel(pixel) {
      return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
    }
    getBasePixel() {
      return this.bottom;
    }
  };
  __publicField(CategoryScale, "id", "category");
  __publicField(CategoryScale, "defaults", {
    ticks: {
      callback: _getLabelForValue
    }
  });
  function generateTicks$1(generationOptions, dataRange) {
    const ticks = [];
    const MIN_SPACING = 1e-14;
    const { bounds, step, min: min2, max: max2, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;
    const unit = step || 1;
    const maxSpaces = maxTicks - 1;
    const { min: rmin, max: rmax } = dataRange;
    const minDefined = !isNullOrUndef(min2);
    const maxDefined = !isNullOrUndef(max2);
    const countDefined = !isNullOrUndef(count);
    const minSpacing = (rmax - rmin) / (maxDigits + 1);
    let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
    let factor, niceMin, niceMax, numSpaces;
    if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
      return [
        {
          value: rmin
        },
        {
          value: rmax
        }
      ];
    }
    numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
    if (numSpaces > maxSpaces) {
      spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
    }
    if (!isNullOrUndef(precision)) {
      factor = Math.pow(10, precision);
      spacing = Math.ceil(spacing * factor) / factor;
    }
    if (bounds === "ticks") {
      niceMin = Math.floor(rmin / spacing) * spacing;
      niceMax = Math.ceil(rmax / spacing) * spacing;
    } else {
      niceMin = rmin;
      niceMax = rmax;
    }
    if (minDefined && maxDefined && step && almostWhole((max2 - min2) / step, spacing / 1e3)) {
      numSpaces = Math.round(Math.min((max2 - min2) / spacing, maxTicks));
      spacing = (max2 - min2) / numSpaces;
      niceMin = min2;
      niceMax = max2;
    } else if (countDefined) {
      niceMin = minDefined ? min2 : niceMin;
      niceMax = maxDefined ? max2 : niceMax;
      numSpaces = count - 1;
      spacing = (niceMax - niceMin) / numSpaces;
    } else {
      numSpaces = (niceMax - niceMin) / spacing;
      if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
        numSpaces = Math.round(numSpaces);
      } else {
        numSpaces = Math.ceil(numSpaces);
      }
    }
    const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
    factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
    niceMin = Math.round(niceMin * factor) / factor;
    niceMax = Math.round(niceMax * factor) / factor;
    let j = 0;
    if (minDefined) {
      if (includeBounds && niceMin !== min2) {
        ticks.push({
          value: min2
        });
        if (niceMin < min2) {
          j++;
        }
        if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min2, relativeLabelSize(min2, minSpacing, generationOptions))) {
          j++;
        }
      } else if (niceMin < min2) {
        j++;
      }
    }
    for (; j < numSpaces; ++j) {
      ticks.push({
        value: Math.round((niceMin + j * spacing) * factor) / factor
      });
    }
    if (maxDefined && includeBounds && niceMax !== max2) {
      if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max2, relativeLabelSize(max2, minSpacing, generationOptions))) {
        ticks[ticks.length - 1].value = max2;
      } else {
        ticks.push({
          value: max2
        });
      }
    } else if (!maxDefined || niceMax === max2) {
      ticks.push({
        value: niceMax
      });
    }
    return ticks;
  }
  function relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {
    const rad = toRadians(minRotation);
    const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
    const length = 0.75 * minSpacing * ("" + value).length;
    return Math.min(minSpacing / ratio, length);
  }
  var LinearScaleBase = class extends Scale {
    constructor(cfg) {
      super(cfg);
      this.start = void 0;
      this.end = void 0;
      this._startValue = void 0;
      this._endValue = void 0;
      this._valueRange = 0;
    }
    parse(raw, index2) {
      if (isNullOrUndef(raw)) {
        return null;
      }
      if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
        return null;
      }
      return +raw;
    }
    handleTickRangeOptions() {
      const { beginAtZero } = this.options;
      const { minDefined, maxDefined } = this.getUserBounds();
      let { min: min2, max: max2 } = this;
      const setMin2 = (v) => min2 = minDefined ? min2 : v;
      const setMax2 = (v) => max2 = maxDefined ? max2 : v;
      if (beginAtZero) {
        const minSign = sign(min2);
        const maxSign = sign(max2);
        if (minSign < 0 && maxSign < 0) {
          setMax2(0);
        } else if (minSign > 0 && maxSign > 0) {
          setMin2(0);
        }
      }
      if (min2 === max2) {
        let offset2 = max2 === 0 ? 1 : Math.abs(max2 * 0.05);
        setMax2(max2 + offset2);
        if (!beginAtZero) {
          setMin2(min2 - offset2);
        }
      }
      this.min = min2;
      this.max = max2;
    }
    getTickLimit() {
      const tickOpts = this.options.ticks;
      let { maxTicksLimit, stepSize } = tickOpts;
      let maxTicks;
      if (stepSize) {
        maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
        if (maxTicks > 1e3) {
          console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
          maxTicks = 1e3;
        }
      } else {
        maxTicks = this.computeTickLimit();
        maxTicksLimit = maxTicksLimit || 11;
      }
      if (maxTicksLimit) {
        maxTicks = Math.min(maxTicksLimit, maxTicks);
      }
      return maxTicks;
    }
    computeTickLimit() {
      return Number.POSITIVE_INFINITY;
    }
    buildTicks() {
      const opts = this.options;
      const tickOpts = opts.ticks;
      let maxTicks = this.getTickLimit();
      maxTicks = Math.max(2, maxTicks);
      const numericGeneratorOptions = {
        maxTicks,
        bounds: opts.bounds,
        min: opts.min,
        max: opts.max,
        precision: tickOpts.precision,
        step: tickOpts.stepSize,
        count: tickOpts.count,
        maxDigits: this._maxDigits(),
        horizontal: this.isHorizontal(),
        minRotation: tickOpts.minRotation || 0,
        includeBounds: tickOpts.includeBounds !== false
      };
      const dataRange = this._range || this;
      const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
      if (opts.bounds === "ticks") {
        _setMinAndMaxByKey(ticks, this, "value");
      }
      if (opts.reverse) {
        ticks.reverse();
        this.start = this.max;
        this.end = this.min;
      } else {
        this.start = this.min;
        this.end = this.max;
      }
      return ticks;
    }
    configure() {
      const ticks = this.ticks;
      let start3 = this.min;
      let end2 = this.max;
      super.configure();
      if (this.options.offset && ticks.length) {
        const offset2 = (end2 - start3) / Math.max(ticks.length - 1, 1) / 2;
        start3 -= offset2;
        end2 += offset2;
      }
      this._startValue = start3;
      this._endValue = end2;
      this._valueRange = end2 - start3;
    }
    getLabelForValue(value) {
      return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
    }
  };
  var LinearScale = class extends LinearScaleBase {
    determineDataLimits() {
      const { min: min2, max: max2 } = this.getMinMax(true);
      this.min = isNumberFinite(min2) ? min2 : 0;
      this.max = isNumberFinite(max2) ? max2 : 1;
      this.handleTickRangeOptions();
    }
    computeTickLimit() {
      const horizontal = this.isHorizontal();
      const length = horizontal ? this.width : this.height;
      const minRotation = toRadians(this.options.ticks.minRotation);
      const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
      const tickFont = this._resolveTickFontOptions(0);
      return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
    }
    getPixelForValue(value) {
      return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
    }
    getValueForPixel(pixel) {
      return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
    }
  };
  __publicField(LinearScale, "id", "linear");
  __publicField(LinearScale, "defaults", {
    ticks: {
      callback: Ticks.formatters.numeric
    }
  });
  var log10Floor = (v) => Math.floor(log10(v));
  var changeExponent = (v, m3) => Math.pow(10, log10Floor(v) + m3);
  function isMajor(tickVal) {
    const remain = tickVal / Math.pow(10, log10Floor(tickVal));
    return remain === 1;
  }
  function steps(min2, max2, rangeExp) {
    const rangeStep = Math.pow(10, rangeExp);
    const start3 = Math.floor(min2 / rangeStep);
    const end2 = Math.ceil(max2 / rangeStep);
    return end2 - start3;
  }
  function startExp(min2, max2) {
    const range = max2 - min2;
    let rangeExp = log10Floor(range);
    while (steps(min2, max2, rangeExp) > 10) {
      rangeExp++;
    }
    while (steps(min2, max2, rangeExp) < 10) {
      rangeExp--;
    }
    return Math.min(rangeExp, log10Floor(min2));
  }
  function generateTicks(generationOptions, { min: min2, max: max2 }) {
    min2 = finiteOrDefault(generationOptions.min, min2);
    const ticks = [];
    const minExp = log10Floor(min2);
    let exp = startExp(min2, max2);
    let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
    const stepSize = Math.pow(10, exp);
    const base = minExp > exp ? Math.pow(10, minExp) : 0;
    const start3 = Math.round((min2 - base) * precision) / precision;
    const offset2 = Math.floor((min2 - base) / stepSize / 10) * stepSize * 10;
    let significand = Math.floor((start3 - offset2) / Math.pow(10, exp));
    let value = finiteOrDefault(generationOptions.min, Math.round((base + offset2 + significand * Math.pow(10, exp)) * precision) / precision);
    while (value < max2) {
      ticks.push({
        value,
        major: isMajor(value),
        significand
      });
      if (significand >= 10) {
        significand = significand < 15 ? 15 : 20;
      } else {
        significand++;
      }
      if (significand >= 20) {
        exp++;
        significand = 2;
        precision = exp >= 0 ? 1 : precision;
      }
      value = Math.round((base + offset2 + significand * Math.pow(10, exp)) * precision) / precision;
    }
    const lastTick = finiteOrDefault(generationOptions.max, value);
    ticks.push({
      value: lastTick,
      major: isMajor(lastTick),
      significand
    });
    return ticks;
  }
  var LogarithmicScale = class extends Scale {
    constructor(cfg) {
      super(cfg);
      this.start = void 0;
      this.end = void 0;
      this._startValue = void 0;
      this._valueRange = 0;
    }
    parse(raw, index2) {
      const value = LinearScaleBase.prototype.parse.apply(this, [
        raw,
        index2
      ]);
      if (value === 0) {
        this._zero = true;
        return void 0;
      }
      return isNumberFinite(value) && value > 0 ? value : null;
    }
    determineDataLimits() {
      const { min: min2, max: max2 } = this.getMinMax(true);
      this.min = isNumberFinite(min2) ? Math.max(0, min2) : null;
      this.max = isNumberFinite(max2) ? Math.max(0, max2) : null;
      if (this.options.beginAtZero) {
        this._zero = true;
      }
      if (this._zero && this.min !== this._suggestedMin && !isNumberFinite(this._userMin)) {
        this.min = min2 === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);
      }
      this.handleTickRangeOptions();
    }
    handleTickRangeOptions() {
      const { minDefined, maxDefined } = this.getUserBounds();
      let min2 = this.min;
      let max2 = this.max;
      const setMin2 = (v) => min2 = minDefined ? min2 : v;
      const setMax2 = (v) => max2 = maxDefined ? max2 : v;
      if (min2 === max2) {
        if (min2 <= 0) {
          setMin2(1);
          setMax2(10);
        } else {
          setMin2(changeExponent(min2, -1));
          setMax2(changeExponent(max2, 1));
        }
      }
      if (min2 <= 0) {
        setMin2(changeExponent(max2, -1));
      }
      if (max2 <= 0) {
        setMax2(changeExponent(min2, 1));
      }
      this.min = min2;
      this.max = max2;
    }
    buildTicks() {
      const opts = this.options;
      const generationOptions = {
        min: this._userMin,
        max: this._userMax
      };
      const ticks = generateTicks(generationOptions, this);
      if (opts.bounds === "ticks") {
        _setMinAndMaxByKey(ticks, this, "value");
      }
      if (opts.reverse) {
        ticks.reverse();
        this.start = this.max;
        this.end = this.min;
      } else {
        this.start = this.min;
        this.end = this.max;
      }
      return ticks;
    }
    getLabelForValue(value) {
      return value === void 0 ? "0" : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
    }
    configure() {
      const start3 = this.min;
      super.configure();
      this._startValue = log10(start3);
      this._valueRange = log10(this.max) - log10(start3);
    }
    getPixelForValue(value) {
      if (value === void 0 || value === 0) {
        value = this.min;
      }
      if (value === null || isNaN(value)) {
        return NaN;
      }
      return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);
    }
    getValueForPixel(pixel) {
      const decimal = this.getDecimalForPixel(pixel);
      return Math.pow(10, this._startValue + decimal * this._valueRange);
    }
  };
  __publicField(LogarithmicScale, "id", "logarithmic");
  __publicField(LogarithmicScale, "defaults", {
    ticks: {
      callback: Ticks.formatters.logarithmic,
      major: {
        enabled: true
      }
    }
  });
  function getTickBackdropHeight(opts) {
    const tickOpts = opts.ticks;
    if (tickOpts.display && opts.display) {
      const padding = toPadding(tickOpts.backdropPadding);
      return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;
    }
    return 0;
  }
  function measureLabelSize(ctx, font, label) {
    label = isArray2(label) ? label : [
      label
    ];
    return {
      w: _longestText(ctx, font.string, label),
      h: label.length * font.lineHeight
    };
  }
  function determineLimits(angle, pos, size, min2, max2) {
    if (angle === min2 || angle === max2) {
      return {
        start: pos - size / 2,
        end: pos + size / 2
      };
    } else if (angle < min2 || angle > max2) {
      return {
        start: pos - size,
        end: pos
      };
    }
    return {
      start: pos,
      end: pos + size
    };
  }
  function fitWithPointLabels(scale) {
    const orig = {
      l: scale.left + scale._padding.left,
      r: scale.right - scale._padding.right,
      t: scale.top + scale._padding.top,
      b: scale.bottom - scale._padding.bottom
    };
    const limits = Object.assign({}, orig);
    const labelSizes = [];
    const padding = [];
    const valueCount = scale._pointLabels.length;
    const pointLabelOpts = scale.options.pointLabels;
    const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
    for (let i3 = 0; i3 < valueCount; i3++) {
      const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i3));
      padding[i3] = opts.padding;
      const pointPosition = scale.getPointPosition(i3, scale.drawingArea + padding[i3], additionalAngle);
      const plFont = toFont(opts.font);
      const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i3]);
      labelSizes[i3] = textSize;
      const angleRadians = _normalizeAngle(scale.getIndexAngle(i3) + additionalAngle);
      const angle = Math.round(toDegrees(angleRadians));
      const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
      const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
      updateLimits(limits, orig, angleRadians, hLimits, vLimits);
    }
    scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
    scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
  }
  function updateLimits(limits, orig, angle, hLimits, vLimits) {
    const sin = Math.abs(Math.sin(angle));
    const cos = Math.abs(Math.cos(angle));
    let x2 = 0;
    let y3 = 0;
    if (hLimits.start < orig.l) {
      x2 = (orig.l - hLimits.start) / sin;
      limits.l = Math.min(limits.l, orig.l - x2);
    } else if (hLimits.end > orig.r) {
      x2 = (hLimits.end - orig.r) / sin;
      limits.r = Math.max(limits.r, orig.r + x2);
    }
    if (vLimits.start < orig.t) {
      y3 = (orig.t - vLimits.start) / cos;
      limits.t = Math.min(limits.t, orig.t - y3);
    } else if (vLimits.end > orig.b) {
      y3 = (vLimits.end - orig.b) / cos;
      limits.b = Math.max(limits.b, orig.b + y3);
    }
  }
  function buildPointLabelItems(scale, labelSizes, padding) {
    const items = [];
    const valueCount = scale._pointLabels.length;
    const opts = scale.options;
    const extra = getTickBackdropHeight(opts) / 2;
    const outerDistance = scale.drawingArea;
    const additionalAngle = opts.pointLabels.centerPointLabels ? PI / valueCount : 0;
    for (let i3 = 0; i3 < valueCount; i3++) {
      const pointLabelPosition = scale.getPointPosition(i3, outerDistance + extra + padding[i3], additionalAngle);
      const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
      const size = labelSizes[i3];
      const y3 = yForAngle(pointLabelPosition.y, size.h, angle);
      const textAlign = getTextAlignForAngle(angle);
      const left2 = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
      items.push({
        x: pointLabelPosition.x,
        y: y3,
        textAlign,
        left: left2,
        top: y3,
        right: left2 + size.w,
        bottom: y3 + size.h
      });
    }
    return items;
  }
  function getTextAlignForAngle(angle) {
    if (angle === 0 || angle === 180) {
      return "center";
    } else if (angle < 180) {
      return "left";
    }
    return "right";
  }
  function leftForTextAlign(x2, w2, align) {
    if (align === "right") {
      x2 -= w2;
    } else if (align === "center") {
      x2 -= w2 / 2;
    }
    return x2;
  }
  function yForAngle(y3, h5, angle) {
    if (angle === 90 || angle === 270) {
      y3 -= h5 / 2;
    } else if (angle > 270 || angle < 90) {
      y3 -= h5;
    }
    return y3;
  }
  function drawPointLabels(scale, labelCount) {
    const { ctx, options: { pointLabels } } = scale;
    for (let i3 = labelCount - 1; i3 >= 0; i3--) {
      const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i3));
      const plFont = toFont(optsAtIndex.font);
      const { x: x2, y: y3, textAlign, left: left2, top: top2, right: right2, bottom: bottom2 } = scale._pointLabelItems[i3];
      const { backdropColor } = optsAtIndex;
      if (!isNullOrUndef(backdropColor)) {
        const borderRadius = toTRBLCorners(optsAtIndex.borderRadius);
        const padding = toPadding(optsAtIndex.backdropPadding);
        ctx.fillStyle = backdropColor;
        const backdropLeft = left2 - padding.left;
        const backdropTop = top2 - padding.top;
        const backdropWidth = right2 - left2 + padding.width;
        const backdropHeight = bottom2 - top2 + padding.height;
        if (Object.values(borderRadius).some((v) => v !== 0)) {
          ctx.beginPath();
          addRoundedRectPath(ctx, {
            x: backdropLeft,
            y: backdropTop,
            w: backdropWidth,
            h: backdropHeight,
            radius: borderRadius
          });
          ctx.fill();
        } else {
          ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
        }
      }
      renderText(ctx, scale._pointLabels[i3], x2, y3 + plFont.lineHeight / 2, plFont, {
        color: optsAtIndex.color,
        textAlign,
        textBaseline: "middle"
      });
    }
  }
  function pathRadiusLine(scale, radius, circular, labelCount) {
    const { ctx } = scale;
    if (circular) {
      ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
    } else {
      let pointPosition = scale.getPointPosition(0, radius);
      ctx.moveTo(pointPosition.x, pointPosition.y);
      for (let i3 = 1; i3 < labelCount; i3++) {
        pointPosition = scale.getPointPosition(i3, radius);
        ctx.lineTo(pointPosition.x, pointPosition.y);
      }
    }
  }
  function drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {
    const ctx = scale.ctx;
    const circular = gridLineOpts.circular;
    const { color: color2, lineWidth } = gridLineOpts;
    if (!circular && !labelCount || !color2 || !lineWidth || radius < 0) {
      return;
    }
    ctx.save();
    ctx.strokeStyle = color2;
    ctx.lineWidth = lineWidth;
    ctx.setLineDash(borderOpts.dash);
    ctx.lineDashOffset = borderOpts.dashOffset;
    ctx.beginPath();
    pathRadiusLine(scale, radius, circular, labelCount);
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
  }
  function createPointLabelContext(parent, index2, label) {
    return createContext(parent, {
      label,
      index: index2,
      type: "pointLabel"
    });
  }
  var RadialLinearScale = class extends LinearScaleBase {
    constructor(cfg) {
      super(cfg);
      this.xCenter = void 0;
      this.yCenter = void 0;
      this.drawingArea = void 0;
      this._pointLabels = [];
      this._pointLabelItems = [];
    }
    setDimensions() {
      const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
      const w2 = this.width = this.maxWidth - padding.width;
      const h5 = this.height = this.maxHeight - padding.height;
      this.xCenter = Math.floor(this.left + w2 / 2 + padding.left);
      this.yCenter = Math.floor(this.top + h5 / 2 + padding.top);
      this.drawingArea = Math.floor(Math.min(w2, h5) / 2);
    }
    determineDataLimits() {
      const { min: min2, max: max2 } = this.getMinMax(false);
      this.min = isNumberFinite(min2) && !isNaN(min2) ? min2 : 0;
      this.max = isNumberFinite(max2) && !isNaN(max2) ? max2 : 0;
      this.handleTickRangeOptions();
    }
    computeTickLimit() {
      return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
    }
    generateTickLabels(ticks) {
      LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
      this._pointLabels = this.getLabels().map((value, index2) => {
        const label = callback(this.options.pointLabels.callback, [
          value,
          index2
        ], this);
        return label || label === 0 ? label : "";
      }).filter((v, i3) => this.chart.getDataVisibility(i3));
    }
    fit() {
      const opts = this.options;
      if (opts.display && opts.pointLabels.display) {
        fitWithPointLabels(this);
      } else {
        this.setCenterPoint(0, 0, 0, 0);
      }
    }
    setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
      this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
      this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
      this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
    }
    getIndexAngle(index2) {
      const angleMultiplier = TAU / (this._pointLabels.length || 1);
      const startAngle = this.options.startAngle || 0;
      return _normalizeAngle(index2 * angleMultiplier + toRadians(startAngle));
    }
    getDistanceFromCenterForValue(value) {
      if (isNullOrUndef(value)) {
        return NaN;
      }
      const scalingFactor = this.drawingArea / (this.max - this.min);
      if (this.options.reverse) {
        return (this.max - value) * scalingFactor;
      }
      return (value - this.min) * scalingFactor;
    }
    getValueForDistanceFromCenter(distance) {
      if (isNullOrUndef(distance)) {
        return NaN;
      }
      const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
      return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
    }
    getPointLabelContext(index2) {
      const pointLabels = this._pointLabels || [];
      if (index2 >= 0 && index2 < pointLabels.length) {
        const pointLabel = pointLabels[index2];
        return createPointLabelContext(this.getContext(), index2, pointLabel);
      }
    }
    getPointPosition(index2, distanceFromCenter, additionalAngle = 0) {
      const angle = this.getIndexAngle(index2) - HALF_PI + additionalAngle;
      return {
        x: Math.cos(angle) * distanceFromCenter + this.xCenter,
        y: Math.sin(angle) * distanceFromCenter + this.yCenter,
        angle
      };
    }
    getPointPositionForValue(index2, value) {
      return this.getPointPosition(index2, this.getDistanceFromCenterForValue(value));
    }
    getBasePosition(index2) {
      return this.getPointPositionForValue(index2 || 0, this.getBaseValue());
    }
    getPointLabelPosition(index2) {
      const { left: left2, top: top2, right: right2, bottom: bottom2 } = this._pointLabelItems[index2];
      return {
        left: left2,
        top: top2,
        right: right2,
        bottom: bottom2
      };
    }
    drawBackground() {
      const { backgroundColor, grid: { circular } } = this.options;
      if (backgroundColor) {
        const ctx = this.ctx;
        ctx.save();
        ctx.beginPath();
        pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
        ctx.closePath();
        ctx.fillStyle = backgroundColor;
        ctx.fill();
        ctx.restore();
      }
    }
    drawGrid() {
      const ctx = this.ctx;
      const opts = this.options;
      const { angleLines, grid, border } = opts;
      const labelCount = this._pointLabels.length;
      let i3, offset2, position;
      if (opts.pointLabels.display) {
        drawPointLabels(this, labelCount);
      }
      if (grid.display) {
        this.ticks.forEach((tick, index2) => {
          if (index2 !== 0) {
            offset2 = this.getDistanceFromCenterForValue(tick.value);
            const context = this.getContext(index2);
            const optsAtIndex = grid.setContext(context);
            const optsAtIndexBorder = border.setContext(context);
            drawRadiusLine(this, optsAtIndex, offset2, labelCount, optsAtIndexBorder);
          }
        });
      }
      if (angleLines.display) {
        ctx.save();
        for (i3 = labelCount - 1; i3 >= 0; i3--) {
          const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i3));
          const { color: color2, lineWidth } = optsAtIndex;
          if (!lineWidth || !color2) {
            continue;
          }
          ctx.lineWidth = lineWidth;
          ctx.strokeStyle = color2;
          ctx.setLineDash(optsAtIndex.borderDash);
          ctx.lineDashOffset = optsAtIndex.borderDashOffset;
          offset2 = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);
          position = this.getPointPosition(i3, offset2);
          ctx.beginPath();
          ctx.moveTo(this.xCenter, this.yCenter);
          ctx.lineTo(position.x, position.y);
          ctx.stroke();
        }
        ctx.restore();
      }
    }
    drawBorder() {
    }
    drawLabels() {
      const ctx = this.ctx;
      const opts = this.options;
      const tickOpts = opts.ticks;
      if (!tickOpts.display) {
        return;
      }
      const startAngle = this.getIndexAngle(0);
      let offset2, width;
      ctx.save();
      ctx.translate(this.xCenter, this.yCenter);
      ctx.rotate(startAngle);
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      this.ticks.forEach((tick, index2) => {
        if (index2 === 0 && !opts.reverse) {
          return;
        }
        const optsAtIndex = tickOpts.setContext(this.getContext(index2));
        const tickFont = toFont(optsAtIndex.font);
        offset2 = this.getDistanceFromCenterForValue(this.ticks[index2].value);
        if (optsAtIndex.showLabelBackdrop) {
          ctx.font = tickFont.string;
          width = ctx.measureText(tick.label).width;
          ctx.fillStyle = optsAtIndex.backdropColor;
          const padding = toPadding(optsAtIndex.backdropPadding);
          ctx.fillRect(-width / 2 - padding.left, -offset2 - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
        }
        renderText(ctx, tick.label, 0, -offset2, tickFont, {
          color: optsAtIndex.color
        });
      });
      ctx.restore();
    }
    drawTitle() {
    }
  };
  __publicField(RadialLinearScale, "id", "radialLinear");
  __publicField(RadialLinearScale, "defaults", {
    display: true,
    animate: true,
    position: "chartArea",
    angleLines: {
      display: true,
      lineWidth: 1,
      borderDash: [],
      borderDashOffset: 0
    },
    grid: {
      circular: false
    },
    startAngle: 0,
    ticks: {
      showLabelBackdrop: true,
      callback: Ticks.formatters.numeric
    },
    pointLabels: {
      backdropColor: void 0,
      backdropPadding: 2,
      display: true,
      font: {
        size: 10
      },
      callback(label) {
        return label;
      },
      padding: 5,
      centerPointLabels: false
    }
  });
  __publicField(RadialLinearScale, "defaultRoutes", {
    "angleLines.color": "borderColor",
    "pointLabels.color": "color",
    "ticks.color": "color"
  });
  __publicField(RadialLinearScale, "descriptors", {
    angleLines: {
      _fallback: "grid"
    }
  });
  var INTERVALS = {
    millisecond: {
      common: true,
      size: 1,
      steps: 1e3
    },
    second: {
      common: true,
      size: 1e3,
      steps: 60
    },
    minute: {
      common: true,
      size: 6e4,
      steps: 60
    },
    hour: {
      common: true,
      size: 36e5,
      steps: 24
    },
    day: {
      common: true,
      size: 864e5,
      steps: 30
    },
    week: {
      common: false,
      size: 6048e5,
      steps: 4
    },
    month: {
      common: true,
      size: 2628e6,
      steps: 12
    },
    quarter: {
      common: false,
      size: 7884e6,
      steps: 4
    },
    year: {
      common: true,
      size: 3154e7
    }
  };
  var UNITS = /* @__PURE__ */ Object.keys(INTERVALS);
  function sorter(a4, b2) {
    return a4 - b2;
  }
  function parse(scale, input) {
    if (isNullOrUndef(input)) {
      return null;
    }
    const adapter = scale._adapter;
    const { parser, round: round3, isoWeekday } = scale._parseOpts;
    let value = input;
    if (typeof parser === "function") {
      value = parser(value);
    }
    if (!isNumberFinite(value)) {
      value = typeof parser === "string" ? adapter.parse(value, parser) : adapter.parse(value);
    }
    if (value === null) {
      return null;
    }
    if (round3) {
      value = round3 === "week" && (isNumber2(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round3);
    }
    return +value;
  }
  function determineUnitForAutoTicks(minUnit, min2, max2, capacity) {
    const ilen = UNITS.length;
    for (let i3 = UNITS.indexOf(minUnit); i3 < ilen - 1; ++i3) {
      const interval = INTERVALS[UNITS[i3]];
      const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
      if (interval.common && Math.ceil((max2 - min2) / (factor * interval.size)) <= capacity) {
        return UNITS[i3];
      }
    }
    return UNITS[ilen - 1];
  }
  function determineUnitForFormatting(scale, numTicks, minUnit, min2, max2) {
    for (let i3 = UNITS.length - 1; i3 >= UNITS.indexOf(minUnit); i3--) {
      const unit = UNITS[i3];
      if (INTERVALS[unit].common && scale._adapter.diff(max2, min2, unit) >= numTicks - 1) {
        return unit;
      }
    }
    return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
  }
  function determineMajorUnit(unit) {
    for (let i3 = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i3 < ilen; ++i3) {
      if (INTERVALS[UNITS[i3]].common) {
        return UNITS[i3];
      }
    }
  }
  function addTick(ticks, time, timestamps) {
    if (!timestamps) {
      ticks[time] = true;
    } else if (timestamps.length) {
      const { lo, hi } = _lookup(timestamps, time);
      const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
      ticks[timestamp] = true;
    }
  }
  function setMajorTicks(scale, ticks, map3, majorUnit) {
    const adapter = scale._adapter;
    const first = +adapter.startOf(ticks[0].value, majorUnit);
    const last = ticks[ticks.length - 1].value;
    let major, index2;
    for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
      index2 = map3[major];
      if (index2 >= 0) {
        ticks[index2].major = true;
      }
    }
    return ticks;
  }
  function ticksFromTimestamps(scale, values, majorUnit) {
    const ticks = [];
    const map3 = {};
    const ilen = values.length;
    let i3, value;
    for (i3 = 0; i3 < ilen; ++i3) {
      value = values[i3];
      map3[value] = i3;
      ticks.push({
        value,
        major: false
      });
    }
    return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map3, majorUnit);
  }
  var TimeScale = class extends Scale {
    constructor(props) {
      super(props);
      this._cache = {
        data: [],
        labels: [],
        all: []
      };
      this._unit = "day";
      this._majorUnit = void 0;
      this._offsets = {};
      this._normalized = false;
      this._parseOpts = void 0;
    }
    init(scaleOpts, opts = {}) {
      const time = scaleOpts.time || (scaleOpts.time = {});
      const adapter = this._adapter = new adapters2._date(scaleOpts.adapters.date);
      adapter.init(opts);
      mergeIf(time.displayFormats, adapter.formats());
      this._parseOpts = {
        parser: time.parser,
        round: time.round,
        isoWeekday: time.isoWeekday
      };
      super.init(scaleOpts);
      this._normalized = opts.normalized;
    }
    parse(raw, index2) {
      if (raw === void 0) {
        return null;
      }
      return parse(this, raw);
    }
    beforeLayout() {
      super.beforeLayout();
      this._cache = {
        data: [],
        labels: [],
        all: []
      };
    }
    determineDataLimits() {
      const options2 = this.options;
      const adapter = this._adapter;
      const unit = options2.time.unit || "day";
      let { min: min2, max: max2, minDefined, maxDefined } = this.getUserBounds();
      function _applyBounds(bounds) {
        if (!minDefined && !isNaN(bounds.min)) {
          min2 = Math.min(min2, bounds.min);
        }
        if (!maxDefined && !isNaN(bounds.max)) {
          max2 = Math.max(max2, bounds.max);
        }
      }
      if (!minDefined || !maxDefined) {
        _applyBounds(this._getLabelBounds());
        if (options2.bounds !== "ticks" || options2.ticks.source !== "labels") {
          _applyBounds(this.getMinMax(false));
        }
      }
      min2 = isNumberFinite(min2) && !isNaN(min2) ? min2 : +adapter.startOf(Date.now(), unit);
      max2 = isNumberFinite(max2) && !isNaN(max2) ? max2 : +adapter.endOf(Date.now(), unit) + 1;
      this.min = Math.min(min2, max2 - 1);
      this.max = Math.max(min2 + 1, max2);
    }
    _getLabelBounds() {
      const arr = this.getLabelTimestamps();
      let min2 = Number.POSITIVE_INFINITY;
      let max2 = Number.NEGATIVE_INFINITY;
      if (arr.length) {
        min2 = arr[0];
        max2 = arr[arr.length - 1];
      }
      return {
        min: min2,
        max: max2
      };
    }
    buildTicks() {
      const options2 = this.options;
      const timeOpts = options2.time;
      const tickOpts = options2.ticks;
      const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
      if (options2.bounds === "ticks" && timestamps.length) {
        this.min = this._userMin || timestamps[0];
        this.max = this._userMax || timestamps[timestamps.length - 1];
      }
      const min2 = this.min;
      const max2 = this.max;
      const ticks = _filterBetween(timestamps, min2, max2);
      this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min2)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
      this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
      this.initOffsets(timestamps);
      if (options2.reverse) {
        ticks.reverse();
      }
      return ticksFromTimestamps(this, ticks, this._majorUnit);
    }
    afterAutoSkip() {
      if (this.options.offsetAfterAutoskip) {
        this.initOffsets(this.ticks.map((tick) => +tick.value));
      }
    }
    initOffsets(timestamps = []) {
      let start3 = 0;
      let end2 = 0;
      let first, last;
      if (this.options.offset && timestamps.length) {
        first = this.getDecimalForValue(timestamps[0]);
        if (timestamps.length === 1) {
          start3 = 1 - first;
        } else {
          start3 = (this.getDecimalForValue(timestamps[1]) - first) / 2;
        }
        last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
        if (timestamps.length === 1) {
          end2 = last;
        } else {
          end2 = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
        }
      }
      const limit = timestamps.length < 3 ? 0.5 : 0.25;
      start3 = _limitValue(start3, 0, limit);
      end2 = _limitValue(end2, 0, limit);
      this._offsets = {
        start: start3,
        end: end2,
        factor: 1 / (start3 + 1 + end2)
      };
    }
    _generate() {
      const adapter = this._adapter;
      const min2 = this.min;
      const max2 = this.max;
      const options2 = this.options;
      const timeOpts = options2.time;
      const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min2, max2, this._getLabelCapacity(min2));
      const stepSize = valueOrDefault(options2.ticks.stepSize, 1);
      const weekday = minor === "week" ? timeOpts.isoWeekday : false;
      const hasWeekday = isNumber2(weekday) || weekday === true;
      const ticks = {};
      let first = min2;
      let time, count;
      if (hasWeekday) {
        first = +adapter.startOf(first, "isoWeek", weekday);
      }
      first = +adapter.startOf(first, hasWeekday ? "day" : minor);
      if (adapter.diff(max2, min2, minor) > 1e5 * stepSize) {
        throw new Error(min2 + " and " + max2 + " are too far apart with stepSize of " + stepSize + " " + minor);
      }
      const timestamps = options2.ticks.source === "data" && this.getDataTimestamps();
      for (time = first, count = 0; time < max2; time = +adapter.add(time, stepSize, minor), count++) {
        addTick(ticks, time, timestamps);
      }
      if (time === max2 || options2.bounds === "ticks" || count === 1) {
        addTick(ticks, time, timestamps);
      }
      return Object.keys(ticks).sort((a4, b2) => a4 - b2).map((x2) => +x2);
    }
    getLabelForValue(value) {
      const adapter = this._adapter;
      const timeOpts = this.options.time;
      if (timeOpts.tooltipFormat) {
        return adapter.format(value, timeOpts.tooltipFormat);
      }
      return adapter.format(value, timeOpts.displayFormats.datetime);
    }
    format(value, format3) {
      const options2 = this.options;
      const formats2 = options2.time.displayFormats;
      const unit = this._unit;
      const fmt = format3 || formats2[unit];
      return this._adapter.format(value, fmt);
    }
    _tickFormatFunction(time, index2, ticks, format3) {
      const options2 = this.options;
      const formatter = options2.ticks.callback;
      if (formatter) {
        return callback(formatter, [
          time,
          index2,
          ticks
        ], this);
      }
      const formats2 = options2.time.displayFormats;
      const unit = this._unit;
      const majorUnit = this._majorUnit;
      const minorFormat = unit && formats2[unit];
      const majorFormat = majorUnit && formats2[majorUnit];
      const tick = ticks[index2];
      const major = majorUnit && majorFormat && tick && tick.major;
      return this._adapter.format(time, format3 || (major ? majorFormat : minorFormat));
    }
    generateTickLabels(ticks) {
      let i3, ilen, tick;
      for (i3 = 0, ilen = ticks.length; i3 < ilen; ++i3) {
        tick = ticks[i3];
        tick.label = this._tickFormatFunction(tick.value, i3, ticks);
      }
    }
    getDecimalForValue(value) {
      return value === null ? NaN : (value - this.min) / (this.max - this.min);
    }
    getPixelForValue(value) {
      const offsets = this._offsets;
      const pos = this.getDecimalForValue(value);
      return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
    }
    getValueForPixel(pixel) {
      const offsets = this._offsets;
      const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
      return this.min + pos * (this.max - this.min);
    }
    _getLabelSize(label) {
      const ticksOpts = this.options.ticks;
      const tickLabelWidth = this.ctx.measureText(label).width;
      const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
      const cosRotation = Math.cos(angle);
      const sinRotation = Math.sin(angle);
      const tickFontSize = this._resolveTickFontOptions(0).size;
      return {
        w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
        h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
      };
    }
    _getLabelCapacity(exampleTime) {
      const timeOpts = this.options.time;
      const displayFormats = timeOpts.displayFormats;
      const format3 = displayFormats[timeOpts.unit] || displayFormats.millisecond;
      const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [
        exampleTime
      ], this._majorUnit), format3);
      const size = this._getLabelSize(exampleLabel);
      const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
      return capacity > 0 ? capacity : 1;
    }
    getDataTimestamps() {
      let timestamps = this._cache.data || [];
      let i3, ilen;
      if (timestamps.length) {
        return timestamps;
      }
      const metas = this.getMatchingVisibleMetas();
      if (this._normalized && metas.length) {
        return this._cache.data = metas[0].controller.getAllParsedValues(this);
      }
      for (i3 = 0, ilen = metas.length; i3 < ilen; ++i3) {
        timestamps = timestamps.concat(metas[i3].controller.getAllParsedValues(this));
      }
      return this._cache.data = this.normalize(timestamps);
    }
    getLabelTimestamps() {
      const timestamps = this._cache.labels || [];
      let i3, ilen;
      if (timestamps.length) {
        return timestamps;
      }
      const labels = this.getLabels();
      for (i3 = 0, ilen = labels.length; i3 < ilen; ++i3) {
        timestamps.push(parse(this, labels[i3]));
      }
      return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
    }
    normalize(values) {
      return _arrayUnique(values.sort(sorter));
    }
  };
  __publicField(TimeScale, "id", "time");
  __publicField(TimeScale, "defaults", {
    bounds: "data",
    adapters: {},
    time: {
      parser: false,
      unit: false,
      round: false,
      isoWeekday: false,
      minUnit: "millisecond",
      displayFormats: {}
    },
    ticks: {
      source: "auto",
      callback: false,
      major: {
        enabled: false
      }
    }
  });
  function interpolate3(table, val, reverse) {
    let lo = 0;
    let hi = table.length - 1;
    let prevSource, nextSource, prevTarget, nextTarget;
    if (reverse) {
      if (val >= table[lo].pos && val <= table[hi].pos) {
        ({ lo, hi } = _lookupByKey(table, "pos", val));
      }
      ({ pos: prevSource, time: prevTarget } = table[lo]);
      ({ pos: nextSource, time: nextTarget } = table[hi]);
    } else {
      if (val >= table[lo].time && val <= table[hi].time) {
        ({ lo, hi } = _lookupByKey(table, "time", val));
      }
      ({ time: prevSource, pos: prevTarget } = table[lo]);
      ({ time: nextSource, pos: nextTarget } = table[hi]);
    }
    const span = nextSource - prevSource;
    return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
  }
  var TimeSeriesScale = class extends TimeScale {
    constructor(props) {
      super(props);
      this._table = [];
      this._minPos = void 0;
      this._tableRange = void 0;
    }
    initOffsets() {
      const timestamps = this._getTimestampsForTable();
      const table = this._table = this.buildLookupTable(timestamps);
      this._minPos = interpolate3(table, this.min);
      this._tableRange = interpolate3(table, this.max) - this._minPos;
      super.initOffsets(timestamps);
    }
    buildLookupTable(timestamps) {
      const { min: min2, max: max2 } = this;
      const items = [];
      const table = [];
      let i3, ilen, prev, curr, next;
      for (i3 = 0, ilen = timestamps.length; i3 < ilen; ++i3) {
        curr = timestamps[i3];
        if (curr >= min2 && curr <= max2) {
          items.push(curr);
        }
      }
      if (items.length < 2) {
        return [
          {
            time: min2,
            pos: 0
          },
          {
            time: max2,
            pos: 1
          }
        ];
      }
      for (i3 = 0, ilen = items.length; i3 < ilen; ++i3) {
        next = items[i3 + 1];
        prev = items[i3 - 1];
        curr = items[i3];
        if (Math.round((next + prev) / 2) !== curr) {
          table.push({
            time: curr,
            pos: i3 / (ilen - 1)
          });
        }
      }
      return table;
    }
    _getTimestampsForTable() {
      let timestamps = this._cache.all || [];
      if (timestamps.length) {
        return timestamps;
      }
      const data = this.getDataTimestamps();
      const label = this.getLabelTimestamps();
      if (data.length && label.length) {
        timestamps = this.normalize(data.concat(label));
      } else {
        timestamps = data.length ? data : label;
      }
      timestamps = this._cache.all = timestamps;
      return timestamps;
    }
    getDecimalForValue(value) {
      return (interpolate3(this._table, value) - this._minPos) / this._tableRange;
    }
    getValueForPixel(pixel) {
      const offsets = this._offsets;
      const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
      return interpolate3(this._table, decimal * this._tableRange + this._minPos, true);
    }
  };
  __publicField(TimeSeriesScale, "id", "timeseries");
  __publicField(TimeSeriesScale, "defaults", TimeScale.defaults);
  var scales = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    CategoryScale,
    LinearScale,
    LogarithmicScale,
    RadialLinearScale,
    TimeScale,
    TimeSeriesScale
  });
  var registerables = [
    controllers,
    elements,
    plugins,
    scales
  ];

  // ../../node_modules/chart.js/auto/auto.js
  Chart3.register(...registerables);
  var auto_default = Chart3;

  // ../../node_modules/date-fns/esm/_lib/toInteger/index.js
  function toInteger(dirtyNumber) {
    if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
      return NaN;
    }
    var number = Number(dirtyNumber);
    if (isNaN(number)) {
      return number;
    }
    return number < 0 ? Math.ceil(number) : Math.floor(number);
  }

  // ../../node_modules/date-fns/esm/_lib/requiredArgs/index.js
  function requiredArgs(required, args) {
    if (args.length < required) {
      throw new TypeError(required + " argument" + (required > 1 ? "s" : "") + " required, but only " + args.length + " present");
    }
  }

  // ../../node_modules/date-fns/esm/toDate/index.js
  function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function _typeof36(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof = function _typeof36(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof(obj);
  }
  function toDate2(argument) {
    requiredArgs(1, arguments);
    var argStr = Object.prototype.toString.call(argument);
    if (argument instanceof Date || _typeof(argument) === "object" && argStr === "[object Date]") {
      return new Date(argument.getTime());
    } else if (typeof argument === "number" || argStr === "[object Number]") {
      return new Date(argument);
    } else {
      if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
        console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments");
        console.warn(new Error().stack);
      }
      return new Date(NaN);
    }
  }

  // ../../node_modules/date-fns/esm/addDays/index.js
  function addDays(dirtyDate, dirtyAmount) {
    requiredArgs(2, arguments);
    var date = toDate2(dirtyDate);
    var amount = toInteger(dirtyAmount);
    if (isNaN(amount)) {
      return new Date(NaN);
    }
    if (!amount) {
      return date;
    }
    date.setDate(date.getDate() + amount);
    return date;
  }

  // ../../node_modules/date-fns/esm/addMonths/index.js
  function addMonths(dirtyDate, dirtyAmount) {
    requiredArgs(2, arguments);
    var date = toDate2(dirtyDate);
    var amount = toInteger(dirtyAmount);
    if (isNaN(amount)) {
      return new Date(NaN);
    }
    if (!amount) {
      return date;
    }
    var dayOfMonth = date.getDate();
    var endOfDesiredMonth = new Date(date.getTime());
    endOfDesiredMonth.setMonth(date.getMonth() + amount + 1, 0);
    var daysInMonth = endOfDesiredMonth.getDate();
    if (dayOfMonth >= daysInMonth) {
      return endOfDesiredMonth;
    } else {
      date.setFullYear(endOfDesiredMonth.getFullYear(), endOfDesiredMonth.getMonth(), dayOfMonth);
      return date;
    }
  }

  // ../../node_modules/date-fns/esm/addMilliseconds/index.js
  function addMilliseconds(dirtyDate, dirtyAmount) {
    requiredArgs(2, arguments);
    var timestamp = toDate2(dirtyDate).getTime();
    var amount = toInteger(dirtyAmount);
    return new Date(timestamp + amount);
  }

  // ../../node_modules/date-fns/esm/addHours/index.js
  var MILLISECONDS_IN_HOUR = 36e5;
  function addHours(dirtyDate, dirtyAmount) {
    requiredArgs(2, arguments);
    var amount = toInteger(dirtyAmount);
    return addMilliseconds(dirtyDate, amount * MILLISECONDS_IN_HOUR);
  }

  // ../../node_modules/date-fns/esm/_lib/defaultOptions/index.js
  var defaultOptions3 = {};
  function getDefaultOptions() {
    return defaultOptions3;
  }

  // ../../node_modules/date-fns/esm/startOfWeek/index.js
  function startOfWeek(dirtyDate, options2) {
    var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
    requiredArgs(1, arguments);
    var defaultOptions4 = getDefaultOptions();
    var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options2 === null || options2 === void 0 ? void 0 : options2.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options2 === null || options2 === void 0 ? void 0 : (_options$locale = options2.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions4.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions4.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
      throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    }
    var date = toDate2(dirtyDate);
    var day = date.getDay();
    var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
    date.setDate(date.getDate() - diff);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  // ../../node_modules/date-fns/esm/_lib/getTimezoneOffsetInMilliseconds/index.js
  function getTimezoneOffsetInMilliseconds(date) {
    var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
    utcDate.setUTCFullYear(date.getFullYear());
    return date.getTime() - utcDate.getTime();
  }

  // ../../node_modules/date-fns/esm/startOfDay/index.js
  function startOfDay(dirtyDate) {
    requiredArgs(1, arguments);
    var date = toDate2(dirtyDate);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  // ../../node_modules/date-fns/esm/differenceInCalendarDays/index.js
  var MILLISECONDS_IN_DAY = 864e5;
  function differenceInCalendarDays(dirtyDateLeft, dirtyDateRight) {
    requiredArgs(2, arguments);
    var startOfDayLeft = startOfDay(dirtyDateLeft);
    var startOfDayRight = startOfDay(dirtyDateRight);
    var timestampLeft = startOfDayLeft.getTime() - getTimezoneOffsetInMilliseconds(startOfDayLeft);
    var timestampRight = startOfDayRight.getTime() - getTimezoneOffsetInMilliseconds(startOfDayRight);
    return Math.round((timestampLeft - timestampRight) / MILLISECONDS_IN_DAY);
  }

  // ../../node_modules/date-fns/esm/addMinutes/index.js
  var MILLISECONDS_IN_MINUTE = 6e4;
  function addMinutes(dirtyDate, dirtyAmount) {
    requiredArgs(2, arguments);
    var amount = toInteger(dirtyAmount);
    return addMilliseconds(dirtyDate, amount * MILLISECONDS_IN_MINUTE);
  }

  // ../../node_modules/date-fns/esm/addQuarters/index.js
  function addQuarters(dirtyDate, dirtyAmount) {
    requiredArgs(2, arguments);
    var amount = toInteger(dirtyAmount);
    var months = amount * 3;
    return addMonths(dirtyDate, months);
  }

  // ../../node_modules/date-fns/esm/addSeconds/index.js
  function addSeconds(dirtyDate, dirtyAmount) {
    requiredArgs(2, arguments);
    var amount = toInteger(dirtyAmount);
    return addMilliseconds(dirtyDate, amount * 1e3);
  }

  // ../../node_modules/date-fns/esm/addWeeks/index.js
  function addWeeks(dirtyDate, dirtyAmount) {
    requiredArgs(2, arguments);
    var amount = toInteger(dirtyAmount);
    var days = amount * 7;
    return addDays(dirtyDate, days);
  }

  // ../../node_modules/date-fns/esm/addYears/index.js
  function addYears(dirtyDate, dirtyAmount) {
    requiredArgs(2, arguments);
    var amount = toInteger(dirtyAmount);
    return addMonths(dirtyDate, amount * 12);
  }

  // ../../node_modules/date-fns/esm/compareAsc/index.js
  function compareAsc(dirtyDateLeft, dirtyDateRight) {
    requiredArgs(2, arguments);
    var dateLeft = toDate2(dirtyDateLeft);
    var dateRight = toDate2(dirtyDateRight);
    var diff = dateLeft.getTime() - dateRight.getTime();
    if (diff < 0) {
      return -1;
    } else if (diff > 0) {
      return 1;
    } else {
      return diff;
    }
  }

  // ../../node_modules/date-fns/esm/constants/index.js
  var daysInYear = 365.2425;
  var maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1e3;
  var millisecondsInMinute = 6e4;
  var millisecondsInHour = 36e5;
  var millisecondsInSecond = 1e3;
  var minTime = -maxTime;
  var secondsInHour = 3600;
  var secondsInDay = secondsInHour * 24;
  var secondsInWeek = secondsInDay * 7;
  var secondsInYear = secondsInDay * daysInYear;
  var secondsInMonth = secondsInYear / 12;
  var secondsInQuarter = secondsInMonth * 3;

  // ../../node_modules/date-fns/esm/isDate/index.js
  function _typeof2(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof2 = function _typeof36(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof2 = function _typeof36(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof2(obj);
  }
  function isDate2(value) {
    requiredArgs(1, arguments);
    return value instanceof Date || _typeof2(value) === "object" && Object.prototype.toString.call(value) === "[object Date]";
  }

  // ../../node_modules/date-fns/esm/isValid/index.js
  function isValid(dirtyDate) {
    requiredArgs(1, arguments);
    if (!isDate2(dirtyDate) && typeof dirtyDate !== "number") {
      return false;
    }
    var date = toDate2(dirtyDate);
    return !isNaN(Number(date));
  }

  // ../../node_modules/date-fns/esm/differenceInCalendarMonths/index.js
  function differenceInCalendarMonths(dirtyDateLeft, dirtyDateRight) {
    requiredArgs(2, arguments);
    var dateLeft = toDate2(dirtyDateLeft);
    var dateRight = toDate2(dirtyDateRight);
    var yearDiff = dateLeft.getFullYear() - dateRight.getFullYear();
    var monthDiff = dateLeft.getMonth() - dateRight.getMonth();
    return yearDiff * 12 + monthDiff;
  }

  // ../../node_modules/date-fns/esm/differenceInCalendarYears/index.js
  function differenceInCalendarYears(dirtyDateLeft, dirtyDateRight) {
    requiredArgs(2, arguments);
    var dateLeft = toDate2(dirtyDateLeft);
    var dateRight = toDate2(dirtyDateRight);
    return dateLeft.getFullYear() - dateRight.getFullYear();
  }

  // ../../node_modules/date-fns/esm/differenceInDays/index.js
  function compareLocalAsc(dateLeft, dateRight) {
    var diff = dateLeft.getFullYear() - dateRight.getFullYear() || dateLeft.getMonth() - dateRight.getMonth() || dateLeft.getDate() - dateRight.getDate() || dateLeft.getHours() - dateRight.getHours() || dateLeft.getMinutes() - dateRight.getMinutes() || dateLeft.getSeconds() - dateRight.getSeconds() || dateLeft.getMilliseconds() - dateRight.getMilliseconds();
    if (diff < 0) {
      return -1;
    } else if (diff > 0) {
      return 1;
    } else {
      return diff;
    }
  }
  function differenceInDays(dirtyDateLeft, dirtyDateRight) {
    requiredArgs(2, arguments);
    var dateLeft = toDate2(dirtyDateLeft);
    var dateRight = toDate2(dirtyDateRight);
    var sign2 = compareLocalAsc(dateLeft, dateRight);
    var difference = Math.abs(differenceInCalendarDays(dateLeft, dateRight));
    dateLeft.setDate(dateLeft.getDate() - sign2 * difference);
    var isLastDayNotFull = Number(compareLocalAsc(dateLeft, dateRight) === -sign2);
    var result = sign2 * (difference - isLastDayNotFull);
    return result === 0 ? 0 : result;
  }

  // ../../node_modules/date-fns/esm/differenceInMilliseconds/index.js
  function differenceInMilliseconds(dateLeft, dateRight) {
    requiredArgs(2, arguments);
    return toDate2(dateLeft).getTime() - toDate2(dateRight).getTime();
  }

  // ../../node_modules/date-fns/esm/_lib/roundingMethods/index.js
  var roundingMap = {
    ceil: Math.ceil,
    round: Math.round,
    floor: Math.floor,
    trunc: function trunc(value) {
      return value < 0 ? Math.ceil(value) : Math.floor(value);
    }
  };
  var defaultRoundingMethod = "trunc";
  function getRoundingMethod(method) {
    return method ? roundingMap[method] : roundingMap[defaultRoundingMethod];
  }

  // ../../node_modules/date-fns/esm/differenceInHours/index.js
  function differenceInHours(dateLeft, dateRight, options2) {
    requiredArgs(2, arguments);
    var diff = differenceInMilliseconds(dateLeft, dateRight) / millisecondsInHour;
    return getRoundingMethod(options2 === null || options2 === void 0 ? void 0 : options2.roundingMethod)(diff);
  }

  // ../../node_modules/date-fns/esm/differenceInMinutes/index.js
  function differenceInMinutes(dateLeft, dateRight, options2) {
    requiredArgs(2, arguments);
    var diff = differenceInMilliseconds(dateLeft, dateRight) / millisecondsInMinute;
    return getRoundingMethod(options2 === null || options2 === void 0 ? void 0 : options2.roundingMethod)(diff);
  }

  // ../../node_modules/date-fns/esm/endOfDay/index.js
  function endOfDay(dirtyDate) {
    requiredArgs(1, arguments);
    var date = toDate2(dirtyDate);
    date.setHours(23, 59, 59, 999);
    return date;
  }

  // ../../node_modules/date-fns/esm/endOfMonth/index.js
  function endOfMonth(dirtyDate) {
    requiredArgs(1, arguments);
    var date = toDate2(dirtyDate);
    var month = date.getMonth();
    date.setFullYear(date.getFullYear(), month + 1, 0);
    date.setHours(23, 59, 59, 999);
    return date;
  }

  // ../../node_modules/date-fns/esm/isLastDayOfMonth/index.js
  function isLastDayOfMonth(dirtyDate) {
    requiredArgs(1, arguments);
    var date = toDate2(dirtyDate);
    return endOfDay(date).getTime() === endOfMonth(date).getTime();
  }

  // ../../node_modules/date-fns/esm/differenceInMonths/index.js
  function differenceInMonths(dirtyDateLeft, dirtyDateRight) {
    requiredArgs(2, arguments);
    var dateLeft = toDate2(dirtyDateLeft);
    var dateRight = toDate2(dirtyDateRight);
    var sign2 = compareAsc(dateLeft, dateRight);
    var difference = Math.abs(differenceInCalendarMonths(dateLeft, dateRight));
    var result;
    if (difference < 1) {
      result = 0;
    } else {
      if (dateLeft.getMonth() === 1 && dateLeft.getDate() > 27) {
        dateLeft.setDate(30);
      }
      dateLeft.setMonth(dateLeft.getMonth() - sign2 * difference);
      var isLastMonthNotFull = compareAsc(dateLeft, dateRight) === -sign2;
      if (isLastDayOfMonth(toDate2(dirtyDateLeft)) && difference === 1 && compareAsc(dirtyDateLeft, dateRight) === 1) {
        isLastMonthNotFull = false;
      }
      result = sign2 * (difference - Number(isLastMonthNotFull));
    }
    return result === 0 ? 0 : result;
  }

  // ../../node_modules/date-fns/esm/differenceInQuarters/index.js
  function differenceInQuarters(dateLeft, dateRight, options2) {
    requiredArgs(2, arguments);
    var diff = differenceInMonths(dateLeft, dateRight) / 3;
    return getRoundingMethod(options2 === null || options2 === void 0 ? void 0 : options2.roundingMethod)(diff);
  }

  // ../../node_modules/date-fns/esm/differenceInSeconds/index.js
  function differenceInSeconds(dateLeft, dateRight, options2) {
    requiredArgs(2, arguments);
    var diff = differenceInMilliseconds(dateLeft, dateRight) / 1e3;
    return getRoundingMethod(options2 === null || options2 === void 0 ? void 0 : options2.roundingMethod)(diff);
  }

  // ../../node_modules/date-fns/esm/differenceInWeeks/index.js
  function differenceInWeeks(dateLeft, dateRight, options2) {
    requiredArgs(2, arguments);
    var diff = differenceInDays(dateLeft, dateRight) / 7;
    return getRoundingMethod(options2 === null || options2 === void 0 ? void 0 : options2.roundingMethod)(diff);
  }

  // ../../node_modules/date-fns/esm/differenceInYears/index.js
  function differenceInYears(dirtyDateLeft, dirtyDateRight) {
    requiredArgs(2, arguments);
    var dateLeft = toDate2(dirtyDateLeft);
    var dateRight = toDate2(dirtyDateRight);
    var sign2 = compareAsc(dateLeft, dateRight);
    var difference = Math.abs(differenceInCalendarYears(dateLeft, dateRight));
    dateLeft.setFullYear(1584);
    dateRight.setFullYear(1584);
    var isLastYearNotFull = compareAsc(dateLeft, dateRight) === -sign2;
    var result = sign2 * (difference - Number(isLastYearNotFull));
    return result === 0 ? 0 : result;
  }

  // ../../node_modules/date-fns/esm/startOfMinute/index.js
  function startOfMinute(dirtyDate) {
    requiredArgs(1, arguments);
    var date = toDate2(dirtyDate);
    date.setSeconds(0, 0);
    return date;
  }

  // ../../node_modules/date-fns/esm/startOfQuarter/index.js
  function startOfQuarter(dirtyDate) {
    requiredArgs(1, arguments);
    var date = toDate2(dirtyDate);
    var currentMonth = date.getMonth();
    var month = currentMonth - currentMonth % 3;
    date.setMonth(month, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  // ../../node_modules/date-fns/esm/startOfMonth/index.js
  function startOfMonth(dirtyDate) {
    requiredArgs(1, arguments);
    var date = toDate2(dirtyDate);
    date.setDate(1);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  // ../../node_modules/date-fns/esm/endOfYear/index.js
  function endOfYear(dirtyDate) {
    requiredArgs(1, arguments);
    var date = toDate2(dirtyDate);
    var year = date.getFullYear();
    date.setFullYear(year + 1, 0, 0);
    date.setHours(23, 59, 59, 999);
    return date;
  }

  // ../../node_modules/date-fns/esm/startOfYear/index.js
  function startOfYear(dirtyDate) {
    requiredArgs(1, arguments);
    var cleanDate = toDate2(dirtyDate);
    var date = new Date(0);
    date.setFullYear(cleanDate.getFullYear(), 0, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  // ../../node_modules/date-fns/esm/endOfHour/index.js
  function endOfHour(dirtyDate) {
    requiredArgs(1, arguments);
    var date = toDate2(dirtyDate);
    date.setMinutes(59, 59, 999);
    return date;
  }

  // ../../node_modules/date-fns/esm/endOfWeek/index.js
  function endOfWeek(dirtyDate, options2) {
    var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
    requiredArgs(1, arguments);
    var defaultOptions4 = getDefaultOptions();
    var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options2 === null || options2 === void 0 ? void 0 : options2.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options2 === null || options2 === void 0 ? void 0 : (_options$locale = options2.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions4.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions4.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
      throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    }
    var date = toDate2(dirtyDate);
    var day = date.getDay();
    var diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);
    date.setDate(date.getDate() + diff);
    date.setHours(23, 59, 59, 999);
    return date;
  }

  // ../../node_modules/date-fns/esm/endOfMinute/index.js
  function endOfMinute(dirtyDate) {
    requiredArgs(1, arguments);
    var date = toDate2(dirtyDate);
    date.setSeconds(59, 999);
    return date;
  }

  // ../../node_modules/date-fns/esm/endOfQuarter/index.js
  function endOfQuarter(dirtyDate) {
    requiredArgs(1, arguments);
    var date = toDate2(dirtyDate);
    var currentMonth = date.getMonth();
    var month = currentMonth - currentMonth % 3 + 3;
    date.setMonth(month, 0);
    date.setHours(23, 59, 59, 999);
    return date;
  }

  // ../../node_modules/date-fns/esm/endOfSecond/index.js
  function endOfSecond(dirtyDate) {
    requiredArgs(1, arguments);
    var date = toDate2(dirtyDate);
    date.setMilliseconds(999);
    return date;
  }

  // ../../node_modules/date-fns/esm/subMilliseconds/index.js
  function subMilliseconds(dirtyDate, dirtyAmount) {
    requiredArgs(2, arguments);
    var amount = toInteger(dirtyAmount);
    return addMilliseconds(dirtyDate, -amount);
  }

  // ../../node_modules/date-fns/esm/_lib/getUTCDayOfYear/index.js
  var MILLISECONDS_IN_DAY2 = 864e5;
  function getUTCDayOfYear(dirtyDate) {
    requiredArgs(1, arguments);
    var date = toDate2(dirtyDate);
    var timestamp = date.getTime();
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
    var startOfYearTimestamp = date.getTime();
    var difference = timestamp - startOfYearTimestamp;
    return Math.floor(difference / MILLISECONDS_IN_DAY2) + 1;
  }

  // ../../node_modules/date-fns/esm/_lib/startOfUTCISOWeek/index.js
  function startOfUTCISOWeek(dirtyDate) {
    requiredArgs(1, arguments);
    var weekStartsOn = 1;
    var date = toDate2(dirtyDate);
    var day = date.getUTCDay();
    var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
    date.setUTCDate(date.getUTCDate() - diff);
    date.setUTCHours(0, 0, 0, 0);
    return date;
  }

  // ../../node_modules/date-fns/esm/_lib/getUTCISOWeekYear/index.js
  function getUTCISOWeekYear(dirtyDate) {
    requiredArgs(1, arguments);
    var date = toDate2(dirtyDate);
    var year = date.getUTCFullYear();
    var fourthOfJanuaryOfNextYear = new Date(0);
    fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
    fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
    var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
    var fourthOfJanuaryOfThisYear = new Date(0);
    fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
    fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
    var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);
    if (date.getTime() >= startOfNextYear.getTime()) {
      return year + 1;
    } else if (date.getTime() >= startOfThisYear.getTime()) {
      return year;
    } else {
      return year - 1;
    }
  }

  // ../../node_modules/date-fns/esm/_lib/startOfUTCISOWeekYear/index.js
  function startOfUTCISOWeekYear(dirtyDate) {
    requiredArgs(1, arguments);
    var year = getUTCISOWeekYear(dirtyDate);
    var fourthOfJanuary = new Date(0);
    fourthOfJanuary.setUTCFullYear(year, 0, 4);
    fourthOfJanuary.setUTCHours(0, 0, 0, 0);
    var date = startOfUTCISOWeek(fourthOfJanuary);
    return date;
  }

  // ../../node_modules/date-fns/esm/_lib/getUTCISOWeek/index.js
  var MILLISECONDS_IN_WEEK = 6048e5;
  function getUTCISOWeek(dirtyDate) {
    requiredArgs(1, arguments);
    var date = toDate2(dirtyDate);
    var diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime();
    return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
  }

  // ../../node_modules/date-fns/esm/_lib/startOfUTCWeek/index.js
  function startOfUTCWeek(dirtyDate, options2) {
    var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
    requiredArgs(1, arguments);
    var defaultOptions4 = getDefaultOptions();
    var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options2 === null || options2 === void 0 ? void 0 : options2.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options2 === null || options2 === void 0 ? void 0 : (_options$locale = options2.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions4.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions4.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
      throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    }
    var date = toDate2(dirtyDate);
    var day = date.getUTCDay();
    var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
    date.setUTCDate(date.getUTCDate() - diff);
    date.setUTCHours(0, 0, 0, 0);
    return date;
  }

  // ../../node_modules/date-fns/esm/_lib/getUTCWeekYear/index.js
  function getUTCWeekYear(dirtyDate, options2) {
    var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
    requiredArgs(1, arguments);
    var date = toDate2(dirtyDate);
    var year = date.getUTCFullYear();
    var defaultOptions4 = getDefaultOptions();
    var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options2 === null || options2 === void 0 ? void 0 : options2.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options2 === null || options2 === void 0 ? void 0 : (_options$locale = options2.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions4.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions4.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
    if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
      throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
    }
    var firstWeekOfNextYear = new Date(0);
    firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
    firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
    var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, options2);
    var firstWeekOfThisYear = new Date(0);
    firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
    firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
    var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, options2);
    if (date.getTime() >= startOfNextYear.getTime()) {
      return year + 1;
    } else if (date.getTime() >= startOfThisYear.getTime()) {
      return year;
    } else {
      return year - 1;
    }
  }

  // ../../node_modules/date-fns/esm/_lib/startOfUTCWeekYear/index.js
  function startOfUTCWeekYear(dirtyDate, options2) {
    var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
    requiredArgs(1, arguments);
    var defaultOptions4 = getDefaultOptions();
    var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options2 === null || options2 === void 0 ? void 0 : options2.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options2 === null || options2 === void 0 ? void 0 : (_options$locale = options2.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions4.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions4.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
    var year = getUTCWeekYear(dirtyDate, options2);
    var firstWeek = new Date(0);
    firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
    firstWeek.setUTCHours(0, 0, 0, 0);
    var date = startOfUTCWeek(firstWeek, options2);
    return date;
  }

  // ../../node_modules/date-fns/esm/_lib/getUTCWeek/index.js
  var MILLISECONDS_IN_WEEK2 = 6048e5;
  function getUTCWeek(dirtyDate, options2) {
    requiredArgs(1, arguments);
    var date = toDate2(dirtyDate);
    var diff = startOfUTCWeek(date, options2).getTime() - startOfUTCWeekYear(date, options2).getTime();
    return Math.round(diff / MILLISECONDS_IN_WEEK2) + 1;
  }

  // ../../node_modules/date-fns/esm/_lib/addLeadingZeros/index.js
  function addLeadingZeros(number, targetLength) {
    var sign2 = number < 0 ? "-" : "";
    var output = Math.abs(number).toString();
    while (output.length < targetLength) {
      output = "0" + output;
    }
    return sign2 + output;
  }

  // ../../node_modules/date-fns/esm/_lib/format/lightFormatters/index.js
  var formatters2 = {
    y: function y(date, token) {
      var signedYear = date.getUTCFullYear();
      var year = signedYear > 0 ? signedYear : 1 - signedYear;
      return addLeadingZeros(token === "yy" ? year % 100 : year, token.length);
    },
    M: function M(date, token) {
      var month = date.getUTCMonth();
      return token === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
    },
    d: function d(date, token) {
      return addLeadingZeros(date.getUTCDate(), token.length);
    },
    a: function a(date, token) {
      var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? "pm" : "am";
      switch (token) {
        case "a":
        case "aa":
          return dayPeriodEnumValue.toUpperCase();
        case "aaa":
          return dayPeriodEnumValue;
        case "aaaaa":
          return dayPeriodEnumValue[0];
        case "aaaa":
        default:
          return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
      }
    },
    h: function h(date, token) {
      return addLeadingZeros(date.getUTCHours() % 12 || 12, token.length);
    },
    H: function H(date, token) {
      return addLeadingZeros(date.getUTCHours(), token.length);
    },
    m: function m(date, token) {
      return addLeadingZeros(date.getUTCMinutes(), token.length);
    },
    s: function s(date, token) {
      return addLeadingZeros(date.getUTCSeconds(), token.length);
    },
    S: function S(date, token) {
      var numberOfDigits = token.length;
      var milliseconds = date.getUTCMilliseconds();
      var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
      return addLeadingZeros(fractionalSeconds, token.length);
    }
  };
  var lightFormatters_default = formatters2;

  // ../../node_modules/date-fns/esm/_lib/format/formatters/index.js
  var dayPeriodEnum = {
    am: "am",
    pm: "pm",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  };
  var formatters3 = {
    G: function G(date, token, localize2) {
      var era = date.getUTCFullYear() > 0 ? 1 : 0;
      switch (token) {
        case "G":
        case "GG":
        case "GGG":
          return localize2.era(era, {
            width: "abbreviated"
          });
        case "GGGGG":
          return localize2.era(era, {
            width: "narrow"
          });
        case "GGGG":
        default:
          return localize2.era(era, {
            width: "wide"
          });
      }
    },
    y: function y2(date, token, localize2) {
      if (token === "yo") {
        var signedYear = date.getUTCFullYear();
        var year = signedYear > 0 ? signedYear : 1 - signedYear;
        return localize2.ordinalNumber(year, {
          unit: "year"
        });
      }
      return lightFormatters_default.y(date, token);
    },
    Y: function Y(date, token, localize2, options2) {
      var signedWeekYear = getUTCWeekYear(date, options2);
      var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
      if (token === "YY") {
        var twoDigitYear = weekYear % 100;
        return addLeadingZeros(twoDigitYear, 2);
      }
      if (token === "Yo") {
        return localize2.ordinalNumber(weekYear, {
          unit: "year"
        });
      }
      return addLeadingZeros(weekYear, token.length);
    },
    R: function R(date, token) {
      var isoWeekYear = getUTCISOWeekYear(date);
      return addLeadingZeros(isoWeekYear, token.length);
    },
    u: function u(date, token) {
      var year = date.getUTCFullYear();
      return addLeadingZeros(year, token.length);
    },
    Q: function Q(date, token, localize2) {
      var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
      switch (token) {
        case "Q":
          return String(quarter);
        case "QQ":
          return addLeadingZeros(quarter, 2);
        case "Qo":
          return localize2.ordinalNumber(quarter, {
            unit: "quarter"
          });
        case "QQQ":
          return localize2.quarter(quarter, {
            width: "abbreviated",
            context: "formatting"
          });
        case "QQQQQ":
          return localize2.quarter(quarter, {
            width: "narrow",
            context: "formatting"
          });
        case "QQQQ":
        default:
          return localize2.quarter(quarter, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    q: function q(date, token, localize2) {
      var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
      switch (token) {
        case "q":
          return String(quarter);
        case "qq":
          return addLeadingZeros(quarter, 2);
        case "qo":
          return localize2.ordinalNumber(quarter, {
            unit: "quarter"
          });
        case "qqq":
          return localize2.quarter(quarter, {
            width: "abbreviated",
            context: "standalone"
          });
        case "qqqqq":
          return localize2.quarter(quarter, {
            width: "narrow",
            context: "standalone"
          });
        case "qqqq":
        default:
          return localize2.quarter(quarter, {
            width: "wide",
            context: "standalone"
          });
      }
    },
    M: function M2(date, token, localize2) {
      var month = date.getUTCMonth();
      switch (token) {
        case "M":
        case "MM":
          return lightFormatters_default.M(date, token);
        case "Mo":
          return localize2.ordinalNumber(month + 1, {
            unit: "month"
          });
        case "MMM":
          return localize2.month(month, {
            width: "abbreviated",
            context: "formatting"
          });
        case "MMMMM":
          return localize2.month(month, {
            width: "narrow",
            context: "formatting"
          });
        case "MMMM":
        default:
          return localize2.month(month, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    L: function L(date, token, localize2) {
      var month = date.getUTCMonth();
      switch (token) {
        case "L":
          return String(month + 1);
        case "LL":
          return addLeadingZeros(month + 1, 2);
        case "Lo":
          return localize2.ordinalNumber(month + 1, {
            unit: "month"
          });
        case "LLL":
          return localize2.month(month, {
            width: "abbreviated",
            context: "standalone"
          });
        case "LLLLL":
          return localize2.month(month, {
            width: "narrow",
            context: "standalone"
          });
        case "LLLL":
        default:
          return localize2.month(month, {
            width: "wide",
            context: "standalone"
          });
      }
    },
    w: function w(date, token, localize2, options2) {
      var week = getUTCWeek(date, options2);
      if (token === "wo") {
        return localize2.ordinalNumber(week, {
          unit: "week"
        });
      }
      return addLeadingZeros(week, token.length);
    },
    I: function I(date, token, localize2) {
      var isoWeek = getUTCISOWeek(date);
      if (token === "Io") {
        return localize2.ordinalNumber(isoWeek, {
          unit: "week"
        });
      }
      return addLeadingZeros(isoWeek, token.length);
    },
    d: function d2(date, token, localize2) {
      if (token === "do") {
        return localize2.ordinalNumber(date.getUTCDate(), {
          unit: "date"
        });
      }
      return lightFormatters_default.d(date, token);
    },
    D: function D(date, token, localize2) {
      var dayOfYear = getUTCDayOfYear(date);
      if (token === "Do") {
        return localize2.ordinalNumber(dayOfYear, {
          unit: "dayOfYear"
        });
      }
      return addLeadingZeros(dayOfYear, token.length);
    },
    E: function E(date, token, localize2) {
      var dayOfWeek = date.getUTCDay();
      switch (token) {
        case "E":
        case "EE":
        case "EEE":
          return localize2.day(dayOfWeek, {
            width: "abbreviated",
            context: "formatting"
          });
        case "EEEEE":
          return localize2.day(dayOfWeek, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEEEE":
          return localize2.day(dayOfWeek, {
            width: "short",
            context: "formatting"
          });
        case "EEEE":
        default:
          return localize2.day(dayOfWeek, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    e: function e(date, token, localize2, options2) {
      var dayOfWeek = date.getUTCDay();
      var localDayOfWeek = (dayOfWeek - options2.weekStartsOn + 8) % 7 || 7;
      switch (token) {
        case "e":
          return String(localDayOfWeek);
        case "ee":
          return addLeadingZeros(localDayOfWeek, 2);
        case "eo":
          return localize2.ordinalNumber(localDayOfWeek, {
            unit: "day"
          });
        case "eee":
          return localize2.day(dayOfWeek, {
            width: "abbreviated",
            context: "formatting"
          });
        case "eeeee":
          return localize2.day(dayOfWeek, {
            width: "narrow",
            context: "formatting"
          });
        case "eeeeee":
          return localize2.day(dayOfWeek, {
            width: "short",
            context: "formatting"
          });
        case "eeee":
        default:
          return localize2.day(dayOfWeek, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    c: function c(date, token, localize2, options2) {
      var dayOfWeek = date.getUTCDay();
      var localDayOfWeek = (dayOfWeek - options2.weekStartsOn + 8) % 7 || 7;
      switch (token) {
        case "c":
          return String(localDayOfWeek);
        case "cc":
          return addLeadingZeros(localDayOfWeek, token.length);
        case "co":
          return localize2.ordinalNumber(localDayOfWeek, {
            unit: "day"
          });
        case "ccc":
          return localize2.day(dayOfWeek, {
            width: "abbreviated",
            context: "standalone"
          });
        case "ccccc":
          return localize2.day(dayOfWeek, {
            width: "narrow",
            context: "standalone"
          });
        case "cccccc":
          return localize2.day(dayOfWeek, {
            width: "short",
            context: "standalone"
          });
        case "cccc":
        default:
          return localize2.day(dayOfWeek, {
            width: "wide",
            context: "standalone"
          });
      }
    },
    i: function i(date, token, localize2) {
      var dayOfWeek = date.getUTCDay();
      var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
      switch (token) {
        case "i":
          return String(isoDayOfWeek);
        case "ii":
          return addLeadingZeros(isoDayOfWeek, token.length);
        case "io":
          return localize2.ordinalNumber(isoDayOfWeek, {
            unit: "day"
          });
        case "iii":
          return localize2.day(dayOfWeek, {
            width: "abbreviated",
            context: "formatting"
          });
        case "iiiii":
          return localize2.day(dayOfWeek, {
            width: "narrow",
            context: "formatting"
          });
        case "iiiiii":
          return localize2.day(dayOfWeek, {
            width: "short",
            context: "formatting"
          });
        case "iiii":
        default:
          return localize2.day(dayOfWeek, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    a: function a2(date, token, localize2) {
      var hours = date.getUTCHours();
      var dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
      switch (token) {
        case "a":
        case "aa":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          });
        case "aaa":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          }).toLowerCase();
        case "aaaaa":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaa":
        default:
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    b: function b(date, token, localize2) {
      var hours = date.getUTCHours();
      var dayPeriodEnumValue;
      if (hours === 12) {
        dayPeriodEnumValue = dayPeriodEnum.noon;
      } else if (hours === 0) {
        dayPeriodEnumValue = dayPeriodEnum.midnight;
      } else {
        dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
      }
      switch (token) {
        case "b":
        case "bb":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          });
        case "bbb":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          }).toLowerCase();
        case "bbbbb":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbb":
        default:
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    B: function B(date, token, localize2) {
      var hours = date.getUTCHours();
      var dayPeriodEnumValue;
      if (hours >= 17) {
        dayPeriodEnumValue = dayPeriodEnum.evening;
      } else if (hours >= 12) {
        dayPeriodEnumValue = dayPeriodEnum.afternoon;
      } else if (hours >= 4) {
        dayPeriodEnumValue = dayPeriodEnum.morning;
      } else {
        dayPeriodEnumValue = dayPeriodEnum.night;
      }
      switch (token) {
        case "B":
        case "BB":
        case "BBB":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          });
        case "BBBBB":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBB":
        default:
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    h: function h3(date, token, localize2) {
      if (token === "ho") {
        var hours = date.getUTCHours() % 12;
        if (hours === 0)
          hours = 12;
        return localize2.ordinalNumber(hours, {
          unit: "hour"
        });
      }
      return lightFormatters_default.h(date, token);
    },
    H: function H2(date, token, localize2) {
      if (token === "Ho") {
        return localize2.ordinalNumber(date.getUTCHours(), {
          unit: "hour"
        });
      }
      return lightFormatters_default.H(date, token);
    },
    K: function K(date, token, localize2) {
      var hours = date.getUTCHours() % 12;
      if (token === "Ko") {
        return localize2.ordinalNumber(hours, {
          unit: "hour"
        });
      }
      return addLeadingZeros(hours, token.length);
    },
    k: function k(date, token, localize2) {
      var hours = date.getUTCHours();
      if (hours === 0)
        hours = 24;
      if (token === "ko") {
        return localize2.ordinalNumber(hours, {
          unit: "hour"
        });
      }
      return addLeadingZeros(hours, token.length);
    },
    m: function m2(date, token, localize2) {
      if (token === "mo") {
        return localize2.ordinalNumber(date.getUTCMinutes(), {
          unit: "minute"
        });
      }
      return lightFormatters_default.m(date, token);
    },
    s: function s2(date, token, localize2) {
      if (token === "so") {
        return localize2.ordinalNumber(date.getUTCSeconds(), {
          unit: "second"
        });
      }
      return lightFormatters_default.s(date, token);
    },
    S: function S2(date, token) {
      return lightFormatters_default.S(date, token);
    },
    X: function X(date, token, _localize, options2) {
      var originalDate = options2._originalDate || date;
      var timezoneOffset = originalDate.getTimezoneOffset();
      if (timezoneOffset === 0) {
        return "Z";
      }
      switch (token) {
        case "X":
          return formatTimezoneWithOptionalMinutes(timezoneOffset);
        case "XXXX":
        case "XX":
          return formatTimezone(timezoneOffset);
        case "XXXXX":
        case "XXX":
        default:
          return formatTimezone(timezoneOffset, ":");
      }
    },
    x: function x(date, token, _localize, options2) {
      var originalDate = options2._originalDate || date;
      var timezoneOffset = originalDate.getTimezoneOffset();
      switch (token) {
        case "x":
          return formatTimezoneWithOptionalMinutes(timezoneOffset);
        case "xxxx":
        case "xx":
          return formatTimezone(timezoneOffset);
        case "xxxxx":
        case "xxx":
        default:
          return formatTimezone(timezoneOffset, ":");
      }
    },
    O: function O(date, token, _localize, options2) {
      var originalDate = options2._originalDate || date;
      var timezoneOffset = originalDate.getTimezoneOffset();
      switch (token) {
        case "O":
        case "OO":
        case "OOO":
          return "GMT" + formatTimezoneShort(timezoneOffset, ":");
        case "OOOO":
        default:
          return "GMT" + formatTimezone(timezoneOffset, ":");
      }
    },
    z: function z(date, token, _localize, options2) {
      var originalDate = options2._originalDate || date;
      var timezoneOffset = originalDate.getTimezoneOffset();
      switch (token) {
        case "z":
        case "zz":
        case "zzz":
          return "GMT" + formatTimezoneShort(timezoneOffset, ":");
        case "zzzz":
        default:
          return "GMT" + formatTimezone(timezoneOffset, ":");
      }
    },
    t: function t(date, token, _localize, options2) {
      var originalDate = options2._originalDate || date;
      var timestamp = Math.floor(originalDate.getTime() / 1e3);
      return addLeadingZeros(timestamp, token.length);
    },
    T: function T(date, token, _localize, options2) {
      var originalDate = options2._originalDate || date;
      var timestamp = originalDate.getTime();
      return addLeadingZeros(timestamp, token.length);
    }
  };
  function formatTimezoneShort(offset2, dirtyDelimiter) {
    var sign2 = offset2 > 0 ? "-" : "+";
    var absOffset = Math.abs(offset2);
    var hours = Math.floor(absOffset / 60);
    var minutes = absOffset % 60;
    if (minutes === 0) {
      return sign2 + String(hours);
    }
    var delimiter = dirtyDelimiter || "";
    return sign2 + String(hours) + delimiter + addLeadingZeros(minutes, 2);
  }
  function formatTimezoneWithOptionalMinutes(offset2, dirtyDelimiter) {
    if (offset2 % 60 === 0) {
      var sign2 = offset2 > 0 ? "-" : "+";
      return sign2 + addLeadingZeros(Math.abs(offset2) / 60, 2);
    }
    return formatTimezone(offset2, dirtyDelimiter);
  }
  function formatTimezone(offset2, dirtyDelimiter) {
    var delimiter = dirtyDelimiter || "";
    var sign2 = offset2 > 0 ? "-" : "+";
    var absOffset = Math.abs(offset2);
    var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
    var minutes = addLeadingZeros(absOffset % 60, 2);
    return sign2 + hours + delimiter + minutes;
  }
  var formatters_default = formatters3;

  // ../../node_modules/date-fns/esm/_lib/format/longFormatters/index.js
  var dateLongFormatter = function dateLongFormatter2(pattern, formatLong2) {
    switch (pattern) {
      case "P":
        return formatLong2.date({
          width: "short"
        });
      case "PP":
        return formatLong2.date({
          width: "medium"
        });
      case "PPP":
        return formatLong2.date({
          width: "long"
        });
      case "PPPP":
      default:
        return formatLong2.date({
          width: "full"
        });
    }
  };
  var timeLongFormatter = function timeLongFormatter2(pattern, formatLong2) {
    switch (pattern) {
      case "p":
        return formatLong2.time({
          width: "short"
        });
      case "pp":
        return formatLong2.time({
          width: "medium"
        });
      case "ppp":
        return formatLong2.time({
          width: "long"
        });
      case "pppp":
      default:
        return formatLong2.time({
          width: "full"
        });
    }
  };
  var dateTimeLongFormatter = function dateTimeLongFormatter2(pattern, formatLong2) {
    var matchResult = pattern.match(/(P+)(p+)?/) || [];
    var datePattern = matchResult[1];
    var timePattern = matchResult[2];
    if (!timePattern) {
      return dateLongFormatter(pattern, formatLong2);
    }
    var dateTimeFormat;
    switch (datePattern) {
      case "P":
        dateTimeFormat = formatLong2.dateTime({
          width: "short"
        });
        break;
      case "PP":
        dateTimeFormat = formatLong2.dateTime({
          width: "medium"
        });
        break;
      case "PPP":
        dateTimeFormat = formatLong2.dateTime({
          width: "long"
        });
        break;
      case "PPPP":
      default:
        dateTimeFormat = formatLong2.dateTime({
          width: "full"
        });
        break;
    }
    return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
  };
  var longFormatters = {
    p: timeLongFormatter,
    P: dateTimeLongFormatter
  };
  var longFormatters_default = longFormatters;

  // ../../node_modules/date-fns/esm/_lib/protectedTokens/index.js
  var protectedDayOfYearTokens = ["D", "DD"];
  var protectedWeekYearTokens = ["YY", "YYYY"];
  function isProtectedDayOfYearToken(token) {
    return protectedDayOfYearTokens.indexOf(token) !== -1;
  }
  function isProtectedWeekYearToken(token) {
    return protectedWeekYearTokens.indexOf(token) !== -1;
  }
  function throwProtectedError(token, format3, input) {
    if (token === "YYYY") {
      throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format3, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
    } else if (token === "YY") {
      throw new RangeError("Use `yy` instead of `YY` (in `".concat(format3, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
    } else if (token === "D") {
      throw new RangeError("Use `d` instead of `D` (in `".concat(format3, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
    } else if (token === "DD") {
      throw new RangeError("Use `dd` instead of `DD` (in `".concat(format3, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
    }
  }

  // ../../node_modules/date-fns/esm/locale/en-US/_lib/formatDistance/index.js
  var formatDistanceLocale = {
    lessThanXSeconds: {
      one: "less than a second",
      other: "less than {{count}} seconds"
    },
    xSeconds: {
      one: "1 second",
      other: "{{count}} seconds"
    },
    halfAMinute: "half a minute",
    lessThanXMinutes: {
      one: "less than a minute",
      other: "less than {{count}} minutes"
    },
    xMinutes: {
      one: "1 minute",
      other: "{{count}} minutes"
    },
    aboutXHours: {
      one: "about 1 hour",
      other: "about {{count}} hours"
    },
    xHours: {
      one: "1 hour",
      other: "{{count}} hours"
    },
    xDays: {
      one: "1 day",
      other: "{{count}} days"
    },
    aboutXWeeks: {
      one: "about 1 week",
      other: "about {{count}} weeks"
    },
    xWeeks: {
      one: "1 week",
      other: "{{count}} weeks"
    },
    aboutXMonths: {
      one: "about 1 month",
      other: "about {{count}} months"
    },
    xMonths: {
      one: "1 month",
      other: "{{count}} months"
    },
    aboutXYears: {
      one: "about 1 year",
      other: "about {{count}} years"
    },
    xYears: {
      one: "1 year",
      other: "{{count}} years"
    },
    overXYears: {
      one: "over 1 year",
      other: "over {{count}} years"
    },
    almostXYears: {
      one: "almost 1 year",
      other: "almost {{count}} years"
    }
  };
  var formatDistance = function formatDistance2(token, count, options2) {
    var result;
    var tokenValue = formatDistanceLocale[token];
    if (typeof tokenValue === "string") {
      result = tokenValue;
    } else if (count === 1) {
      result = tokenValue.one;
    } else {
      result = tokenValue.other.replace("{{count}}", count.toString());
    }
    if (options2 !== null && options2 !== void 0 && options2.addSuffix) {
      if (options2.comparison && options2.comparison > 0) {
        return "in " + result;
      } else {
        return result + " ago";
      }
    }
    return result;
  };
  var formatDistance_default = formatDistance;

  // ../../node_modules/date-fns/esm/locale/_lib/buildFormatLongFn/index.js
  function buildFormatLongFn(args) {
    return function() {
      var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var width = options2.width ? String(options2.width) : args.defaultWidth;
      var format3 = args.formats[width] || args.formats[args.defaultWidth];
      return format3;
    };
  }

  // ../../node_modules/date-fns/esm/locale/en-US/_lib/formatLong/index.js
  var dateFormats = {
    full: "EEEE, MMMM do, y",
    long: "MMMM do, y",
    medium: "MMM d, y",
    short: "MM/dd/yyyy"
  };
  var timeFormats = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
  };
  var dateTimeFormats = {
    full: "{{date}} 'at' {{time}}",
    long: "{{date}} 'at' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
  };
  var formatLong = {
    date: buildFormatLongFn({
      formats: dateFormats,
      defaultWidth: "full"
    }),
    time: buildFormatLongFn({
      formats: timeFormats,
      defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
      formats: dateTimeFormats,
      defaultWidth: "full"
    })
  };
  var formatLong_default = formatLong;

  // ../../node_modules/date-fns/esm/locale/en-US/_lib/formatRelative/index.js
  var formatRelativeLocale = {
    lastWeek: "'last' eeee 'at' p",
    yesterday: "'yesterday at' p",
    today: "'today at' p",
    tomorrow: "'tomorrow at' p",
    nextWeek: "eeee 'at' p",
    other: "P"
  };
  var formatRelative = function formatRelative2(token, _date, _baseDate, _options) {
    return formatRelativeLocale[token];
  };
  var formatRelative_default = formatRelative;

  // ../../node_modules/date-fns/esm/locale/_lib/buildLocalizeFn/index.js
  function buildLocalizeFn(args) {
    return function(dirtyIndex, options2) {
      var context = options2 !== null && options2 !== void 0 && options2.context ? String(options2.context) : "standalone";
      var valuesArray;
      if (context === "formatting" && args.formattingValues) {
        var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
        var width = options2 !== null && options2 !== void 0 && options2.width ? String(options2.width) : defaultWidth;
        valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
      } else {
        var _defaultWidth = args.defaultWidth;
        var _width = options2 !== null && options2 !== void 0 && options2.width ? String(options2.width) : args.defaultWidth;
        valuesArray = args.values[_width] || args.values[_defaultWidth];
      }
      var index2 = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
      return valuesArray[index2];
    };
  }

  // ../../node_modules/date-fns/esm/locale/en-US/_lib/localize/index.js
  var eraValues = {
    narrow: ["B", "A"],
    abbreviated: ["BC", "AD"],
    wide: ["Before Christ", "Anno Domini"]
  };
  var quarterValues = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
    wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
  };
  var monthValues = {
    narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
    abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
  };
  var dayValues = {
    narrow: ["S", "M", "T", "W", "T", "F", "S"],
    short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
  };
  var dayPeriodValues = {
    narrow: {
      am: "a",
      pm: "p",
      midnight: "mi",
      noon: "n",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    },
    abbreviated: {
      am: "AM",
      pm: "PM",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    },
    wide: {
      am: "a.m.",
      pm: "p.m.",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    }
  };
  var formattingDayPeriodValues = {
    narrow: {
      am: "a",
      pm: "p",
      midnight: "mi",
      noon: "n",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    },
    abbreviated: {
      am: "AM",
      pm: "PM",
      midnight: "midnight",
      noon: "noon",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    },
    wide: {
      am: "a.m.",
      pm: "p.m.",
      midnight: "midnight",
      noon: "noon",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    }
  };
  var ordinalNumber = function ordinalNumber2(dirtyNumber, _options) {
    var number = Number(dirtyNumber);
    var rem100 = number % 100;
    if (rem100 > 20 || rem100 < 10) {
      switch (rem100 % 10) {
        case 1:
          return number + "st";
        case 2:
          return number + "nd";
        case 3:
          return number + "rd";
      }
    }
    return number + "th";
  };
  var localize = {
    ordinalNumber,
    era: buildLocalizeFn({
      values: eraValues,
      defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
      values: quarterValues,
      defaultWidth: "wide",
      argumentCallback: function argumentCallback(quarter) {
        return quarter - 1;
      }
    }),
    month: buildLocalizeFn({
      values: monthValues,
      defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
      values: dayValues,
      defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
      values: dayPeriodValues,
      defaultWidth: "wide",
      formattingValues: formattingDayPeriodValues,
      defaultFormattingWidth: "wide"
    })
  };
  var localize_default = localize;

  // ../../node_modules/date-fns/esm/locale/_lib/buildMatchFn/index.js
  function buildMatchFn(args) {
    return function(string) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var width = options2.width;
      var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
      var matchResult = string.match(matchPattern);
      if (!matchResult) {
        return null;
      }
      var matchedString = matchResult[0];
      var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
      var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function(pattern) {
        return pattern.test(matchedString);
      }) : findKey(parsePatterns, function(pattern) {
        return pattern.test(matchedString);
      });
      var value;
      value = args.valueCallback ? args.valueCallback(key) : key;
      value = options2.valueCallback ? options2.valueCallback(value) : value;
      var rest = string.slice(matchedString.length);
      return {
        value,
        rest
      };
    };
  }
  function findKey(object, predicate) {
    for (var key in object) {
      if (object.hasOwnProperty(key) && predicate(object[key])) {
        return key;
      }
    }
    return void 0;
  }
  function findIndex(array, predicate) {
    for (var key = 0; key < array.length; key++) {
      if (predicate(array[key])) {
        return key;
      }
    }
    return void 0;
  }

  // ../../node_modules/date-fns/esm/locale/_lib/buildMatchPatternFn/index.js
  function buildMatchPatternFn(args) {
    return function(string) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var matchResult = string.match(args.matchPattern);
      if (!matchResult)
        return null;
      var matchedString = matchResult[0];
      var parseResult = string.match(args.parsePattern);
      if (!parseResult)
        return null;
      var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
      value = options2.valueCallback ? options2.valueCallback(value) : value;
      var rest = string.slice(matchedString.length);
      return {
        value,
        rest
      };
    };
  }

  // ../../node_modules/date-fns/esm/locale/en-US/_lib/match/index.js
  var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
  var parseOrdinalNumberPattern = /\d+/i;
  var matchEraPatterns = {
    narrow: /^(b|a)/i,
    abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
    wide: /^(before christ|before common era|anno domini|common era)/i
  };
  var parseEraPatterns = {
    any: [/^b/i, /^(a|c)/i]
  };
  var matchQuarterPatterns = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234](th|st|nd|rd)? quarter/i
  };
  var parseQuarterPatterns = {
    any: [/1/i, /2/i, /3/i, /4/i]
  };
  var matchMonthPatterns = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
    wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
  };
  var parseMonthPatterns = {
    narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
    any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
  };
  var matchDayPatterns = {
    narrow: /^[smtwf]/i,
    short: /^(su|mo|tu|we|th|fr|sa)/i,
    abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
    wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
  };
  var parseDayPatterns = {
    narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
    any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
  };
  var matchDayPeriodPatterns = {
    narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
    any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
  };
  var parseDayPeriodPatterns = {
    any: {
      am: /^a/i,
      pm: /^p/i,
      midnight: /^mi/i,
      noon: /^no/i,
      morning: /morning/i,
      afternoon: /afternoon/i,
      evening: /evening/i,
      night: /night/i
    }
  };
  var match = {
    ordinalNumber: buildMatchPatternFn({
      matchPattern: matchOrdinalNumberPattern,
      parsePattern: parseOrdinalNumberPattern,
      valueCallback: function valueCallback(value) {
        return parseInt(value, 10);
      }
    }),
    era: buildMatchFn({
      matchPatterns: matchEraPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseEraPatterns,
      defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
      matchPatterns: matchQuarterPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseQuarterPatterns,
      defaultParseWidth: "any",
      valueCallback: function valueCallback2(index2) {
        return index2 + 1;
      }
    }),
    month: buildMatchFn({
      matchPatterns: matchMonthPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseMonthPatterns,
      defaultParseWidth: "any"
    }),
    day: buildMatchFn({
      matchPatterns: matchDayPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseDayPatterns,
      defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
      matchPatterns: matchDayPeriodPatterns,
      defaultMatchWidth: "any",
      parsePatterns: parseDayPeriodPatterns,
      defaultParseWidth: "any"
    })
  };
  var match_default = match;

  // ../../node_modules/date-fns/esm/locale/en-US/index.js
  var locale = {
    code: "en-US",
    formatDistance: formatDistance_default,
    formatLong: formatLong_default,
    formatRelative: formatRelative_default,
    localize: localize_default,
    match: match_default,
    options: {
      weekStartsOn: 0,
      firstWeekContainsDate: 1
    }
  };
  var en_US_default = locale;

  // ../../node_modules/date-fns/esm/_lib/defaultLocale/index.js
  var defaultLocale_default = en_US_default;

  // ../../node_modules/date-fns/esm/format/index.js
  var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
  var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
  var escapedStringRegExp = /^'([^]*?)'?$/;
  var doubleQuoteRegExp = /''/g;
  var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
  function format(dirtyDate, dirtyFormatStr, options2) {
    var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
    requiredArgs(2, arguments);
    var formatStr = String(dirtyFormatStr);
    var defaultOptions4 = getDefaultOptions();
    var locale2 = (_ref = (_options$locale = options2 === null || options2 === void 0 ? void 0 : options2.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions4.locale) !== null && _ref !== void 0 ? _ref : defaultLocale_default;
    var firstWeekContainsDate = toInteger((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options2 === null || options2 === void 0 ? void 0 : options2.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options2 === null || options2 === void 0 ? void 0 : (_options$locale2 = options2.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions4.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions4.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);
    if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
      throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
    }
    var weekStartsOn = toInteger((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options2 === null || options2 === void 0 ? void 0 : options2.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options2 === null || options2 === void 0 ? void 0 : (_options$locale3 = options2.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions4.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions4.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);
    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
      throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    }
    if (!locale2.localize) {
      throw new RangeError("locale must contain localize property");
    }
    if (!locale2.formatLong) {
      throw new RangeError("locale must contain formatLong property");
    }
    var originalDate = toDate2(dirtyDate);
    if (!isValid(originalDate)) {
      throw new RangeError("Invalid time value");
    }
    var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
    var utcDate = subMilliseconds(originalDate, timezoneOffset);
    var formatterOptions = {
      firstWeekContainsDate,
      weekStartsOn,
      locale: locale2,
      _originalDate: originalDate
    };
    var result = formatStr.match(longFormattingTokensRegExp).map(function(substring) {
      var firstCharacter = substring[0];
      if (firstCharacter === "p" || firstCharacter === "P") {
        var longFormatter = longFormatters_default[firstCharacter];
        return longFormatter(substring, locale2.formatLong);
      }
      return substring;
    }).join("").match(formattingTokensRegExp).map(function(substring) {
      if (substring === "''") {
        return "'";
      }
      var firstCharacter = substring[0];
      if (firstCharacter === "'") {
        return cleanEscapedString(substring);
      }
      var formatter = formatters_default[firstCharacter];
      if (formatter) {
        if (!(options2 !== null && options2 !== void 0 && options2.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(substring)) {
          throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
        }
        if (!(options2 !== null && options2 !== void 0 && options2.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(substring)) {
          throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
        }
        return formatter(utcDate, substring, locale2.localize, formatterOptions);
      }
      if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
        throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
      }
      return substring;
    }).join("");
    return result;
  }
  function cleanEscapedString(input) {
    var matched = input.match(escapedStringRegExp);
    if (!matched) {
      return input;
    }
    return matched[1].replace(doubleQuoteRegExp, "'");
  }

  // ../../node_modules/date-fns/esm/_lib/assign/index.js
  function assign(target, object) {
    if (target == null) {
      throw new TypeError("assign requires that input parameter not be null or undefined");
    }
    for (var property in object) {
      if (Object.prototype.hasOwnProperty.call(object, property)) {
        ;
        target[property] = object[property];
      }
    }
    return target;
  }

  // ../../node_modules/date-fns/esm/parse/_lib/Setter.js
  function _typeof3(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof3 = function _typeof36(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof3 = function _typeof36(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof3(obj);
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
    if (superClass)
      _setPrototypeOf(subClass, superClass);
  }
  function _setPrototypeOf(o2, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf34(o3, p2) {
      o3.__proto__ = p2;
      return o3;
    };
    return _setPrototypeOf(o2, p);
  }
  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _possibleConstructorReturn(self2, call) {
    if (call && (_typeof3(call) === "object" || typeof call === "function")) {
      return call;
    }
    return _assertThisInitialized(self2);
  }
  function _assertThisInitialized(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e3) {
      return false;
    }
  }
  function _getPrototypeOf(o2) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf34(o3) {
      return o3.__proto__ || Object.getPrototypeOf(o3);
    };
    return _getPrototypeOf(o2);
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i3 = 0; i3 < props.length; i3++) {
      var descriptor = props[i3];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var TIMEZONE_UNIT_PRIORITY = 10;
  var Setter = /* @__PURE__ */ function() {
    function Setter2() {
      _classCallCheck(this, Setter2);
      _defineProperty(this, "subPriority", 0);
    }
    _createClass(Setter2, [{
      key: "validate",
      value: function validate(_utcDate, _options) {
        return true;
      }
    }]);
    return Setter2;
  }();
  var ValueSetter = /* @__PURE__ */ function(_Setter) {
    _inherits(ValueSetter2, _Setter);
    var _super = _createSuper(ValueSetter2);
    function ValueSetter2(value, validateValue, setValue, priority, subPriority) {
      var _this;
      _classCallCheck(this, ValueSetter2);
      _this = _super.call(this);
      _this.value = value;
      _this.validateValue = validateValue;
      _this.setValue = setValue;
      _this.priority = priority;
      if (subPriority) {
        _this.subPriority = subPriority;
      }
      return _this;
    }
    _createClass(ValueSetter2, [{
      key: "validate",
      value: function validate(utcDate, options2) {
        return this.validateValue(utcDate, this.value, options2);
      }
    }, {
      key: "set",
      value: function set2(utcDate, flags, options2) {
        return this.setValue(utcDate, flags, this.value, options2);
      }
    }]);
    return ValueSetter2;
  }(Setter);
  var DateToSystemTimezoneSetter = /* @__PURE__ */ function(_Setter2) {
    _inherits(DateToSystemTimezoneSetter2, _Setter2);
    var _super2 = _createSuper(DateToSystemTimezoneSetter2);
    function DateToSystemTimezoneSetter2() {
      var _this2;
      _classCallCheck(this, DateToSystemTimezoneSetter2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this2 = _super2.call.apply(_super2, [this].concat(args));
      _defineProperty(_assertThisInitialized(_this2), "priority", TIMEZONE_UNIT_PRIORITY);
      _defineProperty(_assertThisInitialized(_this2), "subPriority", -1);
      return _this2;
    }
    _createClass(DateToSystemTimezoneSetter2, [{
      key: "set",
      value: function set2(date, flags) {
        if (flags.timestampIsSet) {
          return date;
        }
        var convertedDate = new Date(0);
        convertedDate.setFullYear(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
        convertedDate.setHours(date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
        return convertedDate;
      }
    }]);
    return DateToSystemTimezoneSetter2;
  }(Setter);

  // ../../node_modules/date-fns/esm/parse/_lib/Parser.js
  function _classCallCheck2(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties2(target, props) {
    for (var i3 = 0; i3 < props.length; i3++) {
      var descriptor = props[i3];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass2(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties2(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties2(Constructor, staticProps);
    return Constructor;
  }
  var Parser = /* @__PURE__ */ function() {
    function Parser2() {
      _classCallCheck2(this, Parser2);
    }
    _createClass2(Parser2, [{
      key: "run",
      value: function run(dateString, token, match2, options2) {
        var result = this.parse(dateString, token, match2, options2);
        if (!result) {
          return null;
        }
        return {
          setter: new ValueSetter(result.value, this.validate, this.set, this.priority, this.subPriority),
          rest: result.rest
        };
      }
    }, {
      key: "validate",
      value: function validate(_utcDate, _value, _options) {
        return true;
      }
    }]);
    return Parser2;
  }();

  // ../../node_modules/date-fns/esm/parse/_lib/parsers/EraParser.js
  function _typeof4(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof4 = function _typeof36(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof4 = function _typeof36(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof4(obj);
  }
  function _classCallCheck3(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties3(target, props) {
    for (var i3 = 0; i3 < props.length; i3++) {
      var descriptor = props[i3];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass3(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties3(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties3(Constructor, staticProps);
    return Constructor;
  }
  function _inherits2(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
    if (superClass)
      _setPrototypeOf2(subClass, superClass);
  }
  function _setPrototypeOf2(o2, p) {
    _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf34(o3, p2) {
      o3.__proto__ = p2;
      return o3;
    };
    return _setPrototypeOf2(o2, p);
  }
  function _createSuper2(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct2();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf2(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf2(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn2(this, result);
    };
  }
  function _possibleConstructorReturn2(self2, call) {
    if (call && (_typeof4(call) === "object" || typeof call === "function")) {
      return call;
    }
    return _assertThisInitialized2(self2);
  }
  function _assertThisInitialized2(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _isNativeReflectConstruct2() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e3) {
      return false;
    }
  }
  function _getPrototypeOf2(o2) {
    _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf34(o3) {
      return o3.__proto__ || Object.getPrototypeOf(o3);
    };
    return _getPrototypeOf2(o2);
  }
  function _defineProperty2(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var EraParser = /* @__PURE__ */ function(_Parser) {
    _inherits2(EraParser2, _Parser);
    var _super = _createSuper2(EraParser2);
    function EraParser2() {
      var _this;
      _classCallCheck3(this, EraParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty2(_assertThisInitialized2(_this), "priority", 140);
      _defineProperty2(_assertThisInitialized2(_this), "incompatibleTokens", ["R", "u", "t", "T"]);
      return _this;
    }
    _createClass3(EraParser2, [{
      key: "parse",
      value: function parse3(dateString, token, match2) {
        switch (token) {
          case "G":
          case "GG":
          case "GGG":
            return match2.era(dateString, {
              width: "abbreviated"
            }) || match2.era(dateString, {
              width: "narrow"
            });
          case "GGGGG":
            return match2.era(dateString, {
              width: "narrow"
            });
          case "GGGG":
          default:
            return match2.era(dateString, {
              width: "wide"
            }) || match2.era(dateString, {
              width: "abbreviated"
            }) || match2.era(dateString, {
              width: "narrow"
            });
        }
      }
    }, {
      key: "set",
      value: function set2(date, flags, value) {
        flags.era = value;
        date.setUTCFullYear(value, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }
    }]);
    return EraParser2;
  }(Parser);

  // ../../node_modules/date-fns/esm/parse/_lib/constants.js
  var numericPatterns = {
    month: /^(1[0-2]|0?\d)/,
    date: /^(3[0-1]|[0-2]?\d)/,
    dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
    week: /^(5[0-3]|[0-4]?\d)/,
    hour23h: /^(2[0-3]|[0-1]?\d)/,
    hour24h: /^(2[0-4]|[0-1]?\d)/,
    hour11h: /^(1[0-1]|0?\d)/,
    hour12h: /^(1[0-2]|0?\d)/,
    minute: /^[0-5]?\d/,
    second: /^[0-5]?\d/,
    singleDigit: /^\d/,
    twoDigits: /^\d{1,2}/,
    threeDigits: /^\d{1,3}/,
    fourDigits: /^\d{1,4}/,
    anyDigitsSigned: /^-?\d+/,
    singleDigitSigned: /^-?\d/,
    twoDigitsSigned: /^-?\d{1,2}/,
    threeDigitsSigned: /^-?\d{1,3}/,
    fourDigitsSigned: /^-?\d{1,4}/
  };
  var timezonePatterns = {
    basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
    basic: /^([+-])(\d{2})(\d{2})|Z/,
    basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
    extended: /^([+-])(\d{2}):(\d{2})|Z/,
    extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
  };

  // ../../node_modules/date-fns/esm/parse/_lib/utils.js
  function mapValue(parseFnResult, mapFn) {
    if (!parseFnResult) {
      return parseFnResult;
    }
    return {
      value: mapFn(parseFnResult.value),
      rest: parseFnResult.rest
    };
  }
  function parseNumericPattern(pattern, dateString) {
    var matchResult = dateString.match(pattern);
    if (!matchResult) {
      return null;
    }
    return {
      value: parseInt(matchResult[0], 10),
      rest: dateString.slice(matchResult[0].length)
    };
  }
  function parseTimezonePattern(pattern, dateString) {
    var matchResult = dateString.match(pattern);
    if (!matchResult) {
      return null;
    }
    if (matchResult[0] === "Z") {
      return {
        value: 0,
        rest: dateString.slice(1)
      };
    }
    var sign2 = matchResult[1] === "+" ? 1 : -1;
    var hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
    var minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
    var seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
    return {
      value: sign2 * (hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * millisecondsInSecond),
      rest: dateString.slice(matchResult[0].length)
    };
  }
  function parseAnyDigitsSigned(dateString) {
    return parseNumericPattern(numericPatterns.anyDigitsSigned, dateString);
  }
  function parseNDigits(n2, dateString) {
    switch (n2) {
      case 1:
        return parseNumericPattern(numericPatterns.singleDigit, dateString);
      case 2:
        return parseNumericPattern(numericPatterns.twoDigits, dateString);
      case 3:
        return parseNumericPattern(numericPatterns.threeDigits, dateString);
      case 4:
        return parseNumericPattern(numericPatterns.fourDigits, dateString);
      default:
        return parseNumericPattern(new RegExp("^\\d{1," + n2 + "}"), dateString);
    }
  }
  function parseNDigitsSigned(n2, dateString) {
    switch (n2) {
      case 1:
        return parseNumericPattern(numericPatterns.singleDigitSigned, dateString);
      case 2:
        return parseNumericPattern(numericPatterns.twoDigitsSigned, dateString);
      case 3:
        return parseNumericPattern(numericPatterns.threeDigitsSigned, dateString);
      case 4:
        return parseNumericPattern(numericPatterns.fourDigitsSigned, dateString);
      default:
        return parseNumericPattern(new RegExp("^-?\\d{1," + n2 + "}"), dateString);
    }
  }
  function dayPeriodEnumToHours(dayPeriod) {
    switch (dayPeriod) {
      case "morning":
        return 4;
      case "evening":
        return 17;
      case "pm":
      case "noon":
      case "afternoon":
        return 12;
      case "am":
      case "midnight":
      case "night":
      default:
        return 0;
    }
  }
  function normalizeTwoDigitYear(twoDigitYear, currentYear) {
    var isCommonEra = currentYear > 0;
    var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
    var result;
    if (absCurrentYear <= 50) {
      result = twoDigitYear || 100;
    } else {
      var rangeEnd = absCurrentYear + 50;
      var rangeEndCentury = Math.floor(rangeEnd / 100) * 100;
      var isPreviousCentury = twoDigitYear >= rangeEnd % 100;
      result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
    }
    return isCommonEra ? result : 1 - result;
  }
  function isLeapYearIndex(year) {
    return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
  }

  // ../../node_modules/date-fns/esm/parse/_lib/parsers/YearParser.js
  function _typeof5(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof5 = function _typeof36(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof5 = function _typeof36(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof5(obj);
  }
  function _classCallCheck4(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties4(target, props) {
    for (var i3 = 0; i3 < props.length; i3++) {
      var descriptor = props[i3];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass4(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties4(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties4(Constructor, staticProps);
    return Constructor;
  }
  function _inherits3(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
    if (superClass)
      _setPrototypeOf3(subClass, superClass);
  }
  function _setPrototypeOf3(o2, p) {
    _setPrototypeOf3 = Object.setPrototypeOf || function _setPrototypeOf34(o3, p2) {
      o3.__proto__ = p2;
      return o3;
    };
    return _setPrototypeOf3(o2, p);
  }
  function _createSuper3(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct3();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf3(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf3(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn3(this, result);
    };
  }
  function _possibleConstructorReturn3(self2, call) {
    if (call && (_typeof5(call) === "object" || typeof call === "function")) {
      return call;
    }
    return _assertThisInitialized3(self2);
  }
  function _assertThisInitialized3(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _isNativeReflectConstruct3() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e3) {
      return false;
    }
  }
  function _getPrototypeOf3(o2) {
    _getPrototypeOf3 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf34(o3) {
      return o3.__proto__ || Object.getPrototypeOf(o3);
    };
    return _getPrototypeOf3(o2);
  }
  function _defineProperty3(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var YearParser = /* @__PURE__ */ function(_Parser) {
    _inherits3(YearParser2, _Parser);
    var _super = _createSuper3(YearParser2);
    function YearParser2() {
      var _this;
      _classCallCheck4(this, YearParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty3(_assertThisInitialized3(_this), "priority", 130);
      _defineProperty3(_assertThisInitialized3(_this), "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]);
      return _this;
    }
    _createClass4(YearParser2, [{
      key: "parse",
      value: function parse3(dateString, token, match2) {
        var valueCallback3 = function valueCallback4(year) {
          return {
            year,
            isTwoDigitYear: token === "yy"
          };
        };
        switch (token) {
          case "y":
            return mapValue(parseNDigits(4, dateString), valueCallback3);
          case "yo":
            return mapValue(match2.ordinalNumber(dateString, {
              unit: "year"
            }), valueCallback3);
          default:
            return mapValue(parseNDigits(token.length, dateString), valueCallback3);
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value.isTwoDigitYear || value.year > 0;
      }
    }, {
      key: "set",
      value: function set2(date, flags, value) {
        var currentYear = date.getUTCFullYear();
        if (value.isTwoDigitYear) {
          var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
          date.setUTCFullYear(normalizedTwoDigitYear, 0, 1);
          date.setUTCHours(0, 0, 0, 0);
          return date;
        }
        var year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
        date.setUTCFullYear(year, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }
    }]);
    return YearParser2;
  }(Parser);

  // ../../node_modules/date-fns/esm/parse/_lib/parsers/LocalWeekYearParser.js
  function _typeof6(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof6 = function _typeof36(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof6 = function _typeof36(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof6(obj);
  }
  function _classCallCheck5(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties5(target, props) {
    for (var i3 = 0; i3 < props.length; i3++) {
      var descriptor = props[i3];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass5(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties5(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties5(Constructor, staticProps);
    return Constructor;
  }
  function _inherits4(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
    if (superClass)
      _setPrototypeOf4(subClass, superClass);
  }
  function _setPrototypeOf4(o2, p) {
    _setPrototypeOf4 = Object.setPrototypeOf || function _setPrototypeOf34(o3, p2) {
      o3.__proto__ = p2;
      return o3;
    };
    return _setPrototypeOf4(o2, p);
  }
  function _createSuper4(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct4();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf4(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf4(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn4(this, result);
    };
  }
  function _possibleConstructorReturn4(self2, call) {
    if (call && (_typeof6(call) === "object" || typeof call === "function")) {
      return call;
    }
    return _assertThisInitialized4(self2);
  }
  function _assertThisInitialized4(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _isNativeReflectConstruct4() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e3) {
      return false;
    }
  }
  function _getPrototypeOf4(o2) {
    _getPrototypeOf4 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf34(o3) {
      return o3.__proto__ || Object.getPrototypeOf(o3);
    };
    return _getPrototypeOf4(o2);
  }
  function _defineProperty4(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var LocalWeekYearParser = /* @__PURE__ */ function(_Parser) {
    _inherits4(LocalWeekYearParser2, _Parser);
    var _super = _createSuper4(LocalWeekYearParser2);
    function LocalWeekYearParser2() {
      var _this;
      _classCallCheck5(this, LocalWeekYearParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty4(_assertThisInitialized4(_this), "priority", 130);
      _defineProperty4(_assertThisInitialized4(_this), "incompatibleTokens", ["y", "R", "u", "Q", "q", "M", "L", "I", "d", "D", "i", "t", "T"]);
      return _this;
    }
    _createClass5(LocalWeekYearParser2, [{
      key: "parse",
      value: function parse3(dateString, token, match2) {
        var valueCallback3 = function valueCallback4(year) {
          return {
            year,
            isTwoDigitYear: token === "YY"
          };
        };
        switch (token) {
          case "Y":
            return mapValue(parseNDigits(4, dateString), valueCallback3);
          case "Yo":
            return mapValue(match2.ordinalNumber(dateString, {
              unit: "year"
            }), valueCallback3);
          default:
            return mapValue(parseNDigits(token.length, dateString), valueCallback3);
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value.isTwoDigitYear || value.year > 0;
      }
    }, {
      key: "set",
      value: function set2(date, flags, value, options2) {
        var currentYear = getUTCWeekYear(date, options2);
        if (value.isTwoDigitYear) {
          var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
          date.setUTCFullYear(normalizedTwoDigitYear, 0, options2.firstWeekContainsDate);
          date.setUTCHours(0, 0, 0, 0);
          return startOfUTCWeek(date, options2);
        }
        var year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
        date.setUTCFullYear(year, 0, options2.firstWeekContainsDate);
        date.setUTCHours(0, 0, 0, 0);
        return startOfUTCWeek(date, options2);
      }
    }]);
    return LocalWeekYearParser2;
  }(Parser);

  // ../../node_modules/date-fns/esm/parse/_lib/parsers/ISOWeekYearParser.js
  function _typeof7(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof7 = function _typeof36(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof7 = function _typeof36(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof7(obj);
  }
  function _classCallCheck6(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties6(target, props) {
    for (var i3 = 0; i3 < props.length; i3++) {
      var descriptor = props[i3];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass6(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties6(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties6(Constructor, staticProps);
    return Constructor;
  }
  function _inherits5(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
    if (superClass)
      _setPrototypeOf5(subClass, superClass);
  }
  function _setPrototypeOf5(o2, p) {
    _setPrototypeOf5 = Object.setPrototypeOf || function _setPrototypeOf34(o3, p2) {
      o3.__proto__ = p2;
      return o3;
    };
    return _setPrototypeOf5(o2, p);
  }
  function _createSuper5(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct5();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf5(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf5(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn5(this, result);
    };
  }
  function _possibleConstructorReturn5(self2, call) {
    if (call && (_typeof7(call) === "object" || typeof call === "function")) {
      return call;
    }
    return _assertThisInitialized5(self2);
  }
  function _assertThisInitialized5(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _isNativeReflectConstruct5() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e3) {
      return false;
    }
  }
  function _getPrototypeOf5(o2) {
    _getPrototypeOf5 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf34(o3) {
      return o3.__proto__ || Object.getPrototypeOf(o3);
    };
    return _getPrototypeOf5(o2);
  }
  function _defineProperty5(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var ISOWeekYearParser = /* @__PURE__ */ function(_Parser) {
    _inherits5(ISOWeekYearParser2, _Parser);
    var _super = _createSuper5(ISOWeekYearParser2);
    function ISOWeekYearParser2() {
      var _this;
      _classCallCheck6(this, ISOWeekYearParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty5(_assertThisInitialized5(_this), "priority", 130);
      _defineProperty5(_assertThisInitialized5(_this), "incompatibleTokens", ["G", "y", "Y", "u", "Q", "q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]);
      return _this;
    }
    _createClass6(ISOWeekYearParser2, [{
      key: "parse",
      value: function parse3(dateString, token) {
        if (token === "R") {
          return parseNDigitsSigned(4, dateString);
        }
        return parseNDigitsSigned(token.length, dateString);
      }
    }, {
      key: "set",
      value: function set2(_date, _flags, value) {
        var firstWeekOfYear = new Date(0);
        firstWeekOfYear.setUTCFullYear(value, 0, 4);
        firstWeekOfYear.setUTCHours(0, 0, 0, 0);
        return startOfUTCISOWeek(firstWeekOfYear);
      }
    }]);
    return ISOWeekYearParser2;
  }(Parser);

  // ../../node_modules/date-fns/esm/parse/_lib/parsers/ExtendedYearParser.js
  function _typeof8(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof8 = function _typeof36(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof8 = function _typeof36(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof8(obj);
  }
  function _classCallCheck7(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties7(target, props) {
    for (var i3 = 0; i3 < props.length; i3++) {
      var descriptor = props[i3];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass7(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties7(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties7(Constructor, staticProps);
    return Constructor;
  }
  function _inherits6(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
    if (superClass)
      _setPrototypeOf6(subClass, superClass);
  }
  function _setPrototypeOf6(o2, p) {
    _setPrototypeOf6 = Object.setPrototypeOf || function _setPrototypeOf34(o3, p2) {
      o3.__proto__ = p2;
      return o3;
    };
    return _setPrototypeOf6(o2, p);
  }
  function _createSuper6(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct6();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf6(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf6(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn6(this, result);
    };
  }
  function _possibleConstructorReturn6(self2, call) {
    if (call && (_typeof8(call) === "object" || typeof call === "function")) {
      return call;
    }
    return _assertThisInitialized6(self2);
  }
  function _assertThisInitialized6(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _isNativeReflectConstruct6() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e3) {
      return false;
    }
  }
  function _getPrototypeOf6(o2) {
    _getPrototypeOf6 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf34(o3) {
      return o3.__proto__ || Object.getPrototypeOf(o3);
    };
    return _getPrototypeOf6(o2);
  }
  function _defineProperty6(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var ExtendedYearParser = /* @__PURE__ */ function(_Parser) {
    _inherits6(ExtendedYearParser2, _Parser);
    var _super = _createSuper6(ExtendedYearParser2);
    function ExtendedYearParser2() {
      var _this;
      _classCallCheck7(this, ExtendedYearParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty6(_assertThisInitialized6(_this), "priority", 130);
      _defineProperty6(_assertThisInitialized6(_this), "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]);
      return _this;
    }
    _createClass7(ExtendedYearParser2, [{
      key: "parse",
      value: function parse3(dateString, token) {
        if (token === "u") {
          return parseNDigitsSigned(4, dateString);
        }
        return parseNDigitsSigned(token.length, dateString);
      }
    }, {
      key: "set",
      value: function set2(date, _flags, value) {
        date.setUTCFullYear(value, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }
    }]);
    return ExtendedYearParser2;
  }(Parser);

  // ../../node_modules/date-fns/esm/parse/_lib/parsers/QuarterParser.js
  function _typeof9(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof9 = function _typeof36(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof9 = function _typeof36(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof9(obj);
  }
  function _classCallCheck8(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties8(target, props) {
    for (var i3 = 0; i3 < props.length; i3++) {
      var descriptor = props[i3];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass8(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties8(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties8(Constructor, staticProps);
    return Constructor;
  }
  function _inherits7(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
    if (superClass)
      _setPrototypeOf7(subClass, superClass);
  }
  function _setPrototypeOf7(o2, p) {
    _setPrototypeOf7 = Object.setPrototypeOf || function _setPrototypeOf34(o3, p2) {
      o3.__proto__ = p2;
      return o3;
    };
    return _setPrototypeOf7(o2, p);
  }
  function _createSuper7(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct7();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf7(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf7(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn7(this, result);
    };
  }
  function _possibleConstructorReturn7(self2, call) {
    if (call && (_typeof9(call) === "object" || typeof call === "function")) {
      return call;
    }
    return _assertThisInitialized7(self2);
  }
  function _assertThisInitialized7(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _isNativeReflectConstruct7() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e3) {
      return false;
    }
  }
  function _getPrototypeOf7(o2) {
    _getPrototypeOf7 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf34(o3) {
      return o3.__proto__ || Object.getPrototypeOf(o3);
    };
    return _getPrototypeOf7(o2);
  }
  function _defineProperty7(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var QuarterParser = /* @__PURE__ */ function(_Parser) {
    _inherits7(QuarterParser2, _Parser);
    var _super = _createSuper7(QuarterParser2);
    function QuarterParser2() {
      var _this;
      _classCallCheck8(this, QuarterParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty7(_assertThisInitialized7(_this), "priority", 120);
      _defineProperty7(_assertThisInitialized7(_this), "incompatibleTokens", ["Y", "R", "q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]);
      return _this;
    }
    _createClass8(QuarterParser2, [{
      key: "parse",
      value: function parse3(dateString, token, match2) {
        switch (token) {
          case "Q":
          case "QQ":
            return parseNDigits(token.length, dateString);
          case "Qo":
            return match2.ordinalNumber(dateString, {
              unit: "quarter"
            });
          case "QQQ":
            return match2.quarter(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.quarter(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "QQQQQ":
            return match2.quarter(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "QQQQ":
          default:
            return match2.quarter(dateString, {
              width: "wide",
              context: "formatting"
            }) || match2.quarter(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.quarter(dateString, {
              width: "narrow",
              context: "formatting"
            });
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value >= 1 && value <= 4;
      }
    }, {
      key: "set",
      value: function set2(date, _flags, value) {
        date.setUTCMonth((value - 1) * 3, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }
    }]);
    return QuarterParser2;
  }(Parser);

  // ../../node_modules/date-fns/esm/parse/_lib/parsers/StandAloneQuarterParser.js
  function _typeof10(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof10 = function _typeof36(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof10 = function _typeof36(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof10(obj);
  }
  function _classCallCheck9(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties9(target, props) {
    for (var i3 = 0; i3 < props.length; i3++) {
      var descriptor = props[i3];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass9(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties9(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties9(Constructor, staticProps);
    return Constructor;
  }
  function _inherits8(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
    if (superClass)
      _setPrototypeOf8(subClass, superClass);
  }
  function _setPrototypeOf8(o2, p) {
    _setPrototypeOf8 = Object.setPrototypeOf || function _setPrototypeOf34(o3, p2) {
      o3.__proto__ = p2;
      return o3;
    };
    return _setPrototypeOf8(o2, p);
  }
  function _createSuper8(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct8();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf8(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf8(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn8(this, result);
    };
  }
  function _possibleConstructorReturn8(self2, call) {
    if (call && (_typeof10(call) === "object" || typeof call === "function")) {
      return call;
    }
    return _assertThisInitialized8(self2);
  }
  function _assertThisInitialized8(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _isNativeReflectConstruct8() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e3) {
      return false;
    }
  }
  function _getPrototypeOf8(o2) {
    _getPrototypeOf8 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf34(o3) {
      return o3.__proto__ || Object.getPrototypeOf(o3);
    };
    return _getPrototypeOf8(o2);
  }
  function _defineProperty8(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var StandAloneQuarterParser = /* @__PURE__ */ function(_Parser) {
    _inherits8(StandAloneQuarterParser2, _Parser);
    var _super = _createSuper8(StandAloneQuarterParser2);
    function StandAloneQuarterParser2() {
      var _this;
      _classCallCheck9(this, StandAloneQuarterParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty8(_assertThisInitialized8(_this), "priority", 120);
      _defineProperty8(_assertThisInitialized8(_this), "incompatibleTokens", ["Y", "R", "Q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]);
      return _this;
    }
    _createClass9(StandAloneQuarterParser2, [{
      key: "parse",
      value: function parse3(dateString, token, match2) {
        switch (token) {
          case "q":
          case "qq":
            return parseNDigits(token.length, dateString);
          case "qo":
            return match2.ordinalNumber(dateString, {
              unit: "quarter"
            });
          case "qqq":
            return match2.quarter(dateString, {
              width: "abbreviated",
              context: "standalone"
            }) || match2.quarter(dateString, {
              width: "narrow",
              context: "standalone"
            });
          case "qqqqq":
            return match2.quarter(dateString, {
              width: "narrow",
              context: "standalone"
            });
          case "qqqq":
          default:
            return match2.quarter(dateString, {
              width: "wide",
              context: "standalone"
            }) || match2.quarter(dateString, {
              width: "abbreviated",
              context: "standalone"
            }) || match2.quarter(dateString, {
              width: "narrow",
              context: "standalone"
            });
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value >= 1 && value <= 4;
      }
    }, {
      key: "set",
      value: function set2(date, _flags, value) {
        date.setUTCMonth((value - 1) * 3, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }
    }]);
    return StandAloneQuarterParser2;
  }(Parser);

  // ../../node_modules/date-fns/esm/parse/_lib/parsers/MonthParser.js
  function _typeof11(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof11 = function _typeof36(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof11 = function _typeof36(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof11(obj);
  }
  function _classCallCheck10(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties10(target, props) {
    for (var i3 = 0; i3 < props.length; i3++) {
      var descriptor = props[i3];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass10(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties10(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties10(Constructor, staticProps);
    return Constructor;
  }
  function _inherits9(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
    if (superClass)
      _setPrototypeOf9(subClass, superClass);
  }
  function _setPrototypeOf9(o2, p) {
    _setPrototypeOf9 = Object.setPrototypeOf || function _setPrototypeOf34(o3, p2) {
      o3.__proto__ = p2;
      return o3;
    };
    return _setPrototypeOf9(o2, p);
  }
  function _createSuper9(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct9();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf9(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf9(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn9(this, result);
    };
  }
  function _possibleConstructorReturn9(self2, call) {
    if (call && (_typeof11(call) === "object" || typeof call === "function")) {
      return call;
    }
    return _assertThisInitialized9(self2);
  }
  function _assertThisInitialized9(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _isNativeReflectConstruct9() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e3) {
      return false;
    }
  }
  function _getPrototypeOf9(o2) {
    _getPrototypeOf9 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf34(o3) {
      return o3.__proto__ || Object.getPrototypeOf(o3);
    };
    return _getPrototypeOf9(o2);
  }
  function _defineProperty9(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var MonthParser = /* @__PURE__ */ function(_Parser) {
    _inherits9(MonthParser2, _Parser);
    var _super = _createSuper9(MonthParser2);
    function MonthParser2() {
      var _this;
      _classCallCheck10(this, MonthParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty9(_assertThisInitialized9(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "L", "w", "I", "D", "i", "e", "c", "t", "T"]);
      _defineProperty9(_assertThisInitialized9(_this), "priority", 110);
      return _this;
    }
    _createClass10(MonthParser2, [{
      key: "parse",
      value: function parse3(dateString, token, match2) {
        var valueCallback3 = function valueCallback4(value) {
          return value - 1;
        };
        switch (token) {
          case "M":
            return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback3);
          case "MM":
            return mapValue(parseNDigits(2, dateString), valueCallback3);
          case "Mo":
            return mapValue(match2.ordinalNumber(dateString, {
              unit: "month"
            }), valueCallback3);
          case "MMM":
            return match2.month(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.month(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "MMMMM":
            return match2.month(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "MMMM":
          default:
            return match2.month(dateString, {
              width: "wide",
              context: "formatting"
            }) || match2.month(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.month(dateString, {
              width: "narrow",
              context: "formatting"
            });
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value >= 0 && value <= 11;
      }
    }, {
      key: "set",
      value: function set2(date, _flags, value) {
        date.setUTCMonth(value, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }
    }]);
    return MonthParser2;
  }(Parser);

  // ../../node_modules/date-fns/esm/parse/_lib/parsers/StandAloneMonthParser.js
  function _typeof12(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof12 = function _typeof36(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof12 = function _typeof36(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof12(obj);
  }
  function _classCallCheck11(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties11(target, props) {
    for (var i3 = 0; i3 < props.length; i3++) {
      var descriptor = props[i3];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass11(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties11(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties11(Constructor, staticProps);
    return Constructor;
  }
  function _inherits10(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
    if (superClass)
      _setPrototypeOf10(subClass, superClass);
  }
  function _setPrototypeOf10(o2, p) {
    _setPrototypeOf10 = Object.setPrototypeOf || function _setPrototypeOf34(o3, p2) {
      o3.__proto__ = p2;
      return o3;
    };
    return _setPrototypeOf10(o2, p);
  }
  function _createSuper10(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct10();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf10(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf10(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn10(this, result);
    };
  }
  function _possibleConstructorReturn10(self2, call) {
    if (call && (_typeof12(call) === "object" || typeof call === "function")) {
      return call;
    }
    return _assertThisInitialized10(self2);
  }
  function _assertThisInitialized10(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _isNativeReflectConstruct10() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e3) {
      return false;
    }
  }
  function _getPrototypeOf10(o2) {
    _getPrototypeOf10 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf34(o3) {
      return o3.__proto__ || Object.getPrototypeOf(o3);
    };
    return _getPrototypeOf10(o2);
  }
  function _defineProperty10(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var StandAloneMonthParser = /* @__PURE__ */ function(_Parser) {
    _inherits10(StandAloneMonthParser2, _Parser);
    var _super = _createSuper10(StandAloneMonthParser2);
    function StandAloneMonthParser2() {
      var _this;
      _classCallCheck11(this, StandAloneMonthParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty10(_assertThisInitialized10(_this), "priority", 110);
      _defineProperty10(_assertThisInitialized10(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "w", "I", "D", "i", "e", "c", "t", "T"]);
      return _this;
    }
    _createClass11(StandAloneMonthParser2, [{
      key: "parse",
      value: function parse3(dateString, token, match2) {
        var valueCallback3 = function valueCallback4(value) {
          return value - 1;
        };
        switch (token) {
          case "L":
            return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback3);
          case "LL":
            return mapValue(parseNDigits(2, dateString), valueCallback3);
          case "Lo":
            return mapValue(match2.ordinalNumber(dateString, {
              unit: "month"
            }), valueCallback3);
          case "LLL":
            return match2.month(dateString, {
              width: "abbreviated",
              context: "standalone"
            }) || match2.month(dateString, {
              width: "narrow",
              context: "standalone"
            });
          case "LLLLL":
            return match2.month(dateString, {
              width: "narrow",
              context: "standalone"
            });
          case "LLLL":
          default:
            return match2.month(dateString, {
              width: "wide",
              context: "standalone"
            }) || match2.month(dateString, {
              width: "abbreviated",
              context: "standalone"
            }) || match2.month(dateString, {
              width: "narrow",
              context: "standalone"
            });
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value >= 0 && value <= 11;
      }
    }, {
      key: "set",
      value: function set2(date, _flags, value) {
        date.setUTCMonth(value, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }
    }]);
    return StandAloneMonthParser2;
  }(Parser);

  // ../../node_modules/date-fns/esm/_lib/setUTCWeek/index.js
  function setUTCWeek(dirtyDate, dirtyWeek, options2) {
    requiredArgs(2, arguments);
    var date = toDate2(dirtyDate);
    var week = toInteger(dirtyWeek);
    var diff = getUTCWeek(date, options2) - week;
    date.setUTCDate(date.getUTCDate() - diff * 7);
    return date;
  }

  // ../../node_modules/date-fns/esm/parse/_lib/parsers/LocalWeekParser.js
  function _typeof13(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof13 = function _typeof36(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof13 = function _typeof36(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof13(obj);
  }
  function _classCallCheck12(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties12(target, props) {
    for (var i3 = 0; i3 < props.length; i3++) {
      var descriptor = props[i3];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass12(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties12(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties12(Constructor, staticProps);
    return Constructor;
  }
  function _inherits11(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
    if (superClass)
      _setPrototypeOf11(subClass, superClass);
  }
  function _setPrototypeOf11(o2, p) {
    _setPrototypeOf11 = Object.setPrototypeOf || function _setPrototypeOf34(o3, p2) {
      o3.__proto__ = p2;
      return o3;
    };
    return _setPrototypeOf11(o2, p);
  }
  function _createSuper11(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct11();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf11(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf11(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn11(this, result);
    };
  }
  function _possibleConstructorReturn11(self2, call) {
    if (call && (_typeof13(call) === "object" || typeof call === "function")) {
      return call;
    }
    return _assertThisInitialized11(self2);
  }
  function _assertThisInitialized11(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _isNativeReflectConstruct11() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e3) {
      return false;
    }
  }
  function _getPrototypeOf11(o2) {
    _getPrototypeOf11 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf34(o3) {
      return o3.__proto__ || Object.getPrototypeOf(o3);
    };
    return _getPrototypeOf11(o2);
  }
  function _defineProperty11(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var LocalWeekParser = /* @__PURE__ */ function(_Parser) {
    _inherits11(LocalWeekParser2, _Parser);
    var _super = _createSuper11(LocalWeekParser2);
    function LocalWeekParser2() {
      var _this;
      _classCallCheck12(this, LocalWeekParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty11(_assertThisInitialized11(_this), "priority", 100);
      _defineProperty11(_assertThisInitialized11(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "i", "t", "T"]);
      return _this;
    }
    _createClass12(LocalWeekParser2, [{
      key: "parse",
      value: function parse3(dateString, token, match2) {
        switch (token) {
          case "w":
            return parseNumericPattern(numericPatterns.week, dateString);
          case "wo":
            return match2.ordinalNumber(dateString, {
              unit: "week"
            });
          default:
            return parseNDigits(token.length, dateString);
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value >= 1 && value <= 53;
      }
    }, {
      key: "set",
      value: function set2(date, _flags, value, options2) {
        return startOfUTCWeek(setUTCWeek(date, value, options2), options2);
      }
    }]);
    return LocalWeekParser2;
  }(Parser);

  // ../../node_modules/date-fns/esm/_lib/setUTCISOWeek/index.js
  function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
    requiredArgs(2, arguments);
    var date = toDate2(dirtyDate);
    var isoWeek = toInteger(dirtyISOWeek);
    var diff = getUTCISOWeek(date) - isoWeek;
    date.setUTCDate(date.getUTCDate() - diff * 7);
    return date;
  }

  // ../../node_modules/date-fns/esm/parse/_lib/parsers/ISOWeekParser.js
  function _typeof14(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof14 = function _typeof36(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof14 = function _typeof36(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof14(obj);
  }
  function _classCallCheck13(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties13(target, props) {
    for (var i3 = 0; i3 < props.length; i3++) {
      var descriptor = props[i3];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass13(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties13(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties13(Constructor, staticProps);
    return Constructor;
  }
  function _inherits12(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
    if (superClass)
      _setPrototypeOf12(subClass, superClass);
  }
  function _setPrototypeOf12(o2, p) {
    _setPrototypeOf12 = Object.setPrototypeOf || function _setPrototypeOf34(o3, p2) {
      o3.__proto__ = p2;
      return o3;
    };
    return _setPrototypeOf12(o2, p);
  }
  function _createSuper12(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct12();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf12(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf12(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn12(this, result);
    };
  }
  function _possibleConstructorReturn12(self2, call) {
    if (call && (_typeof14(call) === "object" || typeof call === "function")) {
      return call;
    }
    return _assertThisInitialized12(self2);
  }
  function _assertThisInitialized12(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _isNativeReflectConstruct12() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e3) {
      return false;
    }
  }
  function _getPrototypeOf12(o2) {
    _getPrototypeOf12 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf34(o3) {
      return o3.__proto__ || Object.getPrototypeOf(o3);
    };
    return _getPrototypeOf12(o2);
  }
  function _defineProperty12(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var ISOWeekParser = /* @__PURE__ */ function(_Parser) {
    _inherits12(ISOWeekParser2, _Parser);
    var _super = _createSuper12(ISOWeekParser2);
    function ISOWeekParser2() {
      var _this;
      _classCallCheck13(this, ISOWeekParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty12(_assertThisInitialized12(_this), "priority", 100);
      _defineProperty12(_assertThisInitialized12(_this), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]);
      return _this;
    }
    _createClass13(ISOWeekParser2, [{
      key: "parse",
      value: function parse3(dateString, token, match2) {
        switch (token) {
          case "I":
            return parseNumericPattern(numericPatterns.week, dateString);
          case "Io":
            return match2.ordinalNumber(dateString, {
              unit: "week"
            });
          default:
            return parseNDigits(token.length, dateString);
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value >= 1 && value <= 53;
      }
    }, {
      key: "set",
      value: function set2(date, _flags, value) {
        return startOfUTCISOWeek(setUTCISOWeek(date, value));
      }
    }]);
    return ISOWeekParser2;
  }(Parser);

  // ../../node_modules/date-fns/esm/parse/_lib/parsers/DateParser.js
  function _typeof15(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof15 = function _typeof36(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof15 = function _typeof36(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof15(obj);
  }
  function _classCallCheck14(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties14(target, props) {
    for (var i3 = 0; i3 < props.length; i3++) {
      var descriptor = props[i3];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass14(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties14(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties14(Constructor, staticProps);
    return Constructor;
  }
  function _inherits13(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
    if (superClass)
      _setPrototypeOf13(subClass, superClass);
  }
  function _setPrototypeOf13(o2, p) {
    _setPrototypeOf13 = Object.setPrototypeOf || function _setPrototypeOf34(o3, p2) {
      o3.__proto__ = p2;
      return o3;
    };
    return _setPrototypeOf13(o2, p);
  }
  function _createSuper13(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct13();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf13(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf13(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn13(this, result);
    };
  }
  function _possibleConstructorReturn13(self2, call) {
    if (call && (_typeof15(call) === "object" || typeof call === "function")) {
      return call;
    }
    return _assertThisInitialized13(self2);
  }
  function _assertThisInitialized13(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _isNativeReflectConstruct13() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e3) {
      return false;
    }
  }
  function _getPrototypeOf13(o2) {
    _getPrototypeOf13 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf34(o3) {
      return o3.__proto__ || Object.getPrototypeOf(o3);
    };
    return _getPrototypeOf13(o2);
  }
  function _defineProperty13(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var DateParser = /* @__PURE__ */ function(_Parser) {
    _inherits13(DateParser2, _Parser);
    var _super = _createSuper13(DateParser2);
    function DateParser2() {
      var _this;
      _classCallCheck14(this, DateParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty13(_assertThisInitialized13(_this), "priority", 90);
      _defineProperty13(_assertThisInitialized13(_this), "subPriority", 1);
      _defineProperty13(_assertThisInitialized13(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "w", "I", "D", "i", "e", "c", "t", "T"]);
      return _this;
    }
    _createClass14(DateParser2, [{
      key: "parse",
      value: function parse3(dateString, token, match2) {
        switch (token) {
          case "d":
            return parseNumericPattern(numericPatterns.date, dateString);
          case "do":
            return match2.ordinalNumber(dateString, {
              unit: "date"
            });
          default:
            return parseNDigits(token.length, dateString);
        }
      }
    }, {
      key: "validate",
      value: function validate(date, value) {
        var year = date.getUTCFullYear();
        var isLeapYear = isLeapYearIndex(year);
        var month = date.getUTCMonth();
        if (isLeapYear) {
          return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
        } else {
          return value >= 1 && value <= DAYS_IN_MONTH[month];
        }
      }
    }, {
      key: "set",
      value: function set2(date, _flags, value) {
        date.setUTCDate(value);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }
    }]);
    return DateParser2;
  }(Parser);

  // ../../node_modules/date-fns/esm/parse/_lib/parsers/DayOfYearParser.js
  function _typeof16(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof16 = function _typeof36(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof16 = function _typeof36(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof16(obj);
  }
  function _classCallCheck15(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties15(target, props) {
    for (var i3 = 0; i3 < props.length; i3++) {
      var descriptor = props[i3];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass15(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties15(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties15(Constructor, staticProps);
    return Constructor;
  }
  function _inherits14(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
    if (superClass)
      _setPrototypeOf14(subClass, superClass);
  }
  function _setPrototypeOf14(o2, p) {
    _setPrototypeOf14 = Object.setPrototypeOf || function _setPrototypeOf34(o3, p2) {
      o3.__proto__ = p2;
      return o3;
    };
    return _setPrototypeOf14(o2, p);
  }
  function _createSuper14(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct14();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf14(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf14(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn14(this, result);
    };
  }
  function _possibleConstructorReturn14(self2, call) {
    if (call && (_typeof16(call) === "object" || typeof call === "function")) {
      return call;
    }
    return _assertThisInitialized14(self2);
  }
  function _assertThisInitialized14(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _isNativeReflectConstruct14() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e3) {
      return false;
    }
  }
  function _getPrototypeOf14(o2) {
    _getPrototypeOf14 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf34(o3) {
      return o3.__proto__ || Object.getPrototypeOf(o3);
    };
    return _getPrototypeOf14(o2);
  }
  function _defineProperty14(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var DayOfYearParser = /* @__PURE__ */ function(_Parser) {
    _inherits14(DayOfYearParser2, _Parser);
    var _super = _createSuper14(DayOfYearParser2);
    function DayOfYearParser2() {
      var _this;
      _classCallCheck15(this, DayOfYearParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty14(_assertThisInitialized14(_this), "priority", 90);
      _defineProperty14(_assertThisInitialized14(_this), "subpriority", 1);
      _defineProperty14(_assertThisInitialized14(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "L", "w", "I", "d", "E", "i", "e", "c", "t", "T"]);
      return _this;
    }
    _createClass15(DayOfYearParser2, [{
      key: "parse",
      value: function parse3(dateString, token, match2) {
        switch (token) {
          case "D":
          case "DD":
            return parseNumericPattern(numericPatterns.dayOfYear, dateString);
          case "Do":
            return match2.ordinalNumber(dateString, {
              unit: "date"
            });
          default:
            return parseNDigits(token.length, dateString);
        }
      }
    }, {
      key: "validate",
      value: function validate(date, value) {
        var year = date.getUTCFullYear();
        var isLeapYear = isLeapYearIndex(year);
        if (isLeapYear) {
          return value >= 1 && value <= 366;
        } else {
          return value >= 1 && value <= 365;
        }
      }
    }, {
      key: "set",
      value: function set2(date, _flags, value) {
        date.setUTCMonth(0, value);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }
    }]);
    return DayOfYearParser2;
  }(Parser);

  // ../../node_modules/date-fns/esm/_lib/setUTCDay/index.js
  function setUTCDay(dirtyDate, dirtyDay, options2) {
    var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
    requiredArgs(2, arguments);
    var defaultOptions4 = getDefaultOptions();
    var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options2 === null || options2 === void 0 ? void 0 : options2.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options2 === null || options2 === void 0 ? void 0 : (_options$locale = options2.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions4.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions4.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
      throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    }
    var date = toDate2(dirtyDate);
    var day = toInteger(dirtyDay);
    var currentDay = date.getUTCDay();
    var remainder = day % 7;
    var dayIndex = (remainder + 7) % 7;
    var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
    date.setUTCDate(date.getUTCDate() + diff);
    return date;
  }

  // ../../node_modules/date-fns/esm/parse/_lib/parsers/DayParser.js
  function _typeof17(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof17 = function _typeof36(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof17 = function _typeof36(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof17(obj);
  }
  function _classCallCheck16(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties16(target, props) {
    for (var i3 = 0; i3 < props.length; i3++) {
      var descriptor = props[i3];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass16(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties16(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties16(Constructor, staticProps);
    return Constructor;
  }
  function _inherits15(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
    if (superClass)
      _setPrototypeOf15(subClass, superClass);
  }
  function _setPrototypeOf15(o2, p) {
    _setPrototypeOf15 = Object.setPrototypeOf || function _setPrototypeOf34(o3, p2) {
      o3.__proto__ = p2;
      return o3;
    };
    return _setPrototypeOf15(o2, p);
  }
  function _createSuper15(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct15();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf15(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf15(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn15(this, result);
    };
  }
  function _possibleConstructorReturn15(self2, call) {
    if (call && (_typeof17(call) === "object" || typeof call === "function")) {
      return call;
    }
    return _assertThisInitialized15(self2);
  }
  function _assertThisInitialized15(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _isNativeReflectConstruct15() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e3) {
      return false;
    }
  }
  function _getPrototypeOf15(o2) {
    _getPrototypeOf15 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf34(o3) {
      return o3.__proto__ || Object.getPrototypeOf(o3);
    };
    return _getPrototypeOf15(o2);
  }
  function _defineProperty15(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var DayParser = /* @__PURE__ */ function(_Parser) {
    _inherits15(DayParser2, _Parser);
    var _super = _createSuper15(DayParser2);
    function DayParser2() {
      var _this;
      _classCallCheck16(this, DayParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty15(_assertThisInitialized15(_this), "priority", 90);
      _defineProperty15(_assertThisInitialized15(_this), "incompatibleTokens", ["D", "i", "e", "c", "t", "T"]);
      return _this;
    }
    _createClass16(DayParser2, [{
      key: "parse",
      value: function parse3(dateString, token, match2) {
        switch (token) {
          case "E":
          case "EE":
          case "EEE":
            return match2.day(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.day(dateString, {
              width: "short",
              context: "formatting"
            }) || match2.day(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "EEEEE":
            return match2.day(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "EEEEEE":
            return match2.day(dateString, {
              width: "short",
              context: "formatting"
            }) || match2.day(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "EEEE":
          default:
            return match2.day(dateString, {
              width: "wide",
              context: "formatting"
            }) || match2.day(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.day(dateString, {
              width: "short",
              context: "formatting"
            }) || match2.day(dateString, {
              width: "narrow",
              context: "formatting"
            });
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value >= 0 && value <= 6;
      }
    }, {
      key: "set",
      value: function set2(date, _flags, value, options2) {
        date = setUTCDay(date, value, options2);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }
    }]);
    return DayParser2;
  }(Parser);

  // ../../node_modules/date-fns/esm/parse/_lib/parsers/LocalDayParser.js
  function _typeof18(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof18 = function _typeof36(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof18 = function _typeof36(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof18(obj);
  }
  function _classCallCheck17(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties17(target, props) {
    for (var i3 = 0; i3 < props.length; i3++) {
      var descriptor = props[i3];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass17(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties17(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties17(Constructor, staticProps);
    return Constructor;
  }
  function _inherits16(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
    if (superClass)
      _setPrototypeOf16(subClass, superClass);
  }
  function _setPrototypeOf16(o2, p) {
    _setPrototypeOf16 = Object.setPrototypeOf || function _setPrototypeOf34(o3, p2) {
      o3.__proto__ = p2;
      return o3;
    };
    return _setPrototypeOf16(o2, p);
  }
  function _createSuper16(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct16();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf16(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf16(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn16(this, result);
    };
  }
  function _possibleConstructorReturn16(self2, call) {
    if (call && (_typeof18(call) === "object" || typeof call === "function")) {
      return call;
    }
    return _assertThisInitialized16(self2);
  }
  function _assertThisInitialized16(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _isNativeReflectConstruct16() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e3) {
      return false;
    }
  }
  function _getPrototypeOf16(o2) {
    _getPrototypeOf16 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf34(o3) {
      return o3.__proto__ || Object.getPrototypeOf(o3);
    };
    return _getPrototypeOf16(o2);
  }
  function _defineProperty16(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var LocalDayParser = /* @__PURE__ */ function(_Parser) {
    _inherits16(LocalDayParser2, _Parser);
    var _super = _createSuper16(LocalDayParser2);
    function LocalDayParser2() {
      var _this;
      _classCallCheck17(this, LocalDayParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty16(_assertThisInitialized16(_this), "priority", 90);
      _defineProperty16(_assertThisInitialized16(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "c", "t", "T"]);
      return _this;
    }
    _createClass17(LocalDayParser2, [{
      key: "parse",
      value: function parse3(dateString, token, match2, options2) {
        var valueCallback3 = function valueCallback4(value) {
          var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
          return (value + options2.weekStartsOn + 6) % 7 + wholeWeekDays;
        };
        switch (token) {
          case "e":
          case "ee":
            return mapValue(parseNDigits(token.length, dateString), valueCallback3);
          case "eo":
            return mapValue(match2.ordinalNumber(dateString, {
              unit: "day"
            }), valueCallback3);
          case "eee":
            return match2.day(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.day(dateString, {
              width: "short",
              context: "formatting"
            }) || match2.day(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "eeeee":
            return match2.day(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "eeeeee":
            return match2.day(dateString, {
              width: "short",
              context: "formatting"
            }) || match2.day(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "eeee":
          default:
            return match2.day(dateString, {
              width: "wide",
              context: "formatting"
            }) || match2.day(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.day(dateString, {
              width: "short",
              context: "formatting"
            }) || match2.day(dateString, {
              width: "narrow",
              context: "formatting"
            });
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value >= 0 && value <= 6;
      }
    }, {
      key: "set",
      value: function set2(date, _flags, value, options2) {
        date = setUTCDay(date, value, options2);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }
    }]);
    return LocalDayParser2;
  }(Parser);

  // ../../node_modules/date-fns/esm/parse/_lib/parsers/StandAloneLocalDayParser.js
  function _typeof19(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof19 = function _typeof36(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof19 = function _typeof36(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof19(obj);
  }
  function _classCallCheck18(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties18(target, props) {
    for (var i3 = 0; i3 < props.length; i3++) {
      var descriptor = props[i3];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass18(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties18(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties18(Constructor, staticProps);
    return Constructor;
  }
  function _inherits17(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
    if (superClass)
      _setPrototypeOf17(subClass, superClass);
  }
  function _setPrototypeOf17(o2, p) {
    _setPrototypeOf17 = Object.setPrototypeOf || function _setPrototypeOf34(o3, p2) {
      o3.__proto__ = p2;
      return o3;
    };
    return _setPrototypeOf17(o2, p);
  }
  function _createSuper17(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct17();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf17(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf17(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn17(this, result);
    };
  }
  function _possibleConstructorReturn17(self2, call) {
    if (call && (_typeof19(call) === "object" || typeof call === "function")) {
      return call;
    }
    return _assertThisInitialized17(self2);
  }
  function _assertThisInitialized17(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _isNativeReflectConstruct17() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e3) {
      return false;
    }
  }
  function _getPrototypeOf17(o2) {
    _getPrototypeOf17 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf34(o3) {
      return o3.__proto__ || Object.getPrototypeOf(o3);
    };
    return _getPrototypeOf17(o2);
  }
  function _defineProperty17(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var StandAloneLocalDayParser = /* @__PURE__ */ function(_Parser) {
    _inherits17(StandAloneLocalDayParser2, _Parser);
    var _super = _createSuper17(StandAloneLocalDayParser2);
    function StandAloneLocalDayParser2() {
      var _this;
      _classCallCheck18(this, StandAloneLocalDayParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty17(_assertThisInitialized17(_this), "priority", 90);
      _defineProperty17(_assertThisInitialized17(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "e", "t", "T"]);
      return _this;
    }
    _createClass18(StandAloneLocalDayParser2, [{
      key: "parse",
      value: function parse3(dateString, token, match2, options2) {
        var valueCallback3 = function valueCallback4(value) {
          var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
          return (value + options2.weekStartsOn + 6) % 7 + wholeWeekDays;
        };
        switch (token) {
          case "c":
          case "cc":
            return mapValue(parseNDigits(token.length, dateString), valueCallback3);
          case "co":
            return mapValue(match2.ordinalNumber(dateString, {
              unit: "day"
            }), valueCallback3);
          case "ccc":
            return match2.day(dateString, {
              width: "abbreviated",
              context: "standalone"
            }) || match2.day(dateString, {
              width: "short",
              context: "standalone"
            }) || match2.day(dateString, {
              width: "narrow",
              context: "standalone"
            });
          case "ccccc":
            return match2.day(dateString, {
              width: "narrow",
              context: "standalone"
            });
          case "cccccc":
            return match2.day(dateString, {
              width: "short",
              context: "standalone"
            }) || match2.day(dateString, {
              width: "narrow",
              context: "standalone"
            });
          case "cccc":
          default:
            return match2.day(dateString, {
              width: "wide",
              context: "standalone"
            }) || match2.day(dateString, {
              width: "abbreviated",
              context: "standalone"
            }) || match2.day(dateString, {
              width: "short",
              context: "standalone"
            }) || match2.day(dateString, {
              width: "narrow",
              context: "standalone"
            });
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value >= 0 && value <= 6;
      }
    }, {
      key: "set",
      value: function set2(date, _flags, value, options2) {
        date = setUTCDay(date, value, options2);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }
    }]);
    return StandAloneLocalDayParser2;
  }(Parser);

  // ../../node_modules/date-fns/esm/_lib/setUTCISODay/index.js
  function setUTCISODay(dirtyDate, dirtyDay) {
    requiredArgs(2, arguments);
    var day = toInteger(dirtyDay);
    if (day % 7 === 0) {
      day = day - 7;
    }
    var weekStartsOn = 1;
    var date = toDate2(dirtyDate);
    var currentDay = date.getUTCDay();
    var remainder = day % 7;
    var dayIndex = (remainder + 7) % 7;
    var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
    date.setUTCDate(date.getUTCDate() + diff);
    return date;
  }

  // ../../node_modules/date-fns/esm/parse/_lib/parsers/ISODayParser.js
  function _typeof20(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof20 = function _typeof36(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof20 = function _typeof36(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof20(obj);
  }
  function _classCallCheck19(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties19(target, props) {
    for (var i3 = 0; i3 < props.length; i3++) {
      var descriptor = props[i3];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass19(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties19(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties19(Constructor, staticProps);
    return Constructor;
  }
  function _inherits18(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
    if (superClass)
      _setPrototypeOf18(subClass, superClass);
  }
  function _setPrototypeOf18(o2, p) {
    _setPrototypeOf18 = Object.setPrototypeOf || function _setPrototypeOf34(o3, p2) {
      o3.__proto__ = p2;
      return o3;
    };
    return _setPrototypeOf18(o2, p);
  }
  function _createSuper18(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct18();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf18(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf18(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn18(this, result);
    };
  }
  function _possibleConstructorReturn18(self2, call) {
    if (call && (_typeof20(call) === "object" || typeof call === "function")) {
      return call;
    }
    return _assertThisInitialized18(self2);
  }
  function _assertThisInitialized18(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _isNativeReflectConstruct18() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e3) {
      return false;
    }
  }
  function _getPrototypeOf18(o2) {
    _getPrototypeOf18 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf34(o3) {
      return o3.__proto__ || Object.getPrototypeOf(o3);
    };
    return _getPrototypeOf18(o2);
  }
  function _defineProperty18(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var ISODayParser = /* @__PURE__ */ function(_Parser) {
    _inherits18(ISODayParser2, _Parser);
    var _super = _createSuper18(ISODayParser2);
    function ISODayParser2() {
      var _this;
      _classCallCheck19(this, ISODayParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty18(_assertThisInitialized18(_this), "priority", 90);
      _defineProperty18(_assertThisInitialized18(_this), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "E", "e", "c", "t", "T"]);
      return _this;
    }
    _createClass19(ISODayParser2, [{
      key: "parse",
      value: function parse3(dateString, token, match2) {
        var valueCallback3 = function valueCallback4(value) {
          if (value === 0) {
            return 7;
          }
          return value;
        };
        switch (token) {
          case "i":
          case "ii":
            return parseNDigits(token.length, dateString);
          case "io":
            return match2.ordinalNumber(dateString, {
              unit: "day"
            });
          case "iii":
            return mapValue(match2.day(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.day(dateString, {
              width: "short",
              context: "formatting"
            }) || match2.day(dateString, {
              width: "narrow",
              context: "formatting"
            }), valueCallback3);
          case "iiiii":
            return mapValue(match2.day(dateString, {
              width: "narrow",
              context: "formatting"
            }), valueCallback3);
          case "iiiiii":
            return mapValue(match2.day(dateString, {
              width: "short",
              context: "formatting"
            }) || match2.day(dateString, {
              width: "narrow",
              context: "formatting"
            }), valueCallback3);
          case "iiii":
          default:
            return mapValue(match2.day(dateString, {
              width: "wide",
              context: "formatting"
            }) || match2.day(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.day(dateString, {
              width: "short",
              context: "formatting"
            }) || match2.day(dateString, {
              width: "narrow",
              context: "formatting"
            }), valueCallback3);
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value >= 1 && value <= 7;
      }
    }, {
      key: "set",
      value: function set2(date, _flags, value) {
        date = setUTCISODay(date, value);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }
    }]);
    return ISODayParser2;
  }(Parser);

  // ../../node_modules/date-fns/esm/parse/_lib/parsers/AMPMParser.js
  function _typeof21(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof21 = function _typeof36(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof21 = function _typeof36(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof21(obj);
  }
  function _classCallCheck20(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties20(target, props) {
    for (var i3 = 0; i3 < props.length; i3++) {
      var descriptor = props[i3];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass20(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties20(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties20(Constructor, staticProps);
    return Constructor;
  }
  function _inherits19(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
    if (superClass)
      _setPrototypeOf19(subClass, superClass);
  }
  function _setPrototypeOf19(o2, p) {
    _setPrototypeOf19 = Object.setPrototypeOf || function _setPrototypeOf34(o3, p2) {
      o3.__proto__ = p2;
      return o3;
    };
    return _setPrototypeOf19(o2, p);
  }
  function _createSuper19(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct19();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf19(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf19(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn19(this, result);
    };
  }
  function _possibleConstructorReturn19(self2, call) {
    if (call && (_typeof21(call) === "object" || typeof call === "function")) {
      return call;
    }
    return _assertThisInitialized19(self2);
  }
  function _assertThisInitialized19(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _isNativeReflectConstruct19() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e3) {
      return false;
    }
  }
  function _getPrototypeOf19(o2) {
    _getPrototypeOf19 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf34(o3) {
      return o3.__proto__ || Object.getPrototypeOf(o3);
    };
    return _getPrototypeOf19(o2);
  }
  function _defineProperty19(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var AMPMParser = /* @__PURE__ */ function(_Parser) {
    _inherits19(AMPMParser2, _Parser);
    var _super = _createSuper19(AMPMParser2);
    function AMPMParser2() {
      var _this;
      _classCallCheck20(this, AMPMParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty19(_assertThisInitialized19(_this), "priority", 80);
      _defineProperty19(_assertThisInitialized19(_this), "incompatibleTokens", ["b", "B", "H", "k", "t", "T"]);
      return _this;
    }
    _createClass20(AMPMParser2, [{
      key: "parse",
      value: function parse3(dateString, token, match2) {
        switch (token) {
          case "a":
          case "aa":
          case "aaa":
            return match2.dayPeriod(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "aaaaa":
            return match2.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "aaaa":
          default:
            return match2.dayPeriod(dateString, {
              width: "wide",
              context: "formatting"
            }) || match2.dayPeriod(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting"
            });
        }
      }
    }, {
      key: "set",
      value: function set2(date, _flags, value) {
        date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
        return date;
      }
    }]);
    return AMPMParser2;
  }(Parser);

  // ../../node_modules/date-fns/esm/parse/_lib/parsers/AMPMMidnightParser.js
  function _typeof22(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof22 = function _typeof36(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof22 = function _typeof36(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof22(obj);
  }
  function _classCallCheck21(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties21(target, props) {
    for (var i3 = 0; i3 < props.length; i3++) {
      var descriptor = props[i3];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass21(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties21(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties21(Constructor, staticProps);
    return Constructor;
  }
  function _inherits20(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
    if (superClass)
      _setPrototypeOf20(subClass, superClass);
  }
  function _setPrototypeOf20(o2, p) {
    _setPrototypeOf20 = Object.setPrototypeOf || function _setPrototypeOf34(o3, p2) {
      o3.__proto__ = p2;
      return o3;
    };
    return _setPrototypeOf20(o2, p);
  }
  function _createSuper20(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct20();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf20(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf20(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn20(this, result);
    };
  }
  function _possibleConstructorReturn20(self2, call) {
    if (call && (_typeof22(call) === "object" || typeof call === "function")) {
      return call;
    }
    return _assertThisInitialized20(self2);
  }
  function _assertThisInitialized20(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _isNativeReflectConstruct20() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e3) {
      return false;
    }
  }
  function _getPrototypeOf20(o2) {
    _getPrototypeOf20 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf34(o3) {
      return o3.__proto__ || Object.getPrototypeOf(o3);
    };
    return _getPrototypeOf20(o2);
  }
  function _defineProperty20(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var AMPMMidnightParser = /* @__PURE__ */ function(_Parser) {
    _inherits20(AMPMMidnightParser2, _Parser);
    var _super = _createSuper20(AMPMMidnightParser2);
    function AMPMMidnightParser2() {
      var _this;
      _classCallCheck21(this, AMPMMidnightParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty20(_assertThisInitialized20(_this), "priority", 80);
      _defineProperty20(_assertThisInitialized20(_this), "incompatibleTokens", ["a", "B", "H", "k", "t", "T"]);
      return _this;
    }
    _createClass21(AMPMMidnightParser2, [{
      key: "parse",
      value: function parse3(dateString, token, match2) {
        switch (token) {
          case "b":
          case "bb":
          case "bbb":
            return match2.dayPeriod(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "bbbbb":
            return match2.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "bbbb":
          default:
            return match2.dayPeriod(dateString, {
              width: "wide",
              context: "formatting"
            }) || match2.dayPeriod(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting"
            });
        }
      }
    }, {
      key: "set",
      value: function set2(date, _flags, value) {
        date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
        return date;
      }
    }]);
    return AMPMMidnightParser2;
  }(Parser);

  // ../../node_modules/date-fns/esm/parse/_lib/parsers/DayPeriodParser.js
  function _typeof23(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof23 = function _typeof36(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof23 = function _typeof36(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof23(obj);
  }
  function _classCallCheck22(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties22(target, props) {
    for (var i3 = 0; i3 < props.length; i3++) {
      var descriptor = props[i3];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass22(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties22(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties22(Constructor, staticProps);
    return Constructor;
  }
  function _inherits21(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
    if (superClass)
      _setPrototypeOf21(subClass, superClass);
  }
  function _setPrototypeOf21(o2, p) {
    _setPrototypeOf21 = Object.setPrototypeOf || function _setPrototypeOf34(o3, p2) {
      o3.__proto__ = p2;
      return o3;
    };
    return _setPrototypeOf21(o2, p);
  }
  function _createSuper21(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct21();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf21(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf21(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn21(this, result);
    };
  }
  function _possibleConstructorReturn21(self2, call) {
    if (call && (_typeof23(call) === "object" || typeof call === "function")) {
      return call;
    }
    return _assertThisInitialized21(self2);
  }
  function _assertThisInitialized21(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _isNativeReflectConstruct21() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e3) {
      return false;
    }
  }
  function _getPrototypeOf21(o2) {
    _getPrototypeOf21 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf34(o3) {
      return o3.__proto__ || Object.getPrototypeOf(o3);
    };
    return _getPrototypeOf21(o2);
  }
  function _defineProperty21(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var DayPeriodParser = /* @__PURE__ */ function(_Parser) {
    _inherits21(DayPeriodParser2, _Parser);
    var _super = _createSuper21(DayPeriodParser2);
    function DayPeriodParser2() {
      var _this;
      _classCallCheck22(this, DayPeriodParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty21(_assertThisInitialized21(_this), "priority", 80);
      _defineProperty21(_assertThisInitialized21(_this), "incompatibleTokens", ["a", "b", "t", "T"]);
      return _this;
    }
    _createClass22(DayPeriodParser2, [{
      key: "parse",
      value: function parse3(dateString, token, match2) {
        switch (token) {
          case "B":
          case "BB":
          case "BBB":
            return match2.dayPeriod(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "BBBBB":
            return match2.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "BBBB":
          default:
            return match2.dayPeriod(dateString, {
              width: "wide",
              context: "formatting"
            }) || match2.dayPeriod(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting"
            });
        }
      }
    }, {
      key: "set",
      value: function set2(date, _flags, value) {
        date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
        return date;
      }
    }]);
    return DayPeriodParser2;
  }(Parser);

  // ../../node_modules/date-fns/esm/parse/_lib/parsers/Hour1to12Parser.js
  function _typeof24(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof24 = function _typeof36(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof24 = function _typeof36(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof24(obj);
  }
  function _classCallCheck23(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties23(target, props) {
    for (var i3 = 0; i3 < props.length; i3++) {
      var descriptor = props[i3];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass23(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties23(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties23(Constructor, staticProps);
    return Constructor;
  }
  function _inherits22(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
    if (superClass)
      _setPrototypeOf22(subClass, superClass);
  }
  function _setPrototypeOf22(o2, p) {
    _setPrototypeOf22 = Object.setPrototypeOf || function _setPrototypeOf34(o3, p2) {
      o3.__proto__ = p2;
      return o3;
    };
    return _setPrototypeOf22(o2, p);
  }
  function _createSuper22(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct22();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf22(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf22(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn22(this, result);
    };
  }
  function _possibleConstructorReturn22(self2, call) {
    if (call && (_typeof24(call) === "object" || typeof call === "function")) {
      return call;
    }
    return _assertThisInitialized22(self2);
  }
  function _assertThisInitialized22(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _isNativeReflectConstruct22() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e3) {
      return false;
    }
  }
  function _getPrototypeOf22(o2) {
    _getPrototypeOf22 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf34(o3) {
      return o3.__proto__ || Object.getPrototypeOf(o3);
    };
    return _getPrototypeOf22(o2);
  }
  function _defineProperty22(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var Hour1to12Parser = /* @__PURE__ */ function(_Parser) {
    _inherits22(Hour1to12Parser2, _Parser);
    var _super = _createSuper22(Hour1to12Parser2);
    function Hour1to12Parser2() {
      var _this;
      _classCallCheck23(this, Hour1to12Parser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty22(_assertThisInitialized22(_this), "priority", 70);
      _defineProperty22(_assertThisInitialized22(_this), "incompatibleTokens", ["H", "K", "k", "t", "T"]);
      return _this;
    }
    _createClass23(Hour1to12Parser2, [{
      key: "parse",
      value: function parse3(dateString, token, match2) {
        switch (token) {
          case "h":
            return parseNumericPattern(numericPatterns.hour12h, dateString);
          case "ho":
            return match2.ordinalNumber(dateString, {
              unit: "hour"
            });
          default:
            return parseNDigits(token.length, dateString);
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value >= 1 && value <= 12;
      }
    }, {
      key: "set",
      value: function set2(date, _flags, value) {
        var isPM = date.getUTCHours() >= 12;
        if (isPM && value < 12) {
          date.setUTCHours(value + 12, 0, 0, 0);
        } else if (!isPM && value === 12) {
          date.setUTCHours(0, 0, 0, 0);
        } else {
          date.setUTCHours(value, 0, 0, 0);
        }
        return date;
      }
    }]);
    return Hour1to12Parser2;
  }(Parser);

  // ../../node_modules/date-fns/esm/parse/_lib/parsers/Hour0to23Parser.js
  function _typeof25(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof25 = function _typeof36(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof25 = function _typeof36(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof25(obj);
  }
  function _classCallCheck24(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties24(target, props) {
    for (var i3 = 0; i3 < props.length; i3++) {
      var descriptor = props[i3];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass24(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties24(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties24(Constructor, staticProps);
    return Constructor;
  }
  function _inherits23(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
    if (superClass)
      _setPrototypeOf23(subClass, superClass);
  }
  function _setPrototypeOf23(o2, p) {
    _setPrototypeOf23 = Object.setPrototypeOf || function _setPrototypeOf34(o3, p2) {
      o3.__proto__ = p2;
      return o3;
    };
    return _setPrototypeOf23(o2, p);
  }
  function _createSuper23(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct23();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf23(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf23(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn23(this, result);
    };
  }
  function _possibleConstructorReturn23(self2, call) {
    if (call && (_typeof25(call) === "object" || typeof call === "function")) {
      return call;
    }
    return _assertThisInitialized23(self2);
  }
  function _assertThisInitialized23(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _isNativeReflectConstruct23() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e3) {
      return false;
    }
  }
  function _getPrototypeOf23(o2) {
    _getPrototypeOf23 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf34(o3) {
      return o3.__proto__ || Object.getPrototypeOf(o3);
    };
    return _getPrototypeOf23(o2);
  }
  function _defineProperty23(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var Hour0to23Parser = /* @__PURE__ */ function(_Parser) {
    _inherits23(Hour0to23Parser2, _Parser);
    var _super = _createSuper23(Hour0to23Parser2);
    function Hour0to23Parser2() {
      var _this;
      _classCallCheck24(this, Hour0to23Parser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty23(_assertThisInitialized23(_this), "priority", 70);
      _defineProperty23(_assertThisInitialized23(_this), "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"]);
      return _this;
    }
    _createClass24(Hour0to23Parser2, [{
      key: "parse",
      value: function parse3(dateString, token, match2) {
        switch (token) {
          case "H":
            return parseNumericPattern(numericPatterns.hour23h, dateString);
          case "Ho":
            return match2.ordinalNumber(dateString, {
              unit: "hour"
            });
          default:
            return parseNDigits(token.length, dateString);
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value >= 0 && value <= 23;
      }
    }, {
      key: "set",
      value: function set2(date, _flags, value) {
        date.setUTCHours(value, 0, 0, 0);
        return date;
      }
    }]);
    return Hour0to23Parser2;
  }(Parser);

  // ../../node_modules/date-fns/esm/parse/_lib/parsers/Hour0To11Parser.js
  function _typeof26(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof26 = function _typeof36(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof26 = function _typeof36(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof26(obj);
  }
  function _classCallCheck25(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties25(target, props) {
    for (var i3 = 0; i3 < props.length; i3++) {
      var descriptor = props[i3];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass25(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties25(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties25(Constructor, staticProps);
    return Constructor;
  }
  function _inherits24(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
    if (superClass)
      _setPrototypeOf24(subClass, superClass);
  }
  function _setPrototypeOf24(o2, p) {
    _setPrototypeOf24 = Object.setPrototypeOf || function _setPrototypeOf34(o3, p2) {
      o3.__proto__ = p2;
      return o3;
    };
    return _setPrototypeOf24(o2, p);
  }
  function _createSuper24(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct24();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf24(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf24(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn24(this, result);
    };
  }
  function _possibleConstructorReturn24(self2, call) {
    if (call && (_typeof26(call) === "object" || typeof call === "function")) {
      return call;
    }
    return _assertThisInitialized24(self2);
  }
  function _assertThisInitialized24(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _isNativeReflectConstruct24() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e3) {
      return false;
    }
  }
  function _getPrototypeOf24(o2) {
    _getPrototypeOf24 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf34(o3) {
      return o3.__proto__ || Object.getPrototypeOf(o3);
    };
    return _getPrototypeOf24(o2);
  }
  function _defineProperty24(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var Hour0To11Parser = /* @__PURE__ */ function(_Parser) {
    _inherits24(Hour0To11Parser2, _Parser);
    var _super = _createSuper24(Hour0To11Parser2);
    function Hour0To11Parser2() {
      var _this;
      _classCallCheck25(this, Hour0To11Parser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty24(_assertThisInitialized24(_this), "priority", 70);
      _defineProperty24(_assertThisInitialized24(_this), "incompatibleTokens", ["h", "H", "k", "t", "T"]);
      return _this;
    }
    _createClass25(Hour0To11Parser2, [{
      key: "parse",
      value: function parse3(dateString, token, match2) {
        switch (token) {
          case "K":
            return parseNumericPattern(numericPatterns.hour11h, dateString);
          case "Ko":
            return match2.ordinalNumber(dateString, {
              unit: "hour"
            });
          default:
            return parseNDigits(token.length, dateString);
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value >= 0 && value <= 11;
      }
    }, {
      key: "set",
      value: function set2(date, _flags, value) {
        var isPM = date.getUTCHours() >= 12;
        if (isPM && value < 12) {
          date.setUTCHours(value + 12, 0, 0, 0);
        } else {
          date.setUTCHours(value, 0, 0, 0);
        }
        return date;
      }
    }]);
    return Hour0To11Parser2;
  }(Parser);

  // ../../node_modules/date-fns/esm/parse/_lib/parsers/Hour1To24Parser.js
  function _typeof27(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof27 = function _typeof36(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof27 = function _typeof36(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof27(obj);
  }
  function _classCallCheck26(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties26(target, props) {
    for (var i3 = 0; i3 < props.length; i3++) {
      var descriptor = props[i3];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass26(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties26(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties26(Constructor, staticProps);
    return Constructor;
  }
  function _inherits25(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
    if (superClass)
      _setPrototypeOf25(subClass, superClass);
  }
  function _setPrototypeOf25(o2, p) {
    _setPrototypeOf25 = Object.setPrototypeOf || function _setPrototypeOf34(o3, p2) {
      o3.__proto__ = p2;
      return o3;
    };
    return _setPrototypeOf25(o2, p);
  }
  function _createSuper25(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct25();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf25(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf25(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn25(this, result);
    };
  }
  function _possibleConstructorReturn25(self2, call) {
    if (call && (_typeof27(call) === "object" || typeof call === "function")) {
      return call;
    }
    return _assertThisInitialized25(self2);
  }
  function _assertThisInitialized25(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _isNativeReflectConstruct25() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e3) {
      return false;
    }
  }
  function _getPrototypeOf25(o2) {
    _getPrototypeOf25 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf34(o3) {
      return o3.__proto__ || Object.getPrototypeOf(o3);
    };
    return _getPrototypeOf25(o2);
  }
  function _defineProperty25(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var Hour1To24Parser = /* @__PURE__ */ function(_Parser) {
    _inherits25(Hour1To24Parser2, _Parser);
    var _super = _createSuper25(Hour1To24Parser2);
    function Hour1To24Parser2() {
      var _this;
      _classCallCheck26(this, Hour1To24Parser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty25(_assertThisInitialized25(_this), "priority", 70);
      _defineProperty25(_assertThisInitialized25(_this), "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"]);
      return _this;
    }
    _createClass26(Hour1To24Parser2, [{
      key: "parse",
      value: function parse3(dateString, token, match2) {
        switch (token) {
          case "k":
            return parseNumericPattern(numericPatterns.hour24h, dateString);
          case "ko":
            return match2.ordinalNumber(dateString, {
              unit: "hour"
            });
          default:
            return parseNDigits(token.length, dateString);
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value >= 1 && value <= 24;
      }
    }, {
      key: "set",
      value: function set2(date, _flags, value) {
        var hours = value <= 24 ? value % 24 : value;
        date.setUTCHours(hours, 0, 0, 0);
        return date;
      }
    }]);
    return Hour1To24Parser2;
  }(Parser);

  // ../../node_modules/date-fns/esm/parse/_lib/parsers/MinuteParser.js
  function _typeof28(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof28 = function _typeof36(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof28 = function _typeof36(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof28(obj);
  }
  function _classCallCheck27(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties27(target, props) {
    for (var i3 = 0; i3 < props.length; i3++) {
      var descriptor = props[i3];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass27(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties27(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties27(Constructor, staticProps);
    return Constructor;
  }
  function _inherits26(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
    if (superClass)
      _setPrototypeOf26(subClass, superClass);
  }
  function _setPrototypeOf26(o2, p) {
    _setPrototypeOf26 = Object.setPrototypeOf || function _setPrototypeOf34(o3, p2) {
      o3.__proto__ = p2;
      return o3;
    };
    return _setPrototypeOf26(o2, p);
  }
  function _createSuper26(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct26();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf26(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf26(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn26(this, result);
    };
  }
  function _possibleConstructorReturn26(self2, call) {
    if (call && (_typeof28(call) === "object" || typeof call === "function")) {
      return call;
    }
    return _assertThisInitialized26(self2);
  }
  function _assertThisInitialized26(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _isNativeReflectConstruct26() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e3) {
      return false;
    }
  }
  function _getPrototypeOf26(o2) {
    _getPrototypeOf26 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf34(o3) {
      return o3.__proto__ || Object.getPrototypeOf(o3);
    };
    return _getPrototypeOf26(o2);
  }
  function _defineProperty26(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var MinuteParser = /* @__PURE__ */ function(_Parser) {
    _inherits26(MinuteParser2, _Parser);
    var _super = _createSuper26(MinuteParser2);
    function MinuteParser2() {
      var _this;
      _classCallCheck27(this, MinuteParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty26(_assertThisInitialized26(_this), "priority", 60);
      _defineProperty26(_assertThisInitialized26(_this), "incompatibleTokens", ["t", "T"]);
      return _this;
    }
    _createClass27(MinuteParser2, [{
      key: "parse",
      value: function parse3(dateString, token, match2) {
        switch (token) {
          case "m":
            return parseNumericPattern(numericPatterns.minute, dateString);
          case "mo":
            return match2.ordinalNumber(dateString, {
              unit: "minute"
            });
          default:
            return parseNDigits(token.length, dateString);
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value >= 0 && value <= 59;
      }
    }, {
      key: "set",
      value: function set2(date, _flags, value) {
        date.setUTCMinutes(value, 0, 0);
        return date;
      }
    }]);
    return MinuteParser2;
  }(Parser);

  // ../../node_modules/date-fns/esm/parse/_lib/parsers/SecondParser.js
  function _typeof29(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof29 = function _typeof36(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof29 = function _typeof36(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof29(obj);
  }
  function _classCallCheck28(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties28(target, props) {
    for (var i3 = 0; i3 < props.length; i3++) {
      var descriptor = props[i3];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass28(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties28(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties28(Constructor, staticProps);
    return Constructor;
  }
  function _inherits27(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
    if (superClass)
      _setPrototypeOf27(subClass, superClass);
  }
  function _setPrototypeOf27(o2, p) {
    _setPrototypeOf27 = Object.setPrototypeOf || function _setPrototypeOf34(o3, p2) {
      o3.__proto__ = p2;
      return o3;
    };
    return _setPrototypeOf27(o2, p);
  }
  function _createSuper27(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct27();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf27(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf27(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn27(this, result);
    };
  }
  function _possibleConstructorReturn27(self2, call) {
    if (call && (_typeof29(call) === "object" || typeof call === "function")) {
      return call;
    }
    return _assertThisInitialized27(self2);
  }
  function _assertThisInitialized27(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _isNativeReflectConstruct27() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e3) {
      return false;
    }
  }
  function _getPrototypeOf27(o2) {
    _getPrototypeOf27 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf34(o3) {
      return o3.__proto__ || Object.getPrototypeOf(o3);
    };
    return _getPrototypeOf27(o2);
  }
  function _defineProperty27(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var SecondParser = /* @__PURE__ */ function(_Parser) {
    _inherits27(SecondParser2, _Parser);
    var _super = _createSuper27(SecondParser2);
    function SecondParser2() {
      var _this;
      _classCallCheck28(this, SecondParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty27(_assertThisInitialized27(_this), "priority", 50);
      _defineProperty27(_assertThisInitialized27(_this), "incompatibleTokens", ["t", "T"]);
      return _this;
    }
    _createClass28(SecondParser2, [{
      key: "parse",
      value: function parse3(dateString, token, match2) {
        switch (token) {
          case "s":
            return parseNumericPattern(numericPatterns.second, dateString);
          case "so":
            return match2.ordinalNumber(dateString, {
              unit: "second"
            });
          default:
            return parseNDigits(token.length, dateString);
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value >= 0 && value <= 59;
      }
    }, {
      key: "set",
      value: function set2(date, _flags, value) {
        date.setUTCSeconds(value, 0);
        return date;
      }
    }]);
    return SecondParser2;
  }(Parser);

  // ../../node_modules/date-fns/esm/parse/_lib/parsers/FractionOfSecondParser.js
  function _typeof30(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof30 = function _typeof36(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof30 = function _typeof36(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof30(obj);
  }
  function _classCallCheck29(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties29(target, props) {
    for (var i3 = 0; i3 < props.length; i3++) {
      var descriptor = props[i3];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass29(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties29(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties29(Constructor, staticProps);
    return Constructor;
  }
  function _inherits28(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
    if (superClass)
      _setPrototypeOf28(subClass, superClass);
  }
  function _setPrototypeOf28(o2, p) {
    _setPrototypeOf28 = Object.setPrototypeOf || function _setPrototypeOf34(o3, p2) {
      o3.__proto__ = p2;
      return o3;
    };
    return _setPrototypeOf28(o2, p);
  }
  function _createSuper28(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct28();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf28(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf28(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn28(this, result);
    };
  }
  function _possibleConstructorReturn28(self2, call) {
    if (call && (_typeof30(call) === "object" || typeof call === "function")) {
      return call;
    }
    return _assertThisInitialized28(self2);
  }
  function _assertThisInitialized28(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _isNativeReflectConstruct28() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e3) {
      return false;
    }
  }
  function _getPrototypeOf28(o2) {
    _getPrototypeOf28 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf34(o3) {
      return o3.__proto__ || Object.getPrototypeOf(o3);
    };
    return _getPrototypeOf28(o2);
  }
  function _defineProperty28(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var FractionOfSecondParser = /* @__PURE__ */ function(_Parser) {
    _inherits28(FractionOfSecondParser2, _Parser);
    var _super = _createSuper28(FractionOfSecondParser2);
    function FractionOfSecondParser2() {
      var _this;
      _classCallCheck29(this, FractionOfSecondParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty28(_assertThisInitialized28(_this), "priority", 30);
      _defineProperty28(_assertThisInitialized28(_this), "incompatibleTokens", ["t", "T"]);
      return _this;
    }
    _createClass29(FractionOfSecondParser2, [{
      key: "parse",
      value: function parse3(dateString, token) {
        var valueCallback3 = function valueCallback4(value) {
          return Math.floor(value * Math.pow(10, -token.length + 3));
        };
        return mapValue(parseNDigits(token.length, dateString), valueCallback3);
      }
    }, {
      key: "set",
      value: function set2(date, _flags, value) {
        date.setUTCMilliseconds(value);
        return date;
      }
    }]);
    return FractionOfSecondParser2;
  }(Parser);

  // ../../node_modules/date-fns/esm/parse/_lib/parsers/ISOTimezoneWithZParser.js
  function _typeof31(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof31 = function _typeof36(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof31 = function _typeof36(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof31(obj);
  }
  function _classCallCheck30(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties30(target, props) {
    for (var i3 = 0; i3 < props.length; i3++) {
      var descriptor = props[i3];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass30(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties30(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties30(Constructor, staticProps);
    return Constructor;
  }
  function _inherits29(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
    if (superClass)
      _setPrototypeOf29(subClass, superClass);
  }
  function _setPrototypeOf29(o2, p) {
    _setPrototypeOf29 = Object.setPrototypeOf || function _setPrototypeOf34(o3, p2) {
      o3.__proto__ = p2;
      return o3;
    };
    return _setPrototypeOf29(o2, p);
  }
  function _createSuper29(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct29();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf29(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf29(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn29(this, result);
    };
  }
  function _possibleConstructorReturn29(self2, call) {
    if (call && (_typeof31(call) === "object" || typeof call === "function")) {
      return call;
    }
    return _assertThisInitialized29(self2);
  }
  function _assertThisInitialized29(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _isNativeReflectConstruct29() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e3) {
      return false;
    }
  }
  function _getPrototypeOf29(o2) {
    _getPrototypeOf29 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf34(o3) {
      return o3.__proto__ || Object.getPrototypeOf(o3);
    };
    return _getPrototypeOf29(o2);
  }
  function _defineProperty29(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var ISOTimezoneWithZParser = /* @__PURE__ */ function(_Parser) {
    _inherits29(ISOTimezoneWithZParser2, _Parser);
    var _super = _createSuper29(ISOTimezoneWithZParser2);
    function ISOTimezoneWithZParser2() {
      var _this;
      _classCallCheck30(this, ISOTimezoneWithZParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty29(_assertThisInitialized29(_this), "priority", 10);
      _defineProperty29(_assertThisInitialized29(_this), "incompatibleTokens", ["t", "T", "x"]);
      return _this;
    }
    _createClass30(ISOTimezoneWithZParser2, [{
      key: "parse",
      value: function parse3(dateString, token) {
        switch (token) {
          case "X":
            return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
          case "XX":
            return parseTimezonePattern(timezonePatterns.basic, dateString);
          case "XXXX":
            return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
          case "XXXXX":
            return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
          case "XXX":
          default:
            return parseTimezonePattern(timezonePatterns.extended, dateString);
        }
      }
    }, {
      key: "set",
      value: function set2(date, flags, value) {
        if (flags.timestampIsSet) {
          return date;
        }
        return new Date(date.getTime() - value);
      }
    }]);
    return ISOTimezoneWithZParser2;
  }(Parser);

  // ../../node_modules/date-fns/esm/parse/_lib/parsers/ISOTimezoneParser.js
  function _typeof32(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof32 = function _typeof36(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof32 = function _typeof36(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof32(obj);
  }
  function _classCallCheck31(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties31(target, props) {
    for (var i3 = 0; i3 < props.length; i3++) {
      var descriptor = props[i3];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass31(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties31(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties31(Constructor, staticProps);
    return Constructor;
  }
  function _inherits30(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
    if (superClass)
      _setPrototypeOf30(subClass, superClass);
  }
  function _setPrototypeOf30(o2, p) {
    _setPrototypeOf30 = Object.setPrototypeOf || function _setPrototypeOf34(o3, p2) {
      o3.__proto__ = p2;
      return o3;
    };
    return _setPrototypeOf30(o2, p);
  }
  function _createSuper30(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct30();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf30(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf30(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn30(this, result);
    };
  }
  function _possibleConstructorReturn30(self2, call) {
    if (call && (_typeof32(call) === "object" || typeof call === "function")) {
      return call;
    }
    return _assertThisInitialized30(self2);
  }
  function _assertThisInitialized30(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _isNativeReflectConstruct30() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e3) {
      return false;
    }
  }
  function _getPrototypeOf30(o2) {
    _getPrototypeOf30 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf34(o3) {
      return o3.__proto__ || Object.getPrototypeOf(o3);
    };
    return _getPrototypeOf30(o2);
  }
  function _defineProperty30(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var ISOTimezoneParser = /* @__PURE__ */ function(_Parser) {
    _inherits30(ISOTimezoneParser2, _Parser);
    var _super = _createSuper30(ISOTimezoneParser2);
    function ISOTimezoneParser2() {
      var _this;
      _classCallCheck31(this, ISOTimezoneParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty30(_assertThisInitialized30(_this), "priority", 10);
      _defineProperty30(_assertThisInitialized30(_this), "incompatibleTokens", ["t", "T", "X"]);
      return _this;
    }
    _createClass31(ISOTimezoneParser2, [{
      key: "parse",
      value: function parse3(dateString, token) {
        switch (token) {
          case "x":
            return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
          case "xx":
            return parseTimezonePattern(timezonePatterns.basic, dateString);
          case "xxxx":
            return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
          case "xxxxx":
            return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
          case "xxx":
          default:
            return parseTimezonePattern(timezonePatterns.extended, dateString);
        }
      }
    }, {
      key: "set",
      value: function set2(date, flags, value) {
        if (flags.timestampIsSet) {
          return date;
        }
        return new Date(date.getTime() - value);
      }
    }]);
    return ISOTimezoneParser2;
  }(Parser);

  // ../../node_modules/date-fns/esm/parse/_lib/parsers/TimestampSecondsParser.js
  function _typeof33(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof33 = function _typeof36(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof33 = function _typeof36(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof33(obj);
  }
  function _classCallCheck32(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties32(target, props) {
    for (var i3 = 0; i3 < props.length; i3++) {
      var descriptor = props[i3];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass32(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties32(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties32(Constructor, staticProps);
    return Constructor;
  }
  function _inherits31(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
    if (superClass)
      _setPrototypeOf31(subClass, superClass);
  }
  function _setPrototypeOf31(o2, p) {
    _setPrototypeOf31 = Object.setPrototypeOf || function _setPrototypeOf34(o3, p2) {
      o3.__proto__ = p2;
      return o3;
    };
    return _setPrototypeOf31(o2, p);
  }
  function _createSuper31(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct31();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf31(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf31(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn31(this, result);
    };
  }
  function _possibleConstructorReturn31(self2, call) {
    if (call && (_typeof33(call) === "object" || typeof call === "function")) {
      return call;
    }
    return _assertThisInitialized31(self2);
  }
  function _assertThisInitialized31(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _isNativeReflectConstruct31() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e3) {
      return false;
    }
  }
  function _getPrototypeOf31(o2) {
    _getPrototypeOf31 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf34(o3) {
      return o3.__proto__ || Object.getPrototypeOf(o3);
    };
    return _getPrototypeOf31(o2);
  }
  function _defineProperty31(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var TimestampSecondsParser = /* @__PURE__ */ function(_Parser) {
    _inherits31(TimestampSecondsParser2, _Parser);
    var _super = _createSuper31(TimestampSecondsParser2);
    function TimestampSecondsParser2() {
      var _this;
      _classCallCheck32(this, TimestampSecondsParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty31(_assertThisInitialized31(_this), "priority", 40);
      _defineProperty31(_assertThisInitialized31(_this), "incompatibleTokens", "*");
      return _this;
    }
    _createClass32(TimestampSecondsParser2, [{
      key: "parse",
      value: function parse3(dateString) {
        return parseAnyDigitsSigned(dateString);
      }
    }, {
      key: "set",
      value: function set2(_date, _flags, value) {
        return [new Date(value * 1e3), {
          timestampIsSet: true
        }];
      }
    }]);
    return TimestampSecondsParser2;
  }(Parser);

  // ../../node_modules/date-fns/esm/parse/_lib/parsers/TimestampMillisecondsParser.js
  function _typeof34(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof34 = function _typeof36(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof34 = function _typeof36(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof34(obj);
  }
  function _classCallCheck33(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties33(target, props) {
    for (var i3 = 0; i3 < props.length; i3++) {
      var descriptor = props[i3];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass33(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties33(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties33(Constructor, staticProps);
    return Constructor;
  }
  function _inherits32(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
    if (superClass)
      _setPrototypeOf32(subClass, superClass);
  }
  function _setPrototypeOf32(o2, p) {
    _setPrototypeOf32 = Object.setPrototypeOf || function _setPrototypeOf34(o3, p2) {
      o3.__proto__ = p2;
      return o3;
    };
    return _setPrototypeOf32(o2, p);
  }
  function _createSuper32(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct32();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf32(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf32(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn32(this, result);
    };
  }
  function _possibleConstructorReturn32(self2, call) {
    if (call && (_typeof34(call) === "object" || typeof call === "function")) {
      return call;
    }
    return _assertThisInitialized32(self2);
  }
  function _assertThisInitialized32(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _isNativeReflectConstruct32() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e3) {
      return false;
    }
  }
  function _getPrototypeOf32(o2) {
    _getPrototypeOf32 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf34(o3) {
      return o3.__proto__ || Object.getPrototypeOf(o3);
    };
    return _getPrototypeOf32(o2);
  }
  function _defineProperty32(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var TimestampMillisecondsParser = /* @__PURE__ */ function(_Parser) {
    _inherits32(TimestampMillisecondsParser2, _Parser);
    var _super = _createSuper32(TimestampMillisecondsParser2);
    function TimestampMillisecondsParser2() {
      var _this;
      _classCallCheck33(this, TimestampMillisecondsParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty32(_assertThisInitialized32(_this), "priority", 20);
      _defineProperty32(_assertThisInitialized32(_this), "incompatibleTokens", "*");
      return _this;
    }
    _createClass33(TimestampMillisecondsParser2, [{
      key: "parse",
      value: function parse3(dateString) {
        return parseAnyDigitsSigned(dateString);
      }
    }, {
      key: "set",
      value: function set2(_date, _flags, value) {
        return [new Date(value), {
          timestampIsSet: true
        }];
      }
    }]);
    return TimestampMillisecondsParser2;
  }(Parser);

  // ../../node_modules/date-fns/esm/parse/_lib/parsers/index.js
  var parsers = {
    G: new EraParser(),
    y: new YearParser(),
    Y: new LocalWeekYearParser(),
    R: new ISOWeekYearParser(),
    u: new ExtendedYearParser(),
    Q: new QuarterParser(),
    q: new StandAloneQuarterParser(),
    M: new MonthParser(),
    L: new StandAloneMonthParser(),
    w: new LocalWeekParser(),
    I: new ISOWeekParser(),
    d: new DateParser(),
    D: new DayOfYearParser(),
    E: new DayParser(),
    e: new LocalDayParser(),
    c: new StandAloneLocalDayParser(),
    i: new ISODayParser(),
    a: new AMPMParser(),
    b: new AMPMMidnightParser(),
    B: new DayPeriodParser(),
    h: new Hour1to12Parser(),
    H: new Hour0to23Parser(),
    K: new Hour0To11Parser(),
    k: new Hour1To24Parser(),
    m: new MinuteParser(),
    s: new SecondParser(),
    S: new FractionOfSecondParser(),
    X: new ISOTimezoneWithZParser(),
    x: new ISOTimezoneParser(),
    t: new TimestampSecondsParser(),
    T: new TimestampMillisecondsParser()
  };

  // ../../node_modules/date-fns/esm/parse/index.js
  function _typeof35(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof35 = function _typeof36(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof35 = function _typeof36(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof35(obj);
  }
  function _createForOfIteratorHelper(o2, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o2[Symbol.iterator] == null) {
      if (Array.isArray(o2) || (it = _unsupportedIterableToArray(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
        if (it)
          o2 = it;
        var i3 = 0;
        var F = function F2() {
        };
        return { s: F, n: function n2() {
          if (i3 >= o2.length)
            return { done: true };
          return { done: false, value: o2[i3++] };
        }, e: function e3(_e) {
          throw _e;
        }, f: F };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s4() {
      it = o2[Symbol.iterator]();
    }, n: function n2() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e3(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray(o2, minLen) {
    if (!o2)
      return;
    if (typeof o2 === "string")
      return _arrayLikeToArray(o2, minLen);
    var n2 = Object.prototype.toString.call(o2).slice(8, -1);
    if (n2 === "Object" && o2.constructor)
      n2 = o2.constructor.name;
    if (n2 === "Map" || n2 === "Set")
      return Array.from(o2);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return _arrayLikeToArray(o2, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i3 = 0, arr2 = new Array(len); i3 < len; i3++) {
      arr2[i3] = arr[i3];
    }
    return arr2;
  }
  var formattingTokensRegExp2 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
  var longFormattingTokensRegExp2 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
  var escapedStringRegExp2 = /^'([^]*?)'?$/;
  var doubleQuoteRegExp2 = /''/g;
  var notWhitespaceRegExp = /\S/;
  var unescapedLatinCharacterRegExp2 = /[a-zA-Z]/;
  function parse2(dirtyDateString, dirtyFormatString, dirtyReferenceDate, options2) {
    var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
    requiredArgs(3, arguments);
    var dateString = String(dirtyDateString);
    var formatString = String(dirtyFormatString);
    var defaultOptions4 = getDefaultOptions();
    var locale2 = (_ref = (_options$locale = options2 === null || options2 === void 0 ? void 0 : options2.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions4.locale) !== null && _ref !== void 0 ? _ref : defaultLocale_default;
    if (!locale2.match) {
      throw new RangeError("locale must contain match property");
    }
    var firstWeekContainsDate = toInteger((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options2 === null || options2 === void 0 ? void 0 : options2.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options2 === null || options2 === void 0 ? void 0 : (_options$locale2 = options2.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions4.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions4.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);
    if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
      throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
    }
    var weekStartsOn = toInteger((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options2 === null || options2 === void 0 ? void 0 : options2.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options2 === null || options2 === void 0 ? void 0 : (_options$locale3 = options2.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions4.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions4.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);
    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
      throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    }
    if (formatString === "") {
      if (dateString === "") {
        return toDate2(dirtyReferenceDate);
      } else {
        return new Date(NaN);
      }
    }
    var subFnOptions = {
      firstWeekContainsDate,
      weekStartsOn,
      locale: locale2
    };
    var setters = [new DateToSystemTimezoneSetter()];
    var tokens = formatString.match(longFormattingTokensRegExp2).map(function(substring) {
      var firstCharacter = substring[0];
      if (firstCharacter in longFormatters_default) {
        var longFormatter = longFormatters_default[firstCharacter];
        return longFormatter(substring, locale2.formatLong);
      }
      return substring;
    }).join("").match(formattingTokensRegExp2);
    var usedTokens = [];
    var _iterator = _createForOfIteratorHelper(tokens), _step;
    try {
      var _loop = function _loop2() {
        var token = _step.value;
        if (!(options2 !== null && options2 !== void 0 && options2.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(token)) {
          throwProtectedError(token, formatString, dirtyDateString);
        }
        if (!(options2 !== null && options2 !== void 0 && options2.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(token)) {
          throwProtectedError(token, formatString, dirtyDateString);
        }
        var firstCharacter = token[0];
        var parser = parsers[firstCharacter];
        if (parser) {
          var incompatibleTokens = parser.incompatibleTokens;
          if (Array.isArray(incompatibleTokens)) {
            var incompatibleToken = usedTokens.find(function(usedToken) {
              return incompatibleTokens.includes(usedToken.token) || usedToken.token === firstCharacter;
            });
            if (incompatibleToken) {
              throw new RangeError("The format string mustn't contain `".concat(incompatibleToken.fullToken, "` and `").concat(token, "` at the same time"));
            }
          } else if (parser.incompatibleTokens === "*" && usedTokens.length > 0) {
            throw new RangeError("The format string mustn't contain `".concat(token, "` and any other token at the same time"));
          }
          usedTokens.push({
            token: firstCharacter,
            fullToken: token
          });
          var parseResult = parser.run(dateString, token, locale2.match, subFnOptions);
          if (!parseResult) {
            return {
              v: new Date(NaN)
            };
          }
          setters.push(parseResult.setter);
          dateString = parseResult.rest;
        } else {
          if (firstCharacter.match(unescapedLatinCharacterRegExp2)) {
            throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
          }
          if (token === "''") {
            token = "'";
          } else if (firstCharacter === "'") {
            token = cleanEscapedString2(token);
          }
          if (dateString.indexOf(token) === 0) {
            dateString = dateString.slice(token.length);
          } else {
            return {
              v: new Date(NaN)
            };
          }
        }
      };
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var _ret = _loop();
        if (_typeof35(_ret) === "object")
          return _ret.v;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    if (dateString.length > 0 && notWhitespaceRegExp.test(dateString)) {
      return new Date(NaN);
    }
    var uniquePrioritySetters = setters.map(function(setter2) {
      return setter2.priority;
    }).sort(function(a4, b2) {
      return b2 - a4;
    }).filter(function(priority, index2, array) {
      return array.indexOf(priority) === index2;
    }).map(function(priority) {
      return setters.filter(function(setter2) {
        return setter2.priority === priority;
      }).sort(function(a4, b2) {
        return b2.subPriority - a4.subPriority;
      });
    }).map(function(setterArray) {
      return setterArray[0];
    });
    var date = toDate2(dirtyReferenceDate);
    if (isNaN(date.getTime())) {
      return new Date(NaN);
    }
    var utcDate = subMilliseconds(date, getTimezoneOffsetInMilliseconds(date));
    var flags = {};
    var _iterator2 = _createForOfIteratorHelper(uniquePrioritySetters), _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
        var setter = _step2.value;
        if (!setter.validate(utcDate, subFnOptions)) {
          return new Date(NaN);
        }
        var result = setter.set(utcDate, flags, subFnOptions);
        if (Array.isArray(result)) {
          utcDate = result[0];
          assign(flags, result[1]);
        } else {
          utcDate = result;
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    return utcDate;
  }
  function cleanEscapedString2(input) {
    return input.match(escapedStringRegExp2)[1].replace(doubleQuoteRegExp2, "'");
  }

  // ../../node_modules/date-fns/esm/startOfHour/index.js
  function startOfHour(dirtyDate) {
    requiredArgs(1, arguments);
    var date = toDate2(dirtyDate);
    date.setMinutes(0, 0, 0);
    return date;
  }

  // ../../node_modules/date-fns/esm/startOfSecond/index.js
  function startOfSecond(dirtyDate) {
    requiredArgs(1, arguments);
    var date = toDate2(dirtyDate);
    date.setMilliseconds(0);
    return date;
  }

  // ../../node_modules/date-fns/esm/parseISO/index.js
  function parseISO(argument, options2) {
    var _options$additionalDi;
    requiredArgs(1, arguments);
    var additionalDigits = toInteger((_options$additionalDi = options2 === null || options2 === void 0 ? void 0 : options2.additionalDigits) !== null && _options$additionalDi !== void 0 ? _options$additionalDi : 2);
    if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
      throw new RangeError("additionalDigits must be 0, 1 or 2");
    }
    if (!(typeof argument === "string" || Object.prototype.toString.call(argument) === "[object String]")) {
      return new Date(NaN);
    }
    var dateStrings = splitDateString(argument);
    var date;
    if (dateStrings.date) {
      var parseYearResult = parseYear(dateStrings.date, additionalDigits);
      date = parseDate(parseYearResult.restDateString, parseYearResult.year);
    }
    if (!date || isNaN(date.getTime())) {
      return new Date(NaN);
    }
    var timestamp = date.getTime();
    var time = 0;
    var offset2;
    if (dateStrings.time) {
      time = parseTime(dateStrings.time);
      if (isNaN(time)) {
        return new Date(NaN);
      }
    }
    if (dateStrings.timezone) {
      offset2 = parseTimezone(dateStrings.timezone);
      if (isNaN(offset2)) {
        return new Date(NaN);
      }
    } else {
      var dirtyDate = new Date(timestamp + time);
      var result = new Date(0);
      result.setFullYear(dirtyDate.getUTCFullYear(), dirtyDate.getUTCMonth(), dirtyDate.getUTCDate());
      result.setHours(dirtyDate.getUTCHours(), dirtyDate.getUTCMinutes(), dirtyDate.getUTCSeconds(), dirtyDate.getUTCMilliseconds());
      return result;
    }
    return new Date(timestamp + time + offset2);
  }
  var patterns = {
    dateTimeDelimiter: /[T ]/,
    timeZoneDelimiter: /[Z ]/i,
    timezone: /([Z+-].*)$/
  };
  var dateRegex = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
  var timeRegex = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
  var timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;
  function splitDateString(dateString) {
    var dateStrings = {};
    var array = dateString.split(patterns.dateTimeDelimiter);
    var timeString;
    if (array.length > 2) {
      return dateStrings;
    }
    if (/:/.test(array[0])) {
      timeString = array[0];
    } else {
      dateStrings.date = array[0];
      timeString = array[1];
      if (patterns.timeZoneDelimiter.test(dateStrings.date)) {
        dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];
        timeString = dateString.substr(dateStrings.date.length, dateString.length);
      }
    }
    if (timeString) {
      var token = patterns.timezone.exec(timeString);
      if (token) {
        dateStrings.time = timeString.replace(token[1], "");
        dateStrings.timezone = token[1];
      } else {
        dateStrings.time = timeString;
      }
    }
    return dateStrings;
  }
  function parseYear(dateString, additionalDigits) {
    var regex = new RegExp("^(?:(\\d{4}|[+-]\\d{" + (4 + additionalDigits) + "})|(\\d{2}|[+-]\\d{" + (2 + additionalDigits) + "})$)");
    var captures = dateString.match(regex);
    if (!captures)
      return {
        year: NaN,
        restDateString: ""
      };
    var year = captures[1] ? parseInt(captures[1]) : null;
    var century = captures[2] ? parseInt(captures[2]) : null;
    return {
      year: century === null ? year : century * 100,
      restDateString: dateString.slice((captures[1] || captures[2]).length)
    };
  }
  function parseDate(dateString, year) {
    if (year === null)
      return new Date(NaN);
    var captures = dateString.match(dateRegex);
    if (!captures)
      return new Date(NaN);
    var isWeekDate = !!captures[4];
    var dayOfYear = parseDateUnit(captures[1]);
    var month = parseDateUnit(captures[2]) - 1;
    var day = parseDateUnit(captures[3]);
    var week = parseDateUnit(captures[4]);
    var dayOfWeek = parseDateUnit(captures[5]) - 1;
    if (isWeekDate) {
      if (!validateWeekDate(year, week, dayOfWeek)) {
        return new Date(NaN);
      }
      return dayOfISOWeekYear(year, week, dayOfWeek);
    } else {
      var date = new Date(0);
      if (!validateDate(year, month, day) || !validateDayOfYearDate(year, dayOfYear)) {
        return new Date(NaN);
      }
      date.setUTCFullYear(year, month, Math.max(dayOfYear, day));
      return date;
    }
  }
  function parseDateUnit(value) {
    return value ? parseInt(value) : 1;
  }
  function parseTime(timeString) {
    var captures = timeString.match(timeRegex);
    if (!captures)
      return NaN;
    var hours = parseTimeUnit(captures[1]);
    var minutes = parseTimeUnit(captures[2]);
    var seconds = parseTimeUnit(captures[3]);
    if (!validateTime(hours, minutes, seconds)) {
      return NaN;
    }
    return hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * 1e3;
  }
  function parseTimeUnit(value) {
    return value && parseFloat(value.replace(",", ".")) || 0;
  }
  function parseTimezone(timezoneString) {
    if (timezoneString === "Z")
      return 0;
    var captures = timezoneString.match(timezoneRegex);
    if (!captures)
      return 0;
    var sign2 = captures[1] === "+" ? -1 : 1;
    var hours = parseInt(captures[2]);
    var minutes = captures[3] && parseInt(captures[3]) || 0;
    if (!validateTimezone(hours, minutes)) {
      return NaN;
    }
    return sign2 * (hours * millisecondsInHour + minutes * millisecondsInMinute);
  }
  function dayOfISOWeekYear(isoWeekYear, week, day) {
    var date = new Date(0);
    date.setUTCFullYear(isoWeekYear, 0, 4);
    var fourthOfJanuaryDay = date.getUTCDay() || 7;
    var diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
    date.setUTCDate(date.getUTCDate() + diff);
    return date;
  }
  var daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  function isLeapYearIndex2(year) {
    return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
  }
  function validateDate(year, month, date) {
    return month >= 0 && month <= 11 && date >= 1 && date <= (daysInMonths[month] || (isLeapYearIndex2(year) ? 29 : 28));
  }
  function validateDayOfYearDate(year, dayOfYear) {
    return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex2(year) ? 366 : 365);
  }
  function validateWeekDate(_year, week, day) {
    return week >= 1 && week <= 53 && day >= 0 && day <= 6;
  }
  function validateTime(hours, minutes, seconds) {
    if (hours === 24) {
      return minutes === 0 && seconds === 0;
    }
    return seconds >= 0 && seconds < 60 && minutes >= 0 && minutes < 60 && hours >= 0 && hours < 25;
  }
  function validateTimezone(_hours, minutes) {
    return minutes >= 0 && minutes <= 59;
  }

  // ../../node_modules/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.esm.js
  var FORMATS = {
    datetime: "MMM d, yyyy, h:mm:ss aaaa",
    millisecond: "h:mm:ss.SSS aaaa",
    second: "h:mm:ss aaaa",
    minute: "h:mm aaaa",
    hour: "ha",
    day: "MMM d",
    week: "PP",
    month: "MMM yyyy",
    quarter: "qqq - yyyy",
    year: "yyyy"
  };
  adapters2._date.override({
    _id: "date-fns",
    formats: function() {
      return FORMATS;
    },
    parse: function(value, fmt) {
      if (value === null || typeof value === "undefined") {
        return null;
      }
      const type = typeof value;
      if (type === "number" || value instanceof Date) {
        value = toDate2(value);
      } else if (type === "string") {
        if (typeof fmt === "string") {
          value = parse2(value, fmt, new Date(), this.options);
        } else {
          value = parseISO(value, this.options);
        }
      }
      return isValid(value) ? value.getTime() : null;
    },
    format: function(time, fmt) {
      return format(time, fmt, this.options);
    },
    add: function(time, amount, unit) {
      switch (unit) {
        case "millisecond":
          return addMilliseconds(time, amount);
        case "second":
          return addSeconds(time, amount);
        case "minute":
          return addMinutes(time, amount);
        case "hour":
          return addHours(time, amount);
        case "day":
          return addDays(time, amount);
        case "week":
          return addWeeks(time, amount);
        case "month":
          return addMonths(time, amount);
        case "quarter":
          return addQuarters(time, amount);
        case "year":
          return addYears(time, amount);
        default:
          return time;
      }
    },
    diff: function(max2, min2, unit) {
      switch (unit) {
        case "millisecond":
          return differenceInMilliseconds(max2, min2);
        case "second":
          return differenceInSeconds(max2, min2);
        case "minute":
          return differenceInMinutes(max2, min2);
        case "hour":
          return differenceInHours(max2, min2);
        case "day":
          return differenceInDays(max2, min2);
        case "week":
          return differenceInWeeks(max2, min2);
        case "month":
          return differenceInMonths(max2, min2);
        case "quarter":
          return differenceInQuarters(max2, min2);
        case "year":
          return differenceInYears(max2, min2);
        default:
          return 0;
      }
    },
    startOf: function(time, unit, weekday) {
      switch (unit) {
        case "second":
          return startOfSecond(time);
        case "minute":
          return startOfMinute(time);
        case "hour":
          return startOfHour(time);
        case "day":
          return startOfDay(time);
        case "week":
          return startOfWeek(time);
        case "isoWeek":
          return startOfWeek(time, { weekStartsOn: +weekday });
        case "month":
          return startOfMonth(time);
        case "quarter":
          return startOfQuarter(time);
        case "year":
          return startOfYear(time);
        default:
          return time;
      }
    },
    endOf: function(time, unit) {
      switch (unit) {
        case "second":
          return endOfSecond(time);
        case "minute":
          return endOfMinute(time);
        case "hour":
          return endOfHour(time);
        case "day":
          return endOfDay(time);
        case "week":
          return endOfWeek(time);
        case "month":
          return endOfMonth(time);
        case "quarter":
          return endOfQuarter(time);
        case "year":
          return endOfYear(time);
        default:
          return time;
      }
    }
  });

  // ../../node_modules/chartkick/chart.js/chart.esm.js
  Chartkick.use(auto_default);

  // ../../node_modules/@rails/actiontext/app/javascript/actiontext/attachment_upload.js
  var import_activestorage = __toESM(require_activestorage(), 1);
  var AttachmentUpload = class {
    constructor(attachment, element) {
      this.attachment = attachment;
      this.element = element;
      this.directUpload = new import_activestorage.DirectUpload(attachment.file, this.directUploadUrl, this.directUploadToken, this.attachmentName, this);
    }
    start() {
      this.directUpload.create(this.directUploadDidComplete.bind(this));
    }
    directUploadWillStoreFileWithXHR(xhr) {
      xhr.upload.addEventListener("progress", (event) => {
        const progress = event.loaded / event.total * 100;
        this.attachment.setUploadProgress(progress);
      });
    }
    directUploadDidComplete(error2, attributes) {
      if (error2) {
        throw new Error(`Direct upload failed: ${error2}`);
      }
      this.attachment.setAttributes({
        sgid: attributes.attachable_sgid,
        url: this.createBlobUrl(attributes.signed_id, attributes.filename)
      });
    }
    createBlobUrl(signedId, filename) {
      return this.blobUrlTemplate.replace(":signed_id", signedId).replace(":filename", encodeURIComponent(filename));
    }
    get directUploadUrl() {
      return this.element.dataset.directUploadUrl;
    }
    get blobUrlTemplate() {
      return this.element.dataset.blobUrlTemplate;
    }
    get directUploadToken() {
      return this.element.getAttribute("data-direct-upload-token");
    }
    get attachmentName() {
      return this.element.getAttribute("data-direct-upload-attachment-name");
    }
  };

  // ../../node_modules/@rails/actiontext/app/javascript/actiontext/index.js
  addEventListener("trix-attachment-add", (event) => {
    const { attachment, target } = event;
    if (attachment.file) {
      const upload = new AttachmentUpload(attachment, target);
      upload.start();
    }
  });

  // ../../node_modules/@hotwired/stimulus/dist/stimulus.js
  var EventListener = class {
    constructor(eventTarget, eventName, eventOptions) {
      this.eventTarget = eventTarget;
      this.eventName = eventName;
      this.eventOptions = eventOptions;
      this.unorderedBindings = /* @__PURE__ */ new Set();
    }
    connect() {
      this.eventTarget.addEventListener(this.eventName, this, this.eventOptions);
    }
    disconnect() {
      this.eventTarget.removeEventListener(this.eventName, this, this.eventOptions);
    }
    bindingConnected(binding) {
      this.unorderedBindings.add(binding);
    }
    bindingDisconnected(binding) {
      this.unorderedBindings.delete(binding);
    }
    handleEvent(event) {
      const extendedEvent = extendEvent(event);
      for (const binding of this.bindings) {
        if (extendedEvent.immediatePropagationStopped) {
          break;
        } else {
          binding.handleEvent(extendedEvent);
        }
      }
    }
    get bindings() {
      return Array.from(this.unorderedBindings).sort((left2, right2) => {
        const leftIndex = left2.index, rightIndex = right2.index;
        return leftIndex < rightIndex ? -1 : leftIndex > rightIndex ? 1 : 0;
      });
    }
  };
  function extendEvent(event) {
    if ("immediatePropagationStopped" in event) {
      return event;
    } else {
      const { stopImmediatePropagation } = event;
      return Object.assign(event, {
        immediatePropagationStopped: false,
        stopImmediatePropagation() {
          this.immediatePropagationStopped = true;
          stopImmediatePropagation.call(this);
        }
      });
    }
  }
  var Dispatcher = class {
    constructor(application2) {
      this.application = application2;
      this.eventListenerMaps = /* @__PURE__ */ new Map();
      this.started = false;
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.eventListeners.forEach((eventListener) => eventListener.connect());
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        this.eventListeners.forEach((eventListener) => eventListener.disconnect());
      }
    }
    get eventListeners() {
      return Array.from(this.eventListenerMaps.values()).reduce((listeners, map3) => listeners.concat(Array.from(map3.values())), []);
    }
    bindingConnected(binding) {
      this.fetchEventListenerForBinding(binding).bindingConnected(binding);
    }
    bindingDisconnected(binding) {
      this.fetchEventListenerForBinding(binding).bindingDisconnected(binding);
    }
    handleError(error2, message, detail = {}) {
      this.application.handleError(error2, `Error ${message}`, detail);
    }
    fetchEventListenerForBinding(binding) {
      const { eventTarget, eventName, eventOptions } = binding;
      return this.fetchEventListener(eventTarget, eventName, eventOptions);
    }
    fetchEventListener(eventTarget, eventName, eventOptions) {
      const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);
      const cacheKey = this.cacheKey(eventName, eventOptions);
      let eventListener = eventListenerMap.get(cacheKey);
      if (!eventListener) {
        eventListener = this.createEventListener(eventTarget, eventName, eventOptions);
        eventListenerMap.set(cacheKey, eventListener);
      }
      return eventListener;
    }
    createEventListener(eventTarget, eventName, eventOptions) {
      const eventListener = new EventListener(eventTarget, eventName, eventOptions);
      if (this.started) {
        eventListener.connect();
      }
      return eventListener;
    }
    fetchEventListenerMapForEventTarget(eventTarget) {
      let eventListenerMap = this.eventListenerMaps.get(eventTarget);
      if (!eventListenerMap) {
        eventListenerMap = /* @__PURE__ */ new Map();
        this.eventListenerMaps.set(eventTarget, eventListenerMap);
      }
      return eventListenerMap;
    }
    cacheKey(eventName, eventOptions) {
      const parts = [eventName];
      Object.keys(eventOptions).sort().forEach((key) => {
        parts.push(`${eventOptions[key] ? "" : "!"}${key}`);
      });
      return parts.join(":");
    }
  };
  var descriptorPattern = /^((.+?)(@(window|document))?->)?(.+?)(#([^:]+?))(:(.+))?$/;
  function parseActionDescriptorString(descriptorString) {
    const source = descriptorString.trim();
    const matches = source.match(descriptorPattern) || [];
    return {
      eventTarget: parseEventTarget(matches[4]),
      eventName: matches[2],
      eventOptions: matches[9] ? parseEventOptions(matches[9]) : {},
      identifier: matches[5],
      methodName: matches[7]
    };
  }
  function parseEventTarget(eventTargetName) {
    if (eventTargetName == "window") {
      return window;
    } else if (eventTargetName == "document") {
      return document;
    }
  }
  function parseEventOptions(eventOptions) {
    return eventOptions.split(":").reduce((options2, token) => Object.assign(options2, { [token.replace(/^!/, "")]: !/^!/.test(token) }), {});
  }
  function stringifyEventTarget(eventTarget) {
    if (eventTarget == window) {
      return "window";
    } else if (eventTarget == document) {
      return "document";
    }
  }
  function camelize(value) {
    return value.replace(/(?:[_-])([a-z0-9])/g, (_, char) => char.toUpperCase());
  }
  function capitalize(value) {
    return value.charAt(0).toUpperCase() + value.slice(1);
  }
  function dasherize(value) {
    return value.replace(/([A-Z])/g, (_, char) => `-${char.toLowerCase()}`);
  }
  function tokenize(value) {
    return value.match(/[^\s]+/g) || [];
  }
  var Action = class {
    constructor(element, index2, descriptor) {
      this.element = element;
      this.index = index2;
      this.eventTarget = descriptor.eventTarget || element;
      this.eventName = descriptor.eventName || getDefaultEventNameForElement(element) || error("missing event name");
      this.eventOptions = descriptor.eventOptions || {};
      this.identifier = descriptor.identifier || error("missing identifier");
      this.methodName = descriptor.methodName || error("missing method name");
    }
    static forToken(token) {
      return new this(token.element, token.index, parseActionDescriptorString(token.content));
    }
    toString() {
      const eventNameSuffix = this.eventTargetName ? `@${this.eventTargetName}` : "";
      return `${this.eventName}${eventNameSuffix}->${this.identifier}#${this.methodName}`;
    }
    get params() {
      if (this.eventTarget instanceof Element) {
        return this.getParamsFromEventTargetAttributes(this.eventTarget);
      } else {
        return {};
      }
    }
    getParamsFromEventTargetAttributes(eventTarget) {
      const params = {};
      const pattern = new RegExp(`^data-${this.identifier}-(.+)-param$`);
      const attributes = Array.from(eventTarget.attributes);
      attributes.forEach(({ name: name2, value }) => {
        const match2 = name2.match(pattern);
        const key = match2 && match2[1];
        if (key) {
          Object.assign(params, { [camelize(key)]: typecast(value) });
        }
      });
      return params;
    }
    get eventTargetName() {
      return stringifyEventTarget(this.eventTarget);
    }
  };
  var defaultEventNames = {
    "a": (e3) => "click",
    "button": (e3) => "click",
    "form": (e3) => "submit",
    "details": (e3) => "toggle",
    "input": (e3) => e3.getAttribute("type") == "submit" ? "click" : "input",
    "select": (e3) => "change",
    "textarea": (e3) => "input"
  };
  function getDefaultEventNameForElement(element) {
    const tagName = element.tagName.toLowerCase();
    if (tagName in defaultEventNames) {
      return defaultEventNames[tagName](element);
    }
  }
  function error(message) {
    throw new Error(message);
  }
  function typecast(value) {
    try {
      return JSON.parse(value);
    } catch (o_O) {
      return value;
    }
  }
  var Binding = class {
    constructor(context, action) {
      this.context = context;
      this.action = action;
    }
    get index() {
      return this.action.index;
    }
    get eventTarget() {
      return this.action.eventTarget;
    }
    get eventOptions() {
      return this.action.eventOptions;
    }
    get identifier() {
      return this.context.identifier;
    }
    handleEvent(event) {
      if (this.willBeInvokedByEvent(event)) {
        this.invokeWithEvent(event);
      }
    }
    get eventName() {
      return this.action.eventName;
    }
    get method() {
      const method = this.controller[this.methodName];
      if (typeof method == "function") {
        return method;
      }
      throw new Error(`Action "${this.action}" references undefined method "${this.methodName}"`);
    }
    invokeWithEvent(event) {
      const { target, currentTarget } = event;
      try {
        const { params } = this.action;
        const actionEvent = Object.assign(event, { params });
        this.method.call(this.controller, actionEvent);
        this.context.logDebugActivity(this.methodName, { event, target, currentTarget, action: this.methodName });
      } catch (error2) {
        const { identifier, controller, element, index: index2 } = this;
        const detail = { identifier, controller, element, index: index2, event };
        this.context.handleError(error2, `invoking action "${this.action}"`, detail);
      }
    }
    willBeInvokedByEvent(event) {
      const eventTarget = event.target;
      if (this.element === eventTarget) {
        return true;
      } else if (eventTarget instanceof Element && this.element.contains(eventTarget)) {
        return this.scope.containsElement(eventTarget);
      } else {
        return this.scope.containsElement(this.action.element);
      }
    }
    get controller() {
      return this.context.controller;
    }
    get methodName() {
      return this.action.methodName;
    }
    get element() {
      return this.scope.element;
    }
    get scope() {
      return this.context.scope;
    }
  };
  var ElementObserver = class {
    constructor(element, delegate) {
      this.mutationObserverInit = { attributes: true, childList: true, subtree: true };
      this.element = element;
      this.started = false;
      this.delegate = delegate;
      this.elements = /* @__PURE__ */ new Set();
      this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.mutationObserver.observe(this.element, this.mutationObserverInit);
        this.refresh();
      }
    }
    pause(callback2) {
      if (this.started) {
        this.mutationObserver.disconnect();
        this.started = false;
      }
      callback2();
      if (!this.started) {
        this.mutationObserver.observe(this.element, this.mutationObserverInit);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        this.mutationObserver.takeRecords();
        this.mutationObserver.disconnect();
        this.started = false;
      }
    }
    refresh() {
      if (this.started) {
        const matches = new Set(this.matchElementsInTree());
        for (const element of Array.from(this.elements)) {
          if (!matches.has(element)) {
            this.removeElement(element);
          }
        }
        for (const element of Array.from(matches)) {
          this.addElement(element);
        }
      }
    }
    processMutations(mutations) {
      if (this.started) {
        for (const mutation of mutations) {
          this.processMutation(mutation);
        }
      }
    }
    processMutation(mutation) {
      if (mutation.type == "attributes") {
        this.processAttributeChange(mutation.target, mutation.attributeName);
      } else if (mutation.type == "childList") {
        this.processRemovedNodes(mutation.removedNodes);
        this.processAddedNodes(mutation.addedNodes);
      }
    }
    processAttributeChange(node, attributeName) {
      const element = node;
      if (this.elements.has(element)) {
        if (this.delegate.elementAttributeChanged && this.matchElement(element)) {
          this.delegate.elementAttributeChanged(element, attributeName);
        } else {
          this.removeElement(element);
        }
      } else if (this.matchElement(element)) {
        this.addElement(element);
      }
    }
    processRemovedNodes(nodes) {
      for (const node of Array.from(nodes)) {
        const element = this.elementFromNode(node);
        if (element) {
          this.processTree(element, this.removeElement);
        }
      }
    }
    processAddedNodes(nodes) {
      for (const node of Array.from(nodes)) {
        const element = this.elementFromNode(node);
        if (element && this.elementIsActive(element)) {
          this.processTree(element, this.addElement);
        }
      }
    }
    matchElement(element) {
      return this.delegate.matchElement(element);
    }
    matchElementsInTree(tree = this.element) {
      return this.delegate.matchElementsInTree(tree);
    }
    processTree(tree, processor) {
      for (const element of this.matchElementsInTree(tree)) {
        processor.call(this, element);
      }
    }
    elementFromNode(node) {
      if (node.nodeType == Node.ELEMENT_NODE) {
        return node;
      }
    }
    elementIsActive(element) {
      if (element.isConnected != this.element.isConnected) {
        return false;
      } else {
        return this.element.contains(element);
      }
    }
    addElement(element) {
      if (!this.elements.has(element)) {
        if (this.elementIsActive(element)) {
          this.elements.add(element);
          if (this.delegate.elementMatched) {
            this.delegate.elementMatched(element);
          }
        }
      }
    }
    removeElement(element) {
      if (this.elements.has(element)) {
        this.elements.delete(element);
        if (this.delegate.elementUnmatched) {
          this.delegate.elementUnmatched(element);
        }
      }
    }
  };
  var AttributeObserver = class {
    constructor(element, attributeName, delegate) {
      this.attributeName = attributeName;
      this.delegate = delegate;
      this.elementObserver = new ElementObserver(element, this);
    }
    get element() {
      return this.elementObserver.element;
    }
    get selector() {
      return `[${this.attributeName}]`;
    }
    start() {
      this.elementObserver.start();
    }
    pause(callback2) {
      this.elementObserver.pause(callback2);
    }
    stop() {
      this.elementObserver.stop();
    }
    refresh() {
      this.elementObserver.refresh();
    }
    get started() {
      return this.elementObserver.started;
    }
    matchElement(element) {
      return element.hasAttribute(this.attributeName);
    }
    matchElementsInTree(tree) {
      const match2 = this.matchElement(tree) ? [tree] : [];
      const matches = Array.from(tree.querySelectorAll(this.selector));
      return match2.concat(matches);
    }
    elementMatched(element) {
      if (this.delegate.elementMatchedAttribute) {
        this.delegate.elementMatchedAttribute(element, this.attributeName);
      }
    }
    elementUnmatched(element) {
      if (this.delegate.elementUnmatchedAttribute) {
        this.delegate.elementUnmatchedAttribute(element, this.attributeName);
      }
    }
    elementAttributeChanged(element, attributeName) {
      if (this.delegate.elementAttributeValueChanged && this.attributeName == attributeName) {
        this.delegate.elementAttributeValueChanged(element, attributeName);
      }
    }
  };
  var StringMapObserver = class {
    constructor(element, delegate) {
      this.element = element;
      this.delegate = delegate;
      this.started = false;
      this.stringMap = /* @__PURE__ */ new Map();
      this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.mutationObserver.observe(this.element, { attributes: true, attributeOldValue: true });
        this.refresh();
      }
    }
    stop() {
      if (this.started) {
        this.mutationObserver.takeRecords();
        this.mutationObserver.disconnect();
        this.started = false;
      }
    }
    refresh() {
      if (this.started) {
        for (const attributeName of this.knownAttributeNames) {
          this.refreshAttribute(attributeName, null);
        }
      }
    }
    processMutations(mutations) {
      if (this.started) {
        for (const mutation of mutations) {
          this.processMutation(mutation);
        }
      }
    }
    processMutation(mutation) {
      const attributeName = mutation.attributeName;
      if (attributeName) {
        this.refreshAttribute(attributeName, mutation.oldValue);
      }
    }
    refreshAttribute(attributeName, oldValue) {
      const key = this.delegate.getStringMapKeyForAttribute(attributeName);
      if (key != null) {
        if (!this.stringMap.has(attributeName)) {
          this.stringMapKeyAdded(key, attributeName);
        }
        const value = this.element.getAttribute(attributeName);
        if (this.stringMap.get(attributeName) != value) {
          this.stringMapValueChanged(value, key, oldValue);
        }
        if (value == null) {
          const oldValue2 = this.stringMap.get(attributeName);
          this.stringMap.delete(attributeName);
          if (oldValue2)
            this.stringMapKeyRemoved(key, attributeName, oldValue2);
        } else {
          this.stringMap.set(attributeName, value);
        }
      }
    }
    stringMapKeyAdded(key, attributeName) {
      if (this.delegate.stringMapKeyAdded) {
        this.delegate.stringMapKeyAdded(key, attributeName);
      }
    }
    stringMapValueChanged(value, key, oldValue) {
      if (this.delegate.stringMapValueChanged) {
        this.delegate.stringMapValueChanged(value, key, oldValue);
      }
    }
    stringMapKeyRemoved(key, attributeName, oldValue) {
      if (this.delegate.stringMapKeyRemoved) {
        this.delegate.stringMapKeyRemoved(key, attributeName, oldValue);
      }
    }
    get knownAttributeNames() {
      return Array.from(new Set(this.currentAttributeNames.concat(this.recordedAttributeNames)));
    }
    get currentAttributeNames() {
      return Array.from(this.element.attributes).map((attribute) => attribute.name);
    }
    get recordedAttributeNames() {
      return Array.from(this.stringMap.keys());
    }
  };
  function add(map3, key, value) {
    fetch2(map3, key).add(value);
  }
  function del(map3, key, value) {
    fetch2(map3, key).delete(value);
    prune(map3, key);
  }
  function fetch2(map3, key) {
    let values = map3.get(key);
    if (!values) {
      values = /* @__PURE__ */ new Set();
      map3.set(key, values);
    }
    return values;
  }
  function prune(map3, key) {
    const values = map3.get(key);
    if (values != null && values.size == 0) {
      map3.delete(key);
    }
  }
  var Multimap = class {
    constructor() {
      this.valuesByKey = /* @__PURE__ */ new Map();
    }
    get keys() {
      return Array.from(this.valuesByKey.keys());
    }
    get values() {
      const sets = Array.from(this.valuesByKey.values());
      return sets.reduce((values, set2) => values.concat(Array.from(set2)), []);
    }
    get size() {
      const sets = Array.from(this.valuesByKey.values());
      return sets.reduce((size, set2) => size + set2.size, 0);
    }
    add(key, value) {
      add(this.valuesByKey, key, value);
    }
    delete(key, value) {
      del(this.valuesByKey, key, value);
    }
    has(key, value) {
      const values = this.valuesByKey.get(key);
      return values != null && values.has(value);
    }
    hasKey(key) {
      return this.valuesByKey.has(key);
    }
    hasValue(value) {
      const sets = Array.from(this.valuesByKey.values());
      return sets.some((set2) => set2.has(value));
    }
    getValuesForKey(key) {
      const values = this.valuesByKey.get(key);
      return values ? Array.from(values) : [];
    }
    getKeysForValue(value) {
      return Array.from(this.valuesByKey).filter(([key, values]) => values.has(value)).map(([key, values]) => key);
    }
  };
  var TokenListObserver = class {
    constructor(element, attributeName, delegate) {
      this.attributeObserver = new AttributeObserver(element, attributeName, this);
      this.delegate = delegate;
      this.tokensByElement = new Multimap();
    }
    get started() {
      return this.attributeObserver.started;
    }
    start() {
      this.attributeObserver.start();
    }
    pause(callback2) {
      this.attributeObserver.pause(callback2);
    }
    stop() {
      this.attributeObserver.stop();
    }
    refresh() {
      this.attributeObserver.refresh();
    }
    get element() {
      return this.attributeObserver.element;
    }
    get attributeName() {
      return this.attributeObserver.attributeName;
    }
    elementMatchedAttribute(element) {
      this.tokensMatched(this.readTokensForElement(element));
    }
    elementAttributeValueChanged(element) {
      const [unmatchedTokens, matchedTokens] = this.refreshTokensForElement(element);
      this.tokensUnmatched(unmatchedTokens);
      this.tokensMatched(matchedTokens);
    }
    elementUnmatchedAttribute(element) {
      this.tokensUnmatched(this.tokensByElement.getValuesForKey(element));
    }
    tokensMatched(tokens) {
      tokens.forEach((token) => this.tokenMatched(token));
    }
    tokensUnmatched(tokens) {
      tokens.forEach((token) => this.tokenUnmatched(token));
    }
    tokenMatched(token) {
      this.delegate.tokenMatched(token);
      this.tokensByElement.add(token.element, token);
    }
    tokenUnmatched(token) {
      this.delegate.tokenUnmatched(token);
      this.tokensByElement.delete(token.element, token);
    }
    refreshTokensForElement(element) {
      const previousTokens = this.tokensByElement.getValuesForKey(element);
      const currentTokens = this.readTokensForElement(element);
      const firstDifferingIndex = zip(previousTokens, currentTokens).findIndex(([previousToken, currentToken]) => !tokensAreEqual(previousToken, currentToken));
      if (firstDifferingIndex == -1) {
        return [[], []];
      } else {
        return [previousTokens.slice(firstDifferingIndex), currentTokens.slice(firstDifferingIndex)];
      }
    }
    readTokensForElement(element) {
      const attributeName = this.attributeName;
      const tokenString = element.getAttribute(attributeName) || "";
      return parseTokenString(tokenString, element, attributeName);
    }
  };
  function parseTokenString(tokenString, element, attributeName) {
    return tokenString.trim().split(/\s+/).filter((content) => content.length).map((content, index2) => ({ element, attributeName, content, index: index2 }));
  }
  function zip(left2, right2) {
    const length = Math.max(left2.length, right2.length);
    return Array.from({ length }, (_, index2) => [left2[index2], right2[index2]]);
  }
  function tokensAreEqual(left2, right2) {
    return left2 && right2 && left2.index == right2.index && left2.content == right2.content;
  }
  var ValueListObserver = class {
    constructor(element, attributeName, delegate) {
      this.tokenListObserver = new TokenListObserver(element, attributeName, this);
      this.delegate = delegate;
      this.parseResultsByToken = /* @__PURE__ */ new WeakMap();
      this.valuesByTokenByElement = /* @__PURE__ */ new WeakMap();
    }
    get started() {
      return this.tokenListObserver.started;
    }
    start() {
      this.tokenListObserver.start();
    }
    stop() {
      this.tokenListObserver.stop();
    }
    refresh() {
      this.tokenListObserver.refresh();
    }
    get element() {
      return this.tokenListObserver.element;
    }
    get attributeName() {
      return this.tokenListObserver.attributeName;
    }
    tokenMatched(token) {
      const { element } = token;
      const { value } = this.fetchParseResultForToken(token);
      if (value) {
        this.fetchValuesByTokenForElement(element).set(token, value);
        this.delegate.elementMatchedValue(element, value);
      }
    }
    tokenUnmatched(token) {
      const { element } = token;
      const { value } = this.fetchParseResultForToken(token);
      if (value) {
        this.fetchValuesByTokenForElement(element).delete(token);
        this.delegate.elementUnmatchedValue(element, value);
      }
    }
    fetchParseResultForToken(token) {
      let parseResult = this.parseResultsByToken.get(token);
      if (!parseResult) {
        parseResult = this.parseToken(token);
        this.parseResultsByToken.set(token, parseResult);
      }
      return parseResult;
    }
    fetchValuesByTokenForElement(element) {
      let valuesByToken = this.valuesByTokenByElement.get(element);
      if (!valuesByToken) {
        valuesByToken = /* @__PURE__ */ new Map();
        this.valuesByTokenByElement.set(element, valuesByToken);
      }
      return valuesByToken;
    }
    parseToken(token) {
      try {
        const value = this.delegate.parseValueForToken(token);
        return { value };
      } catch (error2) {
        return { error: error2 };
      }
    }
  };
  var BindingObserver = class {
    constructor(context, delegate) {
      this.context = context;
      this.delegate = delegate;
      this.bindingsByAction = /* @__PURE__ */ new Map();
    }
    start() {
      if (!this.valueListObserver) {
        this.valueListObserver = new ValueListObserver(this.element, this.actionAttribute, this);
        this.valueListObserver.start();
      }
    }
    stop() {
      if (this.valueListObserver) {
        this.valueListObserver.stop();
        delete this.valueListObserver;
        this.disconnectAllActions();
      }
    }
    get element() {
      return this.context.element;
    }
    get identifier() {
      return this.context.identifier;
    }
    get actionAttribute() {
      return this.schema.actionAttribute;
    }
    get schema() {
      return this.context.schema;
    }
    get bindings() {
      return Array.from(this.bindingsByAction.values());
    }
    connectAction(action) {
      const binding = new Binding(this.context, action);
      this.bindingsByAction.set(action, binding);
      this.delegate.bindingConnected(binding);
    }
    disconnectAction(action) {
      const binding = this.bindingsByAction.get(action);
      if (binding) {
        this.bindingsByAction.delete(action);
        this.delegate.bindingDisconnected(binding);
      }
    }
    disconnectAllActions() {
      this.bindings.forEach((binding) => this.delegate.bindingDisconnected(binding));
      this.bindingsByAction.clear();
    }
    parseValueForToken(token) {
      const action = Action.forToken(token);
      if (action.identifier == this.identifier) {
        return action;
      }
    }
    elementMatchedValue(element, action) {
      this.connectAction(action);
    }
    elementUnmatchedValue(element, action) {
      this.disconnectAction(action);
    }
  };
  var ValueObserver = class {
    constructor(context, receiver) {
      this.context = context;
      this.receiver = receiver;
      this.stringMapObserver = new StringMapObserver(this.element, this);
      this.valueDescriptorMap = this.controller.valueDescriptorMap;
      this.invokeChangedCallbacksForDefaultValues();
    }
    start() {
      this.stringMapObserver.start();
    }
    stop() {
      this.stringMapObserver.stop();
    }
    get element() {
      return this.context.element;
    }
    get controller() {
      return this.context.controller;
    }
    getStringMapKeyForAttribute(attributeName) {
      if (attributeName in this.valueDescriptorMap) {
        return this.valueDescriptorMap[attributeName].name;
      }
    }
    stringMapKeyAdded(key, attributeName) {
      const descriptor = this.valueDescriptorMap[attributeName];
      if (!this.hasValue(key)) {
        this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), descriptor.writer(descriptor.defaultValue));
      }
    }
    stringMapValueChanged(value, name2, oldValue) {
      const descriptor = this.valueDescriptorNameMap[name2];
      if (value === null)
        return;
      if (oldValue === null) {
        oldValue = descriptor.writer(descriptor.defaultValue);
      }
      this.invokeChangedCallback(name2, value, oldValue);
    }
    stringMapKeyRemoved(key, attributeName, oldValue) {
      const descriptor = this.valueDescriptorNameMap[key];
      if (this.hasValue(key)) {
        this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), oldValue);
      } else {
        this.invokeChangedCallback(key, descriptor.writer(descriptor.defaultValue), oldValue);
      }
    }
    invokeChangedCallbacksForDefaultValues() {
      for (const { key, name: name2, defaultValue, writer } of this.valueDescriptors) {
        if (defaultValue != void 0 && !this.controller.data.has(key)) {
          this.invokeChangedCallback(name2, writer(defaultValue), void 0);
        }
      }
    }
    invokeChangedCallback(name2, rawValue, rawOldValue) {
      const changedMethodName = `${name2}Changed`;
      const changedMethod = this.receiver[changedMethodName];
      if (typeof changedMethod == "function") {
        const descriptor = this.valueDescriptorNameMap[name2];
        const value = descriptor.reader(rawValue);
        let oldValue = rawOldValue;
        if (rawOldValue) {
          oldValue = descriptor.reader(rawOldValue);
        }
        changedMethod.call(this.receiver, value, oldValue);
      }
    }
    get valueDescriptors() {
      const { valueDescriptorMap } = this;
      return Object.keys(valueDescriptorMap).map((key) => valueDescriptorMap[key]);
    }
    get valueDescriptorNameMap() {
      const descriptors2 = {};
      Object.keys(this.valueDescriptorMap).forEach((key) => {
        const descriptor = this.valueDescriptorMap[key];
        descriptors2[descriptor.name] = descriptor;
      });
      return descriptors2;
    }
    hasValue(attributeName) {
      const descriptor = this.valueDescriptorNameMap[attributeName];
      const hasMethodName = `has${capitalize(descriptor.name)}`;
      return this.receiver[hasMethodName];
    }
  };
  var TargetObserver = class {
    constructor(context, delegate) {
      this.context = context;
      this.delegate = delegate;
      this.targetsByName = new Multimap();
    }
    start() {
      if (!this.tokenListObserver) {
        this.tokenListObserver = new TokenListObserver(this.element, this.attributeName, this);
        this.tokenListObserver.start();
      }
    }
    stop() {
      if (this.tokenListObserver) {
        this.disconnectAllTargets();
        this.tokenListObserver.stop();
        delete this.tokenListObserver;
      }
    }
    tokenMatched({ element, content: name2 }) {
      if (this.scope.containsElement(element)) {
        this.connectTarget(element, name2);
      }
    }
    tokenUnmatched({ element, content: name2 }) {
      this.disconnectTarget(element, name2);
    }
    connectTarget(element, name2) {
      var _a;
      if (!this.targetsByName.has(name2, element)) {
        this.targetsByName.add(name2, element);
        (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.targetConnected(element, name2));
      }
    }
    disconnectTarget(element, name2) {
      var _a;
      if (this.targetsByName.has(name2, element)) {
        this.targetsByName.delete(name2, element);
        (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.targetDisconnected(element, name2));
      }
    }
    disconnectAllTargets() {
      for (const name2 of this.targetsByName.keys) {
        for (const element of this.targetsByName.getValuesForKey(name2)) {
          this.disconnectTarget(element, name2);
        }
      }
    }
    get attributeName() {
      return `data-${this.context.identifier}-target`;
    }
    get element() {
      return this.context.element;
    }
    get scope() {
      return this.context.scope;
    }
  };
  var Context = class {
    constructor(module4, scope) {
      this.logDebugActivity = (functionName, detail = {}) => {
        const { identifier, controller, element } = this;
        detail = Object.assign({ identifier, controller, element }, detail);
        this.application.logDebugActivity(this.identifier, functionName, detail);
      };
      this.module = module4;
      this.scope = scope;
      this.controller = new module4.controllerConstructor(this);
      this.bindingObserver = new BindingObserver(this, this.dispatcher);
      this.valueObserver = new ValueObserver(this, this.controller);
      this.targetObserver = new TargetObserver(this, this);
      try {
        this.controller.initialize();
        this.logDebugActivity("initialize");
      } catch (error2) {
        this.handleError(error2, "initializing controller");
      }
    }
    connect() {
      this.bindingObserver.start();
      this.valueObserver.start();
      this.targetObserver.start();
      try {
        this.controller.connect();
        this.logDebugActivity("connect");
      } catch (error2) {
        this.handleError(error2, "connecting controller");
      }
    }
    disconnect() {
      try {
        this.controller.disconnect();
        this.logDebugActivity("disconnect");
      } catch (error2) {
        this.handleError(error2, "disconnecting controller");
      }
      this.targetObserver.stop();
      this.valueObserver.stop();
      this.bindingObserver.stop();
    }
    get application() {
      return this.module.application;
    }
    get identifier() {
      return this.module.identifier;
    }
    get schema() {
      return this.application.schema;
    }
    get dispatcher() {
      return this.application.dispatcher;
    }
    get element() {
      return this.scope.element;
    }
    get parentElement() {
      return this.element.parentElement;
    }
    handleError(error2, message, detail = {}) {
      const { identifier, controller, element } = this;
      detail = Object.assign({ identifier, controller, element }, detail);
      this.application.handleError(error2, `Error ${message}`, detail);
    }
    targetConnected(element, name2) {
      this.invokeControllerMethod(`${name2}TargetConnected`, element);
    }
    targetDisconnected(element, name2) {
      this.invokeControllerMethod(`${name2}TargetDisconnected`, element);
    }
    invokeControllerMethod(methodName, ...args) {
      const controller = this.controller;
      if (typeof controller[methodName] == "function") {
        controller[methodName](...args);
      }
    }
  };
  function readInheritableStaticArrayValues(constructor, propertyName) {
    const ancestors = getAncestorsForConstructor(constructor);
    return Array.from(ancestors.reduce((values, constructor2) => {
      getOwnStaticArrayValues(constructor2, propertyName).forEach((name2) => values.add(name2));
      return values;
    }, /* @__PURE__ */ new Set()));
  }
  function readInheritableStaticObjectPairs(constructor, propertyName) {
    const ancestors = getAncestorsForConstructor(constructor);
    return ancestors.reduce((pairs, constructor2) => {
      pairs.push(...getOwnStaticObjectPairs(constructor2, propertyName));
      return pairs;
    }, []);
  }
  function getAncestorsForConstructor(constructor) {
    const ancestors = [];
    while (constructor) {
      ancestors.push(constructor);
      constructor = Object.getPrototypeOf(constructor);
    }
    return ancestors.reverse();
  }
  function getOwnStaticArrayValues(constructor, propertyName) {
    const definition = constructor[propertyName];
    return Array.isArray(definition) ? definition : [];
  }
  function getOwnStaticObjectPairs(constructor, propertyName) {
    const definition = constructor[propertyName];
    return definition ? Object.keys(definition).map((key) => [key, definition[key]]) : [];
  }
  function bless(constructor) {
    return shadow(constructor, getBlessedProperties(constructor));
  }
  function shadow(constructor, properties) {
    const shadowConstructor = extend3(constructor);
    const shadowProperties = getShadowProperties(constructor.prototype, properties);
    Object.defineProperties(shadowConstructor.prototype, shadowProperties);
    return shadowConstructor;
  }
  function getBlessedProperties(constructor) {
    const blessings = readInheritableStaticArrayValues(constructor, "blessings");
    return blessings.reduce((blessedProperties, blessing) => {
      const properties = blessing(constructor);
      for (const key in properties) {
        const descriptor = blessedProperties[key] || {};
        blessedProperties[key] = Object.assign(descriptor, properties[key]);
      }
      return blessedProperties;
    }, {});
  }
  function getShadowProperties(prototype, properties) {
    return getOwnKeys(properties).reduce((shadowProperties, key) => {
      const descriptor = getShadowedDescriptor(prototype, properties, key);
      if (descriptor) {
        Object.assign(shadowProperties, { [key]: descriptor });
      }
      return shadowProperties;
    }, {});
  }
  function getShadowedDescriptor(prototype, properties, key) {
    const shadowingDescriptor = Object.getOwnPropertyDescriptor(prototype, key);
    const shadowedByValue = shadowingDescriptor && "value" in shadowingDescriptor;
    if (!shadowedByValue) {
      const descriptor = Object.getOwnPropertyDescriptor(properties, key).value;
      if (shadowingDescriptor) {
        descriptor.get = shadowingDescriptor.get || descriptor.get;
        descriptor.set = shadowingDescriptor.set || descriptor.set;
      }
      return descriptor;
    }
  }
  var getOwnKeys = (() => {
    if (typeof Object.getOwnPropertySymbols == "function") {
      return (object) => [
        ...Object.getOwnPropertyNames(object),
        ...Object.getOwnPropertySymbols(object)
      ];
    } else {
      return Object.getOwnPropertyNames;
    }
  })();
  var extend3 = (() => {
    function extendWithReflect(constructor) {
      function extended() {
        return Reflect.construct(constructor, arguments, new.target);
      }
      extended.prototype = Object.create(constructor.prototype, {
        constructor: { value: extended }
      });
      Reflect.setPrototypeOf(extended, constructor);
      return extended;
    }
    function testReflectExtension() {
      const a4 = function() {
        this.a.call(this);
      };
      const b2 = extendWithReflect(a4);
      b2.prototype.a = function() {
      };
      return new b2();
    }
    try {
      testReflectExtension();
      return extendWithReflect;
    } catch (error2) {
      return (constructor) => class extended extends constructor {
      };
    }
  })();
  function blessDefinition(definition) {
    return {
      identifier: definition.identifier,
      controllerConstructor: bless(definition.controllerConstructor)
    };
  }
  var Module = class {
    constructor(application2, definition) {
      this.application = application2;
      this.definition = blessDefinition(definition);
      this.contextsByScope = /* @__PURE__ */ new WeakMap();
      this.connectedContexts = /* @__PURE__ */ new Set();
    }
    get identifier() {
      return this.definition.identifier;
    }
    get controllerConstructor() {
      return this.definition.controllerConstructor;
    }
    get contexts() {
      return Array.from(this.connectedContexts);
    }
    connectContextForScope(scope) {
      const context = this.fetchContextForScope(scope);
      this.connectedContexts.add(context);
      context.connect();
    }
    disconnectContextForScope(scope) {
      const context = this.contextsByScope.get(scope);
      if (context) {
        this.connectedContexts.delete(context);
        context.disconnect();
      }
    }
    fetchContextForScope(scope) {
      let context = this.contextsByScope.get(scope);
      if (!context) {
        context = new Context(this, scope);
        this.contextsByScope.set(scope, context);
      }
      return context;
    }
  };
  var ClassMap = class {
    constructor(scope) {
      this.scope = scope;
    }
    has(name2) {
      return this.data.has(this.getDataKey(name2));
    }
    get(name2) {
      return this.getAll(name2)[0];
    }
    getAll(name2) {
      const tokenString = this.data.get(this.getDataKey(name2)) || "";
      return tokenize(tokenString);
    }
    getAttributeName(name2) {
      return this.data.getAttributeNameForKey(this.getDataKey(name2));
    }
    getDataKey(name2) {
      return `${name2}-class`;
    }
    get data() {
      return this.scope.data;
    }
  };
  var DataMap = class {
    constructor(scope) {
      this.scope = scope;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get(key) {
      const name2 = this.getAttributeNameForKey(key);
      return this.element.getAttribute(name2);
    }
    set(key, value) {
      const name2 = this.getAttributeNameForKey(key);
      this.element.setAttribute(name2, value);
      return this.get(key);
    }
    has(key) {
      const name2 = this.getAttributeNameForKey(key);
      return this.element.hasAttribute(name2);
    }
    delete(key) {
      if (this.has(key)) {
        const name2 = this.getAttributeNameForKey(key);
        this.element.removeAttribute(name2);
        return true;
      } else {
        return false;
      }
    }
    getAttributeNameForKey(key) {
      return `data-${this.identifier}-${dasherize(key)}`;
    }
  };
  var Guide = class {
    constructor(logger2) {
      this.warnedKeysByObject = /* @__PURE__ */ new WeakMap();
      this.logger = logger2;
    }
    warn(object, key, message) {
      let warnedKeys = this.warnedKeysByObject.get(object);
      if (!warnedKeys) {
        warnedKeys = /* @__PURE__ */ new Set();
        this.warnedKeysByObject.set(object, warnedKeys);
      }
      if (!warnedKeys.has(key)) {
        warnedKeys.add(key);
        this.logger.warn(message, object);
      }
    }
  };
  function attributeValueContainsToken(attributeName, token) {
    return `[${attributeName}~="${token}"]`;
  }
  var TargetSet = class {
    constructor(scope) {
      this.scope = scope;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get schema() {
      return this.scope.schema;
    }
    has(targetName) {
      return this.find(targetName) != null;
    }
    find(...targetNames) {
      return targetNames.reduce((target, targetName) => target || this.findTarget(targetName) || this.findLegacyTarget(targetName), void 0);
    }
    findAll(...targetNames) {
      return targetNames.reduce((targets, targetName) => [
        ...targets,
        ...this.findAllTargets(targetName),
        ...this.findAllLegacyTargets(targetName)
      ], []);
    }
    findTarget(targetName) {
      const selector = this.getSelectorForTargetName(targetName);
      return this.scope.findElement(selector);
    }
    findAllTargets(targetName) {
      const selector = this.getSelectorForTargetName(targetName);
      return this.scope.findAllElements(selector);
    }
    getSelectorForTargetName(targetName) {
      const attributeName = this.schema.targetAttributeForScope(this.identifier);
      return attributeValueContainsToken(attributeName, targetName);
    }
    findLegacyTarget(targetName) {
      const selector = this.getLegacySelectorForTargetName(targetName);
      return this.deprecate(this.scope.findElement(selector), targetName);
    }
    findAllLegacyTargets(targetName) {
      const selector = this.getLegacySelectorForTargetName(targetName);
      return this.scope.findAllElements(selector).map((element) => this.deprecate(element, targetName));
    }
    getLegacySelectorForTargetName(targetName) {
      const targetDescriptor = `${this.identifier}.${targetName}`;
      return attributeValueContainsToken(this.schema.targetAttribute, targetDescriptor);
    }
    deprecate(element, targetName) {
      if (element) {
        const { identifier } = this;
        const attributeName = this.schema.targetAttribute;
        const revisedAttributeName = this.schema.targetAttributeForScope(identifier);
        this.guide.warn(element, `target:${targetName}`, `Please replace ${attributeName}="${identifier}.${targetName}" with ${revisedAttributeName}="${targetName}". The ${attributeName} attribute is deprecated and will be removed in a future version of Stimulus.`);
      }
      return element;
    }
    get guide() {
      return this.scope.guide;
    }
  };
  var Scope = class {
    constructor(schema, element, identifier, logger2) {
      this.targets = new TargetSet(this);
      this.classes = new ClassMap(this);
      this.data = new DataMap(this);
      this.containsElement = (element2) => {
        return element2.closest(this.controllerSelector) === this.element;
      };
      this.schema = schema;
      this.element = element;
      this.identifier = identifier;
      this.guide = new Guide(logger2);
    }
    findElement(selector) {
      return this.element.matches(selector) ? this.element : this.queryElements(selector).find(this.containsElement);
    }
    findAllElements(selector) {
      return [
        ...this.element.matches(selector) ? [this.element] : [],
        ...this.queryElements(selector).filter(this.containsElement)
      ];
    }
    queryElements(selector) {
      return Array.from(this.element.querySelectorAll(selector));
    }
    get controllerSelector() {
      return attributeValueContainsToken(this.schema.controllerAttribute, this.identifier);
    }
  };
  var ScopeObserver = class {
    constructor(element, schema, delegate) {
      this.element = element;
      this.schema = schema;
      this.delegate = delegate;
      this.valueListObserver = new ValueListObserver(this.element, this.controllerAttribute, this);
      this.scopesByIdentifierByElement = /* @__PURE__ */ new WeakMap();
      this.scopeReferenceCounts = /* @__PURE__ */ new WeakMap();
    }
    start() {
      this.valueListObserver.start();
    }
    stop() {
      this.valueListObserver.stop();
    }
    get controllerAttribute() {
      return this.schema.controllerAttribute;
    }
    parseValueForToken(token) {
      const { element, content: identifier } = token;
      const scopesByIdentifier = this.fetchScopesByIdentifierForElement(element);
      let scope = scopesByIdentifier.get(identifier);
      if (!scope) {
        scope = this.delegate.createScopeForElementAndIdentifier(element, identifier);
        scopesByIdentifier.set(identifier, scope);
      }
      return scope;
    }
    elementMatchedValue(element, value) {
      const referenceCount = (this.scopeReferenceCounts.get(value) || 0) + 1;
      this.scopeReferenceCounts.set(value, referenceCount);
      if (referenceCount == 1) {
        this.delegate.scopeConnected(value);
      }
    }
    elementUnmatchedValue(element, value) {
      const referenceCount = this.scopeReferenceCounts.get(value);
      if (referenceCount) {
        this.scopeReferenceCounts.set(value, referenceCount - 1);
        if (referenceCount == 1) {
          this.delegate.scopeDisconnected(value);
        }
      }
    }
    fetchScopesByIdentifierForElement(element) {
      let scopesByIdentifier = this.scopesByIdentifierByElement.get(element);
      if (!scopesByIdentifier) {
        scopesByIdentifier = /* @__PURE__ */ new Map();
        this.scopesByIdentifierByElement.set(element, scopesByIdentifier);
      }
      return scopesByIdentifier;
    }
  };
  var Router = class {
    constructor(application2) {
      this.application = application2;
      this.scopeObserver = new ScopeObserver(this.element, this.schema, this);
      this.scopesByIdentifier = new Multimap();
      this.modulesByIdentifier = /* @__PURE__ */ new Map();
    }
    get element() {
      return this.application.element;
    }
    get schema() {
      return this.application.schema;
    }
    get logger() {
      return this.application.logger;
    }
    get controllerAttribute() {
      return this.schema.controllerAttribute;
    }
    get modules() {
      return Array.from(this.modulesByIdentifier.values());
    }
    get contexts() {
      return this.modules.reduce((contexts, module4) => contexts.concat(module4.contexts), []);
    }
    start() {
      this.scopeObserver.start();
    }
    stop() {
      this.scopeObserver.stop();
    }
    loadDefinition(definition) {
      this.unloadIdentifier(definition.identifier);
      const module4 = new Module(this.application, definition);
      this.connectModule(module4);
    }
    unloadIdentifier(identifier) {
      const module4 = this.modulesByIdentifier.get(identifier);
      if (module4) {
        this.disconnectModule(module4);
      }
    }
    getContextForElementAndIdentifier(element, identifier) {
      const module4 = this.modulesByIdentifier.get(identifier);
      if (module4) {
        return module4.contexts.find((context) => context.element == element);
      }
    }
    handleError(error2, message, detail) {
      this.application.handleError(error2, message, detail);
    }
    createScopeForElementAndIdentifier(element, identifier) {
      return new Scope(this.schema, element, identifier, this.logger);
    }
    scopeConnected(scope) {
      this.scopesByIdentifier.add(scope.identifier, scope);
      const module4 = this.modulesByIdentifier.get(scope.identifier);
      if (module4) {
        module4.connectContextForScope(scope);
      }
    }
    scopeDisconnected(scope) {
      this.scopesByIdentifier.delete(scope.identifier, scope);
      const module4 = this.modulesByIdentifier.get(scope.identifier);
      if (module4) {
        module4.disconnectContextForScope(scope);
      }
    }
    connectModule(module4) {
      this.modulesByIdentifier.set(module4.identifier, module4);
      const scopes = this.scopesByIdentifier.getValuesForKey(module4.identifier);
      scopes.forEach((scope) => module4.connectContextForScope(scope));
    }
    disconnectModule(module4) {
      this.modulesByIdentifier.delete(module4.identifier);
      const scopes = this.scopesByIdentifier.getValuesForKey(module4.identifier);
      scopes.forEach((scope) => module4.disconnectContextForScope(scope));
    }
  };
  var defaultSchema = {
    controllerAttribute: "data-controller",
    actionAttribute: "data-action",
    targetAttribute: "data-target",
    targetAttributeForScope: (identifier) => `data-${identifier}-target`
  };
  var Application = class {
    constructor(element = document.documentElement, schema = defaultSchema) {
      this.logger = console;
      this.debug = false;
      this.logDebugActivity = (identifier, functionName, detail = {}) => {
        if (this.debug) {
          this.logFormattedMessage(identifier, functionName, detail);
        }
      };
      this.element = element;
      this.schema = schema;
      this.dispatcher = new Dispatcher(this);
      this.router = new Router(this);
    }
    static start(element, schema) {
      const application2 = new Application(element, schema);
      application2.start();
      return application2;
    }
    async start() {
      await domReady();
      this.logDebugActivity("application", "starting");
      this.dispatcher.start();
      this.router.start();
      this.logDebugActivity("application", "start");
    }
    stop() {
      this.logDebugActivity("application", "stopping");
      this.dispatcher.stop();
      this.router.stop();
      this.logDebugActivity("application", "stop");
    }
    register(identifier, controllerConstructor) {
      if (controllerConstructor.shouldLoad) {
        this.load({ identifier, controllerConstructor });
      }
    }
    load(head, ...rest) {
      const definitions = Array.isArray(head) ? head : [head, ...rest];
      definitions.forEach((definition) => this.router.loadDefinition(definition));
    }
    unload(head, ...rest) {
      const identifiers = Array.isArray(head) ? head : [head, ...rest];
      identifiers.forEach((identifier) => this.router.unloadIdentifier(identifier));
    }
    get controllers() {
      return this.router.contexts.map((context) => context.controller);
    }
    getControllerForElementAndIdentifier(element, identifier) {
      const context = this.router.getContextForElementAndIdentifier(element, identifier);
      return context ? context.controller : null;
    }
    handleError(error2, message, detail) {
      var _a;
      this.logger.error(`%s

%o

%o`, message, error2, detail);
      (_a = window.onerror) === null || _a === void 0 ? void 0 : _a.call(window, message, "", 0, 0, error2);
    }
    logFormattedMessage(identifier, functionName, detail = {}) {
      detail = Object.assign({ application: this }, detail);
      this.logger.groupCollapsed(`${identifier} #${functionName}`);
      this.logger.log("details:", Object.assign({}, detail));
      this.logger.groupEnd();
    }
  };
  function domReady() {
    return new Promise((resolve2) => {
      if (document.readyState == "loading") {
        document.addEventListener("DOMContentLoaded", () => resolve2());
      } else {
        resolve2();
      }
    });
  }
  function ClassPropertiesBlessing(constructor) {
    const classes = readInheritableStaticArrayValues(constructor, "classes");
    return classes.reduce((properties, classDefinition) => {
      return Object.assign(properties, propertiesForClassDefinition(classDefinition));
    }, {});
  }
  function propertiesForClassDefinition(key) {
    return {
      [`${key}Class`]: {
        get() {
          const { classes } = this;
          if (classes.has(key)) {
            return classes.get(key);
          } else {
            const attribute = classes.getAttributeName(key);
            throw new Error(`Missing attribute "${attribute}"`);
          }
        }
      },
      [`${key}Classes`]: {
        get() {
          return this.classes.getAll(key);
        }
      },
      [`has${capitalize(key)}Class`]: {
        get() {
          return this.classes.has(key);
        }
      }
    };
  }
  function TargetPropertiesBlessing(constructor) {
    const targets = readInheritableStaticArrayValues(constructor, "targets");
    return targets.reduce((properties, targetDefinition) => {
      return Object.assign(properties, propertiesForTargetDefinition(targetDefinition));
    }, {});
  }
  function propertiesForTargetDefinition(name2) {
    return {
      [`${name2}Target`]: {
        get() {
          const target = this.targets.find(name2);
          if (target) {
            return target;
          } else {
            throw new Error(`Missing target element "${name2}" for "${this.identifier}" controller`);
          }
        }
      },
      [`${name2}Targets`]: {
        get() {
          return this.targets.findAll(name2);
        }
      },
      [`has${capitalize(name2)}Target`]: {
        get() {
          return this.targets.has(name2);
        }
      }
    };
  }
  function ValuePropertiesBlessing(constructor) {
    const valueDefinitionPairs = readInheritableStaticObjectPairs(constructor, "values");
    const propertyDescriptorMap = {
      valueDescriptorMap: {
        get() {
          return valueDefinitionPairs.reduce((result, valueDefinitionPair) => {
            const valueDescriptor = parseValueDefinitionPair(valueDefinitionPair);
            const attributeName = this.data.getAttributeNameForKey(valueDescriptor.key);
            return Object.assign(result, { [attributeName]: valueDescriptor });
          }, {});
        }
      }
    };
    return valueDefinitionPairs.reduce((properties, valueDefinitionPair) => {
      return Object.assign(properties, propertiesForValueDefinitionPair(valueDefinitionPair));
    }, propertyDescriptorMap);
  }
  function propertiesForValueDefinitionPair(valueDefinitionPair) {
    const definition = parseValueDefinitionPair(valueDefinitionPair);
    const { key, name: name2, reader: read2, writer: write2 } = definition;
    return {
      [name2]: {
        get() {
          const value = this.data.get(key);
          if (value !== null) {
            return read2(value);
          } else {
            return definition.defaultValue;
          }
        },
        set(value) {
          if (value === void 0) {
            this.data.delete(key);
          } else {
            this.data.set(key, write2(value));
          }
        }
      },
      [`has${capitalize(name2)}`]: {
        get() {
          return this.data.has(key) || definition.hasCustomDefaultValue;
        }
      }
    };
  }
  function parseValueDefinitionPair([token, typeDefinition]) {
    return valueDescriptorForTokenAndTypeDefinition(token, typeDefinition);
  }
  function parseValueTypeConstant(constant) {
    switch (constant) {
      case Array:
        return "array";
      case Boolean:
        return "boolean";
      case Number:
        return "number";
      case Object:
        return "object";
      case String:
        return "string";
    }
  }
  function parseValueTypeDefault(defaultValue) {
    switch (typeof defaultValue) {
      case "boolean":
        return "boolean";
      case "number":
        return "number";
      case "string":
        return "string";
    }
    if (Array.isArray(defaultValue))
      return "array";
    if (Object.prototype.toString.call(defaultValue) === "[object Object]")
      return "object";
  }
  function parseValueTypeObject(typeObject) {
    const typeFromObject = parseValueTypeConstant(typeObject.type);
    if (typeFromObject) {
      const defaultValueType = parseValueTypeDefault(typeObject.default);
      if (typeFromObject !== defaultValueType) {
        throw new Error(`Type "${typeFromObject}" must match the type of the default value. Given default value: "${typeObject.default}" as "${defaultValueType}"`);
      }
      return typeFromObject;
    }
  }
  function parseValueTypeDefinition(typeDefinition) {
    const typeFromObject = parseValueTypeObject(typeDefinition);
    const typeFromDefaultValue = parseValueTypeDefault(typeDefinition);
    const typeFromConstant = parseValueTypeConstant(typeDefinition);
    const type = typeFromObject || typeFromDefaultValue || typeFromConstant;
    if (type)
      return type;
    throw new Error(`Unknown value type "${typeDefinition}"`);
  }
  function defaultValueForDefinition(typeDefinition) {
    const constant = parseValueTypeConstant(typeDefinition);
    if (constant)
      return defaultValuesByType[constant];
    const defaultValue = typeDefinition.default;
    if (defaultValue !== void 0)
      return defaultValue;
    return typeDefinition;
  }
  function valueDescriptorForTokenAndTypeDefinition(token, typeDefinition) {
    const key = `${dasherize(token)}-value`;
    const type = parseValueTypeDefinition(typeDefinition);
    return {
      type,
      key,
      name: camelize(key),
      get defaultValue() {
        return defaultValueForDefinition(typeDefinition);
      },
      get hasCustomDefaultValue() {
        return parseValueTypeDefault(typeDefinition) !== void 0;
      },
      reader: readers[type],
      writer: writers[type] || writers.default
    };
  }
  var defaultValuesByType = {
    get array() {
      return [];
    },
    boolean: false,
    number: 0,
    get object() {
      return {};
    },
    string: ""
  };
  var readers = {
    array(value) {
      const array = JSON.parse(value);
      if (!Array.isArray(array)) {
        throw new TypeError("Expected array");
      }
      return array;
    },
    boolean(value) {
      return !(value == "0" || value == "false");
    },
    number(value) {
      return Number(value);
    },
    object(value) {
      const object = JSON.parse(value);
      if (object === null || typeof object != "object" || Array.isArray(object)) {
        throw new TypeError("Expected object");
      }
      return object;
    },
    string(value) {
      return value;
    }
  };
  var writers = {
    default: writeString,
    array: writeJSON,
    object: writeJSON
  };
  function writeJSON(value) {
    return JSON.stringify(value);
  }
  function writeString(value) {
    return `${value}`;
  }
  var Controller = class {
    constructor(context) {
      this.context = context;
    }
    static get shouldLoad() {
      return true;
    }
    get application() {
      return this.context.application;
    }
    get scope() {
      return this.context.scope;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get targets() {
      return this.scope.targets;
    }
    get classes() {
      return this.scope.classes;
    }
    get data() {
      return this.scope.data;
    }
    initialize() {
    }
    connect() {
    }
    disconnect() {
    }
    dispatch(eventName, { target = this.element, detail = {}, prefix = this.identifier, bubbles = true, cancelable = true } = {}) {
      const type = prefix ? `${prefix}:${eventName}` : eventName;
      const event = new CustomEvent(type, { detail, bubbles, cancelable });
      target.dispatchEvent(event);
      return event;
    }
  };
  Controller.blessings = [ClassPropertiesBlessing, TargetPropertiesBlessing, ValuePropertiesBlessing];
  Controller.targets = [];
  Controller.values = {};

  // controllers/application.js
  var application = Application.start();
  application.debug = false;
  window.Stimulus = application;

  // controllers/accounts_controller.js
  var accounts_controller_exports = {};
  __export(accounts_controller_exports, {
    default: () => accounts_controller_default
  });

  // ../../node_modules/@rails/actioncable/app/assets/javascripts/actioncable.esm.js
  var adapters3 = {
    logger: self.console,
    WebSocket: self.WebSocket
  };
  var logger = {
    log(...messages) {
      if (this.enabled) {
        messages.push(Date.now());
        adapters3.logger.log("[ActionCable]", ...messages);
      }
    }
  };
  var now2 = () => new Date().getTime();
  var secondsSince2 = (time) => (now2() - time) / 1e3;
  var ConnectionMonitor2 = class {
    constructor(connection) {
      this.visibilityDidChange = this.visibilityDidChange.bind(this);
      this.connection = connection;
      this.reconnectAttempts = 0;
    }
    start() {
      if (!this.isRunning()) {
        this.startedAt = now2();
        delete this.stoppedAt;
        this.startPolling();
        addEventListener("visibilitychange", this.visibilityDidChange);
        logger.log(`ConnectionMonitor started. stale threshold = ${this.constructor.staleThreshold} s`);
      }
    }
    stop() {
      if (this.isRunning()) {
        this.stoppedAt = now2();
        this.stopPolling();
        removeEventListener("visibilitychange", this.visibilityDidChange);
        logger.log("ConnectionMonitor stopped");
      }
    }
    isRunning() {
      return this.startedAt && !this.stoppedAt;
    }
    recordPing() {
      this.pingedAt = now2();
    }
    recordConnect() {
      this.reconnectAttempts = 0;
      this.recordPing();
      delete this.disconnectedAt;
      logger.log("ConnectionMonitor recorded connect");
    }
    recordDisconnect() {
      this.disconnectedAt = now2();
      logger.log("ConnectionMonitor recorded disconnect");
    }
    startPolling() {
      this.stopPolling();
      this.poll();
    }
    stopPolling() {
      clearTimeout(this.pollTimeout);
    }
    poll() {
      this.pollTimeout = setTimeout(() => {
        this.reconnectIfStale();
        this.poll();
      }, this.getPollInterval());
    }
    getPollInterval() {
      const { staleThreshold, reconnectionBackoffRate } = this.constructor;
      const backoff = Math.pow(1 + reconnectionBackoffRate, Math.min(this.reconnectAttempts, 10));
      const jitterMax = this.reconnectAttempts === 0 ? 1 : reconnectionBackoffRate;
      const jitter = jitterMax * Math.random();
      return staleThreshold * 1e3 * backoff * (1 + jitter);
    }
    reconnectIfStale() {
      if (this.connectionIsStale()) {
        logger.log(`ConnectionMonitor detected stale connection. reconnectAttempts = ${this.reconnectAttempts}, time stale = ${secondsSince2(this.refreshedAt)} s, stale threshold = ${this.constructor.staleThreshold} s`);
        this.reconnectAttempts++;
        if (this.disconnectedRecently()) {
          logger.log(`ConnectionMonitor skipping reopening recent disconnect. time disconnected = ${secondsSince2(this.disconnectedAt)} s`);
        } else {
          logger.log("ConnectionMonitor reopening");
          this.connection.reopen();
        }
      }
    }
    get refreshedAt() {
      return this.pingedAt ? this.pingedAt : this.startedAt;
    }
    connectionIsStale() {
      return secondsSince2(this.refreshedAt) > this.constructor.staleThreshold;
    }
    disconnectedRecently() {
      return this.disconnectedAt && secondsSince2(this.disconnectedAt) < this.constructor.staleThreshold;
    }
    visibilityDidChange() {
      if (document.visibilityState === "visible") {
        setTimeout(() => {
          if (this.connectionIsStale() || !this.connection.isOpen()) {
            logger.log(`ConnectionMonitor reopening stale connection on visibilitychange. visibilityState = ${document.visibilityState}`);
            this.connection.reopen();
          }
        }, 200);
      }
    }
  };
  ConnectionMonitor2.staleThreshold = 6;
  ConnectionMonitor2.reconnectionBackoffRate = 0.15;
  var INTERNAL = {
    message_types: {
      welcome: "welcome",
      disconnect: "disconnect",
      ping: "ping",
      confirmation: "confirm_subscription",
      rejection: "reject_subscription"
    },
    disconnect_reasons: {
      unauthorized: "unauthorized",
      invalid_request: "invalid_request",
      server_restart: "server_restart"
    },
    default_mount_path: "/cable",
    protocols: ["actioncable-v1-json", "actioncable-unsupported"]
  };
  var { message_types: message_types2, protocols: protocols2 } = INTERNAL;
  var supportedProtocols2 = protocols2.slice(0, protocols2.length - 1);
  var indexOf2 = [].indexOf;
  var Connection2 = class {
    constructor(consumer2) {
      this.open = this.open.bind(this);
      this.consumer = consumer2;
      this.subscriptions = this.consumer.subscriptions;
      this.monitor = new ConnectionMonitor2(this);
      this.disconnected = true;
    }
    send(data) {
      if (this.isOpen()) {
        this.webSocket.send(JSON.stringify(data));
        return true;
      } else {
        return false;
      }
    }
    open() {
      if (this.isActive()) {
        logger.log(`Attempted to open WebSocket, but existing socket is ${this.getState()}`);
        return false;
      } else {
        logger.log(`Opening WebSocket, current state is ${this.getState()}, subprotocols: ${protocols2}`);
        if (this.webSocket) {
          this.uninstallEventHandlers();
        }
        this.webSocket = new adapters3.WebSocket(this.consumer.url, protocols2);
        this.installEventHandlers();
        this.monitor.start();
        return true;
      }
    }
    close({ allowReconnect } = {
      allowReconnect: true
    }) {
      if (!allowReconnect) {
        this.monitor.stop();
      }
      if (this.isActive()) {
        return this.webSocket.close();
      }
    }
    reopen() {
      logger.log(`Reopening WebSocket, current state is ${this.getState()}`);
      if (this.isActive()) {
        try {
          return this.close();
        } catch (error2) {
          logger.log("Failed to reopen WebSocket", error2);
        } finally {
          logger.log(`Reopening WebSocket in ${this.constructor.reopenDelay}ms`);
          setTimeout(this.open, this.constructor.reopenDelay);
        }
      } else {
        return this.open();
      }
    }
    getProtocol() {
      if (this.webSocket) {
        return this.webSocket.protocol;
      }
    }
    isOpen() {
      return this.isState("open");
    }
    isActive() {
      return this.isState("open", "connecting");
    }
    isProtocolSupported() {
      return indexOf2.call(supportedProtocols2, this.getProtocol()) >= 0;
    }
    isState(...states) {
      return indexOf2.call(states, this.getState()) >= 0;
    }
    getState() {
      if (this.webSocket) {
        for (let state in adapters3.WebSocket) {
          if (adapters3.WebSocket[state] === this.webSocket.readyState) {
            return state.toLowerCase();
          }
        }
      }
      return null;
    }
    installEventHandlers() {
      for (let eventName in this.events) {
        const handler = this.events[eventName].bind(this);
        this.webSocket[`on${eventName}`] = handler;
      }
    }
    uninstallEventHandlers() {
      for (let eventName in this.events) {
        this.webSocket[`on${eventName}`] = function() {
        };
      }
    }
  };
  Connection2.reopenDelay = 500;
  Connection2.prototype.events = {
    message(event) {
      if (!this.isProtocolSupported()) {
        return;
      }
      const { identifier, message, reason, reconnect, type } = JSON.parse(event.data);
      switch (type) {
        case message_types2.welcome:
          this.monitor.recordConnect();
          return this.subscriptions.reload();
        case message_types2.disconnect:
          logger.log(`Disconnecting. Reason: ${reason}`);
          return this.close({
            allowReconnect: reconnect
          });
        case message_types2.ping:
          return this.monitor.recordPing();
        case message_types2.confirmation:
          this.subscriptions.confirmSubscription(identifier);
          return this.subscriptions.notify(identifier, "connected");
        case message_types2.rejection:
          return this.subscriptions.reject(identifier);
        default:
          return this.subscriptions.notify(identifier, "received", message);
      }
    },
    open() {
      logger.log(`WebSocket onopen event, using '${this.getProtocol()}' subprotocol`);
      this.disconnected = false;
      if (!this.isProtocolSupported()) {
        logger.log("Protocol is unsupported. Stopping monitor and disconnecting.");
        return this.close({
          allowReconnect: false
        });
      }
    },
    close(event) {
      logger.log("WebSocket onclose event");
      if (this.disconnected) {
        return;
      }
      this.disconnected = true;
      this.monitor.recordDisconnect();
      return this.subscriptions.notifyAll("disconnected", {
        willAttemptReconnect: this.monitor.isRunning()
      });
    },
    error() {
      logger.log("WebSocket onerror event");
    }
  };
  var extend4 = function(object, properties) {
    if (properties != null) {
      for (let key in properties) {
        const value = properties[key];
        object[key] = value;
      }
    }
    return object;
  };
  var Subscription2 = class {
    constructor(consumer2, params = {}, mixin) {
      this.consumer = consumer2;
      this.identifier = JSON.stringify(params);
      extend4(this, mixin);
    }
    perform(action, data = {}) {
      data.action = action;
      return this.send(data);
    }
    send(data) {
      return this.consumer.send({
        command: "message",
        identifier: this.identifier,
        data: JSON.stringify(data)
      });
    }
    unsubscribe() {
      return this.consumer.subscriptions.remove(this);
    }
  };
  var SubscriptionGuarantor = class {
    constructor(subscriptions) {
      this.subscriptions = subscriptions;
      this.pendingSubscriptions = [];
    }
    guarantee(subscription) {
      if (this.pendingSubscriptions.indexOf(subscription) == -1) {
        logger.log(`SubscriptionGuarantor guaranteeing ${subscription.identifier}`);
        this.pendingSubscriptions.push(subscription);
      } else {
        logger.log(`SubscriptionGuarantor already guaranteeing ${subscription.identifier}`);
      }
      this.startGuaranteeing();
    }
    forget(subscription) {
      logger.log(`SubscriptionGuarantor forgetting ${subscription.identifier}`);
      this.pendingSubscriptions = this.pendingSubscriptions.filter((s4) => s4 !== subscription);
    }
    startGuaranteeing() {
      this.stopGuaranteeing();
      this.retrySubscribing();
    }
    stopGuaranteeing() {
      clearTimeout(this.retryTimeout);
    }
    retrySubscribing() {
      this.retryTimeout = setTimeout(() => {
        if (this.subscriptions && typeof this.subscriptions.subscribe === "function") {
          this.pendingSubscriptions.map((subscription) => {
            logger.log(`SubscriptionGuarantor resubscribing ${subscription.identifier}`);
            this.subscriptions.subscribe(subscription);
          });
        }
      }, 500);
    }
  };
  var Subscriptions2 = class {
    constructor(consumer2) {
      this.consumer = consumer2;
      this.guarantor = new SubscriptionGuarantor(this);
      this.subscriptions = [];
    }
    create(channelName, mixin) {
      const channel = channelName;
      const params = typeof channel === "object" ? channel : {
        channel
      };
      const subscription = new Subscription2(this.consumer, params, mixin);
      return this.add(subscription);
    }
    add(subscription) {
      this.subscriptions.push(subscription);
      this.consumer.ensureActiveConnection();
      this.notify(subscription, "initialized");
      this.subscribe(subscription);
      return subscription;
    }
    remove(subscription) {
      this.forget(subscription);
      if (!this.findAll(subscription.identifier).length) {
        this.sendCommand(subscription, "unsubscribe");
      }
      return subscription;
    }
    reject(identifier) {
      return this.findAll(identifier).map((subscription) => {
        this.forget(subscription);
        this.notify(subscription, "rejected");
        return subscription;
      });
    }
    forget(subscription) {
      this.guarantor.forget(subscription);
      this.subscriptions = this.subscriptions.filter((s4) => s4 !== subscription);
      return subscription;
    }
    findAll(identifier) {
      return this.subscriptions.filter((s4) => s4.identifier === identifier);
    }
    reload() {
      return this.subscriptions.map((subscription) => this.subscribe(subscription));
    }
    notifyAll(callbackName, ...args) {
      return this.subscriptions.map((subscription) => this.notify(subscription, callbackName, ...args));
    }
    notify(subscription, callbackName, ...args) {
      let subscriptions;
      if (typeof subscription === "string") {
        subscriptions = this.findAll(subscription);
      } else {
        subscriptions = [subscription];
      }
      return subscriptions.map((subscription2) => typeof subscription2[callbackName] === "function" ? subscription2[callbackName](...args) : void 0);
    }
    subscribe(subscription) {
      if (this.sendCommand(subscription, "subscribe")) {
        this.guarantor.guarantee(subscription);
      }
    }
    confirmSubscription(identifier) {
      logger.log(`Subscription confirmed ${identifier}`);
      this.findAll(identifier).map((subscription) => this.guarantor.forget(subscription));
    }
    sendCommand(subscription, command) {
      const { identifier } = subscription;
      return this.consumer.send({
        command,
        identifier
      });
    }
  };
  var Consumer2 = class {
    constructor(url) {
      this._url = url;
      this.subscriptions = new Subscriptions2(this);
      this.connection = new Connection2(this);
    }
    get url() {
      return createWebSocketURL2(this._url);
    }
    send(data) {
      return this.connection.send(data);
    }
    connect() {
      return this.connection.open();
    }
    disconnect() {
      return this.connection.close({
        allowReconnect: false
      });
    }
    ensureActiveConnection() {
      if (!this.connection.isActive()) {
        return this.connection.open();
      }
    }
  };
  function createWebSocketURL2(url) {
    if (typeof url === "function") {
      url = url();
    }
    if (url && !/^wss?:/i.test(url)) {
      const a4 = document.createElement("a");
      a4.href = url;
      a4.href = a4.href;
      a4.protocol = a4.protocol.replace("http", "ws");
      return a4.href;
    } else {
      return url;
    }
  }
  function createConsumer3(url = getConfig2("url") || INTERNAL.default_mount_path) {
    return new Consumer2(url);
  }
  function getConfig2(name2) {
    const element = document.head.querySelector(`meta[name='action-cable-${name2}']`);
    if (element) {
      return element.getAttribute("content");
    }
  }

  // channels/consumer.js
  var consumer_default = createConsumer3();

  // controllers/accounts_controller.js
  var accounts_controller_default = class extends Controller {
    reconnect(event) {
      if (consumer_default.connection.isActive()) {
        consumer_default.connection.reopen();
      }
    }
  };

  // controllers/braintree_controller.js
  var braintree_controller_exports = {};
  __export(braintree_controller_exports, {
    default: () => braintree_controller_default
  });
  var braintree_controller_default = class extends Controller {
    connect() {
      braintree.dropin.create({
        authorization: this.data.get("clientToken"),
        container: this.dropinTarget,
        paypal: {
          flow: "vault"
        }
      }, this.clientCreated.bind(this));
    }
    clientCreated(error2, instance) {
      if (error2) {
        console.error("Error setting up Braintree dropin:", error2);
        return;
      }
      this.instance = instance;
    }
    submit(event) {
      event.preventDefault();
      this.instance.requestPaymentMethod(this.paymentMethod.bind(this));
    }
    paymentMethod(error2, payload) {
      if (error2) {
        console.error("Error with payment method:", error2);
        return;
      }
      this.addHiddenField("processor", "braintree");
      this.addHiddenField("payment_method_token", payload.nonce);
      Rails.fire(this.formTarget, "submit");
    }
    addHiddenField(name2, value) {
      let hiddenInput = document.createElement("input");
      hiddenInput.setAttribute("type", "hidden");
      hiddenInput.setAttribute("name", name2);
      hiddenInput.setAttribute("value", value);
      this.formTarget.appendChild(hiddenInput);
    }
  };
  __publicField(braintree_controller_default, "targets", ["dropin", "form"]);

  // controllers/bulk_controller.js
  var bulk_controller_exports = {};
  __export(bulk_controller_exports, {
    default: () => bulk_controller_default
  });
  var bulk_controller_default = class extends Controller {
    toggleSelectAll(event) {
      !this.allCheckboxesSelected ? this.selectAll() : this.unselectAll();
    }
    selectAll() {
      this.selectAllTarget.checked = true;
      this.selectAllTarget.indeterminate = false;
      this.unselected.forEach((target) => target.checked = true);
    }
    unselectAll() {
      this.selectAllTarget.checked = false;
      this.selectAllTarget.indeterminate = false;
      this.selected.forEach((target) => target.checked = false);
    }
    change(event) {
      if (this.noCheckboxesSelected) {
        this.selectAllTarget.checked = false;
        this.selectAllTarget.indeterminate = false;
      } else if (this.allCheckboxesSelected) {
        this.selectAllTarget.checked = true;
        this.selectAllTarget.indeterminate = false;
      } else {
        this.selectAllTarget.indeterminate = true;
      }
    }
    get selectedAll() {
      return this.selectAllTarget.checked;
    }
    get selected() {
      return this.checkboxTargets.filter((target) => target.checked);
    }
    get unselected() {
      return this.checkboxTargets.filter((target) => !target.checked);
    }
    get selectedIds() {
      return this.selected.map((target) => target.dataset.id);
    }
    get allCheckboxesSelected() {
      return this.checkboxTargets.every((target) => target.checked);
    }
    get noCheckboxesSelected() {
      return this.checkboxTargets.every((target) => !target.checked);
    }
  };
  __publicField(bulk_controller_default, "targets", ["checkbox", "selectAll"]);

  // controllers/clipboard_controller.js
  var clipboard_controller_exports = {};
  __export(clipboard_controller_exports, {
    default: () => clipboard_controller_default
  });
  var import_clipboard = __toESM(require_clipboard());

  // ../../node_modules/@popperjs/core/lib/enums.js
  var top = "top";
  var bottom = "bottom";
  var right = "right";
  var left = "left";
  var auto = "auto";
  var basePlacements = [top, bottom, right, left];
  var start2 = "start";
  var end = "end";
  var clippingParents = "clippingParents";
  var viewport = "viewport";
  var popper = "popper";
  var reference = "reference";
  var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
    return acc.concat([placement + "-" + start2, placement + "-" + end]);
  }, []);
  var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
    return acc.concat([placement, placement + "-" + start2, placement + "-" + end]);
  }, []);
  var beforeRead = "beforeRead";
  var read = "read";
  var afterRead = "afterRead";
  var beforeMain = "beforeMain";
  var main = "main";
  var afterMain = "afterMain";
  var beforeWrite = "beforeWrite";
  var write = "write";
  var afterWrite = "afterWrite";
  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

  // ../../node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
  function getNodeName(element) {
    return element ? (element.nodeName || "").toLowerCase() : null;
  }

  // ../../node_modules/@popperjs/core/lib/dom-utils/getWindow.js
  function getWindow(node) {
    if (node == null) {
      return window;
    }
    if (node.toString() !== "[object Window]") {
      var ownerDocument = node.ownerDocument;
      return ownerDocument ? ownerDocument.defaultView || window : window;
    }
    return node;
  }

  // ../../node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
  function isElement(node) {
    var OwnElement = getWindow(node).Element;
    return node instanceof OwnElement || node instanceof Element;
  }
  function isHTMLElement(node) {
    var OwnElement = getWindow(node).HTMLElement;
    return node instanceof OwnElement || node instanceof HTMLElement;
  }
  function isShadowRoot(node) {
    if (typeof ShadowRoot === "undefined") {
      return false;
    }
    var OwnElement = getWindow(node).ShadowRoot;
    return node instanceof OwnElement || node instanceof ShadowRoot;
  }

  // ../../node_modules/@popperjs/core/lib/modifiers/applyStyles.js
  function applyStyles(_ref) {
    var state = _ref.state;
    Object.keys(state.elements).forEach(function(name2) {
      var style = state.styles[name2] || {};
      var attributes = state.attributes[name2] || {};
      var element = state.elements[name2];
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(name3) {
        var value = attributes[name3];
        if (value === false) {
          element.removeAttribute(name3);
        } else {
          element.setAttribute(name3, value === true ? "" : value);
        }
      });
    });
  }
  function effect(_ref2) {
    var state = _ref2.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }
    return function() {
      Object.keys(state.elements).forEach(function(name2) {
        var element = state.elements[name2];
        var attributes = state.attributes[name2] || {};
        var styleProperties = Object.keys(state.styles.hasOwnProperty(name2) ? state.styles[name2] : initialStyles[name2]);
        var style = styleProperties.reduce(function(style2, property) {
          style2[property] = "";
          return style2;
        }, {});
        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        }
        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function(attribute) {
          element.removeAttribute(attribute);
        });
      });
    };
  }
  var applyStyles_default = {
    name: "applyStyles",
    enabled: true,
    phase: "write",
    fn: applyStyles,
    effect,
    requires: ["computeStyles"]
  };

  // ../../node_modules/@popperjs/core/lib/utils/getBasePlacement.js
  function getBasePlacement(placement) {
    return placement.split("-")[0];
  }

  // ../../node_modules/@popperjs/core/lib/utils/math.js
  var max = Math.max;
  var min = Math.min;
  var round2 = Math.round;

  // ../../node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
  function getBoundingClientRect(element, includeScale) {
    if (includeScale === void 0) {
      includeScale = false;
    }
    var rect = element.getBoundingClientRect();
    var scaleX = 1;
    var scaleY = 1;
    if (isHTMLElement(element) && includeScale) {
      var offsetHeight = element.offsetHeight;
      var offsetWidth = element.offsetWidth;
      if (offsetWidth > 0) {
        scaleX = round2(rect.width) / offsetWidth || 1;
      }
      if (offsetHeight > 0) {
        scaleY = round2(rect.height) / offsetHeight || 1;
      }
    }
    return {
      width: rect.width / scaleX,
      height: rect.height / scaleY,
      top: rect.top / scaleY,
      right: rect.right / scaleX,
      bottom: rect.bottom / scaleY,
      left: rect.left / scaleX,
      x: rect.left / scaleX,
      y: rect.top / scaleY
    };
  }

  // ../../node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
  function getLayoutRect(element) {
    var clientRect = getBoundingClientRect(element);
    var width = element.offsetWidth;
    var height = element.offsetHeight;
    if (Math.abs(clientRect.width - width) <= 1) {
      width = clientRect.width;
    }
    if (Math.abs(clientRect.height - height) <= 1) {
      height = clientRect.height;
    }
    return {
      x: element.offsetLeft,
      y: element.offsetTop,
      width,
      height
    };
  }

  // ../../node_modules/@popperjs/core/lib/dom-utils/contains.js
  function contains(parent, child) {
    var rootNode = child.getRootNode && child.getRootNode();
    if (parent.contains(child)) {
      return true;
    } else if (rootNode && isShadowRoot(rootNode)) {
      var next = child;
      do {
        if (next && parent.isSameNode(next)) {
          return true;
        }
        next = next.parentNode || next.host;
      } while (next);
    }
    return false;
  }

  // ../../node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
  function getComputedStyle3(element) {
    return getWindow(element).getComputedStyle(element);
  }

  // ../../node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
  function isTableElement(element) {
    return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
  }

  // ../../node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
  function getDocumentElement(element) {
    return ((isElement(element) ? element.ownerDocument : element.document) || window.document).documentElement;
  }

  // ../../node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
  function getParentNode(element) {
    if (getNodeName(element) === "html") {
      return element;
    }
    return element.assignedSlot || element.parentNode || (isShadowRoot(element) ? element.host : null) || getDocumentElement(element);
  }

  // ../../node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
  function getTrueOffsetParent(element) {
    if (!isHTMLElement(element) || getComputedStyle3(element).position === "fixed") {
      return null;
    }
    return element.offsetParent;
  }
  function getContainingBlock(element) {
    var isFirefox = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1;
    var isIE = navigator.userAgent.indexOf("Trident") !== -1;
    if (isIE && isHTMLElement(element)) {
      var elementCss = getComputedStyle3(element);
      if (elementCss.position === "fixed") {
        return null;
      }
    }
    var currentNode = getParentNode(element);
    while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
      var css = getComputedStyle3(currentNode);
      if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
        return currentNode;
      } else {
        currentNode = currentNode.parentNode;
      }
    }
    return null;
  }
  function getOffsetParent(element) {
    var window2 = getWindow(element);
    var offsetParent = getTrueOffsetParent(element);
    while (offsetParent && isTableElement(offsetParent) && getComputedStyle3(offsetParent).position === "static") {
      offsetParent = getTrueOffsetParent(offsetParent);
    }
    if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle3(offsetParent).position === "static")) {
      return window2;
    }
    return offsetParent || getContainingBlock(element) || window2;
  }

  // ../../node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
  function getMainAxisFromPlacement(placement) {
    return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
  }

  // ../../node_modules/@popperjs/core/lib/utils/within.js
  function within(min2, value, max2) {
    return max(min2, min(value, max2));
  }
  function withinMaxClamp(min2, value, max2) {
    var v = within(min2, value, max2);
    return v > max2 ? max2 : v;
  }

  // ../../node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
  function getFreshSideObject() {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }

  // ../../node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
  function mergePaddingObject(paddingObject) {
    return Object.assign({}, getFreshSideObject(), paddingObject);
  }

  // ../../node_modules/@popperjs/core/lib/utils/expandToHashMap.js
  function expandToHashMap(value, keys) {
    return keys.reduce(function(hashMap, key) {
      hashMap[key] = value;
      return hashMap;
    }, {});
  }

  // ../../node_modules/@popperjs/core/lib/modifiers/arrow.js
  var toPaddingObject = function toPaddingObject2(padding, state) {
    padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
      placement: state.placement
    })) : padding;
    return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  };
  function arrow(_ref) {
    var _state$modifiersData$;
    var state = _ref.state, name2 = _ref.name, options2 = _ref.options;
    var arrowElement = state.elements.arrow;
    var popperOffsets2 = state.modifiersData.popperOffsets;
    var basePlacement = getBasePlacement(state.placement);
    var axis = getMainAxisFromPlacement(basePlacement);
    var isVertical = [left, right].indexOf(basePlacement) >= 0;
    var len = isVertical ? "height" : "width";
    if (!arrowElement || !popperOffsets2) {
      return;
    }
    var paddingObject = toPaddingObject(options2.padding, state);
    var arrowRect = getLayoutRect(arrowElement);
    var minProp = axis === "y" ? top : left;
    var maxProp = axis === "y" ? bottom : right;
    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
    var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
    var arrowOffsetParent = getOffsetParent(arrowElement);
    var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    var centerToReference = endDiff / 2 - startDiff / 2;
    var min2 = paddingObject[minProp];
    var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
    var offset2 = within(min2, center, max2);
    var axisProp = axis;
    state.modifiersData[name2] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
  }
  function effect2(_ref2) {
    var state = _ref2.state, options2 = _ref2.options;
    var _options$element = options2.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
    if (arrowElement == null) {
      return;
    }
    if (typeof arrowElement === "string") {
      arrowElement = state.elements.popper.querySelector(arrowElement);
      if (!arrowElement) {
        return;
      }
    }
    if (true) {
      if (!isHTMLElement(arrowElement)) {
        console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "));
      }
    }
    if (!contains(state.elements.popper, arrowElement)) {
      if (true) {
        console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
      }
      return;
    }
    state.elements.arrow = arrowElement;
  }
  var arrow_default = {
    name: "arrow",
    enabled: true,
    phase: "main",
    fn: arrow,
    effect: effect2,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
  };

  // ../../node_modules/@popperjs/core/lib/utils/getVariation.js
  function getVariation(placement) {
    return placement.split("-")[1];
  }

  // ../../node_modules/@popperjs/core/lib/modifiers/computeStyles.js
  var unsetSides = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
  };
  function roundOffsetsByDPR(_ref) {
    var x2 = _ref.x, y3 = _ref.y;
    var win = window;
    var dpr = win.devicePixelRatio || 1;
    return {
      x: round2(x2 * dpr) / dpr || 0,
      y: round2(y3 * dpr) / dpr || 0
    };
  }
  function mapToStyles(_ref2) {
    var _Object$assign2;
    var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
    var _ref3 = roundOffsets === true ? roundOffsetsByDPR(offsets) : typeof roundOffsets === "function" ? roundOffsets(offsets) : offsets, _ref3$x = _ref3.x, x2 = _ref3$x === void 0 ? 0 : _ref3$x, _ref3$y = _ref3.y, y3 = _ref3$y === void 0 ? 0 : _ref3$y;
    var hasX = offsets.hasOwnProperty("x");
    var hasY = offsets.hasOwnProperty("y");
    var sideX = left;
    var sideY = top;
    var win = window;
    if (adaptive) {
      var offsetParent = getOffsetParent(popper2);
      var heightProp = "clientHeight";
      var widthProp = "clientWidth";
      if (offsetParent === getWindow(popper2)) {
        offsetParent = getDocumentElement(popper2);
        if (getComputedStyle3(offsetParent).position !== "static" && position === "absolute") {
          heightProp = "scrollHeight";
          widthProp = "scrollWidth";
        }
      }
      offsetParent = offsetParent;
      if (placement === top || (placement === left || placement === right) && variation === end) {
        sideY = bottom;
        var offsetY = isFixed && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
        y3 -= offsetY - popperRect.height;
        y3 *= gpuAcceleration ? 1 : -1;
      }
      if (placement === left || (placement === top || placement === bottom) && variation === end) {
        sideX = right;
        var offsetX = isFixed && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
        x2 -= offsetX - popperRect.width;
        x2 *= gpuAcceleration ? 1 : -1;
      }
    }
    var commonStyles = Object.assign({
      position
    }, adaptive && unsetSides);
    if (gpuAcceleration) {
      var _Object$assign;
      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x2 + "px, " + y3 + "px)" : "translate3d(" + x2 + "px, " + y3 + "px, 0)", _Object$assign));
    }
    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y3 + "px" : "", _Object$assign2[sideX] = hasX ? x2 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
  }
  function computeStyles(_ref4) {
    var state = _ref4.state, options2 = _ref4.options;
    var _options$gpuAccelerat = options2.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options2.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options2.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
    if (true) {
      var transitionProperty = getComputedStyle3(state.elements.popper).transitionProperty || "";
      if (adaptive && ["transform", "top", "right", "bottom", "left"].some(function(property) {
        return transitionProperty.indexOf(property) >= 0;
      })) {
        console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', "\n\n", 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", "\n\n", "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
      }
    }
    var commonStyles = {
      placement: getBasePlacement(state.placement),
      variation: getVariation(state.placement),
      popper: state.elements.popper,
      popperRect: state.rects.popper,
      gpuAcceleration,
      isFixed: state.options.strategy === "fixed"
    };
    if (state.modifiersData.popperOffsets != null) {
      state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.popperOffsets,
        position: state.options.strategy,
        adaptive,
        roundOffsets
      })));
    }
    if (state.modifiersData.arrow != null) {
      state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.arrow,
        position: "absolute",
        adaptive: false,
        roundOffsets
      })));
    }
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-placement": state.placement
    });
  }
  var computeStyles_default = {
    name: "computeStyles",
    enabled: true,
    phase: "beforeWrite",
    fn: computeStyles,
    data: {}
  };

  // ../../node_modules/@popperjs/core/lib/modifiers/eventListeners.js
  var passive = {
    passive: true
  };
  function effect3(_ref) {
    var state = _ref.state, instance = _ref.instance, options2 = _ref.options;
    var _options$scroll = options2.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options2.resize, resize2 = _options$resize === void 0 ? true : _options$resize;
    var window2 = getWindow(state.elements.popper);
    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.addEventListener("scroll", instance.update, passive);
      });
    }
    if (resize2) {
      window2.addEventListener("resize", instance.update, passive);
    }
    return function() {
      if (scroll) {
        scrollParents.forEach(function(scrollParent) {
          scrollParent.removeEventListener("scroll", instance.update, passive);
        });
      }
      if (resize2) {
        window2.removeEventListener("resize", instance.update, passive);
      }
    };
  }
  var eventListeners_default = {
    name: "eventListeners",
    enabled: true,
    phase: "write",
    fn: function fn() {
    },
    effect: effect3,
    data: {}
  };

  // ../../node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
  var hash = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, function(matched) {
      return hash[matched];
    });
  }

  // ../../node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
  var hash2 = {
    start: "end",
    end: "start"
  };
  function getOppositeVariationPlacement(placement) {
    return placement.replace(/start|end/g, function(matched) {
      return hash2[matched];
    });
  }

  // ../../node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
  function getWindowScroll(node) {
    var win = getWindow(node);
    var scrollLeft = win.pageXOffset;
    var scrollTop = win.pageYOffset;
    return {
      scrollLeft,
      scrollTop
    };
  }

  // ../../node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
  function getWindowScrollBarX(element) {
    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
  }

  // ../../node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
  function getViewportRect(element) {
    var win = getWindow(element);
    var html = getDocumentElement(element);
    var visualViewport = win.visualViewport;
    var width = html.clientWidth;
    var height = html.clientHeight;
    var x2 = 0;
    var y3 = 0;
    if (visualViewport) {
      width = visualViewport.width;
      height = visualViewport.height;
      if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
        x2 = visualViewport.offsetLeft;
        y3 = visualViewport.offsetTop;
      }
    }
    return {
      width,
      height,
      x: x2 + getWindowScrollBarX(element),
      y: y3
    };
  }

  // ../../node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
  function getDocumentRect(element) {
    var _element$ownerDocumen;
    var html = getDocumentElement(element);
    var winScroll = getWindowScroll(element);
    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
    var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
    var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
    var x2 = -winScroll.scrollLeft + getWindowScrollBarX(element);
    var y3 = -winScroll.scrollTop;
    if (getComputedStyle3(body || html).direction === "rtl") {
      x2 += max(html.clientWidth, body ? body.clientWidth : 0) - width;
    }
    return {
      width,
      height,
      x: x2,
      y: y3
    };
  }

  // ../../node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
  function isScrollParent(element) {
    var _getComputedStyle = getComputedStyle3(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
  }

  // ../../node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
  function getScrollParent(node) {
    if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
      return node.ownerDocument.body;
    }
    if (isHTMLElement(node) && isScrollParent(node)) {
      return node;
    }
    return getScrollParent(getParentNode(node));
  }

  // ../../node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
  function listScrollParents(element, list) {
    var _element$ownerDocumen;
    if (list === void 0) {
      list = [];
    }
    var scrollParent = getScrollParent(element);
    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
    var win = getWindow(scrollParent);
    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
    var updatedList = list.concat(target);
    return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
  }

  // ../../node_modules/@popperjs/core/lib/utils/rectToClientRect.js
  function rectToClientRect(rect) {
    return Object.assign({}, rect, {
      left: rect.x,
      top: rect.y,
      right: rect.x + rect.width,
      bottom: rect.y + rect.height
    });
  }

  // ../../node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
  function getInnerBoundingClientRect(element) {
    var rect = getBoundingClientRect(element);
    rect.top = rect.top + element.clientTop;
    rect.left = rect.left + element.clientLeft;
    rect.bottom = rect.top + element.clientHeight;
    rect.right = rect.left + element.clientWidth;
    rect.width = element.clientWidth;
    rect.height = element.clientHeight;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
  }
  function getClientRectFromMixedType(element, clippingParent) {
    return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
  }
  function getClippingParents(element) {
    var clippingParents2 = listScrollParents(getParentNode(element));
    var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle3(element).position) >= 0;
    var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
    if (!isElement(clipperElement)) {
      return [];
    }
    return clippingParents2.filter(function(clippingParent) {
      return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body" && (canEscapeClipping ? getComputedStyle3(clippingParent).position !== "static" : true);
    });
  }
  function getClippingRect(element, boundary, rootBoundary) {
    var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
    var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
    var firstClippingParent = clippingParents2[0];
    var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
      var rect = getClientRectFromMixedType(element, clippingParent);
      accRect.top = max(rect.top, accRect.top);
      accRect.right = min(rect.right, accRect.right);
      accRect.bottom = min(rect.bottom, accRect.bottom);
      accRect.left = max(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromMixedType(element, firstClippingParent));
    clippingRect.width = clippingRect.right - clippingRect.left;
    clippingRect.height = clippingRect.bottom - clippingRect.top;
    clippingRect.x = clippingRect.left;
    clippingRect.y = clippingRect.top;
    return clippingRect;
  }

  // ../../node_modules/@popperjs/core/lib/utils/computeOffsets.js
  function computeOffsets(_ref) {
    var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
    var basePlacement = placement ? getBasePlacement(placement) : null;
    var variation = placement ? getVariation(placement) : null;
    var commonX = reference2.x + reference2.width / 2 - element.width / 2;
    var commonY = reference2.y + reference2.height / 2 - element.height / 2;
    var offsets;
    switch (basePlacement) {
      case top:
        offsets = {
          x: commonX,
          y: reference2.y - element.height
        };
        break;
      case bottom:
        offsets = {
          x: commonX,
          y: reference2.y + reference2.height
        };
        break;
      case right:
        offsets = {
          x: reference2.x + reference2.width,
          y: commonY
        };
        break;
      case left:
        offsets = {
          x: reference2.x - element.width,
          y: commonY
        };
        break;
      default:
        offsets = {
          x: reference2.x,
          y: reference2.y
        };
    }
    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
    if (mainAxis != null) {
      var len = mainAxis === "y" ? "height" : "width";
      switch (variation) {
        case start2:
          offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
          break;
        case end:
          offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
          break;
        default:
      }
    }
    return offsets;
  }

  // ../../node_modules/@popperjs/core/lib/utils/detectOverflow.js
  function detectOverflow(state, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    var _options = options2, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
    var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
    var altContext = elementContext === popper ? reference : popper;
    var popperRect = state.rects.popper;
    var element = state.elements[altBoundary ? altContext : elementContext];
    var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
    var referenceClientRect = getBoundingClientRect(state.elements.reference);
    var popperOffsets2 = computeOffsets({
      reference: referenceClientRect,
      element: popperRect,
      strategy: "absolute",
      placement
    });
    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
    var overflowOffsets = {
      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
      right: elementClientRect.right - clippingClientRect.right + paddingObject.right
    };
    var offsetData = state.modifiersData.offset;
    if (elementContext === popper && offsetData) {
      var offset2 = offsetData[placement];
      Object.keys(overflowOffsets).forEach(function(key) {
        var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
        var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
        overflowOffsets[key] += offset2[axis] * multiply;
      });
    }
    return overflowOffsets;
  }

  // ../../node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
  function computeAutoPlacement(state, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    var _options = options2, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
    var variation = getVariation(placement);
    var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
      return getVariation(placement2) === variation;
    }) : basePlacements;
    var allowedPlacements = placements2.filter(function(placement2) {
      return allowedAutoPlacements.indexOf(placement2) >= 0;
    });
    if (allowedPlacements.length === 0) {
      allowedPlacements = placements2;
      if (true) {
        console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" "));
      }
    }
    var overflows = allowedPlacements.reduce(function(acc, placement2) {
      acc[placement2] = detectOverflow(state, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding
      })[getBasePlacement(placement2)];
      return acc;
    }, {});
    return Object.keys(overflows).sort(function(a4, b2) {
      return overflows[a4] - overflows[b2];
    });
  }

  // ../../node_modules/@popperjs/core/lib/modifiers/flip.js
  function getExpandedFallbackPlacements(placement) {
    if (getBasePlacement(placement) === auto) {
      return [];
    }
    var oppositePlacement = getOppositePlacement(placement);
    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
  }
  function flip(_ref) {
    var state = _ref.state, options2 = _ref.options, name2 = _ref.name;
    if (state.modifiersData[name2]._skip) {
      return;
    }
    var _options$mainAxis = options2.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options2.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options2.fallbackPlacements, padding = options2.padding, boundary = options2.boundary, rootBoundary = options2.rootBoundary, altBoundary = options2.altBoundary, _options$flipVariatio = options2.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options2.allowedAutoPlacements;
    var preferredPlacement = state.options.placement;
    var basePlacement = getBasePlacement(preferredPlacement);
    var isBasePlacement = basePlacement === preferredPlacement;
    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
    var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
      return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding,
        flipVariations,
        allowedAutoPlacements
      }) : placement2);
    }, []);
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var checksMap = /* @__PURE__ */ new Map();
    var makeFallbackChecks = true;
    var firstFittingPlacement = placements2[0];
    for (var i3 = 0; i3 < placements2.length; i3++) {
      var placement = placements2[i3];
      var _basePlacement = getBasePlacement(placement);
      var isStartVariation = getVariation(placement) === start2;
      var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
      var len = isVertical ? "width" : "height";
      var overflow = detectOverflow(state, {
        placement,
        boundary,
        rootBoundary,
        altBoundary,
        padding
      });
      var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
      if (referenceRect[len] > popperRect[len]) {
        mainVariationSide = getOppositePlacement(mainVariationSide);
      }
      var altVariationSide = getOppositePlacement(mainVariationSide);
      var checks = [];
      if (checkMainAxis) {
        checks.push(overflow[_basePlacement] <= 0);
      }
      if (checkAltAxis) {
        checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
      }
      if (checks.every(function(check) {
        return check;
      })) {
        firstFittingPlacement = placement;
        makeFallbackChecks = false;
        break;
      }
      checksMap.set(placement, checks);
    }
    if (makeFallbackChecks) {
      var numberOfChecks = flipVariations ? 3 : 1;
      var _loop = function _loop2(_i2) {
        var fittingPlacement = placements2.find(function(placement2) {
          var checks2 = checksMap.get(placement2);
          if (checks2) {
            return checks2.slice(0, _i2).every(function(check) {
              return check;
            });
          }
        });
        if (fittingPlacement) {
          firstFittingPlacement = fittingPlacement;
          return "break";
        }
      };
      for (var _i = numberOfChecks; _i > 0; _i--) {
        var _ret = _loop(_i);
        if (_ret === "break")
          break;
      }
    }
    if (state.placement !== firstFittingPlacement) {
      state.modifiersData[name2]._skip = true;
      state.placement = firstFittingPlacement;
      state.reset = true;
    }
  }
  var flip_default = {
    name: "flip",
    enabled: true,
    phase: "main",
    fn: flip,
    requiresIfExists: ["offset"],
    data: {
      _skip: false
    }
  };

  // ../../node_modules/@popperjs/core/lib/modifiers/hide.js
  function getSideOffsets(overflow, rect, preventedOffsets) {
    if (preventedOffsets === void 0) {
      preventedOffsets = {
        x: 0,
        y: 0
      };
    }
    return {
      top: overflow.top - rect.height - preventedOffsets.y,
      right: overflow.right - rect.width + preventedOffsets.x,
      bottom: overflow.bottom - rect.height + preventedOffsets.y,
      left: overflow.left - rect.width - preventedOffsets.x
    };
  }
  function isAnySideFullyClipped(overflow) {
    return [top, right, bottom, left].some(function(side) {
      return overflow[side] >= 0;
    });
  }
  function hide(_ref) {
    var state = _ref.state, name2 = _ref.name;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var preventedOffsets = state.modifiersData.preventOverflow;
    var referenceOverflow = detectOverflow(state, {
      elementContext: "reference"
    });
    var popperAltOverflow = detectOverflow(state, {
      altBoundary: true
    });
    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
    state.modifiersData[name2] = {
      referenceClippingOffsets,
      popperEscapeOffsets,
      isReferenceHidden,
      hasPopperEscaped
    };
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-reference-hidden": isReferenceHidden,
      "data-popper-escaped": hasPopperEscaped
    });
  }
  var hide_default = {
    name: "hide",
    enabled: true,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: hide
  };

  // ../../node_modules/@popperjs/core/lib/modifiers/offset.js
  function distanceAndSkiddingToXY(placement, rects, offset2) {
    var basePlacement = getBasePlacement(placement);
    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
    var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
      placement
    })) : offset2, skidding = _ref[0], distance = _ref[1];
    skidding = skidding || 0;
    distance = (distance || 0) * invertDistance;
    return [left, right].indexOf(basePlacement) >= 0 ? {
      x: distance,
      y: skidding
    } : {
      x: skidding,
      y: distance
    };
  }
  function offset(_ref2) {
    var state = _ref2.state, options2 = _ref2.options, name2 = _ref2.name;
    var _options$offset = options2.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
    var data = placements.reduce(function(acc, placement) {
      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
      return acc;
    }, {});
    var _data$state$placement = data[state.placement], x2 = _data$state$placement.x, y3 = _data$state$placement.y;
    if (state.modifiersData.popperOffsets != null) {
      state.modifiersData.popperOffsets.x += x2;
      state.modifiersData.popperOffsets.y += y3;
    }
    state.modifiersData[name2] = data;
  }
  var offset_default = {
    name: "offset",
    enabled: true,
    phase: "main",
    requires: ["popperOffsets"],
    fn: offset
  };

  // ../../node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
  function popperOffsets(_ref) {
    var state = _ref.state, name2 = _ref.name;
    state.modifiersData[name2] = computeOffsets({
      reference: state.rects.reference,
      element: state.rects.popper,
      strategy: "absolute",
      placement: state.placement
    });
  }
  var popperOffsets_default = {
    name: "popperOffsets",
    enabled: true,
    phase: "read",
    fn: popperOffsets,
    data: {}
  };

  // ../../node_modules/@popperjs/core/lib/utils/getAltAxis.js
  function getAltAxis(axis) {
    return axis === "x" ? "y" : "x";
  }

  // ../../node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
  function preventOverflow(_ref) {
    var state = _ref.state, options2 = _ref.options, name2 = _ref.name;
    var _options$mainAxis = options2.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options2.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options2.boundary, rootBoundary = options2.rootBoundary, altBoundary = options2.altBoundary, padding = options2.padding, _options$tether = options2.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options2.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
    var overflow = detectOverflow(state, {
      boundary,
      rootBoundary,
      padding,
      altBoundary
    });
    var basePlacement = getBasePlacement(state.placement);
    var variation = getVariation(state.placement);
    var isBasePlacement = !variation;
    var mainAxis = getMainAxisFromPlacement(basePlacement);
    var altAxis = getAltAxis(mainAxis);
    var popperOffsets2 = state.modifiersData.popperOffsets;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
      placement: state.placement
    })) : tetherOffset;
    var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
      mainAxis: tetherOffsetValue,
      altAxis: tetherOffsetValue
    } : Object.assign({
      mainAxis: 0,
      altAxis: 0
    }, tetherOffsetValue);
    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
    var data = {
      x: 0,
      y: 0
    };
    if (!popperOffsets2) {
      return;
    }
    if (checkMainAxis) {
      var _offsetModifierState$;
      var mainSide = mainAxis === "y" ? top : left;
      var altSide = mainAxis === "y" ? bottom : right;
      var len = mainAxis === "y" ? "height" : "width";
      var offset2 = popperOffsets2[mainAxis];
      var min2 = offset2 + overflow[mainSide];
      var max2 = offset2 - overflow[altSide];
      var additive = tether ? -popperRect[len] / 2 : 0;
      var minLen = variation === start2 ? referenceRect[len] : popperRect[len];
      var maxLen = variation === start2 ? -popperRect[len] : -referenceRect[len];
      var arrowElement = state.elements.arrow;
      var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
        width: 0,
        height: 0
      };
      var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
      var arrowPaddingMin = arrowPaddingObject[mainSide];
      var arrowPaddingMax = arrowPaddingObject[altSide];
      var arrowLen = within(0, referenceRect[len], arrowRect[len]);
      var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
      var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
      var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
      var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
      var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
      var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
      var tetherMax = offset2 + maxOffset - offsetModifierValue;
      var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
      popperOffsets2[mainAxis] = preventedOffset;
      data[mainAxis] = preventedOffset - offset2;
    }
    if (checkAltAxis) {
      var _offsetModifierState$2;
      var _mainSide = mainAxis === "x" ? top : left;
      var _altSide = mainAxis === "x" ? bottom : right;
      var _offset = popperOffsets2[altAxis];
      var _len = altAxis === "y" ? "height" : "width";
      var _min = _offset + overflow[_mainSide];
      var _max = _offset - overflow[_altSide];
      var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
      var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
      var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
      var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
      var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
      popperOffsets2[altAxis] = _preventedOffset;
      data[altAxis] = _preventedOffset - _offset;
    }
    state.modifiersData[name2] = data;
  }
  var preventOverflow_default = {
    name: "preventOverflow",
    enabled: true,
    phase: "main",
    fn: preventOverflow,
    requiresIfExists: ["offset"]
  };

  // ../../node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
  function getHTMLElementScroll(element) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }

  // ../../node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
  function getNodeScroll(node) {
    if (node === getWindow(node) || !isHTMLElement(node)) {
      return getWindowScroll(node);
    } else {
      return getHTMLElementScroll(node);
    }
  }

  // ../../node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
  function isElementScaled(element) {
    var rect = element.getBoundingClientRect();
    var scaleX = round2(rect.width) / element.offsetWidth || 1;
    var scaleY = round2(rect.height) / element.offsetHeight || 1;
    return scaleX !== 1 || scaleY !== 1;
  }
  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
    if (isFixed === void 0) {
      isFixed = false;
    }
    var isOffsetParentAnElement = isHTMLElement(offsetParent);
    var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
    var documentElement = getDocumentElement(offsetParent);
    var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled);
    var scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    var offsets = {
      x: 0,
      y: 0
    };
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isHTMLElement(offsetParent)) {
        offsets = getBoundingClientRect(offsetParent, true);
        offsets.x += offsetParent.clientLeft;
        offsets.y += offsetParent.clientTop;
      } else if (documentElement) {
        offsets.x = getWindowScrollBarX(documentElement);
      }
    }
    return {
      x: rect.left + scroll.scrollLeft - offsets.x,
      y: rect.top + scroll.scrollTop - offsets.y,
      width: rect.width,
      height: rect.height
    };
  }

  // ../../node_modules/@popperjs/core/lib/utils/orderModifiers.js
  function order(modifiers) {
    var map3 = /* @__PURE__ */ new Map();
    var visited = /* @__PURE__ */ new Set();
    var result = [];
    modifiers.forEach(function(modifier) {
      map3.set(modifier.name, modifier);
    });
    function sort(modifier) {
      visited.add(modifier.name);
      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
      requires.forEach(function(dep) {
        if (!visited.has(dep)) {
          var depModifier = map3.get(dep);
          if (depModifier) {
            sort(depModifier);
          }
        }
      });
      result.push(modifier);
    }
    modifiers.forEach(function(modifier) {
      if (!visited.has(modifier.name)) {
        sort(modifier);
      }
    });
    return result;
  }
  function orderModifiers(modifiers) {
    var orderedModifiers = order(modifiers);
    return modifierPhases.reduce(function(acc, phase) {
      return acc.concat(orderedModifiers.filter(function(modifier) {
        return modifier.phase === phase;
      }));
    }, []);
  }

  // ../../node_modules/@popperjs/core/lib/utils/debounce.js
  function debounce2(fn2) {
    var pending;
    return function() {
      if (!pending) {
        pending = new Promise(function(resolve2) {
          Promise.resolve().then(function() {
            pending = void 0;
            resolve2(fn2());
          });
        });
      }
      return pending;
    };
  }

  // ../../node_modules/@popperjs/core/lib/utils/format.js
  function format2(str) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return [].concat(args).reduce(function(p, c2) {
      return p.replace(/%s/, c2);
    }, str);
  }

  // ../../node_modules/@popperjs/core/lib/utils/validateModifiers.js
  var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
  var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
  var VALID_PROPERTIES = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
  function validateModifiers(modifiers) {
    modifiers.forEach(function(modifier) {
      [].concat(Object.keys(modifier), VALID_PROPERTIES).filter(function(value, index2, self2) {
        return self2.indexOf(value) === index2;
      }).forEach(function(key) {
        switch (key) {
          case "name":
            if (typeof modifier.name !== "string") {
              console.error(format2(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', '"' + String(modifier.name) + '"'));
            }
            break;
          case "enabled":
            if (typeof modifier.enabled !== "boolean") {
              console.error(format2(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', '"' + String(modifier.enabled) + '"'));
            }
            break;
          case "phase":
            if (modifierPhases.indexOf(modifier.phase) < 0) {
              console.error(format2(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(", "), '"' + String(modifier.phase) + '"'));
            }
            break;
          case "fn":
            if (typeof modifier.fn !== "function") {
              console.error(format2(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', '"' + String(modifier.fn) + '"'));
            }
            break;
          case "effect":
            if (modifier.effect != null && typeof modifier.effect !== "function") {
              console.error(format2(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', '"' + String(modifier.fn) + '"'));
            }
            break;
          case "requires":
            if (modifier.requires != null && !Array.isArray(modifier.requires)) {
              console.error(format2(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', '"' + String(modifier.requires) + '"'));
            }
            break;
          case "requiresIfExists":
            if (!Array.isArray(modifier.requiresIfExists)) {
              console.error(format2(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', '"' + String(modifier.requiresIfExists) + '"'));
            }
            break;
          case "options":
          case "data":
            break;
          default:
            console.error('PopperJS: an invalid property has been provided to the "' + modifier.name + '" modifier, valid properties are ' + VALID_PROPERTIES.map(function(s4) {
              return '"' + s4 + '"';
            }).join(", ") + '; but "' + key + '" was provided.');
        }
        modifier.requires && modifier.requires.forEach(function(requirement) {
          if (modifiers.find(function(mod) {
            return mod.name === requirement;
          }) == null) {
            console.error(format2(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
          }
        });
      });
    });
  }

  // ../../node_modules/@popperjs/core/lib/utils/uniqueBy.js
  function uniqueBy(arr, fn2) {
    var identifiers = /* @__PURE__ */ new Set();
    return arr.filter(function(item) {
      var identifier = fn2(item);
      if (!identifiers.has(identifier)) {
        identifiers.add(identifier);
        return true;
      }
    });
  }

  // ../../node_modules/@popperjs/core/lib/utils/mergeByName.js
  function mergeByName(modifiers) {
    var merged = modifiers.reduce(function(merged2, current) {
      var existing = merged2[current.name];
      merged2[current.name] = existing ? Object.assign({}, existing, current, {
        options: Object.assign({}, existing.options, current.options),
        data: Object.assign({}, existing.data, current.data)
      }) : current;
      return merged2;
    }, {});
    return Object.keys(merged).map(function(key) {
      return merged[key];
    });
  }

  // ../../node_modules/@popperjs/core/lib/createPopper.js
  var INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
  var INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
  var DEFAULT_OPTIONS = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
  };
  function areValidElements() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return !args.some(function(element) {
      return !(element && typeof element.getBoundingClientRect === "function");
    });
  }
  function popperGenerator(generatorOptions) {
    if (generatorOptions === void 0) {
      generatorOptions = {};
    }
    var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions4 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
    return function createPopper2(reference2, popper2, options2) {
      if (options2 === void 0) {
        options2 = defaultOptions4;
      }
      var state = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions4),
        modifiersData: {},
        elements: {
          reference: reference2,
          popper: popper2
        },
        attributes: {},
        styles: {}
      };
      var effectCleanupFns = [];
      var isDestroyed = false;
      var instance = {
        state,
        setOptions: function setOptions2(setOptionsAction) {
          var options3 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
          cleanupModifierEffects();
          state.options = Object.assign({}, defaultOptions4, state.options, options3);
          state.scrollParents = {
            reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
            popper: listScrollParents(popper2)
          };
          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
          state.orderedModifiers = orderedModifiers.filter(function(m3) {
            return m3.enabled;
          });
          if (true) {
            var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function(_ref) {
              var name2 = _ref.name;
              return name2;
            });
            validateModifiers(modifiers);
            if (getBasePlacement(state.options.placement) === auto) {
              var flipModifier = state.orderedModifiers.find(function(_ref2) {
                var name2 = _ref2.name;
                return name2 === "flip";
              });
              if (!flipModifier) {
                console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
              }
            }
            var _getComputedStyle = getComputedStyle3(popper2), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft;
            if ([marginTop, marginRight, marginBottom, marginLeft].some(function(margin) {
              return parseFloat(margin);
            })) {
              console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
            }
          }
          runModifierEffects();
          return instance.update();
        },
        forceUpdate: function forceUpdate() {
          if (isDestroyed) {
            return;
          }
          var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
          if (!areValidElements(reference3, popper3)) {
            if (true) {
              console.error(INVALID_ELEMENT_ERROR);
            }
            return;
          }
          state.rects = {
            reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
            popper: getLayoutRect(popper3)
          };
          state.reset = false;
          state.placement = state.options.placement;
          state.orderedModifiers.forEach(function(modifier) {
            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
          });
          var __debug_loops__ = 0;
          for (var index2 = 0; index2 < state.orderedModifiers.length; index2++) {
            if (true) {
              __debug_loops__ += 1;
              if (__debug_loops__ > 100) {
                console.error(INFINITE_LOOP_ERROR);
                break;
              }
            }
            if (state.reset === true) {
              state.reset = false;
              index2 = -1;
              continue;
            }
            var _state$orderedModifie = state.orderedModifiers[index2], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name2 = _state$orderedModifie.name;
            if (typeof fn2 === "function") {
              state = fn2({
                state,
                options: _options,
                name: name2,
                instance
              }) || state;
            }
          }
        },
        update: debounce2(function() {
          return new Promise(function(resolve2) {
            instance.forceUpdate();
            resolve2(state);
          });
        }),
        destroy: function destroy6() {
          cleanupModifierEffects();
          isDestroyed = true;
        }
      };
      if (!areValidElements(reference2, popper2)) {
        if (true) {
          console.error(INVALID_ELEMENT_ERROR);
        }
        return instance;
      }
      instance.setOptions(options2).then(function(state2) {
        if (!isDestroyed && options2.onFirstUpdate) {
          options2.onFirstUpdate(state2);
        }
      });
      function runModifierEffects() {
        state.orderedModifiers.forEach(function(_ref3) {
          var name2 = _ref3.name, _ref3$options = _ref3.options, options3 = _ref3$options === void 0 ? {} : _ref3$options, effect5 = _ref3.effect;
          if (typeof effect5 === "function") {
            var cleanupFn = effect5({
              state,
              name: name2,
              instance,
              options: options3
            });
            var noopFn = function noopFn2() {
            };
            effectCleanupFns.push(cleanupFn || noopFn);
          }
        });
      }
      function cleanupModifierEffects() {
        effectCleanupFns.forEach(function(fn2) {
          return fn2();
        });
        effectCleanupFns = [];
      }
      return instance;
    };
  }

  // ../../node_modules/@popperjs/core/lib/popper.js
  var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
  var createPopper = /* @__PURE__ */ popperGenerator({
    defaultModifiers
  });

  // ../../node_modules/tippy.js/dist/tippy.esm.js
  var BOX_CLASS = "tippy-box";
  var CONTENT_CLASS = "tippy-content";
  var BACKDROP_CLASS = "tippy-backdrop";
  var ARROW_CLASS = "tippy-arrow";
  var SVG_ARROW_CLASS = "tippy-svg-arrow";
  var TOUCH_OPTIONS = {
    passive: true,
    capture: true
  };
  var TIPPY_DEFAULT_APPEND_TO = function TIPPY_DEFAULT_APPEND_TO2() {
    return document.body;
  };
  function hasOwnProperty(obj, key) {
    return {}.hasOwnProperty.call(obj, key);
  }
  function getValueAtIndexOrReturn(value, index2, defaultValue) {
    if (Array.isArray(value)) {
      var v = value[index2];
      return v == null ? Array.isArray(defaultValue) ? defaultValue[index2] : defaultValue : v;
    }
    return value;
  }
  function isType(value, type) {
    var str = {}.toString.call(value);
    return str.indexOf("[object") === 0 && str.indexOf(type + "]") > -1;
  }
  function invokeWithArgsOrReturn(value, args) {
    return typeof value === "function" ? value.apply(void 0, args) : value;
  }
  function debounce3(fn2, ms) {
    if (ms === 0) {
      return fn2;
    }
    var timeout;
    return function(arg) {
      clearTimeout(timeout);
      timeout = setTimeout(function() {
        fn2(arg);
      }, ms);
    };
  }
  function removeProperties(obj, keys) {
    var clone3 = Object.assign({}, obj);
    keys.forEach(function(key) {
      delete clone3[key];
    });
    return clone3;
  }
  function splitBySpaces(value) {
    return value.split(/\s+/).filter(Boolean);
  }
  function normalizeToArray(value) {
    return [].concat(value);
  }
  function pushIfUnique(arr, value) {
    if (arr.indexOf(value) === -1) {
      arr.push(value);
    }
  }
  function unique(arr) {
    return arr.filter(function(item, index2) {
      return arr.indexOf(item) === index2;
    });
  }
  function getBasePlacement2(placement) {
    return placement.split("-")[0];
  }
  function arrayFrom(value) {
    return [].slice.call(value);
  }
  function removeUndefinedProps(obj) {
    return Object.keys(obj).reduce(function(acc, key) {
      if (obj[key] !== void 0) {
        acc[key] = obj[key];
      }
      return acc;
    }, {});
  }
  function div() {
    return document.createElement("div");
  }
  function isElement2(value) {
    return ["Element", "Fragment"].some(function(type) {
      return isType(value, type);
    });
  }
  function isNodeList(value) {
    return isType(value, "NodeList");
  }
  function isMouseEvent(value) {
    return isType(value, "MouseEvent");
  }
  function isReferenceElement(value) {
    return !!(value && value._tippy && value._tippy.reference === value);
  }
  function getArrayOfElements(value) {
    if (isElement2(value)) {
      return [value];
    }
    if (isNodeList(value)) {
      return arrayFrom(value);
    }
    if (Array.isArray(value)) {
      return value;
    }
    return arrayFrom(document.querySelectorAll(value));
  }
  function setTransitionDuration(els, value) {
    els.forEach(function(el) {
      if (el) {
        el.style.transitionDuration = value + "ms";
      }
    });
  }
  function setVisibilityState(els, state) {
    els.forEach(function(el) {
      if (el) {
        el.setAttribute("data-state", state);
      }
    });
  }
  function getOwnerDocument(elementOrElements) {
    var _element$ownerDocumen;
    var _normalizeToArray = normalizeToArray(elementOrElements), element = _normalizeToArray[0];
    return element != null && (_element$ownerDocumen = element.ownerDocument) != null && _element$ownerDocumen.body ? element.ownerDocument : document;
  }
  function isCursorOutsideInteractiveBorder(popperTreeData, event) {
    var clientX = event.clientX, clientY = event.clientY;
    return popperTreeData.every(function(_ref) {
      var popperRect = _ref.popperRect, popperState = _ref.popperState, props = _ref.props;
      var interactiveBorder = props.interactiveBorder;
      var basePlacement = getBasePlacement2(popperState.placement);
      var offsetData = popperState.modifiersData.offset;
      if (!offsetData) {
        return true;
      }
      var topDistance = basePlacement === "bottom" ? offsetData.top.y : 0;
      var bottomDistance = basePlacement === "top" ? offsetData.bottom.y : 0;
      var leftDistance = basePlacement === "right" ? offsetData.left.x : 0;
      var rightDistance = basePlacement === "left" ? offsetData.right.x : 0;
      var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
      var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
      var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
      var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
      return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
    });
  }
  function updateTransitionEndListener(box, action, listener) {
    var method = action + "EventListener";
    ["transitionend", "webkitTransitionEnd"].forEach(function(event) {
      box[method](event, listener);
    });
  }
  function actualContains(parent, child) {
    var target = child;
    while (target) {
      var _target$getRootNode;
      if (parent.contains(target)) {
        return true;
      }
      target = target.getRootNode == null ? void 0 : (_target$getRootNode = target.getRootNode()) == null ? void 0 : _target$getRootNode.host;
    }
    return false;
  }
  var currentInput = {
    isTouch: false
  };
  var lastMouseMoveTime = 0;
  function onDocumentTouchStart() {
    if (currentInput.isTouch) {
      return;
    }
    currentInput.isTouch = true;
    if (window.performance) {
      document.addEventListener("mousemove", onDocumentMouseMove);
    }
  }
  function onDocumentMouseMove() {
    var now3 = performance.now();
    if (now3 - lastMouseMoveTime < 20) {
      currentInput.isTouch = false;
      document.removeEventListener("mousemove", onDocumentMouseMove);
    }
    lastMouseMoveTime = now3;
  }
  function onWindowBlur() {
    var activeElement = document.activeElement;
    if (isReferenceElement(activeElement)) {
      var instance = activeElement._tippy;
      if (activeElement.blur && !instance.state.isVisible) {
        activeElement.blur();
      }
    }
  }
  function bindGlobalEventListeners() {
    document.addEventListener("touchstart", onDocumentTouchStart, TOUCH_OPTIONS);
    window.addEventListener("blur", onWindowBlur);
  }
  var isBrowser = typeof window !== "undefined" && typeof document !== "undefined";
  var isIE11 = isBrowser ? !!window.msCrypto : false;
  function createMemoryLeakWarning(method) {
    var txt = method === "destroy" ? "n already-" : " ";
    return [method + "() was called on a" + txt + "destroyed instance. This is a no-op but", "indicates a potential memory leak."].join(" ");
  }
  function clean(value) {
    var spacesAndTabs = /[ \t]{2,}/g;
    var lineStartWithSpaces = /^[ \t]*/gm;
    return value.replace(spacesAndTabs, " ").replace(lineStartWithSpaces, "").trim();
  }
  function getDevMessage(message) {
    return clean("\n  %ctippy.js\n\n  %c" + clean(message) + "\n\n  %c\u{1F477}\u200D This is a development-only message. It will be removed in production.\n  ");
  }
  function getFormattedMessage(message) {
    return [
      getDevMessage(message),
      "color: #00C584; font-size: 1.3em; font-weight: bold;",
      "line-height: 1.5",
      "color: #a6a095;"
    ];
  }
  var visitedMessages;
  if (true) {
    resetVisitedMessages();
  }
  function resetVisitedMessages() {
    visitedMessages = /* @__PURE__ */ new Set();
  }
  function warnWhen(condition, message) {
    if (condition && !visitedMessages.has(message)) {
      var _console;
      visitedMessages.add(message);
      (_console = console).warn.apply(_console, getFormattedMessage(message));
    }
  }
  function errorWhen(condition, message) {
    if (condition && !visitedMessages.has(message)) {
      var _console2;
      visitedMessages.add(message);
      (_console2 = console).error.apply(_console2, getFormattedMessage(message));
    }
  }
  function validateTargets(targets) {
    var didPassFalsyValue = !targets;
    var didPassPlainObject = Object.prototype.toString.call(targets) === "[object Object]" && !targets.addEventListener;
    errorWhen(didPassFalsyValue, ["tippy() was passed", "`" + String(targets) + "`", "as its targets (first) argument. Valid types are: String, Element,", "Element[], or NodeList."].join(" "));
    errorWhen(didPassPlainObject, ["tippy() was passed a plain object which is not supported as an argument", "for virtual positioning. Use props.getReferenceClientRect instead."].join(" "));
  }
  var pluginProps = {
    animateFill: false,
    followCursor: false,
    inlinePositioning: false,
    sticky: false
  };
  var renderProps = {
    allowHTML: false,
    animation: "fade",
    arrow: true,
    content: "",
    inertia: false,
    maxWidth: 350,
    role: "tooltip",
    theme: "",
    zIndex: 9999
  };
  var defaultProps = Object.assign({
    appendTo: TIPPY_DEFAULT_APPEND_TO,
    aria: {
      content: "auto",
      expanded: "auto"
    },
    delay: 0,
    duration: [300, 250],
    getReferenceClientRect: null,
    hideOnClick: true,
    ignoreAttributes: false,
    interactive: false,
    interactiveBorder: 2,
    interactiveDebounce: 0,
    moveTransition: "",
    offset: [0, 10],
    onAfterUpdate: function onAfterUpdate() {
    },
    onBeforeUpdate: function onBeforeUpdate() {
    },
    onCreate: function onCreate() {
    },
    onDestroy: function onDestroy() {
    },
    onHidden: function onHidden() {
    },
    onHide: function onHide() {
    },
    onMount: function onMount() {
    },
    onShow: function onShow() {
    },
    onShown: function onShown() {
    },
    onTrigger: function onTrigger() {
    },
    onUntrigger: function onUntrigger() {
    },
    onClickOutside: function onClickOutside() {
    },
    placement: "top",
    plugins: [],
    popperOptions: {},
    render: null,
    showOnCreate: false,
    touch: true,
    trigger: "mouseenter focus",
    triggerTarget: null
  }, pluginProps, renderProps);
  var defaultKeys = Object.keys(defaultProps);
  var setDefaultProps = function setDefaultProps2(partialProps) {
    if (true) {
      validateProps(partialProps, []);
    }
    var keys = Object.keys(partialProps);
    keys.forEach(function(key) {
      defaultProps[key] = partialProps[key];
    });
  };
  function getExtendedPassedProps(passedProps) {
    var plugins2 = passedProps.plugins || [];
    var pluginProps2 = plugins2.reduce(function(acc, plugin) {
      var name2 = plugin.name, defaultValue = plugin.defaultValue;
      if (name2) {
        var _name;
        acc[name2] = passedProps[name2] !== void 0 ? passedProps[name2] : (_name = defaultProps[name2]) != null ? _name : defaultValue;
      }
      return acc;
    }, {});
    return Object.assign({}, passedProps, pluginProps2);
  }
  function getDataAttributeProps(reference2, plugins2) {
    var propKeys = plugins2 ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {
      plugins: plugins2
    }))) : defaultKeys;
    var props = propKeys.reduce(function(acc, key) {
      var valueAsString = (reference2.getAttribute("data-tippy-" + key) || "").trim();
      if (!valueAsString) {
        return acc;
      }
      if (key === "content") {
        acc[key] = valueAsString;
      } else {
        try {
          acc[key] = JSON.parse(valueAsString);
        } catch (e3) {
          acc[key] = valueAsString;
        }
      }
      return acc;
    }, {});
    return props;
  }
  function evaluateProps(reference2, props) {
    var out = Object.assign({}, props, {
      content: invokeWithArgsOrReturn(props.content, [reference2])
    }, props.ignoreAttributes ? {} : getDataAttributeProps(reference2, props.plugins));
    out.aria = Object.assign({}, defaultProps.aria, out.aria);
    out.aria = {
      expanded: out.aria.expanded === "auto" ? props.interactive : out.aria.expanded,
      content: out.aria.content === "auto" ? props.interactive ? null : "describedby" : out.aria.content
    };
    return out;
  }
  function validateProps(partialProps, plugins2) {
    if (partialProps === void 0) {
      partialProps = {};
    }
    if (plugins2 === void 0) {
      plugins2 = [];
    }
    var keys = Object.keys(partialProps);
    keys.forEach(function(prop) {
      var nonPluginProps = removeProperties(defaultProps, Object.keys(pluginProps));
      var didPassUnknownProp = !hasOwnProperty(nonPluginProps, prop);
      if (didPassUnknownProp) {
        didPassUnknownProp = plugins2.filter(function(plugin) {
          return plugin.name === prop;
        }).length === 0;
      }
      warnWhen(didPassUnknownProp, ["`" + prop + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's", "a plugin, forgot to pass it in an array as props.plugins.", "\n\n", "All props: https://atomiks.github.io/tippyjs/v6/all-props/\n", "Plugins: https://atomiks.github.io/tippyjs/v6/plugins/"].join(" "));
    });
  }
  var innerHTML = function innerHTML2() {
    return "innerHTML";
  };
  function dangerouslySetInnerHTML(element, html) {
    element[innerHTML()] = html;
  }
  function createArrowElement(value) {
    var arrow2 = div();
    if (value === true) {
      arrow2.className = ARROW_CLASS;
    } else {
      arrow2.className = SVG_ARROW_CLASS;
      if (isElement2(value)) {
        arrow2.appendChild(value);
      } else {
        dangerouslySetInnerHTML(arrow2, value);
      }
    }
    return arrow2;
  }
  function setContent(content, props) {
    if (isElement2(props.content)) {
      dangerouslySetInnerHTML(content, "");
      content.appendChild(props.content);
    } else if (typeof props.content !== "function") {
      if (props.allowHTML) {
        dangerouslySetInnerHTML(content, props.content);
      } else {
        content.textContent = props.content;
      }
    }
  }
  function getChildren(popper2) {
    var box = popper2.firstElementChild;
    var boxChildren = arrayFrom(box.children);
    return {
      box,
      content: boxChildren.find(function(node) {
        return node.classList.contains(CONTENT_CLASS);
      }),
      arrow: boxChildren.find(function(node) {
        return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);
      }),
      backdrop: boxChildren.find(function(node) {
        return node.classList.contains(BACKDROP_CLASS);
      })
    };
  }
  function render(instance) {
    var popper2 = div();
    var box = div();
    box.className = BOX_CLASS;
    box.setAttribute("data-state", "hidden");
    box.setAttribute("tabindex", "-1");
    var content = div();
    content.className = CONTENT_CLASS;
    content.setAttribute("data-state", "hidden");
    setContent(content, instance.props);
    popper2.appendChild(box);
    box.appendChild(content);
    onUpdate(instance.props, instance.props);
    function onUpdate(prevProps, nextProps) {
      var _getChildren = getChildren(popper2), box2 = _getChildren.box, content2 = _getChildren.content, arrow2 = _getChildren.arrow;
      if (nextProps.theme) {
        box2.setAttribute("data-theme", nextProps.theme);
      } else {
        box2.removeAttribute("data-theme");
      }
      if (typeof nextProps.animation === "string") {
        box2.setAttribute("data-animation", nextProps.animation);
      } else {
        box2.removeAttribute("data-animation");
      }
      if (nextProps.inertia) {
        box2.setAttribute("data-inertia", "");
      } else {
        box2.removeAttribute("data-inertia");
      }
      box2.style.maxWidth = typeof nextProps.maxWidth === "number" ? nextProps.maxWidth + "px" : nextProps.maxWidth;
      if (nextProps.role) {
        box2.setAttribute("role", nextProps.role);
      } else {
        box2.removeAttribute("role");
      }
      if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {
        setContent(content2, instance.props);
      }
      if (nextProps.arrow) {
        if (!arrow2) {
          box2.appendChild(createArrowElement(nextProps.arrow));
        } else if (prevProps.arrow !== nextProps.arrow) {
          box2.removeChild(arrow2);
          box2.appendChild(createArrowElement(nextProps.arrow));
        }
      } else if (arrow2) {
        box2.removeChild(arrow2);
      }
    }
    return {
      popper: popper2,
      onUpdate
    };
  }
  render.$$tippy = true;
  var idCounter = 1;
  var mouseMoveListeners = [];
  var mountedInstances = [];
  function createTippy(reference2, passedProps) {
    var props = evaluateProps(reference2, Object.assign({}, defaultProps, getExtendedPassedProps(removeUndefinedProps(passedProps))));
    var showTimeout;
    var hideTimeout;
    var scheduleHideAnimationFrame;
    var isVisibleFromClick = false;
    var didHideDueToDocumentMouseDown = false;
    var didTouchMove = false;
    var ignoreOnFirstUpdate = false;
    var lastTriggerEvent;
    var currentTransitionEndListener;
    var onFirstUpdate;
    var listeners = [];
    var debouncedOnMouseMove = debounce3(onMouseMove, props.interactiveDebounce);
    var currentTarget;
    var id = idCounter++;
    var popperInstance = null;
    var plugins2 = unique(props.plugins);
    var state = {
      isEnabled: true,
      isVisible: false,
      isDestroyed: false,
      isMounted: false,
      isShown: false
    };
    var instance = {
      id,
      reference: reference2,
      popper: div(),
      popperInstance,
      props,
      state,
      plugins: plugins2,
      clearDelayTimeouts,
      setProps,
      setContent: setContent2,
      show,
      hide: hide2,
      hideWithInteractivity,
      enable,
      disable,
      unmount,
      destroy: destroy6
    };
    if (!props.render) {
      if (true) {
        errorWhen(true, "render() function has not been supplied.");
      }
      return instance;
    }
    var _props$render = props.render(instance), popper2 = _props$render.popper, onUpdate = _props$render.onUpdate;
    popper2.setAttribute("data-tippy-root", "");
    popper2.id = "tippy-" + instance.id;
    instance.popper = popper2;
    reference2._tippy = instance;
    popper2._tippy = instance;
    var pluginsHooks = plugins2.map(function(plugin) {
      return plugin.fn(instance);
    });
    var hasAriaExpanded = reference2.hasAttribute("aria-expanded");
    addListeners();
    handleAriaExpandedAttribute();
    handleStyles();
    invokeHook("onCreate", [instance]);
    if (props.showOnCreate) {
      scheduleShow();
    }
    popper2.addEventListener("mouseenter", function() {
      if (instance.props.interactive && instance.state.isVisible) {
        instance.clearDelayTimeouts();
      }
    });
    popper2.addEventListener("mouseleave", function() {
      if (instance.props.interactive && instance.props.trigger.indexOf("mouseenter") >= 0) {
        getDocument().addEventListener("mousemove", debouncedOnMouseMove);
      }
    });
    return instance;
    function getNormalizedTouchSettings() {
      var touch = instance.props.touch;
      return Array.isArray(touch) ? touch : [touch, 0];
    }
    function getIsCustomTouchBehavior() {
      return getNormalizedTouchSettings()[0] === "hold";
    }
    function getIsDefaultRenderFn() {
      var _instance$props$rende;
      return !!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy);
    }
    function getCurrentTarget() {
      return currentTarget || reference2;
    }
    function getDocument() {
      var parent = getCurrentTarget().parentNode;
      return parent ? getOwnerDocument(parent) : document;
    }
    function getDefaultTemplateChildren() {
      return getChildren(popper2);
    }
    function getDelay(isShow) {
      if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === "focus") {
        return 0;
      }
      return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);
    }
    function handleStyles(fromHide) {
      if (fromHide === void 0) {
        fromHide = false;
      }
      popper2.style.pointerEvents = instance.props.interactive && !fromHide ? "" : "none";
      popper2.style.zIndex = "" + instance.props.zIndex;
    }
    function invokeHook(hook, args, shouldInvokePropsHook) {
      if (shouldInvokePropsHook === void 0) {
        shouldInvokePropsHook = true;
      }
      pluginsHooks.forEach(function(pluginHooks) {
        if (pluginHooks[hook]) {
          pluginHooks[hook].apply(pluginHooks, args);
        }
      });
      if (shouldInvokePropsHook) {
        var _instance$props;
        (_instance$props = instance.props)[hook].apply(_instance$props, args);
      }
    }
    function handleAriaContentAttribute() {
      var aria = instance.props.aria;
      if (!aria.content) {
        return;
      }
      var attr = "aria-" + aria.content;
      var id2 = popper2.id;
      var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
      nodes.forEach(function(node) {
        var currentValue = node.getAttribute(attr);
        if (instance.state.isVisible) {
          node.setAttribute(attr, currentValue ? currentValue + " " + id2 : id2);
        } else {
          var nextValue = currentValue && currentValue.replace(id2, "").trim();
          if (nextValue) {
            node.setAttribute(attr, nextValue);
          } else {
            node.removeAttribute(attr);
          }
        }
      });
    }
    function handleAriaExpandedAttribute() {
      if (hasAriaExpanded || !instance.props.aria.expanded) {
        return;
      }
      var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
      nodes.forEach(function(node) {
        if (instance.props.interactive) {
          node.setAttribute("aria-expanded", instance.state.isVisible && node === getCurrentTarget() ? "true" : "false");
        } else {
          node.removeAttribute("aria-expanded");
        }
      });
    }
    function cleanupInteractiveMouseListeners() {
      getDocument().removeEventListener("mousemove", debouncedOnMouseMove);
      mouseMoveListeners = mouseMoveListeners.filter(function(listener) {
        return listener !== debouncedOnMouseMove;
      });
    }
    function onDocumentPress(event) {
      if (currentInput.isTouch) {
        if (didTouchMove || event.type === "mousedown") {
          return;
        }
      }
      var actualTarget = event.composedPath && event.composedPath()[0] || event.target;
      if (instance.props.interactive && actualContains(popper2, actualTarget)) {
        return;
      }
      if (normalizeToArray(instance.props.triggerTarget || reference2).some(function(el) {
        return actualContains(el, actualTarget);
      })) {
        if (currentInput.isTouch) {
          return;
        }
        if (instance.state.isVisible && instance.props.trigger.indexOf("click") >= 0) {
          return;
        }
      } else {
        invokeHook("onClickOutside", [instance, event]);
      }
      if (instance.props.hideOnClick === true) {
        instance.clearDelayTimeouts();
        instance.hide();
        didHideDueToDocumentMouseDown = true;
        setTimeout(function() {
          didHideDueToDocumentMouseDown = false;
        });
        if (!instance.state.isMounted) {
          removeDocumentPress();
        }
      }
    }
    function onTouchMove() {
      didTouchMove = true;
    }
    function onTouchStart() {
      didTouchMove = false;
    }
    function addDocumentPress() {
      var doc = getDocument();
      doc.addEventListener("mousedown", onDocumentPress, true);
      doc.addEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
      doc.addEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
      doc.addEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
    }
    function removeDocumentPress() {
      var doc = getDocument();
      doc.removeEventListener("mousedown", onDocumentPress, true);
      doc.removeEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
      doc.removeEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
      doc.removeEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
    }
    function onTransitionedOut(duration2, callback2) {
      onTransitionEnd(duration2, function() {
        if (!instance.state.isVisible && popper2.parentNode && popper2.parentNode.contains(popper2)) {
          callback2();
        }
      });
    }
    function onTransitionedIn(duration2, callback2) {
      onTransitionEnd(duration2, callback2);
    }
    function onTransitionEnd(duration2, callback2) {
      var box = getDefaultTemplateChildren().box;
      function listener(event) {
        if (event.target === box) {
          updateTransitionEndListener(box, "remove", listener);
          callback2();
        }
      }
      if (duration2 === 0) {
        return callback2();
      }
      updateTransitionEndListener(box, "remove", currentTransitionEndListener);
      updateTransitionEndListener(box, "add", listener);
      currentTransitionEndListener = listener;
    }
    function on(eventType, handler, options2) {
      if (options2 === void 0) {
        options2 = false;
      }
      var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
      nodes.forEach(function(node) {
        node.addEventListener(eventType, handler, options2);
        listeners.push({
          node,
          eventType,
          handler,
          options: options2
        });
      });
    }
    function addListeners() {
      if (getIsCustomTouchBehavior()) {
        on("touchstart", onTrigger2, {
          passive: true
        });
        on("touchend", onMouseLeave, {
          passive: true
        });
      }
      splitBySpaces(instance.props.trigger).forEach(function(eventType) {
        if (eventType === "manual") {
          return;
        }
        on(eventType, onTrigger2);
        switch (eventType) {
          case "mouseenter":
            on("mouseleave", onMouseLeave);
            break;
          case "focus":
            on(isIE11 ? "focusout" : "blur", onBlurOrFocusOut);
            break;
          case "focusin":
            on("focusout", onBlurOrFocusOut);
            break;
        }
      });
    }
    function removeListeners() {
      listeners.forEach(function(_ref) {
        var node = _ref.node, eventType = _ref.eventType, handler = _ref.handler, options2 = _ref.options;
        node.removeEventListener(eventType, handler, options2);
      });
      listeners = [];
    }
    function onTrigger2(event) {
      var _lastTriggerEvent;
      var shouldScheduleClickHide = false;
      if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
        return;
      }
      var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === "focus";
      lastTriggerEvent = event;
      currentTarget = event.currentTarget;
      handleAriaExpandedAttribute();
      if (!instance.state.isVisible && isMouseEvent(event)) {
        mouseMoveListeners.forEach(function(listener) {
          return listener(event);
        });
      }
      if (event.type === "click" && (instance.props.trigger.indexOf("mouseenter") < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {
        shouldScheduleClickHide = true;
      } else {
        scheduleShow(event);
      }
      if (event.type === "click") {
        isVisibleFromClick = !shouldScheduleClickHide;
      }
      if (shouldScheduleClickHide && !wasFocused) {
        scheduleHide(event);
      }
    }
    function onMouseMove(event) {
      var target = event.target;
      var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper2.contains(target);
      if (event.type === "mousemove" && isCursorOverReferenceOrPopper) {
        return;
      }
      var popperTreeData = getNestedPopperTree().concat(popper2).map(function(popper3) {
        var _instance$popperInsta;
        var instance2 = popper3._tippy;
        var state2 = (_instance$popperInsta = instance2.popperInstance) == null ? void 0 : _instance$popperInsta.state;
        if (state2) {
          return {
            popperRect: popper3.getBoundingClientRect(),
            popperState: state2,
            props
          };
        }
        return null;
      }).filter(Boolean);
      if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
        cleanupInteractiveMouseListeners();
        scheduleHide(event);
      }
    }
    function onMouseLeave(event) {
      var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf("click") >= 0 && isVisibleFromClick;
      if (shouldBail) {
        return;
      }
      if (instance.props.interactive) {
        instance.hideWithInteractivity(event);
        return;
      }
      scheduleHide(event);
    }
    function onBlurOrFocusOut(event) {
      if (instance.props.trigger.indexOf("focusin") < 0 && event.target !== getCurrentTarget()) {
        return;
      }
      if (instance.props.interactive && event.relatedTarget && popper2.contains(event.relatedTarget)) {
        return;
      }
      scheduleHide(event);
    }
    function isEventListenerStopped(event) {
      return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf("touch") >= 0 : false;
    }
    function createPopperInstance() {
      destroyPopperInstance();
      var _instance$props2 = instance.props, popperOptions = _instance$props2.popperOptions, placement = _instance$props2.placement, offset2 = _instance$props2.offset, getReferenceClientRect = _instance$props2.getReferenceClientRect, moveTransition = _instance$props2.moveTransition;
      var arrow2 = getIsDefaultRenderFn() ? getChildren(popper2).arrow : null;
      var computedReference = getReferenceClientRect ? {
        getBoundingClientRect: getReferenceClientRect,
        contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
      } : reference2;
      var tippyModifier = {
        name: "$$tippy",
        enabled: true,
        phase: "beforeWrite",
        requires: ["computeStyles"],
        fn: function fn2(_ref2) {
          var state2 = _ref2.state;
          if (getIsDefaultRenderFn()) {
            var _getDefaultTemplateCh = getDefaultTemplateChildren(), box = _getDefaultTemplateCh.box;
            ["placement", "reference-hidden", "escaped"].forEach(function(attr) {
              if (attr === "placement") {
                box.setAttribute("data-placement", state2.placement);
              } else {
                if (state2.attributes.popper["data-popper-" + attr]) {
                  box.setAttribute("data-" + attr, "");
                } else {
                  box.removeAttribute("data-" + attr);
                }
              }
            });
            state2.attributes.popper = {};
          }
        }
      };
      var modifiers = [{
        name: "offset",
        options: {
          offset: offset2
        }
      }, {
        name: "preventOverflow",
        options: {
          padding: {
            top: 2,
            bottom: 2,
            left: 5,
            right: 5
          }
        }
      }, {
        name: "flip",
        options: {
          padding: 5
        }
      }, {
        name: "computeStyles",
        options: {
          adaptive: !moveTransition
        }
      }, tippyModifier];
      if (getIsDefaultRenderFn() && arrow2) {
        modifiers.push({
          name: "arrow",
          options: {
            element: arrow2,
            padding: 3
          }
        });
      }
      modifiers.push.apply(modifiers, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
      instance.popperInstance = createPopper(computedReference, popper2, Object.assign({}, popperOptions, {
        placement,
        onFirstUpdate,
        modifiers
      }));
    }
    function destroyPopperInstance() {
      if (instance.popperInstance) {
        instance.popperInstance.destroy();
        instance.popperInstance = null;
      }
    }
    function mount() {
      var appendTo = instance.props.appendTo;
      var parentNode;
      var node = getCurrentTarget();
      if (instance.props.interactive && appendTo === TIPPY_DEFAULT_APPEND_TO || appendTo === "parent") {
        parentNode = node.parentNode;
      } else {
        parentNode = invokeWithArgsOrReturn(appendTo, [node]);
      }
      if (!parentNode.contains(popper2)) {
        parentNode.appendChild(popper2);
      }
      instance.state.isMounted = true;
      createPopperInstance();
      if (true) {
        warnWhen(instance.props.interactive && appendTo === defaultProps.appendTo && node.nextElementSibling !== popper2, ["Interactive tippy element may not be accessible via keyboard", "navigation because it is not directly after the reference element", "in the DOM source order.", "\n\n", "Using a wrapper <div> or <span> tag around the reference element", "solves this by creating a new parentNode context.", "\n\n", "Specifying `appendTo: document.body` silences this warning, but it", "assumes you are using a focus management solution to handle", "keyboard navigation.", "\n\n", "See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity"].join(" "));
      }
    }
    function getNestedPopperTree() {
      return arrayFrom(popper2.querySelectorAll("[data-tippy-root]"));
    }
    function scheduleShow(event) {
      instance.clearDelayTimeouts();
      if (event) {
        invokeHook("onTrigger", [instance, event]);
      }
      addDocumentPress();
      var delay = getDelay(true);
      var _getNormalizedTouchSe = getNormalizedTouchSettings(), touchValue = _getNormalizedTouchSe[0], touchDelay = _getNormalizedTouchSe[1];
      if (currentInput.isTouch && touchValue === "hold" && touchDelay) {
        delay = touchDelay;
      }
      if (delay) {
        showTimeout = setTimeout(function() {
          instance.show();
        }, delay);
      } else {
        instance.show();
      }
    }
    function scheduleHide(event) {
      instance.clearDelayTimeouts();
      invokeHook("onUntrigger", [instance, event]);
      if (!instance.state.isVisible) {
        removeDocumentPress();
        return;
      }
      if (instance.props.trigger.indexOf("mouseenter") >= 0 && instance.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(event.type) >= 0 && isVisibleFromClick) {
        return;
      }
      var delay = getDelay(false);
      if (delay) {
        hideTimeout = setTimeout(function() {
          if (instance.state.isVisible) {
            instance.hide();
          }
        }, delay);
      } else {
        scheduleHideAnimationFrame = requestAnimationFrame(function() {
          instance.hide();
        });
      }
    }
    function enable() {
      instance.state.isEnabled = true;
    }
    function disable() {
      instance.hide();
      instance.state.isEnabled = false;
    }
    function clearDelayTimeouts() {
      clearTimeout(showTimeout);
      clearTimeout(hideTimeout);
      cancelAnimationFrame(scheduleHideAnimationFrame);
    }
    function setProps(partialProps) {
      if (true) {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("setProps"));
      }
      if (instance.state.isDestroyed) {
        return;
      }
      invokeHook("onBeforeUpdate", [instance, partialProps]);
      removeListeners();
      var prevProps = instance.props;
      var nextProps = evaluateProps(reference2, Object.assign({}, prevProps, removeUndefinedProps(partialProps), {
        ignoreAttributes: true
      }));
      instance.props = nextProps;
      addListeners();
      if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
        cleanupInteractiveMouseListeners();
        debouncedOnMouseMove = debounce3(onMouseMove, nextProps.interactiveDebounce);
      }
      if (prevProps.triggerTarget && !nextProps.triggerTarget) {
        normalizeToArray(prevProps.triggerTarget).forEach(function(node) {
          node.removeAttribute("aria-expanded");
        });
      } else if (nextProps.triggerTarget) {
        reference2.removeAttribute("aria-expanded");
      }
      handleAriaExpandedAttribute();
      handleStyles();
      if (onUpdate) {
        onUpdate(prevProps, nextProps);
      }
      if (instance.popperInstance) {
        createPopperInstance();
        getNestedPopperTree().forEach(function(nestedPopper) {
          requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
        });
      }
      invokeHook("onAfterUpdate", [instance, partialProps]);
    }
    function setContent2(content) {
      instance.setProps({
        content
      });
    }
    function show() {
      if (true) {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("show"));
      }
      var isAlreadyVisible = instance.state.isVisible;
      var isDestroyed = instance.state.isDestroyed;
      var isDisabled = !instance.state.isEnabled;
      var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;
      var duration2 = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);
      if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
        return;
      }
      if (getCurrentTarget().hasAttribute("disabled")) {
        return;
      }
      invokeHook("onShow", [instance], false);
      if (instance.props.onShow(instance) === false) {
        return;
      }
      instance.state.isVisible = true;
      if (getIsDefaultRenderFn()) {
        popper2.style.visibility = "visible";
      }
      handleStyles();
      addDocumentPress();
      if (!instance.state.isMounted) {
        popper2.style.transition = "none";
      }
      if (getIsDefaultRenderFn()) {
        var _getDefaultTemplateCh2 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh2.box, content = _getDefaultTemplateCh2.content;
        setTransitionDuration([box, content], 0);
      }
      onFirstUpdate = function onFirstUpdate2() {
        var _instance$popperInsta2;
        if (!instance.state.isVisible || ignoreOnFirstUpdate) {
          return;
        }
        ignoreOnFirstUpdate = true;
        void popper2.offsetHeight;
        popper2.style.transition = instance.props.moveTransition;
        if (getIsDefaultRenderFn() && instance.props.animation) {
          var _getDefaultTemplateCh3 = getDefaultTemplateChildren(), _box = _getDefaultTemplateCh3.box, _content = _getDefaultTemplateCh3.content;
          setTransitionDuration([_box, _content], duration2);
          setVisibilityState([_box, _content], "visible");
        }
        handleAriaContentAttribute();
        handleAriaExpandedAttribute();
        pushIfUnique(mountedInstances, instance);
        (_instance$popperInsta2 = instance.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();
        invokeHook("onMount", [instance]);
        if (instance.props.animation && getIsDefaultRenderFn()) {
          onTransitionedIn(duration2, function() {
            instance.state.isShown = true;
            invokeHook("onShown", [instance]);
          });
        }
      };
      mount();
    }
    function hide2() {
      if (true) {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("hide"));
      }
      var isAlreadyHidden = !instance.state.isVisible;
      var isDestroyed = instance.state.isDestroyed;
      var isDisabled = !instance.state.isEnabled;
      var duration2 = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);
      if (isAlreadyHidden || isDestroyed || isDisabled) {
        return;
      }
      invokeHook("onHide", [instance], false);
      if (instance.props.onHide(instance) === false) {
        return;
      }
      instance.state.isVisible = false;
      instance.state.isShown = false;
      ignoreOnFirstUpdate = false;
      isVisibleFromClick = false;
      if (getIsDefaultRenderFn()) {
        popper2.style.visibility = "hidden";
      }
      cleanupInteractiveMouseListeners();
      removeDocumentPress();
      handleStyles(true);
      if (getIsDefaultRenderFn()) {
        var _getDefaultTemplateCh4 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh4.box, content = _getDefaultTemplateCh4.content;
        if (instance.props.animation) {
          setTransitionDuration([box, content], duration2);
          setVisibilityState([box, content], "hidden");
        }
      }
      handleAriaContentAttribute();
      handleAriaExpandedAttribute();
      if (instance.props.animation) {
        if (getIsDefaultRenderFn()) {
          onTransitionedOut(duration2, instance.unmount);
        }
      } else {
        instance.unmount();
      }
    }
    function hideWithInteractivity(event) {
      if (true) {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("hideWithInteractivity"));
      }
      getDocument().addEventListener("mousemove", debouncedOnMouseMove);
      pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
      debouncedOnMouseMove(event);
    }
    function unmount() {
      if (true) {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("unmount"));
      }
      if (instance.state.isVisible) {
        instance.hide();
      }
      if (!instance.state.isMounted) {
        return;
      }
      destroyPopperInstance();
      getNestedPopperTree().forEach(function(nestedPopper) {
        nestedPopper._tippy.unmount();
      });
      if (popper2.parentNode) {
        popper2.parentNode.removeChild(popper2);
      }
      mountedInstances = mountedInstances.filter(function(i3) {
        return i3 !== instance;
      });
      instance.state.isMounted = false;
      invokeHook("onHidden", [instance]);
    }
    function destroy6() {
      if (true) {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("destroy"));
      }
      if (instance.state.isDestroyed) {
        return;
      }
      instance.clearDelayTimeouts();
      instance.unmount();
      removeListeners();
      delete reference2._tippy;
      instance.state.isDestroyed = true;
      invokeHook("onDestroy", [instance]);
    }
  }
  function tippy(targets, optionalProps) {
    if (optionalProps === void 0) {
      optionalProps = {};
    }
    var plugins2 = defaultProps.plugins.concat(optionalProps.plugins || []);
    if (true) {
      validateTargets(targets);
      validateProps(optionalProps, plugins2);
    }
    bindGlobalEventListeners();
    var passedProps = Object.assign({}, optionalProps, {
      plugins: plugins2
    });
    var elements3 = getArrayOfElements(targets);
    if (true) {
      var isSingleContentElement = isElement2(passedProps.content);
      var isMoreThanOneReferenceElement = elements3.length > 1;
      warnWhen(isSingleContentElement && isMoreThanOneReferenceElement, ["tippy() was passed an Element as the `content` prop, but more than", "one tippy instance was created by this invocation. This means the", "content element will only be appended to the last tippy instance.", "\n\n", "Instead, pass the .innerHTML of the element, or use a function that", "returns a cloned version of the element instead.", "\n\n", "1) content: element.innerHTML\n", "2) content: () => element.cloneNode(true)"].join(" "));
    }
    var instances2 = elements3.reduce(function(acc, reference2) {
      var instance = reference2 && createTippy(reference2, passedProps);
      if (instance) {
        acc.push(instance);
      }
      return acc;
    }, []);
    return isElement2(targets) ? instances2[0] : instances2;
  }
  tippy.defaultProps = defaultProps;
  tippy.setDefaultProps = setDefaultProps;
  tippy.currentInput = currentInput;
  var applyStylesModifier = Object.assign({}, applyStyles_default, {
    effect: function effect4(_ref) {
      var state = _ref.state;
      var initialStyles = {
        popper: {
          position: state.options.strategy,
          left: "0",
          top: "0",
          margin: "0"
        },
        arrow: {
          position: "absolute"
        },
        reference: {}
      };
      Object.assign(state.elements.popper.style, initialStyles.popper);
      state.styles = initialStyles;
      if (state.elements.arrow) {
        Object.assign(state.elements.arrow.style, initialStyles.arrow);
      }
    }
  });
  tippy.setDefaultProps({
    render
  });
  var tippy_esm_default = tippy;

  // controllers/clipboard_controller.js
  var clipboard_controller_default = class extends Controller {
    connect() {
      this.clipboard = new import_clipboard.default(this.element);
      this.clipboard.on("success", (e3) => this.tooltip(this.successMessage));
      this.clipboard.on("error", (e3) => this.tooltip(this.errorMessage));
    }
    tooltip(message) {
      tippy_esm_default(this.element, {
        content: message,
        showOnCreate: true,
        onHidden: (instance) => {
          instance.destroy();
        }
      });
    }
    get successMessage() {
      return this.successMessageValue || "Copied!";
    }
    get errorMessage() {
      return this.errorMessageValue || "Failed!";
    }
  };
  __publicField(clipboard_controller_default, "values", {
    successMessage: String,
    errorMessage: String
  });

  // controllers/mentions_controller.js
  var mentions_controller_exports = {};
  __export(mentions_controller_exports, {
    default: () => mentions_controller_default
  });
  var import_tributejs = __toESM(require_tribute_min());
  var import_trix = __toESM(require_trix());
  var mentions_controller_default = class extends Controller {
    connect() {
      this.editor = this.fieldTarget.editor;
      this.initializeTribute();
    }
    initializeTribute() {
      this.tribute = new import_tributejs.default({
        allowSpaces: true,
        lookup: "name",
        values: this.fetchUsers,
        menuShowMinLength: 1
      });
      this.tribute.attach(this.fieldTarget);
      this.fieldTarget.addEventListener("tribute-replaced", this.replaced);
      this.tribute.range.pasteHtml = this._pasteHtml.bind(this);
    }
    disconnect() {
      this.tribute.detach(this.fieldTarget);
    }
    fetchUsers(text, callback2) {
      fetch(`/users/mentions.json?query=${text}`).then((response) => response.json()).then((users) => callback2(users)).catch((error2) => callback2([]));
    }
    replaced(e3) {
      let mention = e3.detail.item.original;
      let attachment = new import_trix.default.Attachment({
        content: mention.content,
        sgid: mention.sgid
      });
      this.editor.insertAttachment(attachment);
      this.editor.insertString(" ");
    }
    _pasteHtml(html, startPos, endPos) {
      let range = this.editor.getSelectedRange();
      let position = range[0];
      let length = endPos - startPos;
      this.editor.setSelectedRange([position - length, position]);
      this.editor.deleteInDirection("backward");
    }
  };
  __publicField(mentions_controller_default, "targets", ["field"]);

  // controllers/notifications_controller.js
  var notifications_controller_exports = {};
  __export(notifications_controller_exports, {
    default: () => notifications_controller_default
  });
  var notifications_controller_default = class extends Controller {
    connect() {
      this.subscription = consumer_default.subscriptions.create({ channel: "NotificationChannel" }, {
        connected: this._connected.bind(this),
        disconnected: this._disconnected.bind(this),
        received: this._received.bind(this)
      });
      if (this.hasUnread())
        this.showUnreadBadge();
    }
    disconnect() {
      this.subscription.unsubscribe();
    }
    _connected() {
    }
    _disconnected() {
    }
    _received(data) {
      this.totalUnreadValue += 1;
      if (data.account_id && data.account_id == this.accountIdValue) {
        this.accountUnreadValue += 1;
      }
      if (data.account_id && data.account_id != this.accountIdValue) {
        return;
      }
      if (data.html) {
        this.listTarget.insertAdjacentHTML("afterbegin", data.html);
        this.showUnreadBadge();
      }
      if (data.browser) {
        this.checkPermissionAndNotify(data.browser);
      }
    }
    open() {
      this.hideUnreadBadge();
      this.markAllAsRead();
    }
    hasUnread() {
      return !!this.accountUnreadValue;
    }
    showUnreadBadge() {
      if (this.hasBadgeTarget == false) {
        return;
      }
      this.badgeTarget.classList.remove("hidden");
    }
    hideUnreadBadge() {
      if (this.hasBadgeTarget == false) {
        return;
      }
      this.badgeTarget.classList.add("hidden");
    }
    markAllAsRead() {
      let ids = this.notificationTargets.map((target) => target.dataset.id);
      this.subscription.perform("mark_as_read", { ids });
      this.accountUnreadValue = 0;
      this.totalUnreadValue -= ids.length;
    }
    markAsInteracted(event) {
      let id = event.currentTarget.dataset.id;
      if (id == null)
        return;
      this.subscription.perform("mark_as_interacted", { ids: [id] });
    }
    checkPermissionAndNotify(data) {
      if (!("Notification" in window))
        return;
      if (Notification.permission === "granted") {
        this.browserNotification(data);
      } else if (Notification.permission !== "denied") {
        Notification.requestPermission().then((permission) => {
          if (permission === "granted") {
            this.browserNotification(data);
          }
        });
      }
    }
    browserNotification(data) {
      new Notification(data.title, data.options);
    }
    totalUnreadValueChanged() {
      this.syncCountToNative();
    }
    accountUnreadValueChanged() {
      this.syncCountToNative();
    }
    syncCountToNative() {
      window.TurboNativeBridge.setNotificationCount(this.totalUnreadValue, this.accountUnreadValue);
    }
  };
  __publicField(notifications_controller_default, "targets", ["badge", "list", "placeholder", "notification"]);
  __publicField(notifications_controller_default, "values", {
    accountId: String,
    accountUnread: Number,
    totalUnread: Number
  });

  // controllers/paddle_controller.js
  var paddle_controller_exports = {};
  __export(paddle_controller_exports, {
    default: () => paddle_controller_default
  });
  var paddle_controller_default = class extends Controller {
    connect() {
      let params = {
        method: "inline",
        allowQuantity: false,
        disableLogout: true,
        frameTarget: "paddle-checkout",
        frameInitialHeight: 416,
        frameStyle: "width:100%; background-color: transparent; border: none;",
        successCallback: this.checkoutComplete.bind(this)
      };
      if (this.data.get("action") == "create-subscription") {
        Paddle.Checkout.open({
          ...params,
          product: this.data.get("product"),
          email: this.data.get("email"),
          passthrough: this.data.get("passthrough")
        });
      } else if (this.data.get("action") == "update-payment-details") {
        Paddle.Checkout.open({
          ...params,
          override: this.data.get("update-url")
        });
      }
    }
    checkoutComplete(data) {
      this.addHiddenField("processor", "paddle");
      Rails.fire(this.formTarget, "submit");
    }
    addHiddenField(name2, value) {
      let hiddenInput = document.createElement("input");
      hiddenInput.setAttribute("type", "hidden");
      hiddenInput.setAttribute("name", name2);
      hiddenInput.setAttribute("value", value);
      this.formTarget.appendChild(hiddenInput);
    }
  };
  __publicField(paddle_controller_default, "targets", ["form"]);

  // controllers/paypal_controller.js
  var paypal_controller_exports = {};
  __export(paypal_controller_exports, {
    default: () => paypal_controller_default
  });
  var paypal_controller_default = class extends Controller {
    connect() {
      braintree.client.create({
        authorization: this.data.get("clientToken")
      }, this.clientCreated.bind(this));
    }
    disconnect() {
      this.buttonTarget.querySelector(".paypal-button").remove();
    }
    clientCreated(error2, clientInstance) {
      if (error2) {
        console.error("Error creating client", error2);
        return;
      }
      braintree.paypalCheckout.create({
        client: clientInstance
      }, this.paypalCreated.bind(this));
    }
    paypalCreated(paypalCheckoutErr, paypalCheckoutInstance) {
      if (paypalCheckoutErr) {
        console.error("Error creating PayPal Checkout:", paypalCheckoutErr);
        return;
      }
      paypal.Button.render({
        env: this.data.get("env"),
        style: {
          color: "gold",
          shape: "rect",
          size: "medium",
          label: "pay",
          tagline: false
        },
        payment: () => {
          return paypalCheckoutInstance.createPayment({
            flow: "vault"
          });
        },
        onAuthorize: (data, actions) => {
          return paypalCheckoutInstance.tokenizePayment(data, this.paymentMethod.bind(this));
        },
        onCancel: (data) => {
          console.log("checkout.js payment cancelled", JSON.stringify(data, 0, 2));
        },
        onError: (err) => {
          console.error("checkout.js error", err);
        }
      }, this.buttonTarget).then(() => {
      });
    }
    paymentMethod(error2, payload) {
      if (error2) {
        console.error("Error with payment method:", error2);
        return;
      }
      this.addHiddenField("processor", "braintree");
      this.addHiddenField("payment_method_token", payload.nonce);
      Rails.fire(this.formTarget, "submit");
    }
    addHiddenField(name2, value) {
      let hiddenInput = document.createElement("input");
      hiddenInput.setAttribute("type", "hidden");
      hiddenInput.setAttribute("name", name2);
      hiddenInput.setAttribute("value", value);
      this.formTarget.appendChild(hiddenInput);
    }
  };
  __publicField(paypal_controller_default, "targets", ["button", "form"]);

  // controllers/pricing_controller.js
  var pricing_controller_exports = {};
  __export(pricing_controller_exports, {
    default: () => pricing_controller_default
  });
  var pricing_controller_default = class extends Controller {
    connect() {
      this.activeFrequencyClass = (this.data.get("active-frequency-class") || "bg-white shadow-sm text-black hover:text-black").split(" ");
      this.inactiveFrequencyClass = (this.data.get("inactive-frequency-class") || "hover:text-gray-900").split(" ");
      this.activePlansClass = (this.data.get("activePlansClass") || "flex").split(" ");
      this.inactivePlansClass = (this.data.get("inactivePlansClass") || "hidden").split(" ");
      this.frequencyTargets.forEach((target) => {
        let frequency2 = target.dataset.frequency;
        let index2 = this.plansTargets.findIndex((element) => element.dataset.frequency == frequency2 && element.childElementCount > 0);
        if (index2 == -1)
          target.remove();
      });
      if (this.frequencyTargets.length < 2)
        this._hideFrequencyToggle();
      let frequency = this.data.get("active") || this.frequencyTargets[0].dataset.frequency;
      this._toggle(frequency);
    }
    switch(event) {
      event.preventDefault();
      this._toggle(event.target.dataset.frequency);
    }
    _hideFrequencyToggle() {
      this.toggleTarget.classList.add("hidden");
    }
    _toggle(frequency) {
      this.data.set("active", frequency);
      this.frequencyTargets.forEach((target) => {
        if (target.dataset.frequency == frequency) {
          this.showFrequency(target);
        } else {
          this.hideFrequency(target);
        }
      });
      this.plansTargets.forEach((target) => {
        if (target.dataset.frequency == frequency) {
          this.showPlans(target);
        } else {
          this.hidePlans(target);
        }
      });
    }
    showFrequency(element) {
      element.classList.add(...this.activeFrequencyClass);
      element.classList.remove(...this.inactiveFrequencyClass);
    }
    hideFrequency(element) {
      element.classList.remove(...this.activeFrequencyClass);
      element.classList.add(...this.inactiveFrequencyClass);
    }
    showPlans(element) {
      element.classList.add(...this.activePlansClass);
      element.classList.remove(...this.inactivePlansClass);
    }
    hidePlans(element) {
      element.classList.remove(...this.activePlansClass);
      element.classList.add(...this.inactivePlansClass);
    }
  };
  __publicField(pricing_controller_default, "targets", ["toggle", "frequency", "plans"]);

  // controllers/select_controller.js
  var select_controller_exports = {};
  __export(select_controller_exports, {
    default: () => select_controller_default
  });

  // ../../node_modules/slim-select/dist/slimselect.min.mjs
  var exports = {};
  !function(e3, t2) {
    typeof exports == "object" && typeof module == "object" ? module.exports = t2() : typeof define == "function" && define.amd ? define([], t2) : typeof exports == "object" ? exports.SlimSelect = t2() : e3.SlimSelect = t2();
  }(window, function() {
    return n2 = {}, s4.m = i3 = [function(e3, t2, i4) {
      "use strict";
      function n3(e4, t3) {
        t3 = t3 || { bubbles: false, cancelable: false, detail: void 0 };
        var i5 = document.createEvent("CustomEvent");
        return i5.initCustomEvent(e4, t3.bubbles, t3.cancelable, t3.detail), i5;
      }
      t2.__esModule = true, t2.kebabCase = t2.highlight = t2.isValueInArrayOfObjects = t2.debounce = t2.putContent = t2.ensureElementInView = t2.hasClassInTree = void 0, t2.hasClassInTree = function(e4, t3) {
        function n4(e5, t4) {
          return t4 && e5 && e5.classList && e5.classList.contains(t4) ? e5 : null;
        }
        return n4(e4, t3) || function e5(t4, i5) {
          return t4 && t4 !== document ? n4(t4, i5) ? t4 : e5(t4.parentNode, i5) : null;
        }(e4, t3);
      }, t2.ensureElementInView = function(e4, t3) {
        var i5 = e4.scrollTop + e4.offsetTop, n4 = i5 + e4.clientHeight, s5 = t3.offsetTop, t3 = s5 + t3.clientHeight;
        s5 < i5 ? e4.scrollTop -= i5 - s5 : n4 < t3 && (e4.scrollTop += t3 - n4);
      }, t2.putContent = function(e4, t3, i5) {
        var n4 = e4.offsetHeight, s5 = e4.getBoundingClientRect(), e4 = i5 ? s5.top : s5.top - n4, n4 = i5 ? s5.bottom : s5.bottom + n4;
        return e4 <= 0 ? "below" : n4 >= window.innerHeight ? "above" : i5 ? t3 : "below";
      }, t2.debounce = function(s5, a4, o2) {
        var l2;
        return a4 === void 0 && (a4 = 100), o2 === void 0 && (o2 = false), function() {
          for (var e4 = [], t3 = 0; t3 < arguments.length; t3++)
            e4[t3] = arguments[t3];
          var i5 = self, n4 = o2 && !l2;
          clearTimeout(l2), l2 = setTimeout(function() {
            l2 = null, o2 || s5.apply(i5, e4);
          }, a4), n4 && s5.apply(i5, e4);
        };
      }, t2.isValueInArrayOfObjects = function(e4, t3, i5) {
        if (!Array.isArray(e4))
          return e4[t3] === i5;
        for (var n4 = 0, s5 = e4; n4 < s5.length; n4++) {
          var a4 = s5[n4];
          if (a4 && a4[t3] && a4[t3] === i5)
            return true;
        }
        return false;
      }, t2.highlight = function(e4, t3, i5) {
        var n4 = e4, s5 = new RegExp("(" + t3.trim() + ")(?![^<]*>[^<>]*</)", "i");
        if (!e4.match(s5))
          return e4;
        var a4 = e4.match(s5).index, t3 = a4 + e4.match(s5)[0].toString().length, t3 = e4.substring(a4, t3);
        return n4 = n4.replace(s5, '<mark class="'.concat(i5, '">').concat(t3, "</mark>"));
      }, t2.kebabCase = function(e4) {
        var t3 = e4.replace(/[A-Z\u00C0-\u00D6\u00D8-\u00DE]/g, function(e5) {
          return "-" + e5.toLowerCase();
        });
        return e4[0] === e4[0].toUpperCase() ? t3.substring(1) : t3;
      }, typeof (t2 = window).CustomEvent != "function" && (n3.prototype = t2.Event.prototype, t2.CustomEvent = n3);
    }, function(e3, t2, i4) {
      "use strict";
      t2.__esModule = true, t2.validateOption = t2.validateData = t2.Data = void 0;
      var n3 = (s5.prototype.newOption = function(e4) {
        return { id: e4.id || String(Math.floor(1e8 * Math.random())), value: e4.value || "", text: e4.text || "", innerHTML: e4.innerHTML || "", selected: e4.selected || false, display: e4.display === void 0 || e4.display, disabled: e4.disabled || false, placeholder: e4.placeholder || false, class: e4.class || void 0, data: e4.data || {}, mandatory: e4.mandatory || false };
      }, s5.prototype.add = function(e4) {
        this.data.push({ id: String(Math.floor(1e8 * Math.random())), value: e4.value, text: e4.text, innerHTML: "", selected: false, display: true, disabled: false, placeholder: false, class: void 0, mandatory: e4.mandatory, data: {} });
      }, s5.prototype.parseSelectData = function() {
        this.data = [];
        for (var e4 = 0, t3 = this.main.select.element.childNodes; e4 < t3.length; e4++) {
          var i5 = t3[e4];
          if (i5.nodeName === "OPTGROUP") {
            for (var n4 = { label: i5.label, options: [] }, s6 = 0, a4 = i5.childNodes; s6 < a4.length; s6++) {
              var o2, l2 = a4[s6];
              l2.nodeName === "OPTION" && (o2 = this.pullOptionData(l2), n4.options.push(o2), o2.placeholder && o2.text.trim() !== "" && (this.main.config.placeholderText = o2.text));
            }
            this.data.push(n4);
          } else
            i5.nodeName === "OPTION" && (o2 = this.pullOptionData(i5), this.data.push(o2), o2.placeholder && o2.text.trim() !== "" && (this.main.config.placeholderText = o2.text));
        }
      }, s5.prototype.pullOptionData = function(e4) {
        return { id: !!e4.dataset && e4.dataset.id || String(Math.floor(1e8 * Math.random())), value: e4.value, text: e4.text, innerHTML: e4.innerHTML, selected: e4.selected, disabled: e4.disabled, placeholder: e4.dataset.placeholder === "true", class: e4.className, style: e4.style.cssText, data: e4.dataset, mandatory: !!e4.dataset && e4.dataset.mandatory === "true" };
      }, s5.prototype.setSelectedFromSelect = function() {
        if (this.main.config.isMultiple) {
          for (var e4 = [], t3 = 0, i5 = this.main.select.element.options; t3 < i5.length; t3++) {
            var n4 = i5[t3];
            !n4.selected || (n4 = this.getObjectFromData(n4.value, "value")) && n4.id && e4.push(n4.id);
          }
          this.setSelected(e4, "id");
        } else {
          var s6 = this.main.select.element;
          s6.selectedIndex !== -1 && (s6 = s6.options[s6.selectedIndex].value, this.setSelected(s6, "value"));
        }
      }, s5.prototype.setSelected = function(e4, t3) {
        t3 === void 0 && (t3 = "id");
        for (var i5 = 0, n4 = this.data; i5 < n4.length; i5++) {
          var s6 = n4[i5];
          if (s6.hasOwnProperty("label")) {
            if (s6.hasOwnProperty("options")) {
              var a4 = s6.options;
              if (a4)
                for (var o2 = 0, l2 = a4; o2 < l2.length; o2++) {
                  var r3 = l2[o2];
                  r3.placeholder || (r3.selected = this.shouldBeSelected(r3, e4, t3));
                }
            }
          } else
            s6.selected = this.shouldBeSelected(s6, e4, t3);
        }
      }, s5.prototype.shouldBeSelected = function(e4, t3, i5) {
        if (i5 === void 0 && (i5 = "id"), Array.isArray(t3))
          for (var n4 = 0, s6 = t3; n4 < s6.length; n4++) {
            var a4 = s6[n4];
            if (i5 in e4 && String(e4[i5]) === String(a4))
              return true;
          }
        else if (i5 in e4 && String(e4[i5]) === String(t3))
          return true;
        return false;
      }, s5.prototype.getSelected = function() {
        for (var e4 = { text: "", placeholder: this.main.config.placeholderText }, t3 = [], i5 = 0, n4 = this.data; i5 < n4.length; i5++) {
          var s6 = n4[i5];
          if (s6.hasOwnProperty("label")) {
            if (s6.hasOwnProperty("options")) {
              var a4 = s6.options;
              if (a4)
                for (var o2 = 0, l2 = a4; o2 < l2.length; o2++) {
                  var r3 = l2[o2];
                  r3.selected && (this.main.config.isMultiple ? t3.push(r3) : e4 = r3);
                }
            }
          } else
            s6.selected && (this.main.config.isMultiple ? t3.push(s6) : e4 = s6);
        }
        return this.main.config.isMultiple ? t3 : e4;
      }, s5.prototype.addToSelected = function(e4, t3) {
        if (t3 === void 0 && (t3 = "id"), this.main.config.isMultiple) {
          var i5 = [], n4 = this.getSelected();
          if (Array.isArray(n4))
            for (var s6 = 0, a4 = n4; s6 < a4.length; s6++) {
              var o2 = a4[s6];
              i5.push(o2[t3]);
            }
          i5.push(e4), this.setSelected(i5, t3);
        }
      }, s5.prototype.removeFromSelected = function(e4, t3) {
        if (t3 === void 0 && (t3 = "id"), this.main.config.isMultiple) {
          for (var i5 = [], n4 = 0, s6 = this.getSelected(); n4 < s6.length; n4++) {
            var a4 = s6[n4];
            String(a4[t3]) !== String(e4) && i5.push(a4[t3]);
          }
          this.setSelected(i5, t3);
        }
      }, s5.prototype.onDataChange = function() {
        this.main.onChange && this.isOnChangeEnabled && this.main.onChange(JSON.parse(JSON.stringify(this.getSelected())));
      }, s5.prototype.getObjectFromData = function(e4, t3) {
        t3 === void 0 && (t3 = "id");
        for (var i5 = 0, n4 = this.data; i5 < n4.length; i5++) {
          var s6 = n4[i5];
          if (t3 in s6 && String(s6[t3]) === String(e4))
            return s6;
          if (s6.hasOwnProperty("options")) {
            if (s6.options)
              for (var a4 = 0, o2 = s6.options; a4 < o2.length; a4++) {
                var l2 = o2[a4];
                if (String(l2[t3]) === String(e4))
                  return l2;
              }
          }
        }
        return null;
      }, s5.prototype.search = function(n4) {
        var s6, e4;
        (this.searchValue = n4).trim() !== "" ? (s6 = this.main.config.searchFilter, e4 = this.data.slice(0), n4 = n4.trim(), e4 = e4.map(function(e5) {
          if (e5.hasOwnProperty("options")) {
            var t3 = e5, i5 = [];
            if ((i5 = t3.options ? t3.options.filter(function(e6) {
              return s6(e6, n4);
            }) : i5).length !== 0) {
              t3 = Object.assign({}, t3);
              return t3.options = i5, t3;
            }
          }
          if (e5.hasOwnProperty("text") && s6(e5, n4))
            return e5;
          return null;
        }), this.filtered = e4.filter(function(e5) {
          return e5;
        })) : this.filtered = null;
      }, s5);
      function s5(e4) {
        this.contentOpen = false, this.contentPosition = "below", this.isOnChangeEnabled = true, this.main = e4.main, this.searchValue = "", this.data = [], this.filtered = null, this.parseSelectData(), this.setSelectedFromSelect();
      }
      function r2(e4) {
        return e4.text !== void 0 || (console.error("Data object option must have at least have a text value. Check object: " + JSON.stringify(e4)), false);
      }
      t2.Data = n3, t2.validateData = function(e4) {
        if (!e4)
          return console.error("Data must be an array of objects"), false;
        for (var t3 = 0, i5 = 0, n4 = e4; i5 < n4.length; i5++) {
          var s6 = n4[i5];
          if (s6.hasOwnProperty("label")) {
            if (s6.hasOwnProperty("options")) {
              var a4 = s6.options;
              if (a4)
                for (var o2 = 0, l2 = a4; o2 < l2.length; o2++)
                  r2(l2[o2]) || t3++;
            }
          } else
            r2(s6) || t3++;
        }
        return t3 === 0;
      }, t2.validateOption = r2;
    }, function(e3, t2, i4) {
      "use strict";
      t2.__esModule = true;
      var n3 = i4(3), s5 = i4(4), a4 = i4(5), r2 = i4(1), o2 = i4(0), i4 = (l2.prototype.validate = function(e4) {
        e4 = typeof e4.select == "string" ? document.querySelector(e4.select) : e4.select;
        if (!e4)
          throw new Error("Could not find select element");
        if (e4.tagName !== "SELECT")
          throw new Error("Element isnt of type select");
        return e4;
      }, l2.prototype.selected = function() {
        if (this.config.isMultiple) {
          for (var e4 = [], t3 = 0, i5 = s6 = this.data.getSelected(); t3 < i5.length; t3++) {
            var n4 = i5[t3];
            e4.push(n4.value);
          }
          return e4;
        }
        var s6;
        return (s6 = this.data.getSelected()) ? s6.value : "";
      }, l2.prototype.set = function(e4, t3, i5, n4) {
        t3 === void 0 && (t3 = "value"), i5 === void 0 && (i5 = true), n4 === void 0 && (n4 = true), this.config.isMultiple && !Array.isArray(e4) ? this.data.addToSelected(e4, t3) : this.data.setSelected(e4, t3), this.select.setValue(), this.data.onDataChange(), this.render(), (i5 = this.config.hideSelectedOption && this.config.isMultiple && this.data.getSelected().length === this.data.data.length ? true : i5) && this.close();
      }, l2.prototype.setSelected = function(e4, t3, i5, n4) {
        this.set(e4, t3 = t3 === void 0 ? "value" : t3, i5 = i5 === void 0 ? true : i5, n4 = n4 === void 0 ? true : n4);
      }, l2.prototype.setData = function(e4) {
        if ((0, r2.validateData)(e4)) {
          for (var t3 = JSON.parse(JSON.stringify(e4)), i5 = this.data.getSelected(), n4 = 0; n4 < t3.length; n4++)
            t3[n4].value || t3[n4].placeholder || (t3[n4].value = t3[n4].text);
          if (this.config.isAjax && i5)
            if (this.config.isMultiple)
              for (var s6 = 0, a5 = i5.reverse(); s6 < a5.length; s6++) {
                var o3 = a5[s6];
                t3.unshift(o3);
              }
            else {
              t3.unshift(i5);
              for (n4 = 0; n4 < t3.length; n4++)
                t3[n4].placeholder || t3[n4].value !== i5.value || t3[n4].text !== i5.text || t3.splice(n4, 1);
              for (var l3 = false, n4 = 0; n4 < t3.length; n4++)
                t3[n4].placeholder && (l3 = true);
              l3 || t3.unshift({ text: "", placeholder: true });
            }
          this.select.create(t3), this.data.parseSelectData(), this.data.setSelectedFromSelect();
        } else
          console.error("Validation problem on: #" + this.select.element.id);
      }, l2.prototype.addData = function(e4) {
        (0, r2.validateData)([e4]) ? (this.data.add(this.data.newOption(e4)), this.select.create(this.data.data), this.data.parseSelectData(), this.data.setSelectedFromSelect(), this.render()) : console.error("Validation problem on: #" + this.select.element.id);
      }, l2.prototype.open = function() {
        var e4, t3 = this;
        this.config.isEnabled && (this.data.contentOpen || this.config.hideSelectedOption && this.config.isMultiple && this.data.getSelected().length === this.data.data.length || (this.beforeOpen && this.beforeOpen(), this.config.isMultiple && this.slim.multiSelected ? this.slim.multiSelected.plus.classList.add("ss-cross") : this.slim.singleSelected && (this.slim.singleSelected.arrowIcon.arrow.classList.remove("arrow-down"), this.slim.singleSelected.arrowIcon.arrow.classList.add("arrow-up")), this.slim[this.config.isMultiple ? "multiSelected" : "singleSelected"].container.classList.add(this.data.contentPosition === "above" ? this.config.openAbove : this.config.openBelow), this.config.addToBody && (e4 = this.slim.container.getBoundingClientRect(), this.slim.content.style.top = e4.top + e4.height + window.scrollY + "px", this.slim.content.style.left = e4.left + window.scrollX + "px", this.slim.content.style.width = e4.width + "px"), this.slim.content.classList.add(this.config.open), this.config.showContent.toLowerCase() === "up" || this.config.showContent.toLowerCase() !== "down" && (0, o2.putContent)(this.slim.content, this.data.contentPosition, this.data.contentOpen) === "above" ? this.moveContentAbove() : this.moveContentBelow(), this.config.isMultiple || (e4 = this.data.getSelected()) && (e4 = e4.id, (e4 = this.slim.list.querySelector('[data-id="' + e4 + '"]')) && (0, o2.ensureElementInView)(this.slim.list, e4)), setTimeout(function() {
          t3.data.contentOpen = true, t3.config.searchFocus && t3.slim.search.input.focus(), t3.afterOpen && t3.afterOpen();
        }, this.config.timeoutDelay)));
      }, l2.prototype.close = function() {
        var e4 = this;
        this.data.contentOpen && (this.beforeClose && this.beforeClose(), this.config.isMultiple && this.slim.multiSelected ? (this.slim.multiSelected.container.classList.remove(this.config.openAbove), this.slim.multiSelected.container.classList.remove(this.config.openBelow), this.slim.multiSelected.plus.classList.remove("ss-cross")) : this.slim.singleSelected && (this.slim.singleSelected.container.classList.remove(this.config.openAbove), this.slim.singleSelected.container.classList.remove(this.config.openBelow), this.slim.singleSelected.arrowIcon.arrow.classList.add("arrow-down"), this.slim.singleSelected.arrowIcon.arrow.classList.remove("arrow-up")), this.slim.content.classList.remove(this.config.open), this.data.contentOpen = false, this.search(""), setTimeout(function() {
          e4.slim.content.removeAttribute("style"), e4.data.contentPosition = "below", e4.config.isMultiple && e4.slim.multiSelected ? (e4.slim.multiSelected.container.classList.remove(e4.config.openAbove), e4.slim.multiSelected.container.classList.remove(e4.config.openBelow)) : e4.slim.singleSelected && (e4.slim.singleSelected.container.classList.remove(e4.config.openAbove), e4.slim.singleSelected.container.classList.remove(e4.config.openBelow)), e4.slim.search.input.blur(), e4.afterClose && e4.afterClose();
        }, this.config.timeoutDelay));
      }, l2.prototype.moveContentAbove = function() {
        var e4 = 0;
        this.config.isMultiple && this.slim.multiSelected ? e4 = this.slim.multiSelected.container.offsetHeight : this.slim.singleSelected && (e4 = this.slim.singleSelected.container.offsetHeight);
        var t3 = e4 + this.slim.content.offsetHeight - 1;
        this.slim.content.style.margin = "-" + t3 + "px 0 0 0", this.slim.content.style.height = t3 - e4 + 1 + "px", this.slim.content.style.transformOrigin = "center bottom", this.data.contentPosition = "above", this.config.isMultiple && this.slim.multiSelected ? (this.slim.multiSelected.container.classList.remove(this.config.openBelow), this.slim.multiSelected.container.classList.add(this.config.openAbove)) : this.slim.singleSelected && (this.slim.singleSelected.container.classList.remove(this.config.openBelow), this.slim.singleSelected.container.classList.add(this.config.openAbove));
      }, l2.prototype.moveContentBelow = function() {
        this.data.contentPosition = "below", this.config.isMultiple && this.slim.multiSelected ? (this.slim.multiSelected.container.classList.remove(this.config.openAbove), this.slim.multiSelected.container.classList.add(this.config.openBelow)) : this.slim.singleSelected && (this.slim.singleSelected.container.classList.remove(this.config.openAbove), this.slim.singleSelected.container.classList.add(this.config.openBelow));
      }, l2.prototype.enable = function() {
        this.config.isEnabled = true, this.config.isMultiple && this.slim.multiSelected ? this.slim.multiSelected.container.classList.remove(this.config.disabled) : this.slim.singleSelected && this.slim.singleSelected.container.classList.remove(this.config.disabled), this.select.triggerMutationObserver = false, this.select.element.disabled = false, this.slim.search.input.disabled = false, this.select.triggerMutationObserver = true;
      }, l2.prototype.disable = function() {
        this.config.isEnabled = false, this.config.isMultiple && this.slim.multiSelected ? this.slim.multiSelected.container.classList.add(this.config.disabled) : this.slim.singleSelected && this.slim.singleSelected.container.classList.add(this.config.disabled), this.select.triggerMutationObserver = false, this.select.element.disabled = true, this.slim.search.input.disabled = true, this.select.triggerMutationObserver = true;
      }, l2.prototype.search = function(t3) {
        var i5;
        this.data.searchValue !== t3 && (this.slim.search.input.value = t3, this.config.isAjax ? ((i5 = this).config.isSearching = true, this.render(), this.ajax && this.ajax(t3, function(e4) {
          i5.config.isSearching = false, Array.isArray(e4) ? (e4.unshift({ text: "", placeholder: true }), i5.setData(e4), i5.data.search(t3), i5.render()) : typeof e4 == "string" ? i5.slim.options(e4) : i5.render();
        })) : (this.data.search(t3), this.render()));
      }, l2.prototype.setSearchText = function(e4) {
        this.config.searchText = e4;
      }, l2.prototype.render = function() {
        this.config.isMultiple ? this.slim.values() : (this.slim.placeholder(), this.slim.deselect()), this.slim.options();
      }, l2.prototype.destroy = function(e4) {
        var t3 = (e4 = e4 === void 0 ? null : e4) ? document.querySelector("." + e4 + ".ss-main") : this.slim.container, i5 = e4 ? document.querySelector("[data-ssid=".concat(e4, "]")) : this.select.element;
        t3 && i5 && (document.removeEventListener("click", this.documentClick), this.config.showContent === "auto" && window.removeEventListener("scroll", this.windowScroll, false), i5.style.display = "", delete i5.dataset.ssid, i5.slim = null, t3.parentElement && t3.parentElement.removeChild(t3), !this.config.addToBody || (e4 = e4 ? document.querySelector("." + e4 + ".ss-content") : this.slim.content) && document.body.removeChild(e4));
      }, l2);
      function l2(e4) {
        var t3 = this;
        this.ajax = null, this.addable = null, this.beforeOnChange = null, this.onChange = null, this.beforeOpen = null, this.afterOpen = null, this.beforeClose = null, this.afterClose = null, this.windowScroll = (0, o2.debounce)(function(e5) {
          t3.data.contentOpen && ((0, o2.putContent)(t3.slim.content, t3.data.contentPosition, t3.data.contentOpen) === "above" ? t3.moveContentAbove() : t3.moveContentBelow());
        }), this.documentClick = function(e5) {
          e5.target && !(0, o2.hasClassInTree)(e5.target, t3.config.id) && t3.close();
        };
        var i5 = this.validate(e4);
        i5.dataset.ssid && this.destroy(i5.dataset.ssid), e4.ajax && (this.ajax = e4.ajax), e4.addable && (this.addable = e4.addable), this.config = new n3.Config({ select: i5, isAjax: !!e4.ajax, showSearch: e4.showSearch, searchPlaceholder: e4.searchPlaceholder, searchText: e4.searchText, searchingText: e4.searchingText, searchFocus: e4.searchFocus, searchHighlight: e4.searchHighlight, searchFilter: e4.searchFilter, closeOnSelect: e4.closeOnSelect, showContent: e4.showContent, placeholderText: e4.placeholder, allowDeselect: e4.allowDeselect, allowDeselectOption: e4.allowDeselectOption, hideSelectedOption: e4.hideSelectedOption, deselectLabel: e4.deselectLabel, isEnabled: e4.isEnabled, valuesUseText: e4.valuesUseText, showOptionTooltips: e4.showOptionTooltips, selectByGroup: e4.selectByGroup, limit: e4.limit, timeoutDelay: e4.timeoutDelay, addToBody: e4.addToBody }), this.select = new s5.Select({ select: i5, main: this }), this.data = new r2.Data({ main: this }), this.slim = new a4.Slim({ main: this }), this.select.element.parentNode && this.select.element.parentNode.insertBefore(this.slim.container, this.select.element.nextSibling), e4.data ? this.setData(e4.data) : this.render(), document.addEventListener("click", this.documentClick), this.config.showContent === "auto" && window.addEventListener("scroll", this.windowScroll, false), e4.beforeOnChange && (this.beforeOnChange = e4.beforeOnChange), e4.onChange && (this.onChange = e4.onChange), e4.beforeOpen && (this.beforeOpen = e4.beforeOpen), e4.afterOpen && (this.afterOpen = e4.afterOpen), e4.beforeClose && (this.beforeClose = e4.beforeClose), e4.afterClose && (this.afterClose = e4.afterClose), this.config.isEnabled || this.disable();
      }
      t2.default = i4;
    }, function(e3, t2, i4) {
      "use strict";
      t2.__esModule = true, t2.Config = void 0;
      var n3 = (s5.prototype.searchFilter = function(e4, t3) {
        return e4.text.toLowerCase().indexOf(t3.toLowerCase()) !== -1;
      }, s5);
      function s5(e4) {
        this.id = "", this.isMultiple = false, this.isAjax = false, this.isSearching = false, this.showSearch = true, this.searchFocus = true, this.searchHighlight = false, this.closeOnSelect = true, this.showContent = "auto", this.searchPlaceholder = "Search", this.searchText = "No Results", this.searchingText = "Searching...", this.placeholderText = "Select Value", this.allowDeselect = false, this.allowDeselectOption = false, this.hideSelectedOption = false, this.deselectLabel = "x", this.isEnabled = true, this.valuesUseText = false, this.showOptionTooltips = false, this.selectByGroup = false, this.limit = 0, this.timeoutDelay = 200, this.addToBody = false, this.main = "ss-main", this.singleSelected = "ss-single-selected", this.arrow = "ss-arrow", this.multiSelected = "ss-multi-selected", this.add = "ss-add", this.plus = "ss-plus", this.values = "ss-values", this.value = "ss-value", this.valueText = "ss-value-text", this.valueDelete = "ss-value-delete", this.content = "ss-content", this.open = "ss-open", this.openAbove = "ss-open-above", this.openBelow = "ss-open-below", this.search = "ss-search", this.searchHighlighter = "ss-search-highlight", this.addable = "ss-addable", this.list = "ss-list", this.optgroup = "ss-optgroup", this.optgroupLabel = "ss-optgroup-label", this.optgroupLabelSelectable = "ss-optgroup-label-selectable", this.option = "ss-option", this.optionSelected = "ss-option-selected", this.highlighted = "ss-highlighted", this.disabled = "ss-disabled", this.hide = "ss-hide", this.id = "ss-" + Math.floor(1e5 * Math.random()), this.style = e4.select.style.cssText, this.class = e4.select.className.split(" "), this.isMultiple = e4.select.multiple, this.isAjax = e4.isAjax, this.showSearch = e4.showSearch !== false, this.searchFocus = e4.searchFocus !== false, this.searchHighlight = e4.searchHighlight === true, this.closeOnSelect = e4.closeOnSelect !== false, e4.showContent && (this.showContent = e4.showContent), this.isEnabled = e4.isEnabled !== false, e4.searchPlaceholder && (this.searchPlaceholder = e4.searchPlaceholder), e4.searchText && (this.searchText = e4.searchText), e4.searchingText && (this.searchingText = e4.searchingText), e4.placeholderText && (this.placeholderText = e4.placeholderText), this.allowDeselect = e4.allowDeselect === true, this.allowDeselectOption = e4.allowDeselectOption === true, this.hideSelectedOption = e4.hideSelectedOption === true, e4.deselectLabel && (this.deselectLabel = e4.deselectLabel), e4.valuesUseText && (this.valuesUseText = e4.valuesUseText), e4.showOptionTooltips && (this.showOptionTooltips = e4.showOptionTooltips), e4.selectByGroup && (this.selectByGroup = e4.selectByGroup), e4.limit && (this.limit = e4.limit), e4.searchFilter && (this.searchFilter = e4.searchFilter), e4.timeoutDelay != null && (this.timeoutDelay = e4.timeoutDelay), this.addToBody = e4.addToBody === true;
      }
      t2.Config = n3;
    }, function(e3, t2, i4) {
      "use strict";
      t2.__esModule = true, t2.Select = void 0;
      var n3 = i4(0), i4 = (s5.prototype.setValue = function() {
        if (this.main.data.getSelected()) {
          if (this.main.config.isMultiple)
            for (var e4 = this.main.data.getSelected(), t3 = 0, i5 = this.element.options; t3 < i5.length; t3++) {
              var n4 = i5[t3];
              n4.selected = false;
              for (var s6 = 0, a4 = e4; s6 < a4.length; s6++)
                a4[s6].value === n4.value && (n4.selected = true);
            }
          else {
            e4 = this.main.data.getSelected();
            this.element.value = e4 ? e4.value : "";
          }
          this.main.data.isOnChangeEnabled = false, this.element.dispatchEvent(new CustomEvent("change", { bubbles: true })), this.main.data.isOnChangeEnabled = true;
        }
      }, s5.prototype.addAttributes = function() {
        this.element.tabIndex = -1, this.element.style.display = "none", this.element.dataset.ssid = this.main.config.id, this.element.setAttribute("aria-hidden", "true");
      }, s5.prototype.addEventListeners = function() {
        var t3 = this;
        this.element.addEventListener("change", function(e4) {
          t3.main.data.setSelectedFromSelect(), t3.main.render();
        });
      }, s5.prototype.addMutationObserver = function() {
        var t3 = this;
        this.main.config.isAjax || (this.mutationObserver = new MutationObserver(function(e4) {
          t3.triggerMutationObserver && (t3.main.data.parseSelectData(), t3.main.data.setSelectedFromSelect(), t3.main.render(), e4.forEach(function(e5) {
            e5.attributeName === "class" && t3.main.slim.updateContainerDivClass(t3.main.slim.container);
          }));
        }), this.observeMutationObserver());
      }, s5.prototype.observeMutationObserver = function() {
        this.mutationObserver && this.mutationObserver.observe(this.element, { attributes: true, childList: true, characterData: true });
      }, s5.prototype.disconnectMutationObserver = function() {
        this.mutationObserver && this.mutationObserver.disconnect();
      }, s5.prototype.create = function(e4) {
        this.element.innerHTML = "";
        for (var t3 = 0, i5 = e4; t3 < i5.length; t3++) {
          var n4 = i5[t3];
          if (n4.hasOwnProperty("options")) {
            var s6 = n4, a4 = document.createElement("optgroup");
            if (a4.label = s6.label, s6.options)
              for (var o2 = 0, l2 = s6.options; o2 < l2.length; o2++) {
                var r2 = l2[o2];
                a4.appendChild(this.createOption(r2));
              }
            this.element.appendChild(a4);
          } else
            this.element.appendChild(this.createOption(n4));
        }
      }, s5.prototype.createOption = function(t3) {
        var i5 = document.createElement("option");
        return i5.value = t3.value !== "" ? t3.value : t3.text, i5.innerHTML = t3.innerHTML || t3.text, t3.selected && (i5.selected = t3.selected), t3.display === false && (i5.style.display = "none"), t3.disabled && (i5.disabled = true), t3.placeholder && i5.setAttribute("data-placeholder", "true"), t3.mandatory && i5.setAttribute("data-mandatory", "true"), t3.class && t3.class.split(" ").forEach(function(e4) {
          i5.classList.add(e4);
        }), t3.data && typeof t3.data == "object" && Object.keys(t3.data).forEach(function(e4) {
          i5.setAttribute("data-" + (0, n3.kebabCase)(e4), t3.data[e4]);
        }), i5;
      }, s5);
      function s5(e4) {
        this.triggerMutationObserver = true, this.element = e4.select, this.main = e4.main, this.element.disabled && (this.main.config.isEnabled = false), this.addAttributes(), this.addEventListeners(), this.mutationObserver = null, this.addMutationObserver(), this.element.slim = e4.main;
      }
      t2.Select = i4;
    }, function(e3, t2, i4) {
      "use strict";
      t2.__esModule = true, t2.Slim = void 0;
      var n3 = i4(0), o2 = i4(1), i4 = (s5.prototype.containerDiv = function() {
        var e4 = document.createElement("div");
        return e4.style.cssText = this.main.config.style, this.updateContainerDivClass(e4), e4;
      }, s5.prototype.updateContainerDivClass = function(e4) {
        this.main.config.class = this.main.select.element.className.split(" "), e4.className = "", e4.classList.add(this.main.config.id), e4.classList.add(this.main.config.main);
        for (var t3 = 0, i5 = this.main.config.class; t3 < i5.length; t3++) {
          var n4 = i5[t3];
          n4.trim() !== "" && e4.classList.add(n4);
        }
      }, s5.prototype.singleSelectedDiv = function() {
        var t3 = this, e4 = document.createElement("div");
        e4.classList.add(this.main.config.singleSelected);
        var i5 = document.createElement("span");
        i5.classList.add("placeholder"), e4.appendChild(i5);
        var n4 = document.createElement("span");
        n4.innerHTML = this.main.config.deselectLabel, n4.classList.add("ss-deselect"), n4.onclick = function(e5) {
          e5.stopPropagation(), t3.main.config.isEnabled && t3.main.set("");
        }, e4.appendChild(n4);
        var s6 = document.createElement("span");
        s6.classList.add(this.main.config.arrow);
        var a4 = document.createElement("span");
        return a4.classList.add("arrow-down"), s6.appendChild(a4), e4.appendChild(s6), e4.onclick = function() {
          t3.main.config.isEnabled && (t3.main.data.contentOpen ? t3.main.close() : t3.main.open());
        }, { container: e4, placeholder: i5, deselect: n4, arrowIcon: { container: s6, arrow: a4 } };
      }, s5.prototype.placeholder = function() {
        var e4, t3 = this.main.data.getSelected();
        t3 === null || t3 && t3.placeholder ? ((e4 = document.createElement("span")).classList.add(this.main.config.disabled), e4.innerHTML = this.main.config.placeholderText, this.singleSelected && (this.singleSelected.placeholder.innerHTML = e4.outerHTML)) : (e4 = "", t3 && (e4 = t3.innerHTML && this.main.config.valuesUseText !== true ? t3.innerHTML : t3.text), this.singleSelected && (this.singleSelected.placeholder.innerHTML = t3 ? e4 : ""));
      }, s5.prototype.deselect = function() {
        this.singleSelected && (!this.main.config.allowDeselect || this.main.selected() === "" ? this.singleSelected.deselect.classList.add("ss-hide") : this.singleSelected.deselect.classList.remove("ss-hide"));
      }, s5.prototype.multiSelectedDiv = function() {
        var t3 = this, e4 = document.createElement("div");
        e4.classList.add(this.main.config.multiSelected);
        var i5 = document.createElement("div");
        i5.classList.add(this.main.config.values), e4.appendChild(i5);
        var n4 = document.createElement("div");
        n4.classList.add(this.main.config.add);
        var s6 = document.createElement("span");
        return s6.classList.add(this.main.config.plus), s6.onclick = function(e5) {
          t3.main.data.contentOpen && (t3.main.close(), e5.stopPropagation());
        }, n4.appendChild(s6), e4.appendChild(n4), e4.onclick = function(e5) {
          t3.main.config.isEnabled && (e5.target.classList.contains(t3.main.config.valueDelete) || (t3.main.data.contentOpen ? t3.main.close() : t3.main.open()));
        }, { container: e4, values: i5, add: n4, plus: s6 };
      }, s5.prototype.values = function() {
        if (this.multiSelected) {
          for (var e4 = this.multiSelected.values.childNodes, t3 = this.main.data.getSelected(), i5 = [], n4 = 0, s6 = e4; n4 < s6.length; n4++) {
            for (var a4 = s6[n4], o3 = true, l2 = 0, r2 = t3; l2 < r2.length; l2++) {
              var c2 = r2[l2];
              String(c2.id) === String(a4.dataset.id) && (o3 = false);
            }
            o3 && i5.push(a4);
          }
          for (var d3 = 0, h5 = i5; d3 < h5.length; d3++) {
            var u2 = h5[d3];
            u2.classList.add("ss-out"), this.multiSelected.values.removeChild(u2);
          }
          for (var p, e4 = this.multiSelected.values.childNodes, c2 = 0; c2 < t3.length; c2++) {
            o3 = false;
            for (var m3 = 0, f = e4; m3 < f.length; m3++) {
              a4 = f[m3];
              String(t3[c2].id) === String(a4.dataset.id) && (o3 = true);
            }
            o3 || (e4.length !== 0 && HTMLElement.prototype.insertAdjacentElement ? c2 === 0 ? this.multiSelected.values.insertBefore(this.valueDiv(t3[c2]), e4[c2]) : e4[c2 - 1].insertAdjacentElement("afterend", this.valueDiv(t3[c2])) : this.multiSelected.values.appendChild(this.valueDiv(t3[c2])));
          }
          t3.length === 0 && ((p = document.createElement("span")).classList.add(this.main.config.disabled), p.innerHTML = this.main.config.placeholderText, this.multiSelected.values.innerHTML = p.outerHTML);
        }
      }, s5.prototype.valueDiv = function(s6) {
        var a4 = this, e4 = document.createElement("div");
        e4.classList.add(this.main.config.value), e4.dataset.id = s6.id;
        var t3 = document.createElement("span");
        return t3.classList.add(this.main.config.valueText), t3.innerHTML = s6.innerHTML && this.main.config.valuesUseText !== true ? s6.innerHTML : s6.text, e4.appendChild(t3), s6.mandatory || ((t3 = document.createElement("span")).classList.add(this.main.config.valueDelete), t3.innerHTML = this.main.config.deselectLabel, t3.onclick = function(e5) {
          e5.preventDefault(), e5.stopPropagation();
          var t4 = false;
          if (a4.main.beforeOnChange || (t4 = true), a4.main.beforeOnChange) {
            for (var e5 = a4.main.data.getSelected(), i5 = JSON.parse(JSON.stringify(e5)), n4 = 0; n4 < i5.length; n4++)
              i5[n4].id === s6.id && i5.splice(n4, 1);
            a4.main.beforeOnChange(i5) !== false && (t4 = true);
          }
          t4 && (a4.main.data.removeFromSelected(s6.id, "id"), a4.main.render(), a4.main.select.setValue(), a4.main.data.onDataChange());
        }, e4.appendChild(t3)), e4;
      }, s5.prototype.contentDiv = function() {
        var e4 = document.createElement("div");
        return e4.classList.add(this.main.config.content), e4;
      }, s5.prototype.searchDiv = function() {
        var n4 = this, e4 = document.createElement("div"), s6 = document.createElement("input"), a4 = document.createElement("div");
        e4.classList.add(this.main.config.search);
        var t3 = { container: e4, input: s6 };
        return this.main.config.showSearch || (e4.classList.add(this.main.config.hide), s6.readOnly = true), s6.type = "search", s6.placeholder = this.main.config.searchPlaceholder, s6.tabIndex = 0, s6.setAttribute("aria-label", this.main.config.searchPlaceholder), s6.setAttribute("autocapitalize", "off"), s6.setAttribute("autocomplete", "off"), s6.setAttribute("autocorrect", "off"), s6.onclick = function(e5) {
          setTimeout(function() {
            e5.target.value === "" && n4.main.search("");
          }, 10);
        }, s6.onkeydown = function(e5) {
          e5.key === "ArrowUp" ? (n4.main.open(), n4.highlightUp(), e5.preventDefault()) : e5.key === "ArrowDown" ? (n4.main.open(), n4.highlightDown(), e5.preventDefault()) : e5.key === "Tab" ? n4.main.data.contentOpen ? n4.main.close() : setTimeout(function() {
            n4.main.close();
          }, n4.main.config.timeoutDelay) : e5.key === "Enter" && e5.preventDefault();
        }, s6.onkeyup = function(e5) {
          var t4 = e5.target;
          if (e5.key === "Enter") {
            if (n4.main.addable && e5.ctrlKey)
              return a4.click(), e5.preventDefault(), void e5.stopPropagation();
            var i5 = n4.list.querySelector("." + n4.main.config.highlighted);
            i5 && i5.click();
          } else
            e5.key === "ArrowUp" || e5.key === "ArrowDown" || (e5.key === "Escape" ? n4.main.close() : n4.main.config.showSearch && n4.main.data.contentOpen ? n4.main.search(t4.value) : s6.value = "");
          e5.preventDefault(), e5.stopPropagation();
        }, s6.onfocus = function() {
          n4.main.open();
        }, e4.appendChild(s6), this.main.addable && (a4.classList.add(this.main.config.addable), a4.innerHTML = "+", a4.onclick = function(e5) {
          var t4;
          n4.main.addable && (e5.preventDefault(), e5.stopPropagation(), (e5 = n4.search.input.value).trim() !== "" ? (e5 = n4.main.addable(e5), t4 = "", e5 && (typeof e5 == "object" ? (0, o2.validateOption)(e5) && (n4.main.addData(e5), t4 = e5.value || e5.text) : (n4.main.addData(n4.main.data.newOption({ text: e5, value: e5 })), t4 = e5), n4.main.search(""), setTimeout(function() {
            n4.main.set(t4, "value", false, false);
          }, 100), n4.main.config.closeOnSelect && setTimeout(function() {
            n4.main.close();
          }, 100))) : n4.search.input.focus());
        }, e4.appendChild(a4), t3.addable = a4), t3;
      }, s5.prototype.highlightUp = function() {
        var e4 = this.list.querySelector("." + this.main.config.highlighted), t3 = null;
        if (e4)
          for (t3 = e4.previousSibling; t3 !== null && t3.classList.contains(this.main.config.disabled); )
            t3 = t3.previousSibling;
        else
          var i5 = this.list.querySelectorAll("." + this.main.config.option + ":not(." + this.main.config.disabled + ")"), t3 = i5[i5.length - 1];
        (t3 = t3 && t3.classList.contains(this.main.config.optgroupLabel) ? null : t3) !== null || (i5 = e4.parentNode).classList.contains(this.main.config.optgroup) && (!i5.previousSibling || (i5 = i5.previousSibling.querySelectorAll("." + this.main.config.option + ":not(." + this.main.config.disabled + ")")).length && (t3 = i5[i5.length - 1])), t3 && (e4 && e4.classList.remove(this.main.config.highlighted), t3.classList.add(this.main.config.highlighted), (0, n3.ensureElementInView)(this.list, t3));
      }, s5.prototype.highlightDown = function() {
        var e4, t3 = this.list.querySelector("." + this.main.config.highlighted), i5 = null;
        if (t3)
          for (i5 = t3.nextSibling; i5 !== null && i5.classList.contains(this.main.config.disabled); )
            i5 = i5.nextSibling;
        else
          i5 = this.list.querySelector("." + this.main.config.option + ":not(." + this.main.config.disabled + ")");
        i5 !== null || t3 === null || (e4 = t3.parentNode).classList.contains(this.main.config.optgroup) && e4.nextSibling && (i5 = e4.nextSibling.querySelector("." + this.main.config.option + ":not(." + this.main.config.disabled + ")")), i5 && (t3 && t3.classList.remove(this.main.config.highlighted), i5.classList.add(this.main.config.highlighted), (0, n3.ensureElementInView)(this.list, i5));
      }, s5.prototype.listDiv = function() {
        var e4 = document.createElement("div");
        return e4.classList.add(this.main.config.list), e4.setAttribute("role", "listbox"), e4;
      }, s5.prototype.options = function(e4) {
        e4 === void 0 && (e4 = "");
        var t3 = this.main.data.filtered || this.main.data.data;
        if ((this.list.innerHTML = "") !== e4)
          return (i5 = document.createElement("div")).classList.add(this.main.config.option), i5.classList.add(this.main.config.disabled), i5.innerHTML = e4, void this.list.appendChild(i5);
        if (this.main.config.isAjax && this.main.config.isSearching)
          return (i5 = document.createElement("div")).classList.add(this.main.config.option), i5.classList.add(this.main.config.disabled), i5.innerHTML = this.main.config.searchingText, void this.list.appendChild(i5);
        if (t3.length === 0) {
          var i5 = document.createElement("div");
          return i5.classList.add(this.main.config.option), i5.classList.add(this.main.config.disabled), i5.innerHTML = this.main.config.searchText, void this.list.appendChild(i5);
        }
        for (var r2 = this, n4 = 0, s6 = t3; n4 < s6.length; n4++)
          !function(e5) {
            if (e5.hasOwnProperty("label")) {
              var t4 = e5, s7 = document.createElement("div");
              s7.classList.add(r2.main.config.optgroup);
              var i6 = document.createElement("div");
              i6.classList.add(r2.main.config.optgroupLabel), r2.main.config.selectByGroup && r2.main.config.isMultiple && i6.classList.add(r2.main.config.optgroupLabelSelectable), i6.innerHTML = t4.label, s7.appendChild(i6);
              t4 = t4.options;
              if (t4) {
                for (var a4, n5 = 0, o3 = t4; n5 < o3.length; n5++) {
                  var l2 = o3[n5];
                  s7.appendChild(r2.option(l2));
                }
                r2.main.config.selectByGroup && r2.main.config.isMultiple && (a4 = r2, i6.addEventListener("click", function(e6) {
                  e6.preventDefault(), e6.stopPropagation();
                  for (var t5 = 0, i7 = s7.children; t5 < i7.length; t5++) {
                    var n6 = i7[t5];
                    n6.className.indexOf(a4.main.config.option) !== -1 && n6.click();
                  }
                }));
              }
              r2.list.appendChild(s7);
            } else
              r2.list.appendChild(r2.option(e5));
          }(s6[n4]);
      }, s5.prototype.option = function(o3) {
        if (o3.placeholder) {
          var e4 = document.createElement("div");
          return e4.classList.add(this.main.config.option), e4.classList.add(this.main.config.hide), e4;
        }
        var t3 = document.createElement("div");
        t3.classList.add(this.main.config.option), t3.setAttribute("role", "option"), o3.class && o3.class.split(" ").forEach(function(e5) {
          t3.classList.add(e5);
        }), o3.style && (t3.style.cssText = o3.style);
        var l2 = this.main.data.getSelected();
        t3.dataset.id = o3.id, this.main.config.searchHighlight && this.main.slim && o3.innerHTML && this.main.slim.search.input.value.trim() !== "" ? t3.innerHTML = (0, n3.highlight)(o3.innerHTML, this.main.slim.search.input.value, this.main.config.searchHighlighter) : o3.innerHTML && (t3.innerHTML = o3.innerHTML), this.main.config.showOptionTooltips && t3.textContent && t3.setAttribute("title", t3.textContent);
        var r2 = this;
        t3.addEventListener("click", function(e5) {
          e5.preventDefault(), e5.stopPropagation();
          var t4 = this.dataset.id;
          if (o3.selected === true && r2.main.config.allowDeselectOption) {
            var i5 = false;
            if (r2.main.beforeOnChange && r2.main.config.isMultiple || (i5 = true), r2.main.beforeOnChange && r2.main.config.isMultiple) {
              for (var n4 = r2.main.data.getSelected(), s6 = JSON.parse(JSON.stringify(n4)), a4 = 0; a4 < s6.length; a4++)
                s6[a4].id === t4 && s6.splice(a4, 1);
              r2.main.beforeOnChange(s6) !== false && (i5 = true);
            }
            i5 && (r2.main.config.isMultiple ? (r2.main.data.removeFromSelected(t4, "id"), r2.main.render(), r2.main.select.setValue(), r2.main.data.onDataChange()) : r2.main.set(""));
          } else
            o3.disabled || o3.selected || r2.main.config.limit && Array.isArray(l2) && r2.main.config.limit <= l2.length || (r2.main.beforeOnChange ? (n4 = void 0, (i5 = JSON.parse(JSON.stringify(r2.main.data.getObjectFromData(t4)))).selected = true, r2.main.config.isMultiple ? (n4 = JSON.parse(JSON.stringify(l2))).push(i5) : n4 = JSON.parse(JSON.stringify(i5)), r2.main.beforeOnChange(n4) !== false && r2.main.set(t4, "id", r2.main.config.closeOnSelect)) : r2.main.set(t4, "id", r2.main.config.closeOnSelect));
        });
        e4 = l2 && (0, n3.isValueInArrayOfObjects)(l2, "id", o3.id);
        return (o3.disabled || e4) && (t3.onclick = null, r2.main.config.allowDeselectOption || t3.classList.add(this.main.config.disabled), r2.main.config.hideSelectedOption && t3.classList.add(this.main.config.hide)), e4 ? t3.classList.add(this.main.config.optionSelected) : t3.classList.remove(this.main.config.optionSelected), t3;
      }, s5);
      function s5(e4) {
        this.main = e4.main, this.container = this.containerDiv(), this.content = this.contentDiv(), this.search = this.searchDiv(), this.list = this.listDiv(), this.options(), this.singleSelected = null, this.multiSelected = null, this.main.config.isMultiple ? (this.multiSelected = this.multiSelectedDiv(), this.multiSelected && this.container.appendChild(this.multiSelected.container)) : (this.singleSelected = this.singleSelectedDiv(), this.container.appendChild(this.singleSelected.container)), this.main.config.addToBody ? (this.content.classList.add(this.main.config.id), document.body.appendChild(this.content)) : this.container.appendChild(this.content), this.content.appendChild(this.search.container), this.content.appendChild(this.list);
      }
      t2.Slim = i4;
    }], s4.c = n2, s4.d = function(e3, t2, i4) {
      s4.o(e3, t2) || Object.defineProperty(e3, t2, { enumerable: true, get: i4 });
    }, s4.r = function(e3) {
      typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(e3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e3, "__esModule", { value: true });
    }, s4.t = function(t2, e3) {
      if (1 & e3 && (t2 = s4(t2)), 8 & e3)
        return t2;
      if (4 & e3 && typeof t2 == "object" && t2 && t2.__esModule)
        return t2;
      var i4 = Object.create(null);
      if (s4.r(i4), Object.defineProperty(i4, "default", { enumerable: true, value: t2 }), 2 & e3 && typeof t2 != "string")
        for (var n3 in t2)
          s4.d(i4, n3, function(e4) {
            return t2[e4];
          }.bind(null, n3));
      return i4;
    }, s4.n = function(e3) {
      var t2 = e3 && e3.__esModule ? function() {
        return e3.default;
      } : function() {
        return e3;
      };
      return s4.d(t2, "a", t2), t2;
    }, s4.o = function(e3, t2) {
      return Object.prototype.hasOwnProperty.call(e3, t2);
    }, s4.p = "", s4(s4.s = 2).default;
    function s4(e3) {
      if (n2[e3])
        return n2[e3].exports;
      var t2 = n2[e3] = { i: e3, l: false, exports: {} };
      return i3[e3].call(t2.exports, t2, t2.exports, s4), t2.l = true, t2.exports;
    }
    var i3, n2;
  });
  var slimselect_min_default = exports.SlimSelect;

  // controllers/select_controller.js
  var select_controller_default = class extends Controller {
    connect() {
      this.select = new slimselect_min_default({ select: this.element });
    }
    disconnect() {
      this.select.destroy();
    }
  };

  // controllers/stripe_controller.js
  var stripe_controller_exports = {};
  __export(stripe_controller_exports, {
    default: () => stripe_controller_default
  });
  var stripe_controller_default = class extends Controller {
    connect() {
      let stripeMeta = document.querySelector('meta[name="stripe-key"]');
      if (stripeMeta === null) {
        return;
      }
      let stripeKey = stripeMeta.getAttribute("content");
      this.stripe = Stripe(stripeKey);
      let elements3 = this.stripe.elements();
      this.setup_intent = this.data.get("setup-intent");
      this.payment_intent = this.data.get("payment-intent");
      this.card = elements3.create("card", {
        style: {
          base: {
            fontFamily: 'Inter, ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif',
            fontSize: "16px",
            fontSmoothing: "antialiased"
          }
        }
      });
      this.card.mount(this.cardTarget);
      this.card.addEventListener("change", this.changed.bind(this));
    }
    changed(event) {
      if (event.error) {
        this.errorTarget.textContent = event.error.message;
      } else {
        this.errorTarget.textContent = "";
      }
    }
    submit(event) {
      event.preventDefault();
      Rails.disableElement(this.formTarget);
      if (this.nameTarget.value == "") {
        this.showError("Name on card is required.");
        return;
      }
      if (this.payment_intent) {
        this.handleCardPayment();
      } else if (this.setup_intent) {
        this.setupNewCard();
      } else {
        this.stripe.createPaymentMethod({
          type: "card",
          card: this.card,
          billing_details: {
            name: this.nameTarget.value
          }
        }).then((result) => this.handlePaymentMethod(result.paymentMethod.id));
      }
    }
    setupNewCard() {
      let data = {
        payment_method: {
          card: this.card,
          billing_details: {
            name: this.nameTarget.value
          }
        }
      };
      this.stripe.confirmCardSetup(this.setup_intent, data).then((result) => {
        if (result.error) {
          this.showError(result.error.message);
        } else {
          this.handlePaymentMethod(result.setupIntent.payment_method);
        }
      });
    }
    handlePaymentMethod(payment_method_id) {
      this.addHiddenField("processor", "stripe");
      this.addHiddenField("payment_method_token", payment_method_id);
      this.formTarget.submit();
    }
    addHiddenField(name2, value) {
      let hiddenInput = document.createElement("input");
      hiddenInput.setAttribute("type", "hidden");
      hiddenInput.setAttribute("name", name2);
      hiddenInput.setAttribute("value", value);
      this.formTarget.appendChild(hiddenInput);
    }
    handleCardPayment() {
      this.stripe.confirmCardPayment(this.payment_intent).then((result) => {
        if (result.error) {
          this.showError(result.error.message);
        } else if (result.paymentIntent && result.paymentIntent.status === "succeeded") {
          turbo_es2017_esm_exports.clearCache();
          turbo_es2017_esm_exports.visit("/");
        }
      });
    }
    showError(message) {
      this.errorTarget.textContent = message;
      setTimeout(() => {
        Rails.enableElement(this.formTarget);
      }, 100);
    }
  };
  __publicField(stripe_controller_default, "targets", ["card", "name", "error", "form"]);

  // controllers/tooltip_controller.js
  var tooltip_controller_exports = {};
  __export(tooltip_controller_exports, {
    default: () => tooltip_controller_default
  });
  var tooltip_controller_default = class extends Controller {
    connect() {
      let options2 = {};
      if (this.hasContentValue) {
        options2["content"] = this.contentValue;
      }
      this.tippy = tippy_esm_default(this.element, options2);
    }
    disconnect() {
      this.tippy.destroy();
    }
  };
  __publicField(tooltip_controller_default, "values", {
    content: String
  });

  // controllers/turbo_native/push_notifications_controller.js
  var push_notifications_controller_exports = {};
  __export(push_notifications_controller_exports, {
    default: () => push_notifications_controller_default
  });
  var push_notifications_controller_default = class extends Controller {
    connect() {
      window.TurboNativeBridge.postMessage("registerForPushNotifications");
    }
  };

  // controllers/turbo_native/sign_out_controller.js
  var sign_out_controller_exports = {};
  __export(sign_out_controller_exports, {
    default: () => sign_out_controller_default
  });
  var sign_out_controller_default = class extends Controller {
    signOut(event) {
      if (this._isTurboNativeApp) {
        event.preventDefault();
        event.stopImmediatePropagation();
        window.TurboNativeBridge.postMessage("signOut");
      }
    }
    get _isTurboNativeApp() {
      return navigator.userAgent.indexOf("Turbo Native") !== -1;
    }
  };

  // rails:/root/prod/jumpstart-pro/app/javascript/controllers/**/*_controller.js
  var modules = [{ name: "accounts", module: accounts_controller_exports, filename: "./accounts_controller.js" }, { name: "braintree", module: braintree_controller_exports, filename: "./braintree_controller.js" }, { name: "bulk", module: bulk_controller_exports, filename: "./bulk_controller.js" }, { name: "clipboard", module: clipboard_controller_exports, filename: "./clipboard_controller.js" }, { name: "mentions", module: mentions_controller_exports, filename: "./mentions_controller.js" }, { name: "notifications", module: notifications_controller_exports, filename: "./notifications_controller.js" }, { name: "paddle", module: paddle_controller_exports, filename: "./paddle_controller.js" }, { name: "paypal", module: paypal_controller_exports, filename: "./paypal_controller.js" }, { name: "pricing", module: pricing_controller_exports, filename: "./pricing_controller.js" }, { name: "select", module: select_controller_exports, filename: "./select_controller.js" }, { name: "stripe", module: stripe_controller_exports, filename: "./stripe_controller.js" }, { name: "tooltip", module: tooltip_controller_exports, filename: "./tooltip_controller.js" }, { name: "turbo-native--push-notifications", module: push_notifications_controller_exports, filename: "./turbo_native/push_notifications_controller.js" }, { name: "turbo-native--sign-out", module: sign_out_controller_exports, filename: "./turbo_native/sign_out_controller.js" }];
  var controller_default = modules;

  // ../../node_modules/tailwindcss-stimulus-components/dist/tailwindcss-stimulus-components.modern.js
  var s3 = class extends Controller {
    initialize() {
      this.hide();
    }
    connect() {
      setTimeout(() => {
        this.show();
      }, 200), this.hasDismissAfterValue && setTimeout(() => {
        this.close();
      }, this.dismissAfterValue);
    }
    close() {
      this.hide(), setTimeout(() => {
        this.element.remove();
      }, 1100);
    }
    show() {
      this.element.setAttribute("style", "transition: 1s; transform:translate(0, 0);");
    }
    hide() {
      this.element.setAttribute("style", "transition: 1s; transform:translate(400px, 0);");
    }
  };
  s3.values = { dismissAfter: Number };
  var e2 = class extends Controller {
    connect() {
      this.timeout = null, this.duration = this.data.get("duration") || 1e3;
    }
    save() {
      clearTimeout(this.timeout), this.timeout = setTimeout(() => {
        this.statusTarget.textContent = "Saving...", Rails.fire(this.formTarget, "submit");
      }, this.duration);
    }
    success() {
      this.setStatus("Saved!");
    }
    error() {
      this.setStatus("Unable to save!");
    }
    setStatus(t2) {
      this.statusTarget.textContent = t2, this.timeout = setTimeout(() => {
        this.statusTarget.textContent = "";
      }, 2e3);
    }
  };
  e2.targets = ["form", "status"];
  var i2 = class extends Controller {
    constructor(...t2) {
      super(...t2), this._onMenuButtonKeydown = (t3) => {
        switch (t3.keyCode) {
          case 13:
          case 32:
            t3.preventDefault(), this.toggle();
        }
      };
    }
    connect() {
      this.toggleClass = this.data.get("class") || "hidden", this.visibleClass = this.data.get("visibleClass") || null, this.invisibleClass = this.data.get("invisibleClass") || null, this.activeClass = this.data.get("activeClass") || null, this.enteringClass = this.data.get("enteringClass") || null, this.leavingClass = this.data.get("leavingClass") || null, this.hasButtonTarget && this.buttonTarget.addEventListener("keydown", this._onMenuButtonKeydown), this.element.setAttribute("aria-haspopup", "true");
    }
    disconnect() {
      this.hasButtonTarget && this.buttonTarget.removeEventListener("keydown", this._onMenuButtonKeydown);
    }
    toggle() {
      this.openValue = !this.openValue;
    }
    openValueChanged() {
      this.openValue ? this._show() : this._hide();
    }
    _show(t2) {
      setTimeout((() => {
        this.menuTarget.classList.remove(this.toggleClass), this.element.setAttribute("aria-expanded", "true"), this._enteringClassList[0].forEach(((t3) => {
          this.menuTarget.classList.add(t3);
        }).bind(this)), this._activeClassList[0].forEach((t3) => {
          this.activeTarget.classList.add(t3);
        }), this._invisibleClassList[0].forEach((t3) => this.menuTarget.classList.remove(t3)), this._visibleClassList[0].forEach((t3) => {
          this.menuTarget.classList.add(t3);
        }), setTimeout((() => {
          this._enteringClassList[0].forEach((t3) => this.menuTarget.classList.remove(t3));
        }).bind(this), this.enterTimeout[0]), typeof t2 == "function" && t2();
      }).bind(this));
    }
    _hide(t2) {
      setTimeout((() => {
        this.element.setAttribute("aria-expanded", "false"), this._invisibleClassList[0].forEach((t3) => this.menuTarget.classList.add(t3)), this._visibleClassList[0].forEach((t3) => this.menuTarget.classList.remove(t3)), this._activeClassList[0].forEach((t3) => this.activeTarget.classList.remove(t3)), this._leavingClassList[0].forEach((t3) => this.menuTarget.classList.add(t3)), setTimeout((() => {
          this._leavingClassList[0].forEach((t3) => this.menuTarget.classList.remove(t3)), typeof t2 == "function" && t2(), this.menuTarget.classList.add(this.toggleClass);
        }).bind(this), this.leaveTimeout[0]);
      }).bind(this));
    }
    show() {
      this.openValue = true;
    }
    hide(t2) {
      this.element.contains(t2.target) === false && this.openValue && (this.openValue = false);
    }
    get activeTarget() {
      return this.data.has("activeTarget") ? document.querySelector(this.data.get("activeTarget")) : this.element;
    }
    get _activeClassList() {
      return this.activeClass ? this.activeClass.split(",").map((t2) => t2.split(" ")) : [[], []];
    }
    get _visibleClassList() {
      return this.visibleClass ? this.visibleClass.split(",").map((t2) => t2.split(" ")) : [[], []];
    }
    get _invisibleClassList() {
      return this.invisibleClass ? this.invisibleClass.split(",").map((t2) => t2.split(" ")) : [[], []];
    }
    get _enteringClassList() {
      return this.enteringClass ? this.enteringClass.split(",").map((t2) => t2.split(" ")) : [[], []];
    }
    get _leavingClassList() {
      return this.leavingClass ? this.leavingClass.split(",").map((t2) => t2.split(" ")) : [[], []];
    }
    get enterTimeout() {
      return (this.data.get("enterTimeout") || "0,0").split(",").map((t2) => parseInt(t2));
    }
    get leaveTimeout() {
      return (this.data.get("leaveTimeout") || "0,0").split(",").map((t2) => parseInt(t2));
    }
  };
  i2.targets = ["menu", "button"], i2.values = { open: Boolean };
  var a3 = class extends Controller {
    connect() {
      this.toggleClass = this.data.get("class") || "hidden", this.backgroundId = this.data.get("backgroundId") || "modal-background", this.backgroundHtml = this.data.get("backgroundHtml") || this._backgroundHTML(), this.allowBackgroundClose = (this.data.get("allowBackgroundClose") || "true") === "true", this.preventDefaultActionOpening = (this.data.get("preventDefaultActionOpening") || "true") === "true", this.preventDefaultActionClosing = (this.data.get("preventDefaultActionClosing") || "true") === "true";
    }
    disconnect() {
      this.close();
    }
    open(t2) {
      this.preventDefaultActionOpening && t2.preventDefault(), t2.target.blur && t2.target.blur(), this.lockScroll(), this.containerTarget.classList.remove(this.toggleClass), this.data.get("disable-backdrop") || (document.body.insertAdjacentHTML("beforeend", this.backgroundHtml), this.background = document.querySelector(`#${this.backgroundId}`));
    }
    close(t2) {
      t2 && this.preventDefaultActionClosing && t2.preventDefault(), this.unlockScroll(), this.containerTarget.classList.add(this.toggleClass), this.background && this.background.remove();
    }
    closeBackground(t2) {
      this.allowBackgroundClose && t2.target === this.containerTarget && this.close(t2);
    }
    closeWithKeyboard(t2) {
      t2.keyCode !== 27 || this.containerTarget.classList.contains(this.toggleClass) || this.close(t2);
    }
    _backgroundHTML() {
      return `<div id="${this.backgroundId}" class="fixed top-0 left-0 w-full h-full" style="background-color: rgba(0, 0, 0, 0.8); z-index: 9998;"></div>`;
    }
    lockScroll() {
      const t2 = window.innerWidth - document.documentElement.clientWidth;
      document.body.style.paddingRight = `${t2}px`, this.saveScrollPosition(), document.body.classList.add("fixed", "inset-x-0", "overflow-hidden"), document.body.style.top = `-${this.scrollPosition}px`;
    }
    unlockScroll() {
      document.body.style.paddingRight = null, document.body.classList.remove("fixed", "inset-x-0", "overflow-hidden"), this.restoreScrollPosition(), document.body.style.top = null;
    }
    saveScrollPosition() {
      this.scrollPosition = window.pageYOffset || document.body.scrollTop;
    }
    restoreScrollPosition() {
      this.scrollPosition !== void 0 && (document.documentElement.scrollTop = this.scrollPosition);
    }
  };
  a3.targets = ["container"];
  var l = class extends Controller {
    connect() {
      this.activeTabClasses = (this.data.get("activeTab") || "active").split(" "), this.inactiveTabClasses = (this.data.get("inactiveTab") || "inactive").split(" "), this.anchor && (this.index = this.tabTargets.findIndex((t2) => t2.id === this.anchor)), this.showTab();
    }
    change(t2) {
      t2.preventDefault(), this.index = t2.currentTarget.dataset.index ? t2.currentTarget.dataset.index : t2.currentTarget.dataset.id ? this.tabTargets.findIndex((s4) => s4.id == t2.currentTarget.dataset.id) : this.tabTargets.indexOf(t2.currentTarget), window.dispatchEvent(new CustomEvent("tsc:tab-change"));
    }
    showTab() {
      this.tabTargets.forEach((t2, s4) => {
        const e3 = this.panelTargets[s4];
        s4 === this.index ? (e3.classList.remove("hidden"), t2.classList.remove(...this.inactiveTabClasses), t2.classList.add(...this.activeTabClasses), t2.id && (location.hash = t2.id)) : (e3.classList.add("hidden"), t2.classList.remove(...this.activeTabClasses), t2.classList.add(...this.inactiveTabClasses));
      });
    }
    get index() {
      return parseInt(this.data.get("index") || 0);
    }
    set index(t2) {
      this.data.set("index", t2 >= 0 ? t2 : 0), this.showTab();
    }
    get anchor() {
      return document.URL.split("#").length > 1 ? document.URL.split("#")[1] : null;
    }
  };
  l.targets = ["tab", "panel"];
  var n = class extends Controller {
    connect() {
      this.toggleClass = this.data.get("class") || "hidden";
    }
    toggle(t2) {
      t2.preventDefault(), this.openValue = !this.openValue;
    }
    hide(t2) {
      t2.preventDefault(), this.openValue = false;
    }
    show(t2) {
      t2.preventDefault(), this.openValue = true;
    }
    openValueChanged() {
      this.toggleClass && this.toggleableTargets.forEach((t2) => {
        t2.classList.toggle(this.toggleClass);
      });
    }
  };
  n.targets = ["toggleable"], n.values = { open: Boolean };
  var o = class extends Controller {
    initialize() {
      this.contentTarget.setAttribute("style", `transform:translate(${this.data.get("translateX")}, ${this.data.get("translateY")});`);
    }
    mouseOver() {
      this.contentTarget.classList.remove("hidden");
    }
    mouseOut() {
      this.contentTarget.classList.add("hidden");
    }
  };
  o.targets = ["content"];
  var r = class extends i2 {
    _show() {
      this.overlayTarget.classList.remove(this.toggleClass), super._show((() => {
        this._activeClassList[1].forEach((t2) => this.overlayTarget.classList.add(t2)), this._invisibleClassList[1].forEach((t2) => this.overlayTarget.classList.remove(t2)), this._visibleClassList[1].forEach((t2) => this.overlayTarget.classList.add(t2)), setTimeout((() => {
          this._enteringClassList[1].forEach((t2) => this.overlayTarget.classList.remove(t2));
        }).bind(this), this.enterTimeout[1]);
      }).bind(this));
    }
    _hide() {
      this._leavingClassList[1].forEach((t2) => this.overlayTarget.classList.add(t2)), super._hide((() => {
        setTimeout((() => {
          this._visibleClassList[1].forEach((t2) => this.overlayTarget.classList.remove(t2)), this._invisibleClassList[1].forEach((t2) => this.overlayTarget.classList.add(t2)), this._activeClassList[1].forEach((t2) => this.overlayTarget.classList.remove(t2)), this._leavingClassList[1].forEach((t2) => this.overlayTarget.classList.remove(t2)), this.overlayTarget.classList.add(this.toggleClass);
        }).bind(this), this.leaveTimeout[1]);
      }).bind(this));
    }
  };
  r.targets = ["menu", "overlay"];
  var h4 = class extends Controller {
    connect() {
      this.styleProperty = this.data.get("style") || "backgroundColor";
    }
    update() {
      this.preview = this.color;
    }
    set preview(t2) {
      this.previewTarget.style[this.styleProperty] = t2;
      const s4 = this._getContrastYIQ(t2);
      this.styleProperty === "color" ? this.previewTarget.style.backgroundColor = s4 : this.previewTarget.style.color = s4;
    }
    get color() {
      return this.colorTarget.value;
    }
    _getContrastYIQ(t2) {
      return t2 = t2.replace("#", ""), (299 * parseInt(t2.substr(0, 2), 16) + 587 * parseInt(t2.substr(2, 2), 16) + 114 * parseInt(t2.substr(4, 2), 16)) / 1e3 >= 128 ? "#000" : "#fff";
    }
  };
  h4.targets = ["preview", "color"];

  // ../../node_modules/flatpickr/dist/esm/types/options.js
  var HOOKS = [
    "onChange",
    "onClose",
    "onDayCreate",
    "onDestroy",
    "onKeyDown",
    "onMonthChange",
    "onOpen",
    "onParseConfig",
    "onReady",
    "onValueUpdate",
    "onYearChange",
    "onPreCalendarPosition"
  ];
  var defaults2 = {
    _disable: [],
    allowInput: false,
    allowInvalidPreload: false,
    altFormat: "F j, Y",
    altInput: false,
    altInputClass: "form-control input",
    animate: typeof window === "object" && window.navigator.userAgent.indexOf("MSIE") === -1,
    ariaDateFormat: "F j, Y",
    autoFillDefaultTime: true,
    clickOpens: true,
    closeOnSelect: true,
    conjunction: ", ",
    dateFormat: "Y-m-d",
    defaultHour: 12,
    defaultMinute: 0,
    defaultSeconds: 0,
    disable: [],
    disableMobile: false,
    enableSeconds: false,
    enableTime: false,
    errorHandler: (err) => typeof console !== "undefined" && console.warn(err),
    getWeek: (givenDate) => {
      const date = new Date(givenDate.getTime());
      date.setHours(0, 0, 0, 0);
      date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);
      var week1 = new Date(date.getFullYear(), 0, 4);
      return 1 + Math.round(((date.getTime() - week1.getTime()) / 864e5 - 3 + (week1.getDay() + 6) % 7) / 7);
    },
    hourIncrement: 1,
    ignoredFocusElements: [],
    inline: false,
    locale: "default",
    minuteIncrement: 5,
    mode: "single",
    monthSelectorType: "dropdown",
    nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",
    noCalendar: false,
    now: new Date(),
    onChange: [],
    onClose: [],
    onDayCreate: [],
    onDestroy: [],
    onKeyDown: [],
    onMonthChange: [],
    onOpen: [],
    onParseConfig: [],
    onReady: [],
    onValueUpdate: [],
    onYearChange: [],
    onPreCalendarPosition: [],
    plugins: [],
    position: "auto",
    positionElement: void 0,
    prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
    shorthandCurrentMonth: false,
    showMonths: 1,
    static: false,
    time_24hr: false,
    weekNumbers: false,
    wrap: false
  };

  // ../../node_modules/flatpickr/dist/esm/l10n/default.js
  var english = {
    weekdays: {
      shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      longhand: [
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday"
      ]
    },
    months: {
      shorthand: [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ],
      longhand: [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December"
      ]
    },
    daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
    firstDayOfWeek: 0,
    ordinal: (nth) => {
      const s4 = nth % 100;
      if (s4 > 3 && s4 < 21)
        return "th";
      switch (s4 % 10) {
        case 1:
          return "st";
        case 2:
          return "nd";
        case 3:
          return "rd";
        default:
          return "th";
      }
    },
    rangeSeparator: " to ",
    weekAbbreviation: "Wk",
    scrollTitle: "Scroll to increment",
    toggleTitle: "Click to toggle",
    amPM: ["AM", "PM"],
    yearAriaLabel: "Year",
    monthAriaLabel: "Month",
    hourAriaLabel: "Hour",
    minuteAriaLabel: "Minute",
    time_24hr: false
  };
  var default_default = english;

  // ../../node_modules/flatpickr/dist/esm/utils/index.js
  var pad = (number, length = 2) => `000${number}`.slice(length * -1);
  var int = (bool) => bool === true ? 1 : 0;
  function debounce4(fn2, wait) {
    let t2;
    return function() {
      clearTimeout(t2);
      t2 = setTimeout(() => fn2.apply(this, arguments), wait);
    };
  }
  var arrayify = (obj) => obj instanceof Array ? obj : [obj];

  // ../../node_modules/flatpickr/dist/esm/utils/dom.js
  function toggleClass(elem, className, bool) {
    if (bool === true)
      return elem.classList.add(className);
    elem.classList.remove(className);
  }
  function createElement(tag, className, content) {
    const e3 = window.document.createElement(tag);
    className = className || "";
    content = content || "";
    e3.className = className;
    if (content !== void 0)
      e3.textContent = content;
    return e3;
  }
  function clearNode(node) {
    while (node.firstChild)
      node.removeChild(node.firstChild);
  }
  function findParent(node, condition) {
    if (condition(node))
      return node;
    else if (node.parentNode)
      return findParent(node.parentNode, condition);
    return void 0;
  }
  function createNumberInput(inputClassName, opts) {
    const wrapper = createElement("div", "numInputWrapper"), numInput = createElement("input", "numInput " + inputClassName), arrowUp = createElement("span", "arrowUp"), arrowDown = createElement("span", "arrowDown");
    if (navigator.userAgent.indexOf("MSIE 9.0") === -1) {
      numInput.type = "number";
    } else {
      numInput.type = "text";
      numInput.pattern = "\\d*";
    }
    if (opts !== void 0)
      for (const key in opts)
        numInput.setAttribute(key, opts[key]);
    wrapper.appendChild(numInput);
    wrapper.appendChild(arrowUp);
    wrapper.appendChild(arrowDown);
    return wrapper;
  }
  function getEventTarget(event) {
    try {
      if (typeof event.composedPath === "function") {
        const path = event.composedPath();
        return path[0];
      }
      return event.target;
    } catch (error2) {
      return event.target;
    }
  }

  // ../../node_modules/flatpickr/dist/esm/utils/formatting.js
  var doNothing = () => void 0;
  var monthToStr = (monthNumber, shorthand, locale2) => locale2.months[shorthand ? "shorthand" : "longhand"][monthNumber];
  var revFormat = {
    D: doNothing,
    F: function(dateObj, monthName, locale2) {
      dateObj.setMonth(locale2.months.longhand.indexOf(monthName));
    },
    G: (dateObj, hour) => {
      dateObj.setHours(parseFloat(hour));
    },
    H: (dateObj, hour) => {
      dateObj.setHours(parseFloat(hour));
    },
    J: (dateObj, day) => {
      dateObj.setDate(parseFloat(day));
    },
    K: (dateObj, amPM, locale2) => {
      dateObj.setHours(dateObj.getHours() % 12 + 12 * int(new RegExp(locale2.amPM[1], "i").test(amPM)));
    },
    M: function(dateObj, shortMonth, locale2) {
      dateObj.setMonth(locale2.months.shorthand.indexOf(shortMonth));
    },
    S: (dateObj, seconds) => {
      dateObj.setSeconds(parseFloat(seconds));
    },
    U: (_, unixSeconds) => new Date(parseFloat(unixSeconds) * 1e3),
    W: function(dateObj, weekNum, locale2) {
      const weekNumber = parseInt(weekNum);
      const date = new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0);
      date.setDate(date.getDate() - date.getDay() + locale2.firstDayOfWeek);
      return date;
    },
    Y: (dateObj, year) => {
      dateObj.setFullYear(parseFloat(year));
    },
    Z: (_, ISODate) => new Date(ISODate),
    d: (dateObj, day) => {
      dateObj.setDate(parseFloat(day));
    },
    h: (dateObj, hour) => {
      dateObj.setHours(parseFloat(hour));
    },
    i: (dateObj, minutes) => {
      dateObj.setMinutes(parseFloat(minutes));
    },
    j: (dateObj, day) => {
      dateObj.setDate(parseFloat(day));
    },
    l: doNothing,
    m: (dateObj, month) => {
      dateObj.setMonth(parseFloat(month) - 1);
    },
    n: (dateObj, month) => {
      dateObj.setMonth(parseFloat(month) - 1);
    },
    s: (dateObj, seconds) => {
      dateObj.setSeconds(parseFloat(seconds));
    },
    u: (_, unixMillSeconds) => new Date(parseFloat(unixMillSeconds)),
    w: doNothing,
    y: (dateObj, year) => {
      dateObj.setFullYear(2e3 + parseFloat(year));
    }
  };
  var tokenRegex = {
    D: "(\\w+)",
    F: "(\\w+)",
    G: "(\\d\\d|\\d)",
    H: "(\\d\\d|\\d)",
    J: "(\\d\\d|\\d)\\w+",
    K: "",
    M: "(\\w+)",
    S: "(\\d\\d|\\d)",
    U: "(.+)",
    W: "(\\d\\d|\\d)",
    Y: "(\\d{4})",
    Z: "(.+)",
    d: "(\\d\\d|\\d)",
    h: "(\\d\\d|\\d)",
    i: "(\\d\\d|\\d)",
    j: "(\\d\\d|\\d)",
    l: "(\\w+)",
    m: "(\\d\\d|\\d)",
    n: "(\\d\\d|\\d)",
    s: "(\\d\\d|\\d)",
    u: "(.+)",
    w: "(\\d\\d|\\d)",
    y: "(\\d{2})"
  };
  var formats = {
    Z: (date) => date.toISOString(),
    D: function(date, locale2, options2) {
      return locale2.weekdays.shorthand[formats.w(date, locale2, options2)];
    },
    F: function(date, locale2, options2) {
      return monthToStr(formats.n(date, locale2, options2) - 1, false, locale2);
    },
    G: function(date, locale2, options2) {
      return pad(formats.h(date, locale2, options2));
    },
    H: (date) => pad(date.getHours()),
    J: function(date, locale2) {
      return locale2.ordinal !== void 0 ? date.getDate() + locale2.ordinal(date.getDate()) : date.getDate();
    },
    K: (date, locale2) => locale2.amPM[int(date.getHours() > 11)],
    M: function(date, locale2) {
      return monthToStr(date.getMonth(), true, locale2);
    },
    S: (date) => pad(date.getSeconds()),
    U: (date) => date.getTime() / 1e3,
    W: function(date, _, options2) {
      return options2.getWeek(date);
    },
    Y: (date) => pad(date.getFullYear(), 4),
    d: (date) => pad(date.getDate()),
    h: (date) => date.getHours() % 12 ? date.getHours() % 12 : 12,
    i: (date) => pad(date.getMinutes()),
    j: (date) => date.getDate(),
    l: function(date, locale2) {
      return locale2.weekdays.longhand[date.getDay()];
    },
    m: (date) => pad(date.getMonth() + 1),
    n: (date) => date.getMonth() + 1,
    s: (date) => date.getSeconds(),
    u: (date) => date.getTime(),
    w: (date) => date.getDay(),
    y: (date) => String(date.getFullYear()).substring(2)
  };

  // ../../node_modules/flatpickr/dist/esm/utils/dates.js
  var createDateFormatter = ({ config = defaults2, l10n = english, isMobile = false }) => (dateObj, frmt, overrideLocale) => {
    const locale2 = overrideLocale || l10n;
    if (config.formatDate !== void 0 && !isMobile) {
      return config.formatDate(dateObj, frmt, locale2);
    }
    return frmt.split("").map((c2, i3, arr) => formats[c2] && arr[i3 - 1] !== "\\" ? formats[c2](dateObj, locale2, config) : c2 !== "\\" ? c2 : "").join("");
  };
  var createDateParser = ({ config = defaults2, l10n = english }) => (date, givenFormat, timeless, customLocale) => {
    if (date !== 0 && !date)
      return void 0;
    const locale2 = customLocale || l10n;
    let parsedDate;
    const dateOrig = date;
    if (date instanceof Date)
      parsedDate = new Date(date.getTime());
    else if (typeof date !== "string" && date.toFixed !== void 0)
      parsedDate = new Date(date);
    else if (typeof date === "string") {
      const format3 = givenFormat || (config || defaults2).dateFormat;
      const datestr = String(date).trim();
      if (datestr === "today") {
        parsedDate = new Date();
        timeless = true;
      } else if (/Z$/.test(datestr) || /GMT$/.test(datestr))
        parsedDate = new Date(date);
      else if (config && config.parseDate)
        parsedDate = config.parseDate(date, format3);
      else {
        parsedDate = !config || !config.noCalendar ? new Date(new Date().getFullYear(), 0, 1, 0, 0, 0, 0) : new Date(new Date().setHours(0, 0, 0, 0));
        let matched, ops = [];
        for (let i3 = 0, matchIndex = 0, regexStr = ""; i3 < format3.length; i3++) {
          const token = format3[i3];
          const isBackSlash = token === "\\";
          const escaped = format3[i3 - 1] === "\\" || isBackSlash;
          if (tokenRegex[token] && !escaped) {
            regexStr += tokenRegex[token];
            const match2 = new RegExp(regexStr).exec(date);
            if (match2 && (matched = true)) {
              ops[token !== "Y" ? "push" : "unshift"]({
                fn: revFormat[token],
                val: match2[++matchIndex]
              });
            }
          } else if (!isBackSlash)
            regexStr += ".";
          ops.forEach(({ fn: fn2, val }) => parsedDate = fn2(parsedDate, val, locale2) || parsedDate);
        }
        parsedDate = matched ? parsedDate : void 0;
      }
    }
    if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {
      config.errorHandler(new Error(`Invalid date provided: ${dateOrig}`));
      return void 0;
    }
    if (timeless === true)
      parsedDate.setHours(0, 0, 0, 0);
    return parsedDate;
  };
  function compareDates(date1, date2, timeless = true) {
    if (timeless !== false) {
      return new Date(date1.getTime()).setHours(0, 0, 0, 0) - new Date(date2.getTime()).setHours(0, 0, 0, 0);
    }
    return date1.getTime() - date2.getTime();
  }
  var isBetween = (ts, ts1, ts2) => {
    return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);
  };
  var duration = {
    DAY: 864e5
  };
  function getDefaultHours(config) {
    let hours = config.defaultHour;
    let minutes = config.defaultMinute;
    let seconds = config.defaultSeconds;
    if (config.minDate !== void 0) {
      const minHour = config.minDate.getHours();
      const minMinutes = config.minDate.getMinutes();
      const minSeconds = config.minDate.getSeconds();
      if (hours < minHour) {
        hours = minHour;
      }
      if (hours === minHour && minutes < minMinutes) {
        minutes = minMinutes;
      }
      if (hours === minHour && minutes === minMinutes && seconds < minSeconds)
        seconds = config.minDate.getSeconds();
    }
    if (config.maxDate !== void 0) {
      const maxHr = config.maxDate.getHours();
      const maxMinutes = config.maxDate.getMinutes();
      hours = Math.min(hours, maxHr);
      if (hours === maxHr)
        minutes = Math.min(maxMinutes, minutes);
      if (hours === maxHr && minutes === maxMinutes)
        seconds = config.maxDate.getSeconds();
    }
    return { hours, minutes, seconds };
  }

  // ../../node_modules/flatpickr/dist/esm/utils/polyfills.js
  if (typeof Object.assign !== "function") {
    Object.assign = function(target, ...args) {
      if (!target) {
        throw TypeError("Cannot convert undefined or null to object");
      }
      for (const source of args) {
        if (source) {
          Object.keys(source).forEach((key) => target[key] = source[key]);
        }
      }
      return target;
    };
  }

  // ../../node_modules/flatpickr/dist/esm/index.js
  var DEBOUNCED_CHANGE_MS = 300;
  function FlatpickrInstance(element, instanceConfig) {
    const self2 = {
      config: Object.assign(Object.assign({}, defaults2), flatpickr.defaultConfig),
      l10n: default_default
    };
    self2.parseDate = createDateParser({ config: self2.config, l10n: self2.l10n });
    self2._handlers = [];
    self2.pluginElements = [];
    self2.loadedPlugins = [];
    self2._bind = bind;
    self2._setHoursFromDate = setHoursFromDate;
    self2._positionCalendar = positionCalendar;
    self2.changeMonth = changeMonth;
    self2.changeYear = changeYear;
    self2.clear = clear;
    self2.close = close;
    self2._createElement = createElement;
    self2.destroy = destroy6;
    self2.isEnabled = isEnabled;
    self2.jumpToDate = jumpToDate;
    self2.open = open;
    self2.redraw = redraw2;
    self2.set = set2;
    self2.setDate = setDate;
    self2.toggle = toggle;
    function setupHelperFunctions() {
      self2.utils = {
        getDaysInMonth(month = self2.currentMonth, yr = self2.currentYear) {
          if (month === 1 && (yr % 4 === 0 && yr % 100 !== 0 || yr % 400 === 0))
            return 29;
          return self2.l10n.daysInMonth[month];
        }
      };
    }
    function init2() {
      self2.element = self2.input = element;
      self2.isOpen = false;
      parseConfig();
      setupLocale();
      setupInputs();
      setupDates();
      setupHelperFunctions();
      if (!self2.isMobile)
        build();
      bindEvents();
      if (self2.selectedDates.length || self2.config.noCalendar) {
        if (self2.config.enableTime) {
          setHoursFromDate(self2.config.noCalendar ? self2.latestSelectedDateObj : void 0);
        }
        updateValue(false);
      }
      setCalendarWidth();
      const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
      if (!self2.isMobile && isSafari) {
        positionCalendar();
      }
      triggerEvent("onReady");
    }
    function bindToInstance(fn2) {
      return fn2.bind(self2);
    }
    function setCalendarWidth() {
      const config = self2.config;
      if (config.weekNumbers === false && config.showMonths === 1) {
        return;
      } else if (config.noCalendar !== true) {
        window.requestAnimationFrame(function() {
          if (self2.calendarContainer !== void 0) {
            self2.calendarContainer.style.visibility = "hidden";
            self2.calendarContainer.style.display = "block";
          }
          if (self2.daysContainer !== void 0) {
            const daysWidth = (self2.days.offsetWidth + 1) * config.showMonths;
            self2.daysContainer.style.width = daysWidth + "px";
            self2.calendarContainer.style.width = daysWidth + (self2.weekWrapper !== void 0 ? self2.weekWrapper.offsetWidth : 0) + "px";
            self2.calendarContainer.style.removeProperty("visibility");
            self2.calendarContainer.style.removeProperty("display");
          }
        });
      }
    }
    function updateTime(e3) {
      if (self2.selectedDates.length === 0) {
        const defaultDate = self2.config.minDate === void 0 || compareDates(new Date(), self2.config.minDate) >= 0 ? new Date() : new Date(self2.config.minDate.getTime());
        const defaults3 = getDefaultHours(self2.config);
        defaultDate.setHours(defaults3.hours, defaults3.minutes, defaults3.seconds, defaultDate.getMilliseconds());
        self2.selectedDates = [defaultDate];
        self2.latestSelectedDateObj = defaultDate;
      }
      if (e3 !== void 0 && e3.type !== "blur") {
        timeWrapper(e3);
      }
      const prevValue = self2._input.value;
      setHoursFromInputs();
      updateValue();
      if (self2._input.value !== prevValue) {
        self2._debouncedChange();
      }
    }
    function ampm2military(hour, amPM) {
      return hour % 12 + 12 * int(amPM === self2.l10n.amPM[1]);
    }
    function military2ampm(hour) {
      switch (hour % 24) {
        case 0:
        case 12:
          return 12;
        default:
          return hour % 12;
      }
    }
    function setHoursFromInputs() {
      if (self2.hourElement === void 0 || self2.minuteElement === void 0)
        return;
      let hours = (parseInt(self2.hourElement.value.slice(-2), 10) || 0) % 24, minutes = (parseInt(self2.minuteElement.value, 10) || 0) % 60, seconds = self2.secondElement !== void 0 ? (parseInt(self2.secondElement.value, 10) || 0) % 60 : 0;
      if (self2.amPM !== void 0) {
        hours = ampm2military(hours, self2.amPM.textContent);
      }
      const limitMinHours = self2.config.minTime !== void 0 || self2.config.minDate && self2.minDateHasTime && self2.latestSelectedDateObj && compareDates(self2.latestSelectedDateObj, self2.config.minDate, true) === 0;
      const limitMaxHours = self2.config.maxTime !== void 0 || self2.config.maxDate && self2.maxDateHasTime && self2.latestSelectedDateObj && compareDates(self2.latestSelectedDateObj, self2.config.maxDate, true) === 0;
      if (limitMaxHours) {
        const maxTime2 = self2.config.maxTime !== void 0 ? self2.config.maxTime : self2.config.maxDate;
        hours = Math.min(hours, maxTime2.getHours());
        if (hours === maxTime2.getHours())
          minutes = Math.min(minutes, maxTime2.getMinutes());
        if (minutes === maxTime2.getMinutes())
          seconds = Math.min(seconds, maxTime2.getSeconds());
      }
      if (limitMinHours) {
        const minTime2 = self2.config.minTime !== void 0 ? self2.config.minTime : self2.config.minDate;
        hours = Math.max(hours, minTime2.getHours());
        if (hours === minTime2.getHours() && minutes < minTime2.getMinutes())
          minutes = minTime2.getMinutes();
        if (minutes === minTime2.getMinutes())
          seconds = Math.max(seconds, minTime2.getSeconds());
      }
      setHours(hours, minutes, seconds);
    }
    function setHoursFromDate(dateObj) {
      const date = dateObj || self2.latestSelectedDateObj;
      if (date) {
        setHours(date.getHours(), date.getMinutes(), date.getSeconds());
      }
    }
    function setHours(hours, minutes, seconds) {
      if (self2.latestSelectedDateObj !== void 0) {
        self2.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);
      }
      if (!self2.hourElement || !self2.minuteElement || self2.isMobile)
        return;
      self2.hourElement.value = pad(!self2.config.time_24hr ? (12 + hours) % 12 + 12 * int(hours % 12 === 0) : hours);
      self2.minuteElement.value = pad(minutes);
      if (self2.amPM !== void 0)
        self2.amPM.textContent = self2.l10n.amPM[int(hours >= 12)];
      if (self2.secondElement !== void 0)
        self2.secondElement.value = pad(seconds);
    }
    function onYearInput(event) {
      const eventTarget = getEventTarget(event);
      const year = parseInt(eventTarget.value) + (event.delta || 0);
      if (year / 1e3 > 1 || event.key === "Enter" && !/[^\d]/.test(year.toString())) {
        changeYear(year);
      }
    }
    function bind(element2, event, handler, options2) {
      if (event instanceof Array)
        return event.forEach((ev) => bind(element2, ev, handler, options2));
      if (element2 instanceof Array)
        return element2.forEach((el) => bind(el, event, handler, options2));
      element2.addEventListener(event, handler, options2);
      self2._handlers.push({
        remove: () => element2.removeEventListener(event, handler)
      });
    }
    function triggerChange() {
      triggerEvent("onChange");
    }
    function bindEvents() {
      if (self2.config.wrap) {
        ["open", "close", "toggle", "clear"].forEach((evt) => {
          Array.prototype.forEach.call(self2.element.querySelectorAll(`[data-${evt}]`), (el) => bind(el, "click", self2[evt]));
        });
      }
      if (self2.isMobile) {
        setupMobile();
        return;
      }
      const debouncedResize = debounce4(onResize, 50);
      self2._debouncedChange = debounce4(triggerChange, DEBOUNCED_CHANGE_MS);
      if (self2.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent))
        bind(self2.daysContainer, "mouseover", (e3) => {
          if (self2.config.mode === "range")
            onMouseOver(getEventTarget(e3));
        });
      bind(window.document.body, "keydown", onKeyDown);
      if (!self2.config.inline && !self2.config.static)
        bind(window, "resize", debouncedResize);
      if (window.ontouchstart !== void 0)
        bind(window.document, "touchstart", documentClick);
      else
        bind(window.document, "mousedown", documentClick);
      bind(window.document, "focus", documentClick, { capture: true });
      if (self2.config.clickOpens === true) {
        bind(self2._input, "focus", self2.open);
        bind(self2._input, "click", self2.open);
      }
      if (self2.daysContainer !== void 0) {
        bind(self2.monthNav, "click", onMonthNavClick);
        bind(self2.monthNav, ["keyup", "increment"], onYearInput);
        bind(self2.daysContainer, "click", selectDate);
      }
      if (self2.timeContainer !== void 0 && self2.minuteElement !== void 0 && self2.hourElement !== void 0) {
        const selText = (e3) => getEventTarget(e3).select();
        bind(self2.timeContainer, ["increment"], updateTime);
        bind(self2.timeContainer, "blur", updateTime, { capture: true });
        bind(self2.timeContainer, "click", timeIncrement);
        bind([self2.hourElement, self2.minuteElement], ["focus", "click"], selText);
        if (self2.secondElement !== void 0)
          bind(self2.secondElement, "focus", () => self2.secondElement && self2.secondElement.select());
        if (self2.amPM !== void 0) {
          bind(self2.amPM, "click", (e3) => {
            updateTime(e3);
            triggerChange();
          });
        }
      }
      if (self2.config.allowInput) {
        bind(self2._input, "blur", onBlur);
      }
    }
    function jumpToDate(jumpDate, triggerChange2) {
      const jumpTo = jumpDate !== void 0 ? self2.parseDate(jumpDate) : self2.latestSelectedDateObj || (self2.config.minDate && self2.config.minDate > self2.now ? self2.config.minDate : self2.config.maxDate && self2.config.maxDate < self2.now ? self2.config.maxDate : self2.now);
      const oldYear = self2.currentYear;
      const oldMonth = self2.currentMonth;
      try {
        if (jumpTo !== void 0) {
          self2.currentYear = jumpTo.getFullYear();
          self2.currentMonth = jumpTo.getMonth();
        }
      } catch (e3) {
        e3.message = "Invalid date supplied: " + jumpTo;
        self2.config.errorHandler(e3);
      }
      if (triggerChange2 && self2.currentYear !== oldYear) {
        triggerEvent("onYearChange");
        buildMonthSwitch();
      }
      if (triggerChange2 && (self2.currentYear !== oldYear || self2.currentMonth !== oldMonth)) {
        triggerEvent("onMonthChange");
      }
      self2.redraw();
    }
    function timeIncrement(e3) {
      const eventTarget = getEventTarget(e3);
      if (~eventTarget.className.indexOf("arrow"))
        incrementNumInput(e3, eventTarget.classList.contains("arrowUp") ? 1 : -1);
    }
    function incrementNumInput(e3, delta, inputElem) {
      const target = e3 && getEventTarget(e3);
      const input = inputElem || target && target.parentNode && target.parentNode.firstChild;
      const event = createEvent("increment");
      event.delta = delta;
      input && input.dispatchEvent(event);
    }
    function build() {
      const fragment = window.document.createDocumentFragment();
      self2.calendarContainer = createElement("div", "flatpickr-calendar");
      self2.calendarContainer.tabIndex = -1;
      if (!self2.config.noCalendar) {
        fragment.appendChild(buildMonthNav());
        self2.innerContainer = createElement("div", "flatpickr-innerContainer");
        if (self2.config.weekNumbers) {
          const { weekWrapper, weekNumbers } = buildWeeks();
          self2.innerContainer.appendChild(weekWrapper);
          self2.weekNumbers = weekNumbers;
          self2.weekWrapper = weekWrapper;
        }
        self2.rContainer = createElement("div", "flatpickr-rContainer");
        self2.rContainer.appendChild(buildWeekdays());
        if (!self2.daysContainer) {
          self2.daysContainer = createElement("div", "flatpickr-days");
          self2.daysContainer.tabIndex = -1;
        }
        buildDays();
        self2.rContainer.appendChild(self2.daysContainer);
        self2.innerContainer.appendChild(self2.rContainer);
        fragment.appendChild(self2.innerContainer);
      }
      if (self2.config.enableTime) {
        fragment.appendChild(buildTime());
      }
      toggleClass(self2.calendarContainer, "rangeMode", self2.config.mode === "range");
      toggleClass(self2.calendarContainer, "animate", self2.config.animate === true);
      toggleClass(self2.calendarContainer, "multiMonth", self2.config.showMonths > 1);
      self2.calendarContainer.appendChild(fragment);
      const customAppend = self2.config.appendTo !== void 0 && self2.config.appendTo.nodeType !== void 0;
      if (self2.config.inline || self2.config.static) {
        self2.calendarContainer.classList.add(self2.config.inline ? "inline" : "static");
        if (self2.config.inline) {
          if (!customAppend && self2.element.parentNode)
            self2.element.parentNode.insertBefore(self2.calendarContainer, self2._input.nextSibling);
          else if (self2.config.appendTo !== void 0)
            self2.config.appendTo.appendChild(self2.calendarContainer);
        }
        if (self2.config.static) {
          const wrapper = createElement("div", "flatpickr-wrapper");
          if (self2.element.parentNode)
            self2.element.parentNode.insertBefore(wrapper, self2.element);
          wrapper.appendChild(self2.element);
          if (self2.altInput)
            wrapper.appendChild(self2.altInput);
          wrapper.appendChild(self2.calendarContainer);
        }
      }
      if (!self2.config.static && !self2.config.inline)
        (self2.config.appendTo !== void 0 ? self2.config.appendTo : window.document.body).appendChild(self2.calendarContainer);
    }
    function createDay(className, date, dayNumber, i3) {
      const dateIsEnabled = isEnabled(date, true), dayElement = createElement("span", "flatpickr-day " + className, date.getDate().toString());
      dayElement.dateObj = date;
      dayElement.$i = i3;
      dayElement.setAttribute("aria-label", self2.formatDate(date, self2.config.ariaDateFormat));
      if (className.indexOf("hidden") === -1 && compareDates(date, self2.now) === 0) {
        self2.todayDateElem = dayElement;
        dayElement.classList.add("today");
        dayElement.setAttribute("aria-current", "date");
      }
      if (dateIsEnabled) {
        dayElement.tabIndex = -1;
        if (isDateSelected(date)) {
          dayElement.classList.add("selected");
          self2.selectedDateElem = dayElement;
          if (self2.config.mode === "range") {
            toggleClass(dayElement, "startRange", self2.selectedDates[0] && compareDates(date, self2.selectedDates[0], true) === 0);
            toggleClass(dayElement, "endRange", self2.selectedDates[1] && compareDates(date, self2.selectedDates[1], true) === 0);
            if (className === "nextMonthDay")
              dayElement.classList.add("inRange");
          }
        }
      } else {
        dayElement.classList.add("flatpickr-disabled");
      }
      if (self2.config.mode === "range") {
        if (isDateInRange(date) && !isDateSelected(date))
          dayElement.classList.add("inRange");
      }
      if (self2.weekNumbers && self2.config.showMonths === 1 && className !== "prevMonthDay" && dayNumber % 7 === 1) {
        self2.weekNumbers.insertAdjacentHTML("beforeend", "<span class='flatpickr-day'>" + self2.config.getWeek(date) + "</span>");
      }
      triggerEvent("onDayCreate", dayElement);
      return dayElement;
    }
    function focusOnDayElem(targetNode) {
      targetNode.focus();
      if (self2.config.mode === "range")
        onMouseOver(targetNode);
    }
    function getFirstAvailableDay(delta) {
      const startMonth = delta > 0 ? 0 : self2.config.showMonths - 1;
      const endMonth = delta > 0 ? self2.config.showMonths : -1;
      for (let m3 = startMonth; m3 != endMonth; m3 += delta) {
        const month = self2.daysContainer.children[m3];
        const startIndex = delta > 0 ? 0 : month.children.length - 1;
        const endIndex = delta > 0 ? month.children.length : -1;
        for (let i3 = startIndex; i3 != endIndex; i3 += delta) {
          const c2 = month.children[i3];
          if (c2.className.indexOf("hidden") === -1 && isEnabled(c2.dateObj))
            return c2;
        }
      }
      return void 0;
    }
    function getNextAvailableDay(current, delta) {
      const givenMonth = current.className.indexOf("Month") === -1 ? current.dateObj.getMonth() : self2.currentMonth;
      const endMonth = delta > 0 ? self2.config.showMonths : -1;
      const loopDelta = delta > 0 ? 1 : -1;
      for (let m3 = givenMonth - self2.currentMonth; m3 != endMonth; m3 += loopDelta) {
        const month = self2.daysContainer.children[m3];
        const startIndex = givenMonth - self2.currentMonth === m3 ? current.$i + delta : delta < 0 ? month.children.length - 1 : 0;
        const numMonthDays = month.children.length;
        for (let i3 = startIndex; i3 >= 0 && i3 < numMonthDays && i3 != (delta > 0 ? numMonthDays : -1); i3 += loopDelta) {
          const c2 = month.children[i3];
          if (c2.className.indexOf("hidden") === -1 && isEnabled(c2.dateObj) && Math.abs(current.$i - i3) >= Math.abs(delta))
            return focusOnDayElem(c2);
        }
      }
      self2.changeMonth(loopDelta);
      focusOnDay(getFirstAvailableDay(loopDelta), 0);
      return void 0;
    }
    function focusOnDay(current, offset2) {
      const dayFocused = isInView(document.activeElement || document.body);
      const startElem = current !== void 0 ? current : dayFocused ? document.activeElement : self2.selectedDateElem !== void 0 && isInView(self2.selectedDateElem) ? self2.selectedDateElem : self2.todayDateElem !== void 0 && isInView(self2.todayDateElem) ? self2.todayDateElem : getFirstAvailableDay(offset2 > 0 ? 1 : -1);
      if (startElem === void 0) {
        self2._input.focus();
      } else if (!dayFocused) {
        focusOnDayElem(startElem);
      } else {
        getNextAvailableDay(startElem, offset2);
      }
    }
    function buildMonthDays(year, month) {
      const firstOfMonth = (new Date(year, month, 1).getDay() - self2.l10n.firstDayOfWeek + 7) % 7;
      const prevMonthDays = self2.utils.getDaysInMonth((month - 1 + 12) % 12, year);
      const daysInMonth = self2.utils.getDaysInMonth(month, year), days = window.document.createDocumentFragment(), isMultiMonth = self2.config.showMonths > 1, prevMonthDayClass = isMultiMonth ? "prevMonthDay hidden" : "prevMonthDay", nextMonthDayClass = isMultiMonth ? "nextMonthDay hidden" : "nextMonthDay";
      let dayNumber = prevMonthDays + 1 - firstOfMonth, dayIndex = 0;
      for (; dayNumber <= prevMonthDays; dayNumber++, dayIndex++) {
        days.appendChild(createDay(prevMonthDayClass, new Date(year, month - 1, dayNumber), dayNumber, dayIndex));
      }
      for (dayNumber = 1; dayNumber <= daysInMonth; dayNumber++, dayIndex++) {
        days.appendChild(createDay("", new Date(year, month, dayNumber), dayNumber, dayIndex));
      }
      for (let dayNum = daysInMonth + 1; dayNum <= 42 - firstOfMonth && (self2.config.showMonths === 1 || dayIndex % 7 !== 0); dayNum++, dayIndex++) {
        days.appendChild(createDay(nextMonthDayClass, new Date(year, month + 1, dayNum % daysInMonth), dayNum, dayIndex));
      }
      const dayContainer = createElement("div", "dayContainer");
      dayContainer.appendChild(days);
      return dayContainer;
    }
    function buildDays() {
      if (self2.daysContainer === void 0) {
        return;
      }
      clearNode(self2.daysContainer);
      if (self2.weekNumbers)
        clearNode(self2.weekNumbers);
      const frag = document.createDocumentFragment();
      for (let i3 = 0; i3 < self2.config.showMonths; i3++) {
        const d3 = new Date(self2.currentYear, self2.currentMonth, 1);
        d3.setMonth(self2.currentMonth + i3);
        frag.appendChild(buildMonthDays(d3.getFullYear(), d3.getMonth()));
      }
      self2.daysContainer.appendChild(frag);
      self2.days = self2.daysContainer.firstChild;
      if (self2.config.mode === "range" && self2.selectedDates.length === 1) {
        onMouseOver();
      }
    }
    function buildMonthSwitch() {
      if (self2.config.showMonths > 1 || self2.config.monthSelectorType !== "dropdown")
        return;
      const shouldBuildMonth = function(month) {
        if (self2.config.minDate !== void 0 && self2.currentYear === self2.config.minDate.getFullYear() && month < self2.config.minDate.getMonth()) {
          return false;
        }
        return !(self2.config.maxDate !== void 0 && self2.currentYear === self2.config.maxDate.getFullYear() && month > self2.config.maxDate.getMonth());
      };
      self2.monthsDropdownContainer.tabIndex = -1;
      self2.monthsDropdownContainer.innerHTML = "";
      for (let i3 = 0; i3 < 12; i3++) {
        if (!shouldBuildMonth(i3))
          continue;
        const month = createElement("option", "flatpickr-monthDropdown-month");
        month.value = new Date(self2.currentYear, i3).getMonth().toString();
        month.textContent = monthToStr(i3, self2.config.shorthandCurrentMonth, self2.l10n);
        month.tabIndex = -1;
        if (self2.currentMonth === i3) {
          month.selected = true;
        }
        self2.monthsDropdownContainer.appendChild(month);
      }
    }
    function buildMonth() {
      const container = createElement("div", "flatpickr-month");
      const monthNavFragment = window.document.createDocumentFragment();
      let monthElement;
      if (self2.config.showMonths > 1 || self2.config.monthSelectorType === "static") {
        monthElement = createElement("span", "cur-month");
      } else {
        self2.monthsDropdownContainer = createElement("select", "flatpickr-monthDropdown-months");
        self2.monthsDropdownContainer.setAttribute("aria-label", self2.l10n.monthAriaLabel);
        bind(self2.monthsDropdownContainer, "change", (e3) => {
          const target = getEventTarget(e3);
          const selectedMonth = parseInt(target.value, 10);
          self2.changeMonth(selectedMonth - self2.currentMonth);
          triggerEvent("onMonthChange");
        });
        buildMonthSwitch();
        monthElement = self2.monthsDropdownContainer;
      }
      const yearInput = createNumberInput("cur-year", { tabindex: "-1" });
      const yearElement = yearInput.getElementsByTagName("input")[0];
      yearElement.setAttribute("aria-label", self2.l10n.yearAriaLabel);
      if (self2.config.minDate) {
        yearElement.setAttribute("min", self2.config.minDate.getFullYear().toString());
      }
      if (self2.config.maxDate) {
        yearElement.setAttribute("max", self2.config.maxDate.getFullYear().toString());
        yearElement.disabled = !!self2.config.minDate && self2.config.minDate.getFullYear() === self2.config.maxDate.getFullYear();
      }
      const currentMonth = createElement("div", "flatpickr-current-month");
      currentMonth.appendChild(monthElement);
      currentMonth.appendChild(yearInput);
      monthNavFragment.appendChild(currentMonth);
      container.appendChild(monthNavFragment);
      return {
        container,
        yearElement,
        monthElement
      };
    }
    function buildMonths() {
      clearNode(self2.monthNav);
      self2.monthNav.appendChild(self2.prevMonthNav);
      if (self2.config.showMonths) {
        self2.yearElements = [];
        self2.monthElements = [];
      }
      for (let m3 = self2.config.showMonths; m3--; ) {
        const month = buildMonth();
        self2.yearElements.push(month.yearElement);
        self2.monthElements.push(month.monthElement);
        self2.monthNav.appendChild(month.container);
      }
      self2.monthNav.appendChild(self2.nextMonthNav);
    }
    function buildMonthNav() {
      self2.monthNav = createElement("div", "flatpickr-months");
      self2.yearElements = [];
      self2.monthElements = [];
      self2.prevMonthNav = createElement("span", "flatpickr-prev-month");
      self2.prevMonthNav.innerHTML = self2.config.prevArrow;
      self2.nextMonthNav = createElement("span", "flatpickr-next-month");
      self2.nextMonthNav.innerHTML = self2.config.nextArrow;
      buildMonths();
      Object.defineProperty(self2, "_hidePrevMonthArrow", {
        get: () => self2.__hidePrevMonthArrow,
        set(bool) {
          if (self2.__hidePrevMonthArrow !== bool) {
            toggleClass(self2.prevMonthNav, "flatpickr-disabled", bool);
            self2.__hidePrevMonthArrow = bool;
          }
        }
      });
      Object.defineProperty(self2, "_hideNextMonthArrow", {
        get: () => self2.__hideNextMonthArrow,
        set(bool) {
          if (self2.__hideNextMonthArrow !== bool) {
            toggleClass(self2.nextMonthNav, "flatpickr-disabled", bool);
            self2.__hideNextMonthArrow = bool;
          }
        }
      });
      self2.currentYearElement = self2.yearElements[0];
      updateNavigationCurrentMonth();
      return self2.monthNav;
    }
    function buildTime() {
      self2.calendarContainer.classList.add("hasTime");
      if (self2.config.noCalendar)
        self2.calendarContainer.classList.add("noCalendar");
      const defaults3 = getDefaultHours(self2.config);
      self2.timeContainer = createElement("div", "flatpickr-time");
      self2.timeContainer.tabIndex = -1;
      const separator = createElement("span", "flatpickr-time-separator", ":");
      const hourInput = createNumberInput("flatpickr-hour", {
        "aria-label": self2.l10n.hourAriaLabel
      });
      self2.hourElement = hourInput.getElementsByTagName("input")[0];
      const minuteInput = createNumberInput("flatpickr-minute", {
        "aria-label": self2.l10n.minuteAriaLabel
      });
      self2.minuteElement = minuteInput.getElementsByTagName("input")[0];
      self2.hourElement.tabIndex = self2.minuteElement.tabIndex = -1;
      self2.hourElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getHours() : self2.config.time_24hr ? defaults3.hours : military2ampm(defaults3.hours));
      self2.minuteElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getMinutes() : defaults3.minutes);
      self2.hourElement.setAttribute("step", self2.config.hourIncrement.toString());
      self2.minuteElement.setAttribute("step", self2.config.minuteIncrement.toString());
      self2.hourElement.setAttribute("min", self2.config.time_24hr ? "0" : "1");
      self2.hourElement.setAttribute("max", self2.config.time_24hr ? "23" : "12");
      self2.hourElement.setAttribute("maxlength", "2");
      self2.minuteElement.setAttribute("min", "0");
      self2.minuteElement.setAttribute("max", "59");
      self2.minuteElement.setAttribute("maxlength", "2");
      self2.timeContainer.appendChild(hourInput);
      self2.timeContainer.appendChild(separator);
      self2.timeContainer.appendChild(minuteInput);
      if (self2.config.time_24hr)
        self2.timeContainer.classList.add("time24hr");
      if (self2.config.enableSeconds) {
        self2.timeContainer.classList.add("hasSeconds");
        const secondInput = createNumberInput("flatpickr-second");
        self2.secondElement = secondInput.getElementsByTagName("input")[0];
        self2.secondElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getSeconds() : defaults3.seconds);
        self2.secondElement.setAttribute("step", self2.minuteElement.getAttribute("step"));
        self2.secondElement.setAttribute("min", "0");
        self2.secondElement.setAttribute("max", "59");
        self2.secondElement.setAttribute("maxlength", "2");
        self2.timeContainer.appendChild(createElement("span", "flatpickr-time-separator", ":"));
        self2.timeContainer.appendChild(secondInput);
      }
      if (!self2.config.time_24hr) {
        self2.amPM = createElement("span", "flatpickr-am-pm", self2.l10n.amPM[int((self2.latestSelectedDateObj ? self2.hourElement.value : self2.config.defaultHour) > 11)]);
        self2.amPM.title = self2.l10n.toggleTitle;
        self2.amPM.tabIndex = -1;
        self2.timeContainer.appendChild(self2.amPM);
      }
      return self2.timeContainer;
    }
    function buildWeekdays() {
      if (!self2.weekdayContainer)
        self2.weekdayContainer = createElement("div", "flatpickr-weekdays");
      else
        clearNode(self2.weekdayContainer);
      for (let i3 = self2.config.showMonths; i3--; ) {
        const container = createElement("div", "flatpickr-weekdaycontainer");
        self2.weekdayContainer.appendChild(container);
      }
      updateWeekdays();
      return self2.weekdayContainer;
    }
    function updateWeekdays() {
      if (!self2.weekdayContainer) {
        return;
      }
      const firstDayOfWeek = self2.l10n.firstDayOfWeek;
      let weekdays = [...self2.l10n.weekdays.shorthand];
      if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {
        weekdays = [
          ...weekdays.splice(firstDayOfWeek, weekdays.length),
          ...weekdays.splice(0, firstDayOfWeek)
        ];
      }
      for (let i3 = self2.config.showMonths; i3--; ) {
        self2.weekdayContainer.children[i3].innerHTML = `
      <span class='flatpickr-weekday'>
        ${weekdays.join("</span><span class='flatpickr-weekday'>")}
      </span>
      `;
      }
    }
    function buildWeeks() {
      self2.calendarContainer.classList.add("hasWeeks");
      const weekWrapper = createElement("div", "flatpickr-weekwrapper");
      weekWrapper.appendChild(createElement("span", "flatpickr-weekday", self2.l10n.weekAbbreviation));
      const weekNumbers = createElement("div", "flatpickr-weeks");
      weekWrapper.appendChild(weekNumbers);
      return {
        weekWrapper,
        weekNumbers
      };
    }
    function changeMonth(value, isOffset = true) {
      const delta = isOffset ? value : value - self2.currentMonth;
      if (delta < 0 && self2._hidePrevMonthArrow === true || delta > 0 && self2._hideNextMonthArrow === true)
        return;
      self2.currentMonth += delta;
      if (self2.currentMonth < 0 || self2.currentMonth > 11) {
        self2.currentYear += self2.currentMonth > 11 ? 1 : -1;
        self2.currentMonth = (self2.currentMonth + 12) % 12;
        triggerEvent("onYearChange");
        buildMonthSwitch();
      }
      buildDays();
      triggerEvent("onMonthChange");
      updateNavigationCurrentMonth();
    }
    function clear(triggerChangeEvent = true, toInitial = true) {
      self2.input.value = "";
      if (self2.altInput !== void 0)
        self2.altInput.value = "";
      if (self2.mobileInput !== void 0)
        self2.mobileInput.value = "";
      self2.selectedDates = [];
      self2.latestSelectedDateObj = void 0;
      if (toInitial === true) {
        self2.currentYear = self2._initialDate.getFullYear();
        self2.currentMonth = self2._initialDate.getMonth();
      }
      if (self2.config.enableTime === true) {
        const { hours, minutes, seconds } = getDefaultHours(self2.config);
        setHours(hours, minutes, seconds);
      }
      self2.redraw();
      if (triggerChangeEvent)
        triggerEvent("onChange");
    }
    function close() {
      self2.isOpen = false;
      if (!self2.isMobile) {
        if (self2.calendarContainer !== void 0) {
          self2.calendarContainer.classList.remove("open");
        }
        if (self2._input !== void 0) {
          self2._input.classList.remove("active");
        }
      }
      triggerEvent("onClose");
    }
    function destroy6() {
      if (self2.config !== void 0)
        triggerEvent("onDestroy");
      for (let i3 = self2._handlers.length; i3--; ) {
        self2._handlers[i3].remove();
      }
      self2._handlers = [];
      if (self2.mobileInput) {
        if (self2.mobileInput.parentNode)
          self2.mobileInput.parentNode.removeChild(self2.mobileInput);
        self2.mobileInput = void 0;
      } else if (self2.calendarContainer && self2.calendarContainer.parentNode) {
        if (self2.config.static && self2.calendarContainer.parentNode) {
          const wrapper = self2.calendarContainer.parentNode;
          wrapper.lastChild && wrapper.removeChild(wrapper.lastChild);
          if (wrapper.parentNode) {
            while (wrapper.firstChild)
              wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);
            wrapper.parentNode.removeChild(wrapper);
          }
        } else
          self2.calendarContainer.parentNode.removeChild(self2.calendarContainer);
      }
      if (self2.altInput) {
        self2.input.type = "text";
        if (self2.altInput.parentNode)
          self2.altInput.parentNode.removeChild(self2.altInput);
        delete self2.altInput;
      }
      if (self2.input) {
        self2.input.type = self2.input._type;
        self2.input.classList.remove("flatpickr-input");
        self2.input.removeAttribute("readonly");
      }
      [
        "_showTimeInput",
        "latestSelectedDateObj",
        "_hideNextMonthArrow",
        "_hidePrevMonthArrow",
        "__hideNextMonthArrow",
        "__hidePrevMonthArrow",
        "isMobile",
        "isOpen",
        "selectedDateElem",
        "minDateHasTime",
        "maxDateHasTime",
        "days",
        "daysContainer",
        "_input",
        "_positionElement",
        "innerContainer",
        "rContainer",
        "monthNav",
        "todayDateElem",
        "calendarContainer",
        "weekdayContainer",
        "prevMonthNav",
        "nextMonthNav",
        "monthsDropdownContainer",
        "currentMonthElement",
        "currentYearElement",
        "navigationCurrentMonth",
        "selectedDateElem",
        "config"
      ].forEach((k2) => {
        try {
          delete self2[k2];
        } catch (_) {
        }
      });
    }
    function isCalendarElem(elem) {
      if (self2.config.appendTo && self2.config.appendTo.contains(elem))
        return true;
      return self2.calendarContainer.contains(elem);
    }
    function documentClick(e3) {
      if (self2.isOpen && !self2.config.inline) {
        const eventTarget = getEventTarget(e3);
        const isCalendarElement = isCalendarElem(eventTarget);
        const isInput = eventTarget === self2.input || eventTarget === self2.altInput || self2.element.contains(eventTarget) || e3.path && e3.path.indexOf && (~e3.path.indexOf(self2.input) || ~e3.path.indexOf(self2.altInput));
        const lostFocus = e3.type === "blur" ? isInput && e3.relatedTarget && !isCalendarElem(e3.relatedTarget) : !isInput && !isCalendarElement && !isCalendarElem(e3.relatedTarget);
        const isIgnored = !self2.config.ignoredFocusElements.some((elem) => elem.contains(eventTarget));
        if (lostFocus && isIgnored) {
          if (self2.timeContainer !== void 0 && self2.minuteElement !== void 0 && self2.hourElement !== void 0 && self2.input.value !== "" && self2.input.value !== void 0) {
            updateTime();
          }
          self2.close();
          if (self2.config && self2.config.mode === "range" && self2.selectedDates.length === 1) {
            self2.clear(false);
            self2.redraw();
          }
        }
      }
    }
    function changeYear(newYear) {
      if (!newYear || self2.config.minDate && newYear < self2.config.minDate.getFullYear() || self2.config.maxDate && newYear > self2.config.maxDate.getFullYear())
        return;
      const newYearNum = newYear, isNewYear = self2.currentYear !== newYearNum;
      self2.currentYear = newYearNum || self2.currentYear;
      if (self2.config.maxDate && self2.currentYear === self2.config.maxDate.getFullYear()) {
        self2.currentMonth = Math.min(self2.config.maxDate.getMonth(), self2.currentMonth);
      } else if (self2.config.minDate && self2.currentYear === self2.config.minDate.getFullYear()) {
        self2.currentMonth = Math.max(self2.config.minDate.getMonth(), self2.currentMonth);
      }
      if (isNewYear) {
        self2.redraw();
        triggerEvent("onYearChange");
        buildMonthSwitch();
      }
    }
    function isEnabled(date, timeless = true) {
      var _a;
      const dateToCheck = self2.parseDate(date, void 0, timeless);
      if (self2.config.minDate && dateToCheck && compareDates(dateToCheck, self2.config.minDate, timeless !== void 0 ? timeless : !self2.minDateHasTime) < 0 || self2.config.maxDate && dateToCheck && compareDates(dateToCheck, self2.config.maxDate, timeless !== void 0 ? timeless : !self2.maxDateHasTime) > 0)
        return false;
      if (!self2.config.enable && self2.config.disable.length === 0)
        return true;
      if (dateToCheck === void 0)
        return false;
      const bool = !!self2.config.enable, array = (_a = self2.config.enable) !== null && _a !== void 0 ? _a : self2.config.disable;
      for (let i3 = 0, d3; i3 < array.length; i3++) {
        d3 = array[i3];
        if (typeof d3 === "function" && d3(dateToCheck))
          return bool;
        else if (d3 instanceof Date && dateToCheck !== void 0 && d3.getTime() === dateToCheck.getTime())
          return bool;
        else if (typeof d3 === "string") {
          const parsed = self2.parseDate(d3, void 0, true);
          return parsed && parsed.getTime() === dateToCheck.getTime() ? bool : !bool;
        } else if (typeof d3 === "object" && dateToCheck !== void 0 && d3.from && d3.to && dateToCheck.getTime() >= d3.from.getTime() && dateToCheck.getTime() <= d3.to.getTime())
          return bool;
      }
      return !bool;
    }
    function isInView(elem) {
      if (self2.daysContainer !== void 0)
        return elem.className.indexOf("hidden") === -1 && elem.className.indexOf("flatpickr-disabled") === -1 && self2.daysContainer.contains(elem);
      return false;
    }
    function onBlur(e3) {
      const isInput = e3.target === self2._input;
      if (isInput && (self2.selectedDates.length > 0 || self2._input.value.length > 0) && !(e3.relatedTarget && isCalendarElem(e3.relatedTarget))) {
        self2.setDate(self2._input.value, true, e3.target === self2.altInput ? self2.config.altFormat : self2.config.dateFormat);
      }
    }
    function onKeyDown(e3) {
      const eventTarget = getEventTarget(e3);
      const isInput = self2.config.wrap ? element.contains(eventTarget) : eventTarget === self2._input;
      const allowInput = self2.config.allowInput;
      const allowKeydown = self2.isOpen && (!allowInput || !isInput);
      const allowInlineKeydown = self2.config.inline && isInput && !allowInput;
      if (e3.keyCode === 13 && isInput) {
        if (allowInput) {
          self2.setDate(self2._input.value, true, eventTarget === self2.altInput ? self2.config.altFormat : self2.config.dateFormat);
          return eventTarget.blur();
        } else {
          self2.open();
        }
      } else if (isCalendarElem(eventTarget) || allowKeydown || allowInlineKeydown) {
        const isTimeObj = !!self2.timeContainer && self2.timeContainer.contains(eventTarget);
        switch (e3.keyCode) {
          case 13:
            if (isTimeObj) {
              e3.preventDefault();
              updateTime();
              focusAndClose();
            } else
              selectDate(e3);
            break;
          case 27:
            e3.preventDefault();
            focusAndClose();
            break;
          case 8:
          case 46:
            if (isInput && !self2.config.allowInput) {
              e3.preventDefault();
              self2.clear();
            }
            break;
          case 37:
          case 39:
            if (!isTimeObj && !isInput) {
              e3.preventDefault();
              if (self2.daysContainer !== void 0 && (allowInput === false || document.activeElement && isInView(document.activeElement))) {
                const delta2 = e3.keyCode === 39 ? 1 : -1;
                if (!e3.ctrlKey)
                  focusOnDay(void 0, delta2);
                else {
                  e3.stopPropagation();
                  changeMonth(delta2);
                  focusOnDay(getFirstAvailableDay(1), 0);
                }
              }
            } else if (self2.hourElement)
              self2.hourElement.focus();
            break;
          case 38:
          case 40:
            e3.preventDefault();
            const delta = e3.keyCode === 40 ? 1 : -1;
            if (self2.daysContainer && eventTarget.$i !== void 0 || eventTarget === self2.input || eventTarget === self2.altInput) {
              if (e3.ctrlKey) {
                e3.stopPropagation();
                changeYear(self2.currentYear - delta);
                focusOnDay(getFirstAvailableDay(1), 0);
              } else if (!isTimeObj)
                focusOnDay(void 0, delta * 7);
            } else if (eventTarget === self2.currentYearElement) {
              changeYear(self2.currentYear - delta);
            } else if (self2.config.enableTime) {
              if (!isTimeObj && self2.hourElement)
                self2.hourElement.focus();
              updateTime(e3);
              self2._debouncedChange();
            }
            break;
          case 9:
            if (isTimeObj) {
              const elems = [
                self2.hourElement,
                self2.minuteElement,
                self2.secondElement,
                self2.amPM
              ].concat(self2.pluginElements).filter((x2) => x2);
              const i3 = elems.indexOf(eventTarget);
              if (i3 !== -1) {
                const target = elems[i3 + (e3.shiftKey ? -1 : 1)];
                e3.preventDefault();
                (target || self2._input).focus();
              }
            } else if (!self2.config.noCalendar && self2.daysContainer && self2.daysContainer.contains(eventTarget) && e3.shiftKey) {
              e3.preventDefault();
              self2._input.focus();
            }
            break;
          default:
            break;
        }
      }
      if (self2.amPM !== void 0 && eventTarget === self2.amPM) {
        switch (e3.key) {
          case self2.l10n.amPM[0].charAt(0):
          case self2.l10n.amPM[0].charAt(0).toLowerCase():
            self2.amPM.textContent = self2.l10n.amPM[0];
            setHoursFromInputs();
            updateValue();
            break;
          case self2.l10n.amPM[1].charAt(0):
          case self2.l10n.amPM[1].charAt(0).toLowerCase():
            self2.amPM.textContent = self2.l10n.amPM[1];
            setHoursFromInputs();
            updateValue();
            break;
        }
      }
      if (isInput || isCalendarElem(eventTarget)) {
        triggerEvent("onKeyDown", e3);
      }
    }
    function onMouseOver(elem) {
      if (self2.selectedDates.length !== 1 || elem && (!elem.classList.contains("flatpickr-day") || elem.classList.contains("flatpickr-disabled")))
        return;
      const hoverDate = elem ? elem.dateObj.getTime() : self2.days.firstElementChild.dateObj.getTime(), initialDate = self2.parseDate(self2.selectedDates[0], void 0, true).getTime(), rangeStartDate = Math.min(hoverDate, self2.selectedDates[0].getTime()), rangeEndDate = Math.max(hoverDate, self2.selectedDates[0].getTime());
      let containsDisabled = false;
      let minRange = 0, maxRange = 0;
      for (let t2 = rangeStartDate; t2 < rangeEndDate; t2 += duration.DAY) {
        if (!isEnabled(new Date(t2), true)) {
          containsDisabled = containsDisabled || t2 > rangeStartDate && t2 < rangeEndDate;
          if (t2 < initialDate && (!minRange || t2 > minRange))
            minRange = t2;
          else if (t2 > initialDate && (!maxRange || t2 < maxRange))
            maxRange = t2;
        }
      }
      for (let m3 = 0; m3 < self2.config.showMonths; m3++) {
        const month = self2.daysContainer.children[m3];
        for (let i3 = 0, l2 = month.children.length; i3 < l2; i3++) {
          const dayElem = month.children[i3], date = dayElem.dateObj;
          const timestamp = date.getTime();
          const outOfRange = minRange > 0 && timestamp < minRange || maxRange > 0 && timestamp > maxRange;
          if (outOfRange) {
            dayElem.classList.add("notAllowed");
            ["inRange", "startRange", "endRange"].forEach((c2) => {
              dayElem.classList.remove(c2);
            });
            continue;
          } else if (containsDisabled && !outOfRange)
            continue;
          ["startRange", "inRange", "endRange", "notAllowed"].forEach((c2) => {
            dayElem.classList.remove(c2);
          });
          if (elem !== void 0) {
            elem.classList.add(hoverDate <= self2.selectedDates[0].getTime() ? "startRange" : "endRange");
            if (initialDate < hoverDate && timestamp === initialDate)
              dayElem.classList.add("startRange");
            else if (initialDate > hoverDate && timestamp === initialDate)
              dayElem.classList.add("endRange");
            if (timestamp >= minRange && (maxRange === 0 || timestamp <= maxRange) && isBetween(timestamp, initialDate, hoverDate))
              dayElem.classList.add("inRange");
          }
        }
      }
    }
    function onResize() {
      if (self2.isOpen && !self2.config.static && !self2.config.inline)
        positionCalendar();
    }
    function open(e3, positionElement = self2._positionElement) {
      if (self2.isMobile === true) {
        if (e3) {
          e3.preventDefault();
          const eventTarget = getEventTarget(e3);
          if (eventTarget) {
            eventTarget.blur();
          }
        }
        if (self2.mobileInput !== void 0) {
          self2.mobileInput.focus();
          self2.mobileInput.click();
        }
        triggerEvent("onOpen");
        return;
      } else if (self2._input.disabled || self2.config.inline) {
        return;
      }
      const wasOpen = self2.isOpen;
      self2.isOpen = true;
      if (!wasOpen) {
        self2.calendarContainer.classList.add("open");
        self2._input.classList.add("active");
        triggerEvent("onOpen");
        positionCalendar(positionElement);
      }
      if (self2.config.enableTime === true && self2.config.noCalendar === true) {
        if (self2.config.allowInput === false && (e3 === void 0 || !self2.timeContainer.contains(e3.relatedTarget))) {
          setTimeout(() => self2.hourElement.select(), 50);
        }
      }
    }
    function minMaxDateSetter(type) {
      return (date) => {
        const dateObj = self2.config[`_${type}Date`] = self2.parseDate(date, self2.config.dateFormat);
        const inverseDateObj = self2.config[`_${type === "min" ? "max" : "min"}Date`];
        if (dateObj !== void 0) {
          self2[type === "min" ? "minDateHasTime" : "maxDateHasTime"] = dateObj.getHours() > 0 || dateObj.getMinutes() > 0 || dateObj.getSeconds() > 0;
        }
        if (self2.selectedDates) {
          self2.selectedDates = self2.selectedDates.filter((d3) => isEnabled(d3));
          if (!self2.selectedDates.length && type === "min")
            setHoursFromDate(dateObj);
          updateValue();
        }
        if (self2.daysContainer) {
          redraw2();
          if (dateObj !== void 0)
            self2.currentYearElement[type] = dateObj.getFullYear().toString();
          else
            self2.currentYearElement.removeAttribute(type);
          self2.currentYearElement.disabled = !!inverseDateObj && dateObj !== void 0 && inverseDateObj.getFullYear() === dateObj.getFullYear();
        }
      };
    }
    function parseConfig() {
      const boolOpts = [
        "wrap",
        "weekNumbers",
        "allowInput",
        "allowInvalidPreload",
        "clickOpens",
        "time_24hr",
        "enableTime",
        "noCalendar",
        "altInput",
        "shorthandCurrentMonth",
        "inline",
        "static",
        "enableSeconds",
        "disableMobile"
      ];
      const userConfig = Object.assign(Object.assign({}, JSON.parse(JSON.stringify(element.dataset || {}))), instanceConfig);
      const formats2 = {};
      self2.config.parseDate = userConfig.parseDate;
      self2.config.formatDate = userConfig.formatDate;
      Object.defineProperty(self2.config, "enable", {
        get: () => self2.config._enable,
        set: (dates) => {
          self2.config._enable = parseDateRules(dates);
        }
      });
      Object.defineProperty(self2.config, "disable", {
        get: () => self2.config._disable,
        set: (dates) => {
          self2.config._disable = parseDateRules(dates);
        }
      });
      const timeMode = userConfig.mode === "time";
      if (!userConfig.dateFormat && (userConfig.enableTime || timeMode)) {
        const defaultDateFormat = flatpickr.defaultConfig.dateFormat || defaults2.dateFormat;
        formats2.dateFormat = userConfig.noCalendar || timeMode ? "H:i" + (userConfig.enableSeconds ? ":S" : "") : defaultDateFormat + " H:i" + (userConfig.enableSeconds ? ":S" : "");
      }
      if (userConfig.altInput && (userConfig.enableTime || timeMode) && !userConfig.altFormat) {
        const defaultAltFormat = flatpickr.defaultConfig.altFormat || defaults2.altFormat;
        formats2.altFormat = userConfig.noCalendar || timeMode ? "h:i" + (userConfig.enableSeconds ? ":S K" : " K") : defaultAltFormat + ` h:i${userConfig.enableSeconds ? ":S" : ""} K`;
      }
      Object.defineProperty(self2.config, "minDate", {
        get: () => self2.config._minDate,
        set: minMaxDateSetter("min")
      });
      Object.defineProperty(self2.config, "maxDate", {
        get: () => self2.config._maxDate,
        set: minMaxDateSetter("max")
      });
      const minMaxTimeSetter = (type) => (val) => {
        self2.config[type === "min" ? "_minTime" : "_maxTime"] = self2.parseDate(val, "H:i:S");
      };
      Object.defineProperty(self2.config, "minTime", {
        get: () => self2.config._minTime,
        set: minMaxTimeSetter("min")
      });
      Object.defineProperty(self2.config, "maxTime", {
        get: () => self2.config._maxTime,
        set: minMaxTimeSetter("max")
      });
      if (userConfig.mode === "time") {
        self2.config.noCalendar = true;
        self2.config.enableTime = true;
      }
      Object.assign(self2.config, formats2, userConfig);
      for (let i3 = 0; i3 < boolOpts.length; i3++)
        self2.config[boolOpts[i3]] = self2.config[boolOpts[i3]] === true || self2.config[boolOpts[i3]] === "true";
      HOOKS.filter((hook) => self2.config[hook] !== void 0).forEach((hook) => {
        self2.config[hook] = arrayify(self2.config[hook] || []).map(bindToInstance);
      });
      self2.isMobile = !self2.config.disableMobile && !self2.config.inline && self2.config.mode === "single" && !self2.config.disable.length && !self2.config.enable && !self2.config.weekNumbers && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      for (let i3 = 0; i3 < self2.config.plugins.length; i3++) {
        const pluginConf = self2.config.plugins[i3](self2) || {};
        for (const key in pluginConf) {
          if (HOOKS.indexOf(key) > -1) {
            self2.config[key] = arrayify(pluginConf[key]).map(bindToInstance).concat(self2.config[key]);
          } else if (typeof userConfig[key] === "undefined")
            self2.config[key] = pluginConf[key];
        }
      }
      if (!userConfig.altInputClass) {
        self2.config.altInputClass = getInputElem().className + " " + self2.config.altInputClass;
      }
      triggerEvent("onParseConfig");
    }
    function getInputElem() {
      return self2.config.wrap ? element.querySelector("[data-input]") : element;
    }
    function setupLocale() {
      if (typeof self2.config.locale !== "object" && typeof flatpickr.l10ns[self2.config.locale] === "undefined")
        self2.config.errorHandler(new Error(`flatpickr: invalid locale ${self2.config.locale}`));
      self2.l10n = Object.assign(Object.assign({}, flatpickr.l10ns.default), typeof self2.config.locale === "object" ? self2.config.locale : self2.config.locale !== "default" ? flatpickr.l10ns[self2.config.locale] : void 0);
      tokenRegex.K = `(${self2.l10n.amPM[0]}|${self2.l10n.amPM[1]}|${self2.l10n.amPM[0].toLowerCase()}|${self2.l10n.amPM[1].toLowerCase()})`;
      const userConfig = Object.assign(Object.assign({}, instanceConfig), JSON.parse(JSON.stringify(element.dataset || {})));
      if (userConfig.time_24hr === void 0 && flatpickr.defaultConfig.time_24hr === void 0) {
        self2.config.time_24hr = self2.l10n.time_24hr;
      }
      self2.formatDate = createDateFormatter(self2);
      self2.parseDate = createDateParser({ config: self2.config, l10n: self2.l10n });
    }
    function positionCalendar(customPositionElement) {
      if (typeof self2.config.position === "function") {
        return void self2.config.position(self2, customPositionElement);
      }
      if (self2.calendarContainer === void 0)
        return;
      triggerEvent("onPreCalendarPosition");
      const positionElement = customPositionElement || self2._positionElement;
      const calendarHeight = Array.prototype.reduce.call(self2.calendarContainer.children, (acc, child) => acc + child.offsetHeight, 0), calendarWidth = self2.calendarContainer.offsetWidth, configPos = self2.config.position.split(" "), configPosVertical = configPos[0], configPosHorizontal = configPos.length > 1 ? configPos[1] : null, inputBounds = positionElement.getBoundingClientRect(), distanceFromBottom = window.innerHeight - inputBounds.bottom, showOnTop = configPosVertical === "above" || configPosVertical !== "below" && distanceFromBottom < calendarHeight && inputBounds.top > calendarHeight;
      const top2 = window.pageYOffset + inputBounds.top + (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);
      toggleClass(self2.calendarContainer, "arrowTop", !showOnTop);
      toggleClass(self2.calendarContainer, "arrowBottom", showOnTop);
      if (self2.config.inline)
        return;
      let left2 = window.pageXOffset + inputBounds.left;
      let isCenter = false;
      let isRight = false;
      if (configPosHorizontal === "center") {
        left2 -= (calendarWidth - inputBounds.width) / 2;
        isCenter = true;
      } else if (configPosHorizontal === "right") {
        left2 -= calendarWidth - inputBounds.width;
        isRight = true;
      }
      toggleClass(self2.calendarContainer, "arrowLeft", !isCenter && !isRight);
      toggleClass(self2.calendarContainer, "arrowCenter", isCenter);
      toggleClass(self2.calendarContainer, "arrowRight", isRight);
      const right2 = window.document.body.offsetWidth - (window.pageXOffset + inputBounds.right);
      const rightMost = left2 + calendarWidth > window.document.body.offsetWidth;
      const centerMost = right2 + calendarWidth > window.document.body.offsetWidth;
      toggleClass(self2.calendarContainer, "rightMost", rightMost);
      if (self2.config.static)
        return;
      self2.calendarContainer.style.top = `${top2}px`;
      if (!rightMost) {
        self2.calendarContainer.style.left = `${left2}px`;
        self2.calendarContainer.style.right = "auto";
      } else if (!centerMost) {
        self2.calendarContainer.style.left = "auto";
        self2.calendarContainer.style.right = `${right2}px`;
      } else {
        const doc = getDocumentStyleSheet();
        if (doc === void 0)
          return;
        const bodyWidth = window.document.body.offsetWidth;
        const centerLeft = Math.max(0, bodyWidth / 2 - calendarWidth / 2);
        const centerBefore = ".flatpickr-calendar.centerMost:before";
        const centerAfter = ".flatpickr-calendar.centerMost:after";
        const centerIndex = doc.cssRules.length;
        const centerStyle = `{left:${inputBounds.left}px;right:auto;}`;
        toggleClass(self2.calendarContainer, "rightMost", false);
        toggleClass(self2.calendarContainer, "centerMost", true);
        doc.insertRule(`${centerBefore},${centerAfter}${centerStyle}`, centerIndex);
        self2.calendarContainer.style.left = `${centerLeft}px`;
        self2.calendarContainer.style.right = "auto";
      }
    }
    function getDocumentStyleSheet() {
      let editableSheet = null;
      for (let i3 = 0; i3 < document.styleSheets.length; i3++) {
        const sheet = document.styleSheets[i3];
        try {
          sheet.cssRules;
        } catch (err) {
          continue;
        }
        editableSheet = sheet;
        break;
      }
      return editableSheet != null ? editableSheet : createStyleSheet();
    }
    function createStyleSheet() {
      const style = document.createElement("style");
      document.head.appendChild(style);
      return style.sheet;
    }
    function redraw2() {
      if (self2.config.noCalendar || self2.isMobile)
        return;
      buildMonthSwitch();
      updateNavigationCurrentMonth();
      buildDays();
    }
    function focusAndClose() {
      self2._input.focus();
      if (window.navigator.userAgent.indexOf("MSIE") !== -1 || navigator.msMaxTouchPoints !== void 0) {
        setTimeout(self2.close, 0);
      } else {
        self2.close();
      }
    }
    function selectDate(e3) {
      e3.preventDefault();
      e3.stopPropagation();
      const isSelectable = (day) => day.classList && day.classList.contains("flatpickr-day") && !day.classList.contains("flatpickr-disabled") && !day.classList.contains("notAllowed");
      const t2 = findParent(getEventTarget(e3), isSelectable);
      if (t2 === void 0)
        return;
      const target = t2;
      const selectedDate = self2.latestSelectedDateObj = new Date(target.dateObj.getTime());
      const shouldChangeMonth = (selectedDate.getMonth() < self2.currentMonth || selectedDate.getMonth() > self2.currentMonth + self2.config.showMonths - 1) && self2.config.mode !== "range";
      self2.selectedDateElem = target;
      if (self2.config.mode === "single")
        self2.selectedDates = [selectedDate];
      else if (self2.config.mode === "multiple") {
        const selectedIndex = isDateSelected(selectedDate);
        if (selectedIndex)
          self2.selectedDates.splice(parseInt(selectedIndex), 1);
        else
          self2.selectedDates.push(selectedDate);
      } else if (self2.config.mode === "range") {
        if (self2.selectedDates.length === 2) {
          self2.clear(false, false);
        }
        self2.latestSelectedDateObj = selectedDate;
        self2.selectedDates.push(selectedDate);
        if (compareDates(selectedDate, self2.selectedDates[0], true) !== 0)
          self2.selectedDates.sort((a4, b2) => a4.getTime() - b2.getTime());
      }
      setHoursFromInputs();
      if (shouldChangeMonth) {
        const isNewYear = self2.currentYear !== selectedDate.getFullYear();
        self2.currentYear = selectedDate.getFullYear();
        self2.currentMonth = selectedDate.getMonth();
        if (isNewYear) {
          triggerEvent("onYearChange");
          buildMonthSwitch();
        }
        triggerEvent("onMonthChange");
      }
      updateNavigationCurrentMonth();
      buildDays();
      updateValue();
      if (!shouldChangeMonth && self2.config.mode !== "range" && self2.config.showMonths === 1)
        focusOnDayElem(target);
      else if (self2.selectedDateElem !== void 0 && self2.hourElement === void 0) {
        self2.selectedDateElem && self2.selectedDateElem.focus();
      }
      if (self2.hourElement !== void 0)
        self2.hourElement !== void 0 && self2.hourElement.focus();
      if (self2.config.closeOnSelect) {
        const single = self2.config.mode === "single" && !self2.config.enableTime;
        const range = self2.config.mode === "range" && self2.selectedDates.length === 2 && !self2.config.enableTime;
        if (single || range) {
          focusAndClose();
        }
      }
      triggerChange();
    }
    const CALLBACKS = {
      locale: [setupLocale, updateWeekdays],
      showMonths: [buildMonths, setCalendarWidth, buildWeekdays],
      minDate: [jumpToDate],
      maxDate: [jumpToDate],
      clickOpens: [
        () => {
          if (self2.config.clickOpens === true) {
            bind(self2._input, "focus", self2.open);
            bind(self2._input, "click", self2.open);
          } else {
            self2._input.removeEventListener("focus", self2.open);
            self2._input.removeEventListener("click", self2.open);
          }
        }
      ]
    };
    function set2(option, value) {
      if (option !== null && typeof option === "object") {
        Object.assign(self2.config, option);
        for (const key in option) {
          if (CALLBACKS[key] !== void 0)
            CALLBACKS[key].forEach((x2) => x2());
        }
      } else {
        self2.config[option] = value;
        if (CALLBACKS[option] !== void 0)
          CALLBACKS[option].forEach((x2) => x2());
        else if (HOOKS.indexOf(option) > -1)
          self2.config[option] = arrayify(value);
      }
      self2.redraw();
      updateValue(true);
    }
    function setSelectedDate(inputDate, format3) {
      let dates = [];
      if (inputDate instanceof Array)
        dates = inputDate.map((d3) => self2.parseDate(d3, format3));
      else if (inputDate instanceof Date || typeof inputDate === "number")
        dates = [self2.parseDate(inputDate, format3)];
      else if (typeof inputDate === "string") {
        switch (self2.config.mode) {
          case "single":
          case "time":
            dates = [self2.parseDate(inputDate, format3)];
            break;
          case "multiple":
            dates = inputDate.split(self2.config.conjunction).map((date) => self2.parseDate(date, format3));
            break;
          case "range":
            dates = inputDate.split(self2.l10n.rangeSeparator).map((date) => self2.parseDate(date, format3));
            break;
          default:
            break;
        }
      } else
        self2.config.errorHandler(new Error(`Invalid date supplied: ${JSON.stringify(inputDate)}`));
      self2.selectedDates = self2.config.allowInvalidPreload ? dates : dates.filter((d3) => d3 instanceof Date && isEnabled(d3, false));
      if (self2.config.mode === "range")
        self2.selectedDates.sort((a4, b2) => a4.getTime() - b2.getTime());
    }
    function setDate(date, triggerChange2 = false, format3 = self2.config.dateFormat) {
      if (date !== 0 && !date || date instanceof Array && date.length === 0)
        return self2.clear(triggerChange2);
      setSelectedDate(date, format3);
      self2.latestSelectedDateObj = self2.selectedDates[self2.selectedDates.length - 1];
      self2.redraw();
      jumpToDate(void 0, triggerChange2);
      setHoursFromDate();
      if (self2.selectedDates.length === 0) {
        self2.clear(false);
      }
      updateValue(triggerChange2);
      if (triggerChange2)
        triggerEvent("onChange");
    }
    function parseDateRules(arr) {
      return arr.slice().map((rule) => {
        if (typeof rule === "string" || typeof rule === "number" || rule instanceof Date) {
          return self2.parseDate(rule, void 0, true);
        } else if (rule && typeof rule === "object" && rule.from && rule.to)
          return {
            from: self2.parseDate(rule.from, void 0),
            to: self2.parseDate(rule.to, void 0)
          };
        return rule;
      }).filter((x2) => x2);
    }
    function setupDates() {
      self2.selectedDates = [];
      self2.now = self2.parseDate(self2.config.now) || new Date();
      const preloadedDate = self2.config.defaultDate || ((self2.input.nodeName === "INPUT" || self2.input.nodeName === "TEXTAREA") && self2.input.placeholder && self2.input.value === self2.input.placeholder ? null : self2.input.value);
      if (preloadedDate)
        setSelectedDate(preloadedDate, self2.config.dateFormat);
      self2._initialDate = self2.selectedDates.length > 0 ? self2.selectedDates[0] : self2.config.minDate && self2.config.minDate.getTime() > self2.now.getTime() ? self2.config.minDate : self2.config.maxDate && self2.config.maxDate.getTime() < self2.now.getTime() ? self2.config.maxDate : self2.now;
      self2.currentYear = self2._initialDate.getFullYear();
      self2.currentMonth = self2._initialDate.getMonth();
      if (self2.selectedDates.length > 0)
        self2.latestSelectedDateObj = self2.selectedDates[0];
      if (self2.config.minTime !== void 0)
        self2.config.minTime = self2.parseDate(self2.config.minTime, "H:i");
      if (self2.config.maxTime !== void 0)
        self2.config.maxTime = self2.parseDate(self2.config.maxTime, "H:i");
      self2.minDateHasTime = !!self2.config.minDate && (self2.config.minDate.getHours() > 0 || self2.config.minDate.getMinutes() > 0 || self2.config.minDate.getSeconds() > 0);
      self2.maxDateHasTime = !!self2.config.maxDate && (self2.config.maxDate.getHours() > 0 || self2.config.maxDate.getMinutes() > 0 || self2.config.maxDate.getSeconds() > 0);
    }
    function setupInputs() {
      self2.input = getInputElem();
      if (!self2.input) {
        self2.config.errorHandler(new Error("Invalid input element specified"));
        return;
      }
      self2.input._type = self2.input.type;
      self2.input.type = "text";
      self2.input.classList.add("flatpickr-input");
      self2._input = self2.input;
      if (self2.config.altInput) {
        self2.altInput = createElement(self2.input.nodeName, self2.config.altInputClass);
        self2._input = self2.altInput;
        self2.altInput.placeholder = self2.input.placeholder;
        self2.altInput.disabled = self2.input.disabled;
        self2.altInput.required = self2.input.required;
        self2.altInput.tabIndex = self2.input.tabIndex;
        self2.altInput.type = "text";
        self2.input.setAttribute("type", "hidden");
        if (!self2.config.static && self2.input.parentNode)
          self2.input.parentNode.insertBefore(self2.altInput, self2.input.nextSibling);
      }
      if (!self2.config.allowInput)
        self2._input.setAttribute("readonly", "readonly");
      self2._positionElement = self2.config.positionElement || self2._input;
    }
    function setupMobile() {
      const inputType = self2.config.enableTime ? self2.config.noCalendar ? "time" : "datetime-local" : "date";
      self2.mobileInput = createElement("input", self2.input.className + " flatpickr-mobile");
      self2.mobileInput.tabIndex = 1;
      self2.mobileInput.type = inputType;
      self2.mobileInput.disabled = self2.input.disabled;
      self2.mobileInput.required = self2.input.required;
      self2.mobileInput.placeholder = self2.input.placeholder;
      self2.mobileFormatStr = inputType === "datetime-local" ? "Y-m-d\\TH:i:S" : inputType === "date" ? "Y-m-d" : "H:i:S";
      if (self2.selectedDates.length > 0) {
        self2.mobileInput.defaultValue = self2.mobileInput.value = self2.formatDate(self2.selectedDates[0], self2.mobileFormatStr);
      }
      if (self2.config.minDate)
        self2.mobileInput.min = self2.formatDate(self2.config.minDate, "Y-m-d");
      if (self2.config.maxDate)
        self2.mobileInput.max = self2.formatDate(self2.config.maxDate, "Y-m-d");
      if (self2.input.getAttribute("step"))
        self2.mobileInput.step = String(self2.input.getAttribute("step"));
      self2.input.type = "hidden";
      if (self2.altInput !== void 0)
        self2.altInput.type = "hidden";
      try {
        if (self2.input.parentNode)
          self2.input.parentNode.insertBefore(self2.mobileInput, self2.input.nextSibling);
      } catch (_a) {
      }
      bind(self2.mobileInput, "change", (e3) => {
        self2.setDate(getEventTarget(e3).value, false, self2.mobileFormatStr);
        triggerEvent("onChange");
        triggerEvent("onClose");
      });
    }
    function toggle(e3) {
      if (self2.isOpen === true)
        return self2.close();
      self2.open(e3);
    }
    function triggerEvent(event, data) {
      if (self2.config === void 0)
        return;
      const hooks = self2.config[event];
      if (hooks !== void 0 && hooks.length > 0) {
        for (let i3 = 0; hooks[i3] && i3 < hooks.length; i3++)
          hooks[i3](self2.selectedDates, self2.input.value, self2, data);
      }
      if (event === "onChange") {
        self2.input.dispatchEvent(createEvent("change"));
        self2.input.dispatchEvent(createEvent("input"));
      }
    }
    function createEvent(name2) {
      const e3 = document.createEvent("Event");
      e3.initEvent(name2, true, true);
      return e3;
    }
    function isDateSelected(date) {
      for (let i3 = 0; i3 < self2.selectedDates.length; i3++) {
        if (compareDates(self2.selectedDates[i3], date) === 0)
          return "" + i3;
      }
      return false;
    }
    function isDateInRange(date) {
      if (self2.config.mode !== "range" || self2.selectedDates.length < 2)
        return false;
      return compareDates(date, self2.selectedDates[0]) >= 0 && compareDates(date, self2.selectedDates[1]) <= 0;
    }
    function updateNavigationCurrentMonth() {
      if (self2.config.noCalendar || self2.isMobile || !self2.monthNav)
        return;
      self2.yearElements.forEach((yearElement, i3) => {
        const d3 = new Date(self2.currentYear, self2.currentMonth, 1);
        d3.setMonth(self2.currentMonth + i3);
        if (self2.config.showMonths > 1 || self2.config.monthSelectorType === "static") {
          self2.monthElements[i3].textContent = monthToStr(d3.getMonth(), self2.config.shorthandCurrentMonth, self2.l10n) + " ";
        } else {
          self2.monthsDropdownContainer.value = d3.getMonth().toString();
        }
        yearElement.value = d3.getFullYear().toString();
      });
      self2._hidePrevMonthArrow = self2.config.minDate !== void 0 && (self2.currentYear === self2.config.minDate.getFullYear() ? self2.currentMonth <= self2.config.minDate.getMonth() : self2.currentYear < self2.config.minDate.getFullYear());
      self2._hideNextMonthArrow = self2.config.maxDate !== void 0 && (self2.currentYear === self2.config.maxDate.getFullYear() ? self2.currentMonth + 1 > self2.config.maxDate.getMonth() : self2.currentYear > self2.config.maxDate.getFullYear());
    }
    function getDateStr(format3) {
      return self2.selectedDates.map((dObj) => self2.formatDate(dObj, format3)).filter((d3, i3, arr) => self2.config.mode !== "range" || self2.config.enableTime || arr.indexOf(d3) === i3).join(self2.config.mode !== "range" ? self2.config.conjunction : self2.l10n.rangeSeparator);
    }
    function updateValue(triggerChange2 = true) {
      if (self2.mobileInput !== void 0 && self2.mobileFormatStr) {
        self2.mobileInput.value = self2.latestSelectedDateObj !== void 0 ? self2.formatDate(self2.latestSelectedDateObj, self2.mobileFormatStr) : "";
      }
      self2.input.value = getDateStr(self2.config.dateFormat);
      if (self2.altInput !== void 0) {
        self2.altInput.value = getDateStr(self2.config.altFormat);
      }
      if (triggerChange2 !== false)
        triggerEvent("onValueUpdate");
    }
    function onMonthNavClick(e3) {
      const eventTarget = getEventTarget(e3);
      const isPrevMonth = self2.prevMonthNav.contains(eventTarget);
      const isNextMonth = self2.nextMonthNav.contains(eventTarget);
      if (isPrevMonth || isNextMonth) {
        changeMonth(isPrevMonth ? -1 : 1);
      } else if (self2.yearElements.indexOf(eventTarget) >= 0) {
        eventTarget.select();
      } else if (eventTarget.classList.contains("arrowUp")) {
        self2.changeYear(self2.currentYear + 1);
      } else if (eventTarget.classList.contains("arrowDown")) {
        self2.changeYear(self2.currentYear - 1);
      }
    }
    function timeWrapper(e3) {
      e3.preventDefault();
      const isKeyDown = e3.type === "keydown", eventTarget = getEventTarget(e3), input = eventTarget;
      if (self2.amPM !== void 0 && eventTarget === self2.amPM) {
        self2.amPM.textContent = self2.l10n.amPM[int(self2.amPM.textContent === self2.l10n.amPM[0])];
      }
      const min2 = parseFloat(input.getAttribute("min")), max2 = parseFloat(input.getAttribute("max")), step = parseFloat(input.getAttribute("step")), curValue = parseInt(input.value, 10), delta = e3.delta || (isKeyDown ? e3.which === 38 ? 1 : -1 : 0);
      let newValue = curValue + step * delta;
      if (typeof input.value !== "undefined" && input.value.length === 2) {
        const isHourElem = input === self2.hourElement, isMinuteElem = input === self2.minuteElement;
        if (newValue < min2) {
          newValue = max2 + newValue + int(!isHourElem) + (int(isHourElem) && int(!self2.amPM));
          if (isMinuteElem)
            incrementNumInput(void 0, -1, self2.hourElement);
        } else if (newValue > max2) {
          newValue = input === self2.hourElement ? newValue - max2 - int(!self2.amPM) : min2;
          if (isMinuteElem)
            incrementNumInput(void 0, 1, self2.hourElement);
        }
        if (self2.amPM && isHourElem && (step === 1 ? newValue + curValue === 23 : Math.abs(newValue - curValue) > step)) {
          self2.amPM.textContent = self2.l10n.amPM[int(self2.amPM.textContent === self2.l10n.amPM[0])];
        }
        input.value = pad(newValue);
      }
    }
    init2();
    return self2;
  }
  function _flatpickr(nodeList, config) {
    const nodes = Array.prototype.slice.call(nodeList).filter((x2) => x2 instanceof HTMLElement);
    const instances2 = [];
    for (let i3 = 0; i3 < nodes.length; i3++) {
      const node = nodes[i3];
      try {
        if (node.getAttribute("data-fp-omit") !== null)
          continue;
        if (node._flatpickr !== void 0) {
          node._flatpickr.destroy();
          node._flatpickr = void 0;
        }
        node._flatpickr = FlatpickrInstance(node, config || {});
        instances2.push(node._flatpickr);
      } catch (e3) {
        console.error(e3);
      }
    }
    return instances2.length === 1 ? instances2[0] : instances2;
  }
  if (typeof HTMLElement !== "undefined" && typeof HTMLCollection !== "undefined" && typeof NodeList !== "undefined") {
    HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function(config) {
      return _flatpickr(this, config);
    };
    HTMLElement.prototype.flatpickr = function(config) {
      return _flatpickr([this], config);
    };
  }
  var flatpickr = function(selector, config) {
    if (typeof selector === "string") {
      return _flatpickr(window.document.querySelectorAll(selector), config);
    } else if (selector instanceof Node) {
      return _flatpickr([selector], config);
    } else {
      return _flatpickr(selector, config);
    }
  };
  flatpickr.defaultConfig = {};
  flatpickr.l10ns = {
    en: Object.assign({}, default_default),
    default: Object.assign({}, default_default)
  };
  flatpickr.localize = (l10n) => {
    flatpickr.l10ns.default = Object.assign(Object.assign({}, flatpickr.l10ns.default), l10n);
  };
  flatpickr.setDefaults = (config) => {
    flatpickr.defaultConfig = Object.assign(Object.assign({}, flatpickr.defaultConfig), config);
  };
  flatpickr.parseDate = createDateParser({});
  flatpickr.formatDate = createDateFormatter({});
  flatpickr.compareDates = compareDates;
  if (typeof jQuery !== "undefined" && typeof jQuery.fn !== "undefined") {
    jQuery.fn.flatpickr = function(config) {
      return _flatpickr(this, config);
    };
  }
  Date.prototype.fp_incr = function(days) {
    return new Date(this.getFullYear(), this.getMonth(), this.getDate() + (typeof days === "string" ? parseInt(days, 10) : days));
  };
  if (typeof window !== "undefined") {
    window.flatpickr = flatpickr;
  }
  var esm_default = flatpickr;

  // ../../node_modules/stimulus-flatpickr/dist/index.m.js
  function _classCallCheck34(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties34(target, props) {
    for (var i3 = 0; i3 < props.length; i3++) {
      var descriptor = props[i3];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass34(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties34(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties34(Constructor, staticProps);
    return Constructor;
  }
  function _defineProperty33(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2(target) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source = arguments[i3] != null ? arguments[i3] : {};
      if (i3 % 2) {
        ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty33(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _inherits33(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass)
      _setPrototypeOf33(subClass, superClass);
  }
  function _getPrototypeOf33(o2) {
    _getPrototypeOf33 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf34(o3) {
      return o3.__proto__ || Object.getPrototypeOf(o3);
    };
    return _getPrototypeOf33(o2);
  }
  function _setPrototypeOf33(o2, p) {
    _setPrototypeOf33 = Object.setPrototypeOf || function _setPrototypeOf34(o3, p2) {
      o3.__proto__ = p2;
      return o3;
    };
    return _setPrototypeOf33(o2, p);
  }
  function _isNativeReflectConstruct33() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e3) {
      return false;
    }
  }
  function _assertThisInitialized33(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _possibleConstructorReturn33(self2, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }
    return _assertThisInitialized33(self2);
  }
  function _createSuper33(Derived) {
    return function() {
      var Super = _getPrototypeOf33(Derived), result;
      if (_isNativeReflectConstruct33()) {
        var NewTarget = _getPrototypeOf33(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn33(this, result);
    };
  }
  function camelize2(value) {
    return value.replace(/(?:[_-])([a-z0-9])/g, (_, char) => char.toUpperCase());
  }
  function capitalize2(value) {
    return value.charAt(0).toUpperCase() + value.slice(1);
  }
  function dasherize2(value) {
    return value.replace(/([A-Z])/g, (_, char) => `-${char.toLowerCase()}`);
  }
  function readInheritableStaticArrayValues2(constructor, propertyName) {
    const ancestors = getAncestorsForConstructor2(constructor);
    return Array.from(ancestors.reduce((values, constructor2) => {
      getOwnStaticArrayValues2(constructor2, propertyName).forEach((name2) => values.add(name2));
      return values;
    }, /* @__PURE__ */ new Set()));
  }
  function readInheritableStaticObjectPairs2(constructor, propertyName) {
    const ancestors = getAncestorsForConstructor2(constructor);
    return ancestors.reduce((pairs, constructor2) => {
      pairs.push(...getOwnStaticObjectPairs2(constructor2, propertyName));
      return pairs;
    }, []);
  }
  function getAncestorsForConstructor2(constructor) {
    const ancestors = [];
    while (constructor) {
      ancestors.push(constructor);
      constructor = Object.getPrototypeOf(constructor);
    }
    return ancestors.reverse();
  }
  function getOwnStaticArrayValues2(constructor, propertyName) {
    const definition = constructor[propertyName];
    return Array.isArray(definition) ? definition : [];
  }
  function getOwnStaticObjectPairs2(constructor, propertyName) {
    const definition = constructor[propertyName];
    return definition ? Object.keys(definition).map((key) => [key, definition[key]]) : [];
  }
  var extend5 = (() => {
    function extendWithReflect(constructor) {
      function extended() {
        return Reflect.construct(constructor, arguments, new.target);
      }
      extended.prototype = Object.create(constructor.prototype, {
        constructor: {
          value: extended
        }
      });
      Reflect.setPrototypeOf(extended, constructor);
      return extended;
    }
    function testReflectExtension() {
      const a4 = function() {
        this.a.call(this);
      };
      const b2 = extendWithReflect(a4);
      b2.prototype.a = function() {
      };
      return new b2();
    }
    try {
      testReflectExtension();
      return extendWithReflect;
    } catch (error2) {
      return (constructor) => class extended extends constructor {
      };
    }
  })();
  function ClassPropertiesBlessing2(constructor) {
    const classes = readInheritableStaticArrayValues2(constructor, "classes");
    return classes.reduce((properties, classDefinition) => {
      return Object.assign(properties, propertiesForClassDefinition2(classDefinition));
    }, {});
  }
  function propertiesForClassDefinition2(key) {
    return {
      [`${key}Class`]: {
        get() {
          const {
            classes
          } = this;
          if (classes.has(key)) {
            return classes.get(key);
          } else {
            const attribute = classes.getAttributeName(key);
            throw new Error(`Missing attribute "${attribute}"`);
          }
        }
      },
      [`${key}Classes`]: {
        get() {
          return this.classes.getAll(key);
        }
      },
      [`has${capitalize2(key)}Class`]: {
        get() {
          return this.classes.has(key);
        }
      }
    };
  }
  function TargetPropertiesBlessing2(constructor) {
    const targets = readInheritableStaticArrayValues2(constructor, "targets");
    return targets.reduce((properties, targetDefinition) => {
      return Object.assign(properties, propertiesForTargetDefinition2(targetDefinition));
    }, {});
  }
  function propertiesForTargetDefinition2(name2) {
    return {
      [`${name2}Target`]: {
        get() {
          const target = this.targets.find(name2);
          if (target) {
            return target;
          } else {
            throw new Error(`Missing target element "${name2}" for "${this.identifier}" controller`);
          }
        }
      },
      [`${name2}Targets`]: {
        get() {
          return this.targets.findAll(name2);
        }
      },
      [`has${capitalize2(name2)}Target`]: {
        get() {
          return this.targets.has(name2);
        }
      }
    };
  }
  function ValuePropertiesBlessing2(constructor) {
    const valueDefinitionPairs = readInheritableStaticObjectPairs2(constructor, "values");
    const propertyDescriptorMap = {
      valueDescriptorMap: {
        get() {
          return valueDefinitionPairs.reduce((result, valueDefinitionPair) => {
            const valueDescriptor = parseValueDefinitionPair2(valueDefinitionPair);
            const attributeName = this.data.getAttributeNameForKey(valueDescriptor.key);
            return Object.assign(result, {
              [attributeName]: valueDescriptor
            });
          }, {});
        }
      }
    };
    return valueDefinitionPairs.reduce((properties, valueDefinitionPair) => {
      return Object.assign(properties, propertiesForValueDefinitionPair2(valueDefinitionPair));
    }, propertyDescriptorMap);
  }
  function propertiesForValueDefinitionPair2(valueDefinitionPair) {
    const definition = parseValueDefinitionPair2(valueDefinitionPair);
    const {
      key,
      name: name2,
      reader: read2,
      writer: write2
    } = definition;
    return {
      [name2]: {
        get() {
          const value = this.data.get(key);
          if (value !== null) {
            return read2(value);
          } else {
            return definition.defaultValue;
          }
        },
        set(value) {
          if (value === void 0) {
            this.data.delete(key);
          } else {
            this.data.set(key, write2(value));
          }
        }
      },
      [`has${capitalize2(name2)}`]: {
        get() {
          return this.data.has(key) || definition.hasCustomDefaultValue;
        }
      }
    };
  }
  function parseValueDefinitionPair2([token, typeDefinition]) {
    return valueDescriptorForTokenAndTypeDefinition2(token, typeDefinition);
  }
  function parseValueTypeConstant2(constant) {
    switch (constant) {
      case Array:
        return "array";
      case Boolean:
        return "boolean";
      case Number:
        return "number";
      case Object:
        return "object";
      case String:
        return "string";
    }
  }
  function parseValueTypeDefault2(defaultValue) {
    switch (typeof defaultValue) {
      case "boolean":
        return "boolean";
      case "number":
        return "number";
      case "string":
        return "string";
    }
    if (Array.isArray(defaultValue))
      return "array";
    if (Object.prototype.toString.call(defaultValue) === "[object Object]")
      return "object";
  }
  function parseValueTypeObject2(typeObject) {
    const typeFromObject = parseValueTypeConstant2(typeObject.type);
    if (typeFromObject) {
      const defaultValueType = parseValueTypeDefault2(typeObject.default);
      if (typeFromObject !== defaultValueType) {
        throw new Error(`Type "${typeFromObject}" must match the type of the default value. Given default value: "${typeObject.default}" as "${defaultValueType}"`);
      }
      return typeFromObject;
    }
  }
  function parseValueTypeDefinition2(typeDefinition) {
    const typeFromObject = parseValueTypeObject2(typeDefinition);
    const typeFromDefaultValue = parseValueTypeDefault2(typeDefinition);
    const typeFromConstant = parseValueTypeConstant2(typeDefinition);
    const type = typeFromObject || typeFromDefaultValue || typeFromConstant;
    if (type)
      return type;
    throw new Error(`Unknown value type "${typeDefinition}"`);
  }
  function defaultValueForDefinition2(typeDefinition) {
    const constant = parseValueTypeConstant2(typeDefinition);
    if (constant)
      return defaultValuesByType2[constant];
    const defaultValue = typeDefinition.default;
    if (defaultValue !== void 0)
      return defaultValue;
    return typeDefinition;
  }
  function valueDescriptorForTokenAndTypeDefinition2(token, typeDefinition) {
    const key = `${dasherize2(token)}-value`;
    const type = parseValueTypeDefinition2(typeDefinition);
    return {
      type,
      key,
      name: camelize2(key),
      get defaultValue() {
        return defaultValueForDefinition2(typeDefinition);
      },
      get hasCustomDefaultValue() {
        return parseValueTypeDefault2(typeDefinition) !== void 0;
      },
      reader: readers2[type],
      writer: writers2[type] || writers2.default
    };
  }
  var defaultValuesByType2 = {
    get array() {
      return [];
    },
    boolean: false,
    number: 0,
    get object() {
      return {};
    },
    string: ""
  };
  var readers2 = {
    array(value) {
      const array = JSON.parse(value);
      if (!Array.isArray(array)) {
        throw new TypeError("Expected array");
      }
      return array;
    },
    boolean(value) {
      return !(value == "0" || value == "false");
    },
    number(value) {
      return Number(value);
    },
    object(value) {
      const object = JSON.parse(value);
      if (object === null || typeof object != "object" || Array.isArray(object)) {
        throw new TypeError("Expected object");
      }
      return object;
    },
    string(value) {
      return value;
    }
  };
  var writers2 = {
    default: writeString2,
    array: writeJSON2,
    object: writeJSON2
  };
  function writeJSON2(value) {
    return JSON.stringify(value);
  }
  function writeString2(value) {
    return `${value}`;
  }
  var Controller2 = class {
    constructor(context) {
      this.context = context;
    }
    static get shouldLoad() {
      return true;
    }
    get application() {
      return this.context.application;
    }
    get scope() {
      return this.context.scope;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get targets() {
      return this.scope.targets;
    }
    get classes() {
      return this.scope.classes;
    }
    get data() {
      return this.scope.data;
    }
    initialize() {
    }
    connect() {
    }
    disconnect() {
    }
    dispatch(eventName, {
      target = this.element,
      detail = {},
      prefix = this.identifier,
      bubbles = true,
      cancelable = true
    } = {}) {
      const type = prefix ? `${prefix}:${eventName}` : eventName;
      const event = new CustomEvent(type, {
        detail,
        bubbles,
        cancelable
      });
      target.dispatchEvent(event);
      return event;
    }
  };
  Controller2.blessings = [ClassPropertiesBlessing2, TargetPropertiesBlessing2, ValuePropertiesBlessing2];
  Controller2.targets = [];
  Controller2.values = {};
  var kebabCase = (string) => string.replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[\s_]+/g, "-").toLowerCase();
  var capitalize$1 = (string) => {
    return string.charAt(0).toUpperCase() + string.slice(1);
  };
  var booleanOptions = ["allowInput", "altInput", "animate", "clickOpens", "closeOnSelect", "disableMobile", "enableSeconds", "enableTime", "inline", "noCalendar", "shorthandCurrentMonth", "static", "time_24hr", "weekNumbers", "wrap"];
  var stringOptions = ["altInputClass", "conjunction", "mode", "nextArrow", "position", "prevArrow", "monthSelectorType"];
  var numberOptions = ["defaultHour", "defaultMinute", "defaultSeconds", "hourIncrement", "minuteIncrement", "showMonths"];
  var arrayOptions = ["disable", "enable", "disableDaysOfWeek", "enableDaysOfWeek"];
  var arrayOrStringOptions = ["defaultDate"];
  var dateOptions = ["maxDate", "minDate", "maxTime", "minTime", "now"];
  var dateFormats2 = ["altFormat", "ariaDateFormat", "dateFormat"];
  var options = {
    string: stringOptions,
    boolean: booleanOptions,
    date: dateOptions,
    array: arrayOptions,
    number: numberOptions,
    arrayOrString: arrayOrStringOptions
  };
  var events = ["change", "open", "close", "monthChange", "yearChange", "ready", "valueUpdate", "dayCreate"];
  var elements2 = ["calendarContainer", "currentYearElement", "days", "daysContainer", "input", "nextMonthNav", "monthNav", "prevMonthNav", "rContainer", "selectedDateElem", "todayDateElem", "weekdayContainer"];
  var mapping = {
    "%Y": "Y",
    "%y": "y",
    "%C": "Y",
    "%m": "m",
    "%-m": "n",
    "%_m": "n",
    "%B": "F",
    "%^B": "F",
    "%b": "M",
    "%^b": "M",
    "%h": "M",
    "%^h": "M",
    "%d": "d",
    "%-d": "j",
    "%e": "j",
    "%H": "H",
    "%k": "H",
    "%I": "h",
    "%l": "h",
    "%-l": "h",
    "%P": "K",
    "%p": "K",
    "%M": "i",
    "%S": "S",
    "%A": "l",
    "%a": "D",
    "%w": "w"
  };
  var strftimeRegex = new RegExp(Object.keys(mapping).join("|").replace(new RegExp("\\^", "g"), "\\^"), "g");
  var convertDateFormat = (format3) => {
    return format3.replace(strftimeRegex, (match2) => {
      return mapping[match2];
    });
  };
  var StimulusFlatpickr = /* @__PURE__ */ function(_Controller) {
    _inherits33(StimulusFlatpickr2, _Controller);
    var _super = _createSuper33(StimulusFlatpickr2);
    function StimulusFlatpickr2() {
      _classCallCheck34(this, StimulusFlatpickr2);
      return _super.apply(this, arguments);
    }
    _createClass34(StimulusFlatpickr2, [{
      key: "initialize",
      value: function initialize() {
        this.config = {};
      }
    }, {
      key: "connect",
      value: function connect() {
        this._initializeEvents();
        this._initializeOptions();
        this._initializeDateFormats();
        this.fp = esm_default(this.flatpickrElement, _objectSpread2({}, this.config));
        this._initializeElements();
      }
    }, {
      key: "disconnect",
      value: function disconnect() {
        const value = this.inputTarget.value;
        this.fp.destroy();
        this.inputTarget.value = value;
      }
    }, {
      key: "_initializeEvents",
      value: function _initializeEvents() {
        events.forEach((event) => {
          if (this[event]) {
            const hook = `on${capitalize$1(event)}`;
            this.config[hook] = this[event].bind(this);
          }
        });
      }
    }, {
      key: "_initializeOptions",
      value: function _initializeOptions() {
        Object.keys(options).forEach((optionType) => {
          const optionsCamelCase = options[optionType];
          optionsCamelCase.forEach((option) => {
            const optionKebab = kebabCase(option);
            if (this.data.has(optionKebab)) {
              this.config[option] = this[`_${optionType}`](optionKebab);
            }
          });
        });
        this._handleDaysOfWeek();
      }
    }, {
      key: "_handleDaysOfWeek",
      value: function _handleDaysOfWeek() {
        if (this.config.disableDaysOfWeek) {
          this.config.disableDaysOfWeek = this._validateDaysOfWeek(this.config.disableDaysOfWeek);
          this.config.disable = [...this.config.disable || [], this._disable.bind(this)];
        }
        if (this.config.enableDaysOfWeek) {
          this.config.enableDaysOfWeek = this._validateDaysOfWeek(this.config.enableDaysOfWeek);
          this.config.enable = [...this.config.enable || [], this._enable.bind(this)];
        }
      }
    }, {
      key: "_validateDaysOfWeek",
      value: function _validateDaysOfWeek(days) {
        if (Array.isArray(days)) {
          return days.map((day) => parseInt(day));
        } else {
          console.error("days of week must be a valid array");
          return [];
        }
      }
    }, {
      key: "_disable",
      value: function _disable(date) {
        const disabledDays = this.config.disableDaysOfWeek;
        return disabledDays.includes(date.getDay());
      }
    }, {
      key: "_enable",
      value: function _enable(date) {
        const enabledDays = this.config.enableDaysOfWeek;
        return enabledDays.includes(date.getDay());
      }
    }, {
      key: "_initializeDateFormats",
      value: function _initializeDateFormats() {
        dateFormats2.forEach((dateFormat) => {
          if (this.data.has(dateFormat)) {
            this.config[dateFormat] = convertDateFormat(this.data.get(dateFormat));
          }
        });
      }
    }, {
      key: "_initializeElements",
      value: function _initializeElements() {
        elements2.forEach((element) => {
          this[`${element}Target`] = this.fp[element];
        });
      }
    }, {
      key: "_string",
      value: function _string(option) {
        return this.data.get(option);
      }
    }, {
      key: "_date",
      value: function _date(option) {
        return this.data.get(option);
      }
    }, {
      key: "_boolean",
      value: function _boolean(option) {
        return !(this.data.get(option) == "0" || this.data.get(option) == "false");
      }
    }, {
      key: "_array",
      value: function _array(option) {
        return JSON.parse(this.data.get(option));
      }
    }, {
      key: "_number",
      value: function _number(option) {
        return parseInt(this.data.get(option));
      }
    }, {
      key: "_arrayOrString",
      value: function _arrayOrString(option) {
        const val = this.data.get(option);
        try {
          return JSON.parse(val);
        } catch (e3) {
          return val;
        }
      }
    }, {
      key: "flatpickrElement",
      get: function() {
        return this.hasInstanceTarget && this.instanceTarget || this.element;
      }
    }]);
    return StimulusFlatpickr2;
  }(Controller2);
  _defineProperty33(StimulusFlatpickr, "targets", ["instance"]);
  var index_m_default = StimulusFlatpickr;

  // controllers/index.js
  controller_default.forEach((controller) => {
    application.register(controller.name, controller.module.default);
  });
  application.register("dropdown", i2);
  application.register("modal", a3);
  application.register("tabs", l);
  application.register("popover", o);
  application.register("toggle", n);
  application.register("slideover", r);
  application.register("flatpickr", index_m_default);

  // src/actiontext.js
  var import_trix2 = __toESM(require_trix());

  // ../../node_modules/@rails/request.js/src/fetch_response.js
  var FetchResponse2 = class {
    constructor(response) {
      this.response = response;
    }
    get statusCode() {
      return this.response.status;
    }
    get redirected() {
      return this.response.redirected;
    }
    get ok() {
      return this.response.ok;
    }
    get unauthenticated() {
      return this.statusCode === 401;
    }
    get unprocessableEntity() {
      return this.statusCode === 422;
    }
    get authenticationURL() {
      return this.response.headers.get("WWW-Authenticate");
    }
    get contentType() {
      const contentType = this.response.headers.get("Content-Type") || "";
      return contentType.replace(/;.*$/, "");
    }
    get headers() {
      return this.response.headers;
    }
    get html() {
      if (this.contentType.match(/^(application|text)\/(html|xhtml\+xml)$/)) {
        return this.text;
      }
      return Promise.reject(new Error(`Expected an HTML response but got "${this.contentType}" instead`));
    }
    get json() {
      if (this.contentType.match(/^application\/.*json$/)) {
        return this.responseJson || (this.responseJson = this.response.json());
      }
      return Promise.reject(new Error(`Expected a JSON response but got "${this.contentType}" instead`));
    }
    get text() {
      return this.responseText || (this.responseText = this.response.text());
    }
    get isTurboStream() {
      return this.contentType.match(/^text\/vnd\.turbo-stream\.html/);
    }
    async renderTurboStream() {
      if (this.isTurboStream) {
        if (window.Turbo) {
          await window.Turbo.renderStreamMessage(await this.text);
        } else {
          console.warn("You must set `window.Turbo = Turbo` to automatically process Turbo Stream events with request.js");
        }
      } else {
        return Promise.reject(new Error(`Expected a Turbo Stream response but got "${this.contentType}" instead`));
      }
    }
  };

  // ../../node_modules/@rails/request.js/src/request_interceptor.js
  var RequestInterceptor = class {
    static register(interceptor) {
      this.interceptor = interceptor;
    }
    static get() {
      return this.interceptor;
    }
    static reset() {
      this.interceptor = void 0;
    }
  };

  // ../../node_modules/@rails/request.js/src/lib/utils.js
  function getCookie(name2) {
    const cookies = document.cookie ? document.cookie.split("; ") : [];
    const prefix = `${encodeURIComponent(name2)}=`;
    const cookie = cookies.find((cookie2) => cookie2.startsWith(prefix));
    if (cookie) {
      const value = cookie.split("=").slice(1).join("=");
      if (value) {
        return decodeURIComponent(value);
      }
    }
  }
  function compact(object) {
    const result = {};
    for (const key in object) {
      const value = object[key];
      if (value !== void 0) {
        result[key] = value;
      }
    }
    return result;
  }
  function metaContent(name2) {
    const element = document.head.querySelector(`meta[name="${name2}"]`);
    return element && element.content;
  }
  function stringEntriesFromFormData(formData) {
    return [...formData].reduce((entries, [name2, value]) => {
      return entries.concat(typeof value === "string" ? [[name2, value]] : []);
    }, []);
  }
  function mergeEntries(searchParams, entries) {
    for (const [name2, value] of entries) {
      if (value instanceof window.File)
        continue;
      if (searchParams.has(name2)) {
        searchParams.delete(name2);
        searchParams.set(name2, value);
      } else {
        searchParams.append(name2, value);
      }
    }
  }

  // ../../node_modules/@rails/request.js/src/fetch_request.js
  var FetchRequest2 = class {
    constructor(method, url, options2 = {}) {
      this.method = method;
      this.options = options2;
      this.originalUrl = url.toString();
    }
    async perform() {
      try {
        const requestInterceptor = RequestInterceptor.get();
        if (requestInterceptor) {
          await requestInterceptor(this);
        }
      } catch (error2) {
        console.error(error2);
      }
      const response = new FetchResponse2(await window.fetch(this.url, this.fetchOptions));
      if (response.unauthenticated && response.authenticationURL) {
        return Promise.reject(window.location.href = response.authenticationURL);
      }
      if (response.ok && response.isTurboStream) {
        await response.renderTurboStream();
      }
      return response;
    }
    addHeader(key, value) {
      const headers = this.additionalHeaders;
      headers[key] = value;
      this.options.headers = headers;
    }
    get fetchOptions() {
      return {
        method: this.method.toUpperCase(),
        headers: this.headers,
        body: this.formattedBody,
        signal: this.signal,
        credentials: "same-origin",
        redirect: this.redirect
      };
    }
    get headers() {
      return compact(Object.assign({
        "X-Requested-With": "XMLHttpRequest",
        "X-CSRF-Token": this.csrfToken,
        "Content-Type": this.contentType,
        Accept: this.accept
      }, this.additionalHeaders));
    }
    get csrfToken() {
      return getCookie(metaContent("csrf-param")) || metaContent("csrf-token");
    }
    get contentType() {
      if (this.options.contentType) {
        return this.options.contentType;
      } else if (this.body == null || this.body instanceof window.FormData) {
        return void 0;
      } else if (this.body instanceof window.File) {
        return this.body.type;
      }
      return "application/json";
    }
    get accept() {
      switch (this.responseKind) {
        case "html":
          return "text/html, application/xhtml+xml";
        case "turbo-stream":
          return "text/vnd.turbo-stream.html, text/html, application/xhtml+xml";
        case "json":
          return "application/json, application/vnd.api+json";
        default:
          return "*/*";
      }
    }
    get body() {
      return this.options.body;
    }
    get query() {
      const originalQuery = (this.originalUrl.split("?")[1] || "").split("#")[0];
      const params = new URLSearchParams(originalQuery);
      let requestQuery = this.options.query;
      if (requestQuery instanceof window.FormData) {
        requestQuery = stringEntriesFromFormData(requestQuery);
      } else if (requestQuery instanceof window.URLSearchParams) {
        requestQuery = requestQuery.entries();
      } else {
        requestQuery = Object.entries(requestQuery || {});
      }
      mergeEntries(params, requestQuery);
      const query = params.toString();
      return query.length > 0 ? `?${query}` : "";
    }
    get url() {
      return this.originalUrl.split("?")[0].split("#")[0] + this.query;
    }
    get responseKind() {
      return this.options.responseKind || "html";
    }
    get signal() {
      return this.options.signal;
    }
    get redirect() {
      return this.options.redirect || "follow";
    }
    get additionalHeaders() {
      return this.options.headers || {};
    }
    get formattedBody() {
      const bodyIsAString = Object.prototype.toString.call(this.body) === "[object String]";
      const contentTypeIsJson = this.headers["Content-Type"] === "application/json";
      if (contentTypeIsJson && !bodyIsAString) {
        return JSON.stringify(this.body);
      }
      return this.body;
    }
  };

  // ../../node_modules/@rails/request.js/src/verbs.js
  async function get(url, options2) {
    const request = new FetchRequest2("get", url, options2);
    return request.perform();
  }

  // src/actiontext.js
  import_trix2.default.config.textAttributes.inlineCode = {
    tagName: "code",
    inheritable: true
  };
  var EmbedController = class {
    constructor(element) {
      this.patterns = void 0;
      this.element = element;
      this.editor = element.editor;
      this.toolbar = element.toolbarElement;
      this.injectHTML();
      this.hrefElement = this.toolbar.querySelector("[data-trix-input][name='href']");
      this.embedContainerElement = this.toolbar.querySelector("[data-behavior='embed_container']");
      this.embedElement = this.toolbar.querySelector("[data-behavior='embed_url']");
      this.reset();
      this.installEventHandlers();
    }
    injectHTML() {
      this.toolbar.querySelector('[data-trix-dialog="href"]').insertAdjacentHTML("beforeend", `
        <div data-behavior="embed_container">
          <div class="link_to_embed link_to_embed--new">
            Would you like to embed media from this site?
            <input class="btn btn-tertiary btn-small outline" type="button" data-behavior="embed_url" value="Yes, embed it">
          </div>
        </div>
    `);
    }
    installEventHandlers() {
      this.hrefElement.addEventListener("input", this.didInput.bind(this));
      this.hrefElement.addEventListener("focusin", this.didInput.bind(this));
      this.embedElement.addEventListener("click", this.embed.bind(this));
    }
    didInput(event) {
      let value = event.target.value.trim();
      if (this.patterns === void 0) {
        this.loadPatterns(value);
      } else if (this.match(value)) {
        this.fetch(value);
      } else {
        this.reset();
      }
    }
    async loadPatterns(value) {
      const response = await get("/action_text/embeds/patterns.json", { responseKind: "json" });
      if (response.ok) {
        const patterns2 = await response.json;
        this.patterns = patterns2.map((pattern) => new RegExp(pattern.source, pattern.options));
        if (this.match(value)) {
          this.fetch(value);
        }
      }
    }
    match(value) {
      return this.patterns.some((regex) => regex.test(value));
    }
    fetch(value) {
      Rails.ajax({
        url: `/action_text/embeds?id=${encodeURIComponent(value)}`,
        type: "post",
        error: this.reset.bind(this),
        success: this.showEmbed.bind(this)
      });
    }
    embed(event) {
      if (this.currentEmbed == null) {
        return;
      }
      let attachment = new import_trix2.default.Attachment(this.currentEmbed);
      this.editor.insertAttachment(attachment);
      this.element.focus();
    }
    showEmbed(embed) {
      this.currentEmbed = embed;
      this.embedContainerElement.style.display = "block";
    }
    reset() {
      this.embedContainerElement.style.display = "none";
      this.currentEmbed = null;
    }
  };
  var InlineCode = class {
    constructor(element) {
      this.element = element;
      this.editor = element.editor;
      this.toolbar = element.toolbarElement;
      this.installEventHandlers();
    }
    installEventHandlers() {
      const blockCodeButton = this.toolbar.querySelector("[data-trix-attribute=code]");
      const inlineCodeButton = blockCodeButton.cloneNode(true);
      inlineCodeButton.hidden = true;
      inlineCodeButton.dataset.trixAttribute = "inlineCode";
      blockCodeButton.insertAdjacentElement("afterend", inlineCodeButton);
      this.element.addEventListener("trix-selection-change", (_) => {
        const type = this.getCodeFormattingType();
        blockCodeButton.hidden = type == "inline";
        inlineCodeButton.hidden = type == "block";
      });
    }
    getCodeFormattingType() {
      if (this.editor.attributeIsActive("code"))
        return "block";
      if (this.editor.attributeIsActive("inlineCode"))
        return "inline";
      const range = this.editor.getSelectedRange();
      if (range[0] == range[1])
        return "block";
      const text = this.editor.getSelectedDocument().toString().trim();
      return /\n/.test(text) ? "block" : "inline";
    }
  };
  document.addEventListener("trix-initialize", function(event) {
    new EmbedController(event.target);
    new InlineCode(event.target);
  });

  // rails:/root/prod/jumpstart-pro/app/javascript/src/**/*
  var module1 = __toESM(require_confirm());
  var module2 = __toESM(require_direct_uploads());
  var module3 = __toESM(require_lazysrc());

  // ../../node_modules/js-cookie/dist/js.cookie.mjs
  function assign2(target) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source = arguments[i3];
      for (var key in source) {
        target[key] = source[key];
      }
    }
    return target;
  }
  var defaultConverter = {
    read: function(value) {
      if (value[0] === '"') {
        value = value.slice(1, -1);
      }
      return value.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent);
    },
    write: function(value) {
      return encodeURIComponent(value).replace(/%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g, decodeURIComponent);
    }
  };
  function init(converter, defaultAttributes) {
    function set2(key, value, attributes) {
      if (typeof document === "undefined") {
        return;
      }
      attributes = assign2({}, defaultAttributes, attributes);
      if (typeof attributes.expires === "number") {
        attributes.expires = new Date(Date.now() + attributes.expires * 864e5);
      }
      if (attributes.expires) {
        attributes.expires = attributes.expires.toUTCString();
      }
      key = encodeURIComponent(key).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
      var stringifiedAttributes = "";
      for (var attributeName in attributes) {
        if (!attributes[attributeName]) {
          continue;
        }
        stringifiedAttributes += "; " + attributeName;
        if (attributes[attributeName] === true) {
          continue;
        }
        stringifiedAttributes += "=" + attributes[attributeName].split(";")[0];
      }
      return document.cookie = key + "=" + converter.write(value, key) + stringifiedAttributes;
    }
    function get2(key) {
      if (typeof document === "undefined" || arguments.length && !key) {
        return;
      }
      var cookies = document.cookie ? document.cookie.split("; ") : [];
      var jar = {};
      for (var i3 = 0; i3 < cookies.length; i3++) {
        var parts = cookies[i3].split("=");
        var value = parts.slice(1).join("=");
        try {
          var foundKey = decodeURIComponent(parts[0]);
          jar[foundKey] = converter.read(value, foundKey);
          if (key === foundKey) {
            break;
          }
        } catch (e3) {
        }
      }
      return key ? jar[key] : jar;
    }
    return Object.create({
      set: set2,
      get: get2,
      remove: function(key, attributes) {
        set2(key, "", assign2({}, attributes, {
          expires: -1
        }));
      },
      withAttributes: function(attributes) {
        return init(this.converter, assign2({}, this.attributes, attributes));
      },
      withConverter: function(converter2) {
        return init(assign2({}, this.converter, converter2), this.attributes);
      }
    }, {
      attributes: { value: Object.freeze(defaultAttributes) },
      converter: { value: Object.freeze(converter) }
    });
  }
  var api = init(defaultConverter, { path: "/" });
  var js_cookie_default = api;

  // src/timezone.js
  var import_jstz = __toESM(require_jstz2());
  function findTimeZone() {
    const oldIntl = window.Intl;
    try {
      window.Intl = void 0;
      const tz = import_jstz.default.determine().name();
      window.Intl = oldIntl;
      return tz;
    } catch (e3) {
      return import_jstz.default.determine().name();
    }
  }
  document.addEventListener("turbo:load", () => {
    js_cookie_default.set("browser_time_zone", findTimeZone(), { expires: 365, path: "/", secure: true });
  });

  // src/turbo_native/bridge.js
  var Bridge = class {
    static toggleNavBar() {
      const event = new CustomEvent("toggle-nav-bar");
      window.dispatchEvent(event);
    }
    static setNotificationCount(icon, tab = icon) {
      this.postMessage("showNotificationBadge", { icon, tab });
    }
    static postMessage(name2, data = {}) {
      window.webkit?.messageHandlers?.nativeApp?.postMessage({ name: name2, ...data });
      window.nativeApp?.postMessage(JSON.stringify({ name: name2, ...data }));
    }
  };
  window.TurboNativeBridge = Bridge;

  // application.js
  window.Rails = import_ujs.default;
  window.Turbo = turbo_es2017_esm_exports;
  require_activestorage().start();
  require_local_time().start();
  import_ujs.default.start();
})();
/*!
 * @kurkle/color v0.3.2
 * https://github.com/kurkle/color#readme
 * (c) 2023 Jukka Kurkela
 * Released under the MIT License
 */
/*!
 * Chart.js v4.2.1
 * https://www.chartjs.org
 * (c) 2023 Chart.js Contributors
 * Released under the MIT License
 */
/*!
 * Chartkick.js v5.0.1
 * Create beautiful charts with one line of JavaScript
 * https://github.com/ankane/chartkick.js
 * MIT License
 */
/*!
 * chartjs-adapter-date-fns v3.0.0
 * https://www.chartjs.org
 * (c) 2022 chartjs-adapter-date-fns Contributors
 * Released under the MIT license
 */
/*!
 * clipboard.js v2.0.8
 * https://clipboardjs.com/
 *
 * Licensed MIT  Zeno Rocha
 */
/*! js-cookie v3.0.1 | MIT */
/**
 * This script gives you the zone info key representing your device's time zone setting.
 *
 * @name jsTimezoneDetect
 * @version 1.0.6
 * @author Jon Nylander
 * @license MIT License - https://bitbucket.org/pellepim/jstimezonedetect/src/default/LICENCE.txt
 *
 * For usage and examples, visit:
 * http://pellepim.bitbucket.org/jstz/
 *
 * Copyright (c) Jon Nylander
 */
